\input formatmac

\vfill\break
{\bf spitbol--\rm copyright notice}
\vskip1em
\lnie
\endln
\lnie
copyright (c) by robert b. k. dewar, 1983, 2009\endln
\lnie
\endln
\lnie
this software is the property of\endln
\lnie
     professor robert b. k. dewar\endln
\lnie
     courant institute of mathematical sciences\endln
\lnie
     251 mercer street\endln
\lnie
     new york,  ny 10012\endln
\lnie
     u.s.a.\endln
\lnie
tel no -  (212) 460 7497\endln
\lnie
\endln
\vfill\break

\vfill\break
{\bf license--\rm software license for this program}
\vskip1em
\lnie
this program is free software: you can redistribute it and/or modify\endln
\lnie
it under the terms of the gnu general public license as published by\endln
\lnie
the free software foundation, either version 3 of the license, or\endln
\lnie
(at your option) any later version.\endln
\lnie
\endln
\lnie
this program is distributed in the hope that it will be useful,\endln
\lnie
but without any warranty; without even the implied warranty of\endln
\lnie
merchantability or fitness for a particular purpose.  see the\endln
\lnie
gnu general public license for more details.\endln
\lnie
\endln
\lnie
you should have received a copy of the gnu general public license\endln
\lnie
along with this program.  if not, see <http://www.gnu.org/licenses/>.\endln
\vfill\break
{\bf spitbol--\rm notes to implementors}
\vskip1em
\lnie
\endln
\lnie
m a c r o   s p i t b o l     v e r s i o n   3 . 7\endln
\lnie
---------------------------------------------------\endln
\lnie
\endln
\lnie
date of release  -  16 april 2009\endln
\lnie
\endln
\lnie
permission to use spitbol may be negotiated with\endln
\lnie
professor robert b. k. dewar.\endln
\lnie
sites which have obtained such permission may not pass\endln
\lnie
on copies of the spitbol system or parts of it except\endln
\lnie
by agreement with dewar.\endln
\lnie
\endln
\lnie
version 3.7 was maintained by\endln
\lnie
     mark emmer\endln
\lnie
     catspaw, inc.\endln
\lnie
     p.o. box 1123\endln
\lnie
     salida, colorado 81021\endln
\lnie
     u.s.a\endln
\lnie
tel no -  (719) 539 3884\endln
\lnie
e-mail - marke at snobol4 dot com\endln
\lnie
\endln
\lnie
versions 2.6 through 3.4 were maintained by\endln
\lnie
     dr. a. p. mccann\endln
\lnie
     department of computer studies\endln
\lnie
     university of leeds\endln
\lnie
     leeds ls2 9jt\endln
\lnie
     england.\endln
\lnie
\endln
\lnie
from 1979 through early 1983 a number of fixes and\endln
\lnie
enhancements were made by steve duff and robert goldberg.\endln
\lnie
\endln
\lnie
to assist implementors a revision history based on\endln
\lnie
version 2.7 is being maintained.\endln
\lnie
\endln
\vfill\break
{\bf spitbol--\rm revision history}
\vskip1em
\vfill\break

\lnie
r e v i s i o n   h i s t o r y\endln
\lnie
-------------------------------\endln
\lnie
\endln
\lnie
\endln
\lnie
version 3.6a to 3.7 (november 1, 1991, mark b. emmer)\endln
\lnie
-----------------------------------------------------\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
\endln
\lnie
b3.701  add btkwv and refined test at cdgvl+9 to prevent\endln
\lnie
        variable names alphabet, lcase, ucase from being\endln
\lnie
        pre-evaluated because of their associated\endln
\lnie
        constant keywords.  the code\endln
\lnie
           alphabet = "abc"; output = size(alphabet)\endln
\lnie
        returned zero because of pre-evaluation.\endln
\lnie
b3.702  delay binding to function block of fourth\endln
\lnie
        argument to trace function.  this permits the\endln
\lnie
        trace function to be invoked before the 4th\endln
\lnie
        argument function is defined.  accomplished by\endln
\lnie
        storing a vrblk pointer in trfnc, and fetching\endln
\lnie
        its vrfnc entry later, in trxeq.\endln
\lnie
b3.703  references to keywords with constant pattern\endln
\lnie
        values (&arb, &bal, etc.) did not work.  a wtb\endln
\lnie
        instruction had been omitted at acs14+2.\endln
\lnie
b3.704  if a program employed the code function to\endln
\lnie
        redefine a label that was the entry location of\endln
\lnie
        a user-defined function, the function would\endln
\lnie
        continue to jump to its old function body.  pfcod\endln
\lnie
        in pfblk was pointing directly to the target code\endln
\lnie
        block, instead of doing so indirectly through the\endln
\lnie
        vrblk for the entry label.\endln
\lnie
b3.705  the test that required a label to be defined\endln
\lnie
        before it could be used as the entry of a user-\endln
\lnie
        defined function has been removed.  functions\endln
\lnie
        may be defined even if the label is yet\endln
\lnie
        undefined.\endln
\lnie
b3.706  after a compilation error in the code function,\endln
\lnie
        the eval function produces spurrious errors.  the\endln
\lnie
        code offset cwcof was not being reset to the\endln
\lnie
        beginning of code block.  add line at err04+1 to\endln
\lnie
        accomplish this reset.\endln
\lnie
b3.707  inconsistant tests with mxlen corrected.  several\endln
\lnie
        places were testing with bge instead of bgt,\endln
\lnie
        resulting in such anomalies as the statement\endln
\lnie
           &maxlngth = &maxlngth\endln
\lnie
        failing.  since mxlen is guaranteed to be\endln
\lnie
        strictly less than dnamb, it is permissible to\endln
\lnie
        create objects of size mxlen.  bge changed to\endln
\lnie
        bgt at locations\endln
\lnie
           s$arr+14, sar07+8, alobf+3, asg14+8, gtar6+10.\endln
\lnie
b3.708  exit(command string) was not loading ptr to fcb\endln
\lnie
        chain into wb.  corrected at sext1.\endln
\lnie
b3.709  change patst to return non-string error for null\endln
\lnie
        argument.  previously, break(), any(), etc., were\endln
\lnie
        succeeding, contrary to the language definition.\endln
\lnie
b3.710  convert function with null second argument\endln
\lnie
        crashed system by calling flstg with wa=0.  added\endln
\lnie
        test at s$cnv, moved error 74 to separate erb at\endln
\lnie
        scv29.\endln
\lnie
b3.711  leq(,) crashed system.  lcomp did not obey\endln
\lnie
        minimal assumption that cmc opcode will always\endln
\lnie
        be called with wa .gt. 0.  added test at lcmp1.\endln
\lnie
b3.712  modified line at sdf07+4 to use register wa\endln
\lnie
        instead of wb.  this corrects problem of define\endln
\lnie
        function with local variable list that begins\endln
\lnie
        with comma-  define("f(x),l1,l2")\endln
\lnie
b3.713  erroneous plc on uninitialised r$cim in listr.\endln
\lnie
b3.714  erroneous call to flstg possible with null string\endln
\lnie
        at sdat1.\endln
\lnie
b3.715  when copy function used with table argument, fix\endln
\lnie
        problem at cop07.  when copying first teblk on a\endln
\lnie
        chain, the pseudo-previous block pointer in xr\endln
\lnie
        is pushed on the stack prior to calling alloc.\endln
\lnie
        this is not a valid block pointer, as it points\endln
\lnie
        within the tbblk.  if the subsequent alloc\endln
\lnie
        invokes gbcol, the heap becomes scrambled.\endln
\lnie
        recoded to save pointer to start of block, plus\endln
\lnie
        offset in wb.\endln
\lnie
b3.716  at iop01, if gtvar triggered garbage collection\endln
\lnie
        via alost, trap block in wc was not collected.\endln
\lnie
        save wc on stack to make it collectable across\endln
\lnie
        gtvar call.\endln
\lnie
b3.717  at asg10, allow case of variable with more than\endln
\lnie
        one trblk, as happens with the following stmt -\endln
\lnie
        output(.output, .output, filename).\endln
\lnie
b3.718  at senf1, trblk chain search was reloading chain\endln
\lnie
        head, causing infinite loop if the desired trblk\endln
\lnie
        was not the first on chain.  system crashed with\endln
\lnie
        trace(.v1) output(.v2,.v1,file).\endln
\lnie
b3.719  prototype strings (define, load, data, etc.) were\endln
\lnie
        allowing blank characters, producing bogus\endln
\lnie
        variable names.\endln
\lnie
b3.720  the fact that iofcb destroyed register wc was not\endln
\lnie
        documented.  b$efc conversion of file argument\endln
\lnie
        never worked because wc and xt were destroyed by\endln
\lnie
        call to iofcb.\endln
\lnie
b3.721  ioput left a trblk attached to filearg1 if sysio\endln
\lnie
        failed.  subsequent use of this filearg1 variable\endln
\lnie
        in another i/o call would crash system.\endln
\lnie
b3.722  add chk at evlp1 to catch recursive pattern error.\endln
\lnie
b3.723  allow -line to work properly within code function\endln
\lnie
        by setting cmpln directly in cnc44.  if file name\endln
\lnie
        absent, decrement scnpt to rescan terminator.\endln
\lnie
b3.724  when mxlen exceeds start of dynamic memory, round\endln
\lnie
        it up to multiple of word size prior to storing\endln
\lnie
        in dnamb at ini06.\endln
\lnie
b3.725  provide right padding of zero characters to any\endln
\lnie
        string returned by an external function.\endln
\lnie
b3.726  reset flptr at bpf17 for undefined function\endln
\lnie
        when evalx is evaluating an expression.\endln
\lnie
b3.727  modify code after read5 for outer nesting of\endln
\lnie
        an execute-time compile of -include statement.\endln
\lnie
        create a substring of remainder of original\endln
\lnie
        code function argument string and return as\endln
\lnie
        result of readr function\endln
\lnie
b3.728  the definition of the aov opcode is corrected.\endln
\lnie
        formerly the definition specified that the branch\endln
\lnie
        was to be taken if the result of the addition\endln
\lnie
        exceeded cfp$m, implying a test for overflow\endln
\lnie
        from signed addition.\endln
\lnie
        however, address arithmetic must be unsigned to\endln
\lnie
        allow for systems where the high order address\endln
\lnie
        bit is set.  therefore, the test must be for\endln
\lnie
        carry out of the high order bit, if the result\endln
\lnie
        would exceed cfp$l.\endln
\lnie
b3.729  a label trace on the entry label for a function\endln
\lnie
        was undetected, resulting in a transfer to\endln
\lnie
        b$trt and subsequent crash.  see bpf08 for fix.\endln
\lnie
b3.730  pop first argument to substr if it is a buffer.\endln
\lnie
b3.731  pattern replacement with buffer subject returned\endln
\lnie
        null string instead of new subject value.\endln
\lnie
        changed to behave as if subject was a string.\endln
\lnie
b3.732  if convert function was called with a buffer\endln
\lnie
        first argument and "buffer" second argument,\endln
\lnie
        it would convert the buffer to a string, and\endln
\lnie
        then back to a buffer.  this has be corrected\endln
\lnie
        to simply return the first argument as the\endln
\lnie
        function result.\endln
\lnie
b3.733  detect external function returning a null string\endln
\lnie
        unconverted result at bef12, and jump to exnul.\endln
\lnie
b3.734  fix problem at ins04 when inserting zero length\endln
\lnie
        string into buffer.  defend against invoking\endln
\lnie
        mvc with a zero value in wa, which will cause\endln
\lnie
        some implementations to wrap the counter.\endln
\lnie
b3.735  add overflow test for cos and sin to detect\endln
\lnie
        out-of-range argument.\endln
\lnie
b3.736  fixed problem introduced with b3.727 not\endln
\lnie
        restoring r$cim, scnpt and scnil after creating\endln
\lnie
        substring.\endln
\lnie
b3.737  fixed tfind to place default value in newly\endln
\lnie
        allocated teblk.\endln
\lnie
b3.738  added bl$p0 to p$nth entry point.  the expression\endln
\lnie
        datatype(convert("","pattern")) would crash when\endln
\lnie
        the dtype function uses the non-existant type\endln
\lnie
        word preceding p$nth.\endln
\lnie
b3.739  bug at gtn35 in the case of overflow during cvm.\endln
\lnie
        wb can be destroyed by cvm on some platforms.\endln
\lnie
b3.740  protect scontinue from usage in other than error\endln
\lnie
        320 case.\endln
\lnie
b3.741  protect continue from usage following error\endln
\lnie
        evaluating complex failure goto.\endln
\lnie
\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
c3.701  add .culk conditional to include &lcase, &ucase.\endln
\lnie
c3.702  add -line nn "filename" control card.\endln
\lnie
c3.703  move .cnld conditional up in routine dffnc to\endln
\lnie
        omit all tests for b$efc.\endln
\lnie
c3.704  add conditional .cicc to ignore unrecognized\endln
\lnie
        control cards.\endln
\lnie
c3.705  add conditional .cnsc to omit string to numeric\endln
\lnie
        conversion in sort.  the presence of this\endln
\lnie
        conversion mode produces a sort result that is\endln
\lnie
        dependent upon the order of input data.\endln
\lnie
        for example, given input data "2", 5, "10",\endln
\lnie
        string comparison yields "10" lt "2", but string\endln
\lnie
        to integer conversion yields "2" lt 5 lt "10".\endln
\lnie
c3.706  add seventh return from syshs that allows callee\endln
\lnie
        to return a string pointer and length.  this is\endln
\lnie
        done to eliminate the need for the caller to have\endln
\lnie
        an scblk big enough to accommodate long strings.\endln
\lnie
c3.707  add eighth return from syshs to force copy of\endln
\lnie
        block pointed to by xr.\endln
\lnie
c3.708  made -copy a synonym for -include.\endln
\lnie
c3.709  add conditional .cbyt for statistics displayed\endln
\lnie
        in bytes rather than words.\endln
\lnie
c3.710  dump null valued variables when dump = 3.  core\endln
\lnie
        dump produced for dump = 4.\endln
\lnie
c3.711  restrict minimum value to which keyword maxlngth\endln
\lnie
        can be set to 1,024 via new variable mnlen.\endln
\lnie
c3.712  add conditional symbol .cmth for extended math\endln
\lnie
        functions- atan, chop, cos, exp, ln, sin, sqrt,\endln
\lnie
        tan.  x**y and remdr(x,y) are extended to include\endln
\lnie
        reals.\endln
\lnie
c3.713  add bit to syspp to set -print upon entry\endln
\lnie
c3.714  add conditional .csfn to track source file name\endln
\lnie
        associated with each code block.\endln
\lnie
c3.715  add conditional .cinc for -include control card\endln
\lnie
        feature.  the format of the card is\endln
\lnie
           -include "filename"\endln
\lnie
        include control cards may be used during both the\endln
\lnie
        initial compile and execute-time compile.  the\endln
\lnie
        filename is saved in a table, and redundant\endln
\lnie
        includes of that file are ignored.\endln
\lnie
c3.716  add conditional .csln to include source line\endln
\lnie
        number in code blocks.  release current ccblk\endln
\lnie
        after initial compile.\endln
\lnie
c3.717  changed rilen to 258 (from 120) to provide\endln
\lnie
        uniform input line length when reading from\endln
\lnie
        terminal or input.\endln
\lnie
c3.718  add additional exit to iofcb to distinguish\endln
\lnie
        argument not convertable to string and argument\endln
\lnie
        file not open.\endln
\lnie
c3.719  add fourth and fifth arguments to host function.\endln
\lnie
c3.720  add &compare keyword to control string\endln
\lnie
        comparisons.\endln
\lnie
c3.721  setup pfdmp at iniy0 in case osint forced\endln
\lnie
        &profile non-zero.\endln
\lnie
c3.722  add conditional symbol .caex to include up arrow\endln
\lnie
        as synonym for exponentiation.\endln
\lnie
c3.723  add conditional .ccmc and external function syscm\endln
\lnie
        to provide string comparison using collation\endln
\lnie
        sequence other than strict ordering of character\endln
\lnie
        codes (international compares).\endln
\lnie
c3.724  add conditional .cpol and external function syspl\endln
\lnie
        to provide interactive control of spitbol\endln
\lnie
        execution.\endln
\lnie
c3.725  add conditional symbol .cera and external\endln
\lnie
        function sysea to provide advice of compilation\endln
\lnie
        and runtime errors to osint.\endln
\lnie
c3.726  add cmpln, rdcln, rdnln to track source line\endln
\lnie
        number.\endln
\lnie
c3.727  converted error messages to upper/lower case.\endln
\lnie
c3.728  add conditional .cgbc to external routine sysgc.\endln
\lnie
        called at the start and end of garbage collection\endln
\lnie
        to perform any needed notification to operating\endln
\lnie
        system or user.\endln
\lnie
c3.729  modified last line of s$set from exnul to exint\endln
\lnie
        so seek can return final file position after\endln
\lnie
        seek.\endln
\lnie
c3.730  place mov xr,(xs) at s$rmd+4 to allow real second\endln
\lnie
        arg to remdr.\endln
\lnie
c3.731  remove redundant bge xr,=cfp$u,scn07 at scn06+4\endln
\lnie
c3.732  change definition of cmc and trc such that only\endln
\lnie
        xl must be cleared after operation.  note, this\endln
\lnie
        change was subsequently voided.  cmc and trc must\endln
\lnie
        clear both xl and xr, because utility routines\endln
\lnie
        may preserve xl or xr on the stack, and the stack\endln
\lnie
        is collectable by gbcol.\endln
\lnie
c3.733  remove most branches to exits and exixr.\endln
\lnie
        instead, jump directly to next code word.\endln
\lnie
c3.734  add error 260 for array too large in gtarr.\endln
\lnie
c3.735  add conditional .cs32 to initialize stlim to\endln
\lnie
        2147483647.\endln
\lnie
c3.736  add second argument to exit function, allowing\endln
\lnie
        user to specify file name of load module being\endln
\lnie
        written.  if omitted, osint will provide a\endln
\lnie
        default name.\endln
\lnie
c3.737  add conditional .cspr to include spare locations\endln
\lnie
        in working area.  these may be used in later bug\endln
\lnie
        fixes without changing the size of the working\endln
\lnie
        storage and obsoleting modules created by exit().\endln
\lnie
        subsuently removed in c3.767.\endln
\lnie
c3.738  add r$cts to remember last string used to build\endln
\lnie
        bit column in patst.\endln
\lnie
c3.739  change flstg to type e procedure instead of r.\endln
\lnie
c3.740  standardize on big-endian systems.  at the\endln
\lnie
        implementors choice, the zgb opcode can also\endln
\lnie
        perform a byte swap if necessary to achieve big-\endln
\lnie
        endian byte ordering.  this is done so that\endln
\lnie
        systems with similar word lengths will produce\endln
\lnie
        the same hash code for strings, and hence the\endln
\lnie
        same ordering for table entries.  the hashs\endln
\lnie
        procedure has an additional zgb added to reorder\endln
\lnie
        the length word.\endln
\lnie
c3.741  add conditional .csou to cause assignments to\endln
\lnie
        output and terminal variables to be processed\endln
\lnie
        through calls to sysou rather than through\endln
\lnie
        listing buffer.  done to eliminate short record\endln
\lnie
        lengths enforced by buffer size.  a code of 0 or\endln
\lnie
        1 is passed to sysou instead of an fcblk.\endln
\lnie
c3.742  increased iniln, inils, rilen to 1024.\endln
\lnie
c3.743  add bit to syspp to set noerrors mode.\endln
\lnie
c3.744  add .ccmk conditional to include keyword compare\endln
\lnie
        even if syscm is not being included.  done to\endln
\lnie
        provide identical data regions in systems that\endln
\lnie
        implement syscm and those which do not, so that\endln
\lnie
        save files can be exchanged in the next release.\endln
\lnie
c3.745  add wc return parameter to sysil to allow\endln
\lnie
        interface to inform spitbol if file about to be\endln
\lnie
        read is a binary file.  if so, no blank trimming\endln
\lnie
        occurs.\endln
\lnie
c3.746  fold load function argument types to upper case.\endln
\lnie
c3.747  add .cexp conditional to have sysex pop its\endln
\lnie
        arguments.\endln
\lnie
c3.748  in stopr, do not attempt to display file name and\endln
\lnie
        line number if stopping because of stack overflow\endln
\lnie
        during garbage collection.  pointers to file name\endln
\lnie
        table and code block are wrong.\endln
\lnie
c3.749  add bit to syspp to set case folding mode.\endln
\lnie
c3.750  add additional return from sysld if insufficient\endln
\lnie
        memory to load/call external function.\endln
\lnie
c3.751  add additional returns from sysex if insufficient\endln
\lnie
        memory or bad argument type.\endln
\lnie
c3.752  ignore leading and trailing blanks in arguments\endln
\lnie
        within prototype strings to clear, data, define\endln
\lnie
        and load.\endln
\lnie
c3.753  test for fatal error at err04 and abort if so.\endln
\lnie
        force termination on stack overflow by setting\endln
\lnie
        errft to 4 in stack overflow section.\endln
\lnie
c3.754  recode copy loop at srt14 to exchange usage of\endln
\lnie
        registers xl and xr.  this permits use of the\endln
\lnie
        mvw order instead of the explicit loop coding\endln
\lnie
        previously employed.\endln
\lnie
c3.755  add .ceng conditional to include routines needed\endln
\lnie
        by text processing engine. add routines enevs and\endln
\lnie
        engts for use by engine or debugger.  copy xr to\endln
\lnie
        xl around call to syspl to allow syspl to\endln
\lnie
        trigger garbage collection.\endln
\lnie
c3.756  add &file, &lastfile, &line, &lastline keywords.\endln
\lnie
        for now, line and lastline are maintained in the\endln
\lnie
        same manner as stno and lastno, which adds over-\endln
\lnie
        head to the statement initialization code.  a\endln
\lnie
        possible change is to create a stmln procedure\endln
\lnie
        that maps statement numbers to line numbers.\endln
\lnie
        one simple strategy would be to sweep code blocks\endln
\lnie
        in memory looking for the statement number and\endln
\lnie
        extracting the line number from that code block.\endln
\lnie
        such a procedure would also allow line numbers\endln
\lnie
        (and file names) to be added to statement profile\endln
\lnie
        reports.\endln
\lnie
c3.757  change sort to fail instead of producing error\endln
\lnie
        message if argument table is null.  change sorta\endln
\lnie
        to return failure.  add another return to gtarr\endln
\lnie
        to distinguish null table from bad argument.\endln
\lnie
c3.758  create procedure prtmm to display memory usage\endln
\lnie
        statistics, and call it when producing end-of-\endln
\lnie
        run stats.\endln
\lnie
c3.759  add label scontinue to allow setexit to resume\endln
\lnie
        execution exactly where it was interrupted.\endln
\lnie
c3.760  add snobol4 backspace function and conditional\endln
\lnie
        .cbsp.\endln
\lnie
c3.761  add additional arguments to sysgc to assist\endln
\lnie
        virtual memory managers.\endln
\lnie
c3.762  the method of converting a table to an array has\endln
\lnie
        been revised.  previously, table elements were\endln
\lnie
        copied to the result array in the order they were\endln
\lnie
        encountered along the various hash chains.  this\endln
\lnie
        appeared to the user as a random ordering.  how-\endln
\lnie
        ever, spitbol/370 as well as sil snobol4 ordered\endln
\lnie
        array elements according to their time of entry\endln
\lnie
        into the table.  user programs that relied upon\endln
\lnie
        this behavior malfunctioned when ported to macro\endln
\lnie
        spitbol.\endln
\lnie
        to remedy this, the conversion is performed in\endln
\lnie
        three steps:\endln
\lnie
        1. convert table to an array placing the address\endln
\lnie
           of each teblk in the array instead of the key\endln
\lnie
           and value.\endln
\lnie
        2. sort the array of addresses.  this orders ele-\endln
\lnie
           ments by time of creation (ascending address).\endln
\lnie
        3. scan the array, replacing addresses with the\endln
\lnie
           key and value from the referenced teblk.\endln
\lnie
        the affected portions of the program are at s$cnv\endln
\lnie
        and in gtarr, which now accepts an additional\endln
\lnie
        argument specifying whether to place key/values\endln
\lnie
        in the array or teblk addresses.\endln
\lnie
c3.763  if case-folding is active, fold the function name\endln
\lnie
        provided to the load() function before passing it\endln
\lnie
        to sysld.\endln
\lnie
c3.764  add sediment algorithm to garbage collector,\endln
\lnie
        conditioned on .csed.\endln
\lnie
c3.765  add optimization to discard null statements and\endln
\lnie
        statements which just have a constant subject\endln
\lnie
        (see code at cmp12).\endln
\lnie
c3.766  rearranged order of initial objects in static\endln
\lnie
        memory so that hash table is the last of the four\endln
\lnie
        object created by initialization code.  this is\endln
\lnie
        done so that the print buffer, gts work area, and\endln
\lnie
        &alphabet keywords do not need to be saved in\endln
\lnie
        any save file created by osint.  added routine to\endln
\lnie
        initialize these structures.\endln
\lnie
c3.767  removed .cspr conditional and spare locations.\endln
\lnie
c3.768  added .crel conditional and extensive routines\endln
\lnie
        (reloc et. al.) to perform relocation of data\endln
\lnie
        in working section, static region, and dynamic\endln
\lnie
        region after reload of a saved memory image.\endln
\lnie
        routines relaj, relcr, and reloc are invoked\endln
\lnie
        by osint after reloading a save file.\endln
\lnie
        it is now possible to reload such an image even\endln
\lnie
        if the spitbol compiler and its data structures\endln
\lnie
        are reloaded to other addresses.  the working\endln
\lnie
        section has been extensively rearranged to\endln
\lnie
        accommodate the reloc procedure.\endln
\lnie
c3.769  zero r$ccb (interim ccblk ptr) in collect,\endln
\lnie
        convert, eval, and exit functions to release\endln
\lnie
        unneeded ccblk memory.\endln
\lnie
c3.770  add exit(4) and exit(-4) to allow execution to\endln
\lnie
        continue after writing save file or load module.\endln
\lnie
        revised sysxi interface to detect continuation\endln
\lnie
        after performance of exit(4) or exit(-4) action.\endln
\lnie
c3.771  change filnm to preserve registers.\endln
\lnie
c3.772  addition of .cncr and syscr (real to string\endln
\lnie
        system routine option).\endln
\lnie
c3.773  modified replace function to optimize usage\endln
\lnie
        when second argument is &alphabet.  in this case,\endln
\lnie
        the third argument can be used as the translate\endln
\lnie
        table directly.\endln
\lnie
c3.774  modified conditionals for buffers and reals so\endln
\lnie
        that their respective block codes are always\endln
\lnie
        present, even if these data types are conditioned\endln
\lnie
        out.  this provides consistent block code\endln
\lnie
        numbering for external functions.\endln
\lnie
c3.775  modified alobf to test string length against\endln
\lnie
        kvmxl instead of mxlen.  also, alobf was testing\endln
\lnie
        total size of bfblk, instead of just string len.\endln
\lnie
c3.776  move utility routines source up to lie between\endln
\lnie
        predefined snobol functions (s$xxx) routines and\endln
\lnie
        utility procedures.  this was done to assist\endln
\lnie
        translation on platforms such as apple macintosh\endln
\lnie
        that use 15-bit offsets to store error exits (ppm\endln
\lnie
        branches).  offsets to labels like exfal were\endln
\lnie
        just too far away.  similarly, functions tfind,\endln
\lnie
        tmake, and vmake are located out of alphabetic\endln
\lnie
        order to satisfy the macintosh's limited range\endln
\lnie
        for subroutine calls.  move built-in labels\endln
\lnie
        beyond the block and pattern routines to get it\endln
\lnie
        within 32k of the error routines.\endln
\lnie
c3.777  at scn46, allow colon, right paren and right\endln
\lnie
        bracket to terminate = operator with default\endln
\lnie
        null operand.\endln
\lnie
c3.778  added .ctet conditional for table entry trace.\endln
\lnie
c3.779  introduce cfp$l, the largest unsigned value\endln
\lnie
        that may be stored in a one-word integer.  this\endln
\lnie
        is done to accommodate machines where memory\endln
\lnie
        addresses have the high-order address bit set.\endln
\lnie
c3.780  perform replace in place if first arg is buffer.\endln
\lnie
c3.781  perform reverse in place if first arg is buffer.\endln
\lnie
c3.782  change sysou to accept buffer as well as string\endln
\lnie
        to be output.  change code at asg11 to prevent\endln
\lnie
        conversion of buffer to string.\endln
\lnie
c3.783  optimize pos and rpos when it is the first node\endln
\lnie
        of a pattern and has either an integer or simple\endln
\lnie
        expression variable argument.  if unanchored mode\endln
\lnie
        and the cursor is zero, it is advanced directly\endln
\lnie
        to the desired cursor position.\endln
\lnie
c3.784  perform trim function in place if arg is buffer.\endln
\lnie
c3.785  add gtstb procedure to get a string or buffer\endln
\lnie
        argument for replace, reverse, size, trim, etc.\endln
\lnie
c3.786  change leq, lgt, etc. to perform comparisons\endln
\lnie
        without converting buffer arguments to strings.\endln
\lnie
        this is done by changing lcomp to accept buffer\endln
\lnie
        argument(s).  this also affects sort function,\endln
\lnie
        which will compare two buffers as strings.\endln
\lnie
c3.787  change gtnum to use characters in buffer without\endln
\lnie
        conversion to a string.  this implies that acomp\endln
\lnie
        will perform arithmetic comparisons of buffers\endln
\lnie
        without converting to strings first.\endln
\lnie
c3.788  perform comparisons of strings and buffers in\endln
\lnie
        sortc.\endln
\lnie
c3.789  change insbf to allow insertion of a buffer into\endln
\lnie
        a buffer without first converting it to a string.\endln
\lnie
        note that this only works when the two buffers\endln
\lnie
        are not the same.\endln
\lnie
c3.790  documentation change:  note that all of the block\endln
\lnie
        move opcodes should have wa .gt. 0.  not all\endln
\lnie
        implementations avoid moving objects when wa is\endln
\lnie
        zero.\endln
\lnie
c3.791  change ident to provide buffer/buffer and\endln
\lnie
        buffer/string comparisons, to accommodate users\endln
\lnie
        who perform ident(buf) to check for null string\endln
\lnie
        in buffer.\endln
\lnie
c3.792  added fullscan keyword initialized to one.  user\endln
\lnie
        may set to any non-zero value, will receive an\endln
\lnie
        error message if attempts to set to zero, since\endln
\lnie
        quickscan mode is not supported.\endln
\lnie
c3.793  rewrote statement startup code at stmgo to only\endln
\lnie
        perform checking of profiling, stcount tracing,\endln
\lnie
        and statement counting if necessary.\endln
\lnie
c3.794  add additional exit to sysfc and ioput to signal\endln
\lnie
        that i/o channel (fcblk) is already in use.\endln
\lnie
        added error message numbers 289 and 290.\endln
\lnie
c3.795  added optional integer argument to date function\endln
\lnie
        to specify format of date string returned by\endln
\lnie
        sysdt.\endln
\lnie
\endln
\lnie
\endln
\lnie
version 3.6 to 3.6a (oct 83)\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
c3.617  add .cnlf. if defined, then arguments to external\endln
\lnie
        functions may be declared to have type file.\endln
\lnie
        such arguments must have been used as second\endln
\lnie
        arg to input() or output() and a pointer to the\endln
\lnie
        fcb is passed to the external function.\endln
\lnie
\endln
\lnie
\endln
\lnie
version 3.5 to 3.6 (jun 83)\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
codes used to identify authors are (sgd) for duff,\endln
\lnie
(reg) for  goldberg, and (lds) for shields.\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
b3.601  (sgd) to fix multiple trap block problem in asign\endln
\lnie
b3.602  (sgd) patch in gtarr to fix null convert.\endln
\lnie
b3.603  (sgd) inserted missing wtb after sysmm calls.\endln
\lnie
b3.604  (sgd) use string length in hashs.\endln
\lnie
b3.605  (sgd) fixed serious parser problem\endln
\lnie
        relating to (x y) on line being viewed as pattern\endln
\lnie
        match.  fixed by addition of new cmtyp value\endln
\lnie
        c$cnp (concatenation - not pattern match).\endln
\lnie
b3.606  (sgd) fixed exit(n) respecification code\endln
\lnie
        to properly observe header semantics on return.\endln
\lnie
b3.607  (sgd) bypass prtpg call at initialization\endln
\lnie
        following compilation if no output generated.\endln
\lnie
        this prevents output files consisting of the\endln
\lnie
        headers and a few blank lines when there is no\endln
\lnie
        source listing and no compilation stats.\endln
\lnie
        also fix timsx initialization in same code.\endln
\lnie
b3.608  (sgd) b$efc code did not check for\endln
\lnie
        unconverted result returning null string.\endln
\lnie
b3.609  (sgd) load pfvbl field in retrn for\endln
\lnie
        return tracing. this was causing bug on return\endln
\lnie
        traces that tried to access the variable name.\endln
\lnie
b3.610  (sgd) fixed problem relating to compilation of\endln
\lnie
        goto fields containing small integers\endln
\lnie
        (in const sec).\endln
\lnie
b3.611  (reg) prevent clear() from clobbering protected\endln
\lnie
        variables at label sclr5.\endln
\lnie
b3.612  (reg) fixed gtexp from accepting trailing\endln
\lnie
        semicolon or colon. this is not a legal way\endln
\lnie
        to end an expression.\endln
\lnie
b3.613  (reg) fixed difficulties with listings during\endln
\lnie
        execution when no listing generated during\endln
\lnie
        compilation. -list to code() caused bomb.\endln
\lnie
        fix is to reset r$ttl and r$stl to nulls not 0\endln
\lnie
        after compilation.\endln
\lnie
        (listr and listt expect nulls)\endln
\lnie
        when listing and statistics routed to different\endln
\lnie
        file than execution output, error message is sent\endln
\lnie
        to execution output (and gets separated from\endln
\lnie
        ... in statement ... msg). labo1 calls sysax and\endln
\lnie
        stopr does not call sysax if entered from labo1.\endln
\lnie
b3.614  (lds) fix misuse of wc just after asg10.\endln
\lnie
b3.615  (lds) add comment pointing out suspicious code\endln
\lnie
        after tfn02\endln
\lnie
b3.616  (lds) fix inconsistent declaration of sorth.\endln
\lnie
b3.617  (lds) insert missing conditional tests on cnbf.\endln
\lnie
b3.618  (lds) fix some violations of minimal language\endln
\lnie
        that had slipped past some translators.\endln
\lnie
b3.619  (lds) correct error introduced in fixing b3.614.\endln
\vfill\break

\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
\endln
\lnie
c3.601  (sgd) addition of .cnci and sysci (int to string\endln
\lnie
        system routine option)\endln
\lnie
c3.602  (reg) changed iniln and and inils to 258\endln
\lnie
c3.603  (sgd) merged in profiler patches, repaired code.\endln
\lnie
c3.604  (sgd) added buffer type and symbol cnbf\endln
\lnie
c3.605  (sgd) added char function.  char(n) returns nth\endln
\lnie
        character of host machine character set.\endln
\lnie
c3.606  (reg) added cfp$u to ease translation on smaller\endln
\lnie
        systems - conditional .cucf\endln
\lnie
c3.607  (reg) added lower case support, conditional .culc\endln
\lnie
c3.608  (reg) added set i/o function, conditional .cust\endln
\lnie
c3.609  (reg) conditionalized page eject after call to\endln
\lnie
        sysbx and added another before call to sysbx,\endln
\lnie
        so that, if desired by the implementor,\endln
\lnie
        standard output will reflect assignments made\endln
\lnie
        by executing program only.\endln
\lnie
        conditional .cuej controls - if defined then\endln
\lnie
        eject is before call to sysbx.\endln
\lnie
c3.610  (lds) introduce .ctmd to support systm that\endln
\lnie
        reports elapsed time in deciseconds instead of\endln
\lnie
        milliseconds.\endln
\lnie
c3.611  (lds)  provide place for .def or .und for each\endln
\lnie
        conditional  option, so that settings can be\endln
\lnie
        changed without changing line numbers.\endln
\lnie
        current settings are for 808x translation.\endln
\lnie
c3.612  (lds) obey (new) restriction that operand in\endln
\lnie
        conditional branch instruction cannot have form\endln
\lnie
        (x)+ in order to simplify translations for which\endln
\lnie
        postincrement not readily available.\endln
\lnie
c3.613  (reg,lds) add op\endln
\lnie
              flc wreg\endln
\lnie
        that folds character in wreg to upper case.\endln
\lnie
        this op is used only if .culc is defined.\endln
\lnie
        this change also involves addition of keyword\endln
\lnie
        &case which when nonzero (the initial setting)\endln
\lnie
        causes the case folding just described to be\endln
\lnie
        done.\endln
\lnie
c3.614  (lds) add option .cs16 to permit initialization\endln
\lnie
        of statement limit values to 32767 for 16 bit\endln
\lnie
        machines.\endln
\lnie
c3.615  (lds) permit return point and entry point\endln
\lnie
        addresses to be distinguished by their parity\endln
\lnie
        instead of by lying within a certain range\endln
\lnie
        of values.  introduce conditional symbols\endln
\lnie
        .crpp  return points have odd parity\endln
\lnie
        .cepp  entry points have odd parity\endln
\lnie
c3.616  (lds) introduce new minimal opcodes to branch\endln
\lnie
        according to parity,\endln
\lnie
          bev  opn,plbl  branch if address even\endln
\lnie
          bod  opn,plbl  branch if address odd\endln
\lnie
        an address is even if it is a multiple of cfp$b.\endln
\vfill\break

\lnie
documentation revisions\endln
\lnie
-----------------------\endln
\lnie
\endln
\lnie
d3.601  (lds) bring minimal machine description up to\endln
\lnie
        date\endln
\lnie
\endln
\vfill\break

\lnie
version 3.4 to 3.5 (feb 79)\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
\endln
\lnie
b3.401  prtst should be declared as an r type procedure.\endln
\lnie
b3.402  timing error if spitbol fails in dump.\endln
\lnie
b3.403  error in handling omitted args of operators.\endln
\lnie
b3.404  too many lines put on first page of listing.\endln
\lnie
b3.405  leading unary operator in eval erroneously needed\endln
\lnie
        preceding blank.\endln
\lnie
b3.406  identifying name in dump of array or table values\endln
\lnie
        was omitted.\endln
\lnie
b3.407  eval unable to return a deferred expression.\endln
\lnie
b3.408  illegal if setexit code branches to return.\endln
\lnie
b3.409  illegal on detaching input, output, terminal.\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
c3.401  -sequ and -nose control cards removed.\endln
\lnie
c3.402  option provided to suppress system identification\endln
\lnie
        on listing.\endln
\lnie
c3.403  description of sysbx slightly revised.\endln
\lnie
c3.404  permissible to modify scblk length before taking\endln
\lnie
        error returns from sysin, sysrd, sysri.\endln
\lnie
c3.405  conditional .cnld may be defined to omit load().\endln
\lnie
c3.406  conditional .cnex may be defined to omit exit().\endln
\lnie
c3.407  table now accepts a third argument specifying\endln
\lnie
        default initial lookup value.\endln
\lnie
c3.408  routines sort, rsort for sorting arrays and table\endln
\lnie
        introduced. specification is as in sitbol.\endln
\lnie
        routines may be omitted by defining .cnsr .\endln
\lnie
c3.409  error in code(), eval() call now causes statement\endln
\lnie
        failure but errtext keyword is still set.\endln
\lnie
c3.410  arg to code() may contain embedded control cards\endln
\lnie
        and comment delimited by a semicolon.\endln
\lnie
\endln
\lnie
documentation revisions\endln
\lnie
-----------------------\endln
\lnie
\endln
\lnie
d3.401  purpose of restriction 2 in minimal section -6-\endln
\lnie
        (operations on char values), erroneously stated\endln
\lnie
        to be for cmc, rather than for ceq, cne.\endln
\lnie
        descriptions of above opcodes revised.\endln
\lnie
d3.402  description of ent clarified.\endln
\lnie
d3.403  descriptions of several opcodes revised to remove\endln
\lnie
        technically invalid literals e.g. =0 , *1.\endln
\lnie
d3.405  restricted use of letter z in minimal clarified.\endln
\lnie
d3.406  divide by zero explicitly mentioned in relation\endln
\lnie
        to overflow setting.\endln
\vfill\break

\lnie
version 3.3 to 3.4 (oct 78)\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
\endln
\lnie
b3.301  illegal for erroneous eval() arg.\endln
\lnie
b3.302  address arithmetic overflow in alloc and alocs.\endln
\lnie
b3.303  -eject and -space ignored -nolist option.\endln
\lnie
b3.304  erroneous argument scan in load().\endln
\lnie
b3.305  erroneous plc on uninitialised r$cim in nexts.\endln
\lnie
b3.306  ldi used instead of mti after prv07.\endln
\lnie
b3.307  misuse of rmi at erra2.\endln
\lnie
b3.308  misuse of mti in hashs.\endln
\lnie
b3.309  bug in -sequ card sequence number checking.\endln
\lnie
b3.310  stack overflow error message not always printed.\endln
\lnie
b3.311  corrupt prototype print for traced arrays.\endln
\lnie
b3.312  pattern first arg in dupl caused error.\endln
\lnie
b3.313  omitted csc in s$rpd, erroneous csc in convert.\endln
\lnie
b3.314  misplaced btw in exbld.\endln
\lnie
b3.315  incorrect code in hashs.\endln
\lnie
b3.316  failure of load to scan integer arg.\endln
\lnie
b3.317  table access with negative integer arg. failed.\endln
\lnie
b3.318  error in returning result of loaded function.\endln
\lnie
b3.319  =e$srs used after ini01 instead of *e$srs.\endln
\lnie
b3.320  err used instead of erb after systu\endln
\lnie
b3.321  label could start with disallowed character.\endln
\lnie
b3.322  continue after setexit had bad heuristic.\endln
\vfill\break

\lnie
\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
c3.301  sysax and .csax introduced - see sysax\endln
\lnie
        in procedures section.\endln
\lnie
c3.302  variable mxlen introduced. contains the maximum\endln
\lnie
        size of a spitbol object and is not changeable\endln
\lnie
        after initialisation. may be defaulted or set\endln
\lnie
        explicitly by sysmx.\endln
\lnie
c3.303  syshs returns revised - see syshs.\endln
\lnie
c3.304  new minimal opcode aov to fix b3.302.\endln
\lnie
c3.305  inhibit stlimit check if stlimit made negative.\endln
\lnie
c3.306  cfp$m is required to be of form 2**n - 1.\endln
\lnie
c3.307  dupl made to conform to sil snobol4 standard.\endln
\lnie
c3.308  lch and sch actions more closely defined.\endln
\lnie
c3.309  batch initialisation code omitted if conditional\endln
\lnie
        assembly symbol .cnbt (no batch) defined.\endln
\lnie
c3.310  (wa) contains argument count in sysex call.\endln
\lnie
c3.311  sysfc  may request allocation of static fcblk.\endln
\lnie
c3.312  if ia,wc overlap, restriction put on dumping/\endln
\lnie
        restoring these registers.\endln
\lnie
c3.313  new listing option intermediate between compact\endln
\lnie
        and extended provided (see syspp).\endln
\lnie
c3.314  revision of sysxi interface to permit options for\endln
\lnie
        load module standard o/p file (see sysxi,syspp).\endln
\lnie
c3.315  last arg of substr may be omitted - treated\endln
\lnie
        as remainder of string.\endln
\vfill\break

\lnie
version 3.2 to 3.3 (jan 78)\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
\endln
\lnie
b3.201  array reference and external function load\endln
\lnie
        routines illegally accessed information\endln
\lnie
        beyond the stack front.\endln
\lnie
        similar fault in unanchored pattern matching.\endln
\lnie
b3.202  dump(1) produced dump(2) type output.\endln
\lnie
b3.203  wtb conversion omitted in code following\endln
\lnie
        ini01, ini02, exbld.\endln
\lnie
b3.204  incorrect fail return from tfind in arref.\endln
\lnie
b3.205  endfile did not detach i/o associated variables.\endln
\lnie
b3.206  -space with omitted arg. failed\endln
\lnie
b3.207  looped if dump keyword non-zero after stack\endln
\lnie
        overflow in garbage collect failure.\endln
\lnie
b3.208  failure in reading numbers with trailing blanks.\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
the extensive changes made here mostly result from a\endln
\lnie
snobol4 implementors meeting held at new york university\endln
\lnie
in august 1977. they are aimed at\endln
\lnie
     (1) having spitbol conform to certain snobol4\endln
\lnie
     language standards  and\endln
\lnie
     (2) producing a stable definition of minimal by\endln
\lnie
     carrying out a few essential revisions in the light\endln
\lnie
     of experience in its use.\endln
\lnie
\endln
\lnie
changes to spitbol\endln
\lnie
------------------\endln
\lnie
\endln
\lnie
c3.201  default values for keywords trim and anchor are\endln
\lnie
        zero. on systems where records are customarily\endln
\lnie
        handled without traling blanks, there is no\endln
\lnie
        obligation to supply such blanks.\endln
\lnie
c3.202  default value of -inxx control card is -in72.\endln
\vfill\break

\lnie
c3.203  the second argument of input and output is\endln
\lnie
        permitted to be an integer as in snobol4.\endln
\lnie
        in addition input(), output() now give a snobol4\endln
\lnie
        statement failure if sysio uses the file not\endln
\lnie
        found return.\endln
\lnie
        the third argument has a recommended format and\endln
\lnie
        to override its default delimiter (,) a\endln
\lnie
        conditional assembly symbol, .ciod, is used.\endln
\lnie
        interfaces to sysef,sysej,syfc,sysio,sysrw\endln
\lnie
        are revised.\endln
\lnie
        wc may now be used to return from sysio, a max\endln
\lnie
        record length.\endln
\lnie
c3.204  a new configuration parameter cfp$f (scblk offset\endln
\lnie
        is introduced. cfp$u is removed.\endln
\lnie
c3.205  implementation and version identification is\endln
\lnie
        required - see sysid.\endln
\lnie
c3.206  routine sysmx returns the maximum length of\endln
\lnie
        spitbol objects (strings arrays etc).  this\endln
\lnie
        information is not now needed at time of entry to\endln
\lnie
        spitbol and hence wc should be zero on entry.\endln
\lnie
c3.207  a conditional parameter .cnra permits assembly\endln
\lnie
        of a more compact version with no real\endln
\lnie
        arithmetic code.\endln
\lnie
c3.208  terminal is a new pre-associated variable\endln
\lnie
        capable of performing input and output to an\endln
\lnie
        online terminal.\endln
\lnie
        sysri is a new routine used in the implementation\endln
\lnie
        of this. see also syspp.\endln
\lnie
c3.209  the environment parameters e$--- are now\endln
\lnie
        provided by the minimal translator using the\endln
\lnie
        revised   equ  *   format (see c3.229 and start\endln
\lnie
        of spitbol definitions section - some reordering\endln
\lnie
        of symbols has occurred).\endln
\lnie
c3.210  the interface of sysxi has been slightly revised.\endln
\lnie
        unavailability of i/o channels after exit(1),\endln
\lnie
        exit(-1) is documented together with additional\endln
\lnie
        error return usage for sysin,sysou,syspr,sysrd.\endln
\lnie
c3.211  spitbol error codes have been frozen - see c3.230\endln
\lnie
c3.212  the utility routines arref etc. are now\endln
\lnie
        introduced by rtn statements.\endln
\lnie
c3.213  sysrl (record length for std input file) is\endln
\lnie
        removed. since implementation of a general -inxxx\endln
\lnie
        control card and an ability to specify max record\endln
\lnie
        length using the third argument of input, sysrl\endln
\lnie
        has become redundant.\endln
\lnie
c3.214  sysej and sysxi are now passed a chain linking\endln
\lnie
        all fcblks in use.\endln
\lnie
c3.215  a special ending code in sysej is used when\endln
\lnie
        attempts to use standard output channel fail.\endln
\lnie
c3.216  restriction c3.233 observed so simplifying\endln
\lnie
        optimised translation of ent with omitted val.\endln
\vfill\break

\lnie
\endln
\lnie
changes to minimal\endln
\lnie
------------------\endln
\lnie
\endln
\lnie
c3.220  minimal opcodes dec, dim, inc, and bmp\endln
\lnie
        are withdrawn and replaced by the more consistent\endln
\lnie
        set dca, dcv, ica, icv.\endln
\lnie
c3.221  chs has been replaced by the more generally\endln
\lnie
        useful zgb (still likely to be a no-op for most\endln
\lnie
        implementations however).\endln
\lnie
c3.222  the set of character comparisons has been\endln
\lnie
        reduced to ceq and cne to ease implementation\endln
\lnie
        problems.\endln
\lnie
c3.223  opcode irz is removed and dvi, rmi orders are\endln
\lnie
        redefined to conform to more common usage.\endln
\lnie
c3.224  new opcodes ssl and sss are defined. their use\endln
\lnie
        permits return links for n type procedures to be\endln
\lnie
        placed on a local stack if desired.\endln
\lnie
c3.225  opcode mnz complements zer. it moves a non-zero\endln
\lnie
        flag to its destination.\endln
\lnie
c3.226  for some machines it is preferable for the stack\endln
\lnie
        to build up rather than down. to permit this\endln
\lnie
        without need for massive changes in minimal and\endln
\lnie
        recoding of existing programs, a scheme has been\endln
\lnie
        devised in which an additional register name, xt,\endln
\lnie
        is used as a synonym for xl when this register\endln
\lnie
        is involved in stack manipulation- see section 4.\endln
\lnie
c3.227  section 0 of a minimal program is renamed the\endln
\lnie
        procedure section. it now contains, in addition\endln
\lnie
        to exp, specifications of internal procedures\endln
\lnie
        and routines by means of the inp and inr opcodes.\endln
\lnie
c3.228  the literal operand formats =int and *int have\endln
\lnie
        been withdrawn. =dlbl and *dlbl must be used in\endln
\lnie
        their stead.\endln
\lnie
c3.229  the format\endln
\lnie
        label  equ  *nn\endln
\lnie
        used to specify values supplied by the minimal\endln
\lnie
        translator for char. codes etc. is replaced by\endln
\lnie
        label  equ  *\endln
\lnie
        where the order in which the definitions are\endln
\lnie
        supplied by the translator should match the\endln
\lnie
        order of occurrence in the definitions section.\endln
\lnie
c3.230  the format of err,erb opcodes is changed to\endln
\lnie
        require a numeric operand.\endln
\lnie
c3.231  the rtn opcode is used to introduce routines\endln
\lnie
        (which are quite distinct from procedures).\endln
\lnie
c3.232  conditional assembly directives may be nested.\endln
\lnie
c3.233  minor restriction placed on the omission of\endln
\lnie
        val with the ent opcode.\endln
\vfill\break

\lnie
version 3.1 to 3.2 (aug 77)\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
\endln
\lnie
b3.101  astonishing this was unnoticed for three years.\endln
\lnie
        bad code for snobol4 integer divide, /, gave\endln
\lnie
        wrong result for operands of opposite signs.\endln
\lnie
        implementations have either wrongly translated\endln
\lnie
        dvi and got correct result or correctly\endln
\lnie
        translated dvi and got wrong result - leeds had\endln
\lnie
        one of each. see also c3.106.\endln
\lnie
        test program no. 1 now extended to check /\endln
\lnie
        more thoroughly.\endln
\lnie
b3.102  garbage collection bug in scane\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
c3.101  option to use additional characters ch$ht,ch$vt\endln
\lnie
        (horizontal and vertical tab) with same syntactic\endln
\lnie
        significance as ch$bl (blank).\endln
\lnie
c3.102  option to use a set of shifted case alphabetic\endln
\lnie
        characters ch$$a ... ch$$$.\endln
\lnie
c3.103  conditional assembly features are introduced into\endln
\lnie
        minimal on account of the above.\endln
\lnie
        see minimal documentation section for details\endln
\lnie
        of above changes.\endln
\lnie
c3.104  lch and sch may use an x register first\endln
\lnie
        operand as alternative to a w register.\endln
\lnie
c3.105  spitbol statement numbers in the listing may\endln
\lnie
        optionally be padded to 6 or 8 chars instead of 5\endln
\lnie
        by defining conditional assembly symbols\endln
\lnie
        .csn6 or .csn8 .\endln
\lnie
c3.106  to fix bug 3.101. at moderate cost,\endln
\lnie
        opcode irz (branch if integer divide remainder\endln
\lnie
        zero) introduced.\endln
\lnie
c3.107  to handle possible machine dependency in string\endln
\lnie
        hashing, chs (complete hashing of string) opcode\endln
\lnie
        is introduced. probably a no-op on most machines\endln
\lnie
        - not on the dec10.\endln
\lnie
c3.108  procedures patin,tfind,trace have been\endln
\lnie
        modified to conform to the minimal standard\endln
\lnie
        call and return regime.\endln
\lnie
c3.109  sysfc interface revised slightly to permit\endln
\lnie
        osint to return a pointer to a privately\endln
\lnie
        allocated fcblk which spitbol will return on\endln
\lnie
        subsequent i/o - see sysfc doc.\endln
\lnie
c3.110  to remove inconsistencies in calling sequences,\endln
\lnie
        all sys routines having access to a possible\endln
\lnie
        fcblk have fcblk ptr or zero in reg. wa on entry.\endln
\lnie
        change affects sysef, sysen, sysil, sysin,\endln
\lnie
        sysou, sysrw.\endln
\lnie
c3.111  syspp bit allocated to provide\endln
\lnie
         -noexec option on entry to spitbol.\endln
\vfill\break

\lnie
\endln
\lnie
documentation revisions\endln
\lnie
-----------------------\endln
\lnie
\endln
\lnie
d3.101  need to preserve registers in syspi, syspr,\endln
\lnie
        sysrd calls was overstated.\endln
\vfill\break

\lnie
version 3.0 to 3.1 (mar 77)\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
\endln
\lnie
b3.001  replace() could fail during pre-evaluation.\endln
\lnie
        spitbol now signals an error for null or\endln
\lnie
        unequally long 2nd and 3rd arguments.\endln
\lnie
b3.002  negative second arguments to dupl, lpad, rpad\endln
\lnie
        caused spitbol to signal an error. now causes\endln
\lnie
        return of null string or first arg respectively.\endln
\lnie
b3.003  brn-s used instead of ppm-s in s$sub.\endln
\lnie
b3.004  err used instead of erb after cmp30.\endln
\lnie
b3.005  b$pfc, s$cnv, s$def, arith and arref kept\endln
\lnie
        information illegally above the stack top.\endln
\lnie
b3.006  pre-evaluation of constant parts of\endln
\lnie
        complex gotos was erroneous.\endln
\lnie
b3.007  incorrect handling of labels compiled by code().\endln
\lnie
b3.008  the single use of trc (in s$rpl) was not in\endln
\lnie
        accord with its definition. some translations of\endln
\lnie
        trc may need revision now that the use\endln
\lnie
        has been brought into line with definition.\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
a debate on a few weaknesses in minimal design has\endln
\lnie
been resolved by introducing 4 new opcodes.\endln
\lnie
\endln
\lnie
c3.001  new minimal opcodes bmp and dim introduced\endln
\lnie
        to augment inc and dec which are applicable\endln
\lnie
        only to addresses.\endln
\lnie
c3.002  the opcode szc (store zero characters) had\endln
\lnie
        a restricted applicability. it has been\endln
\lnie
        replaced by the more general zer (zeroise).\endln
\lnie
c3.003  fcblks may be optionally allocated as xrblk-s or\endln
\lnie
        xnblk-s  - see sysfc for vital information.\endln
\lnie
c3.004  control card processing has been recoded.\endln
\lnie
        -inxxx allows specification of standard input\endln
\lnie
        file record lengths other than 72 or 80, see also\endln
\lnie
        sysrl. -sequ is ignored unless -in80 is in effect\endln
\lnie
c3.005  to enable efficient buffering of chars on\endln
\lnie
        machines without char. handling orders, the\endln
\lnie
        csc (complete store characters) instruction\endln
\lnie
        is introduced. current implementations can\endln
\lnie
        translate it as a no-op if it is of no benefit.\endln
\lnie
c3.006  integers 0,1,2 are treated specially.\endln
\lnie
        icblks in static are used instead of\endln
\lnie
        allocating space in dynamic.\endln
\vfill\break

\lnie
\endln
\lnie
version 2.7 (june 76) to 3.0 (jan 77)\endln
\lnie
-------------------------------------\endln
\lnie
\endln
\lnie
bugs fixed\endln
\lnie
----------\endln
\lnie
\endln
\lnie
b2.701  goes illegal if timed out during processing of\endln
\lnie
        dump() call.\endln
\lnie
b2.702  goes illegal if spitbol error detected in args of\endln
\lnie
        code() or eval(). bug fixed so that user now gets\endln
\lnie
        a spitbol error report (trappable by setexit)\endln
\lnie
        before statement failure.\endln
\lnie
b2.703  goes illegal in some circumstances when\endln
\lnie
        multiple compilation errors occur in a statement\endln
\lnie
b2.704  goes illegal if garbage collector runs out of\endln
\lnie
        stack space.\endln
\lnie
b2.705  control card processing incorrect for cdc 6400.\endln
\lnie
b2.706  incorrect handling of multiple occurrences of\endln
\lnie
        chars in replace 2nd and 3rd args.\endln
\lnie
b2.707  stack overflow in pre-evaluation of replace in\endln
\lnie
        cdc 6400 version.\endln
\lnie
b2.708  an explicit call of sysmw was coded in s$dat\endln
\lnie
        instead of the mvw opcode.\endln
\lnie
b2.709  call of garbage collector whilst dumping\endln
\lnie
        caused havoc.\endln
\lnie
b2.710  size restriction on spitbol objects (size must be\endln
\lnie
        numerically less than lowest dynamic address)\endln
\lnie
        was not enforced, with potential for catastrophe.\endln
\lnie
b2.711  deferred expressions involving alternation or\endln
\lnie
        negation were incorrectly translated.\endln
\lnie
b2.712  listing of a compilation error at the end of a\endln
\lnie
        long line could cause compiler to go illegal.\endln
\lnie
b2.713  incorrect -nofail code with success goto.\endln
\vfill\break

\lnie
\endln
\lnie
\endln
\lnie
changes\endln
\lnie
-------\endln
\lnie
\endln
\lnie
(it is not anticipated that major revisions on this\endln
\lnie
scale will be frequent).\endln
\lnie
\endln
\lnie
c2.701  default value of anchor keyword is set to 1. this\endln
\lnie
        conflicts with snobol4 practice but is a\endln
\lnie
        preferable default for most applications.\endln
\lnie
c2.702  if errtype is out of range the string in keyword\endln
\lnie
        errtext is printed as the error message.\endln
\lnie
c2.703  if stlimit is exceeded, up to 10 more statements\endln
\lnie
        may be obeyed to permit setexit trap to gain\endln
\lnie
        control.\endln
\lnie
c2.704  the concept of an interactive channel is\endln
\lnie
        introduced for implementations where an online\endln
\lnie
        terminal may be used for spitbol. the standard\endln
\lnie
        print file may be specified as interactive in\endln
\lnie
        which case shorter title lines are output.\endln
\lnie
        alternatively copies of compilation and\endln
\lnie
        execution errors only may be sent to this channel\endln
\lnie
c2.705  printing of compilation statistics may be\endln
\lnie
        suppressed.\endln
\lnie
c2.706  printing of execution statistics may be\endln
\lnie
        suppressed.\endln
\lnie
c2.707  extended or compact listing format may be\endln
\lnie
        selected.\endln
\lnie
c2.708  an initial -nolist option may be specified\endln
\lnie
        before compilation starts.\endln
\lnie
c2.709  to specify choices implied by c2.704 to c2.708\endln
\lnie
        syspp interface is revised and syspi is defined.\endln
\lnie
c2.710  compilation and execution time statistics\endln
\lnie
        messages have been shortened.\endln
\lnie
c2.711  the exit function as in sitbol is introduced\endln
\lnie
        to permit saving load modules - see sysxi, s$ext.\endln
\lnie
c2.712  diagnostic routines sysgb and sysgd have been\endln
\lnie
        removed. they were useful in the early debugging\endln
\lnie
        days but have fallen into disuse now.\endln
\lnie
c2.713  szc may have an operand of type opn instead of\endln
\lnie
        type opw\endln
\lnie
c2.714  input/output association interface has been\endln
\lnie
        revised. sysif,sysof have been consolidated into\endln
\lnie
        the new system routine, sysio, and the\endln
\lnie
        specification of sysfc has been slightly changed.\endln
\lnie
c2.715  configuration parameter mxlen has been withdrawn\endln
\lnie
        and the maximum size of a spitbol object which\endln
\lnie
        was formerly fixed at spitbol compile time by\endln
\lnie
        reference to it may now be specified as a run\endln
\lnie
        time option by placing a value in wc before entry\endln
\lnie
        to spitbol. (see comment on dynamic area in\endln
\lnie
        basic information section).\endln
\lnie
c2.716  a function, host, is introduced which yields\endln
\lnie
        information about the host machine - see syshs\endln
\lnie
        and s$hst.\endln
\vfill\break

\lnie
\endln
\lnie
documentation revisions\endln
\lnie
-----------------------\endln
\lnie
\endln
\lnie
d2.701  the description of mvc has been revised to\endln
\lnie
        reflect the fact that some spitbol code sequences\endln
\lnie
        rely on mvc not destroying wb. minor changes\endln
\lnie
        have been made to mwb and mvw descriptions to\endln
\lnie
        emphasise similarities in the implicit loops of\endln
\lnie
        these orders.\endln
\lnie
d2.702  descriptions of dvi and rmi have been clarified.\endln
\lnie
d2.703  implementation of rsx,lsx,ceq,cge,cgt,chi,clo,clt\endln
\lnie
        is optional at present since they are currently\endln
\lnie
        unused. their use in later versions is not\endln
\lnie
        excluded.\endln
\lnie
d2.704  impossibility of using stack for return links of\endln
\lnie
        n type procedures is emphasised.\endln
\lnie
d2.705  notation (xl),(wc) etc in language description is\endln
\lnie
        clarified.\endln
\lnie
d2.706  documentation of sysfc, sysio has been improved.\endln
\lnie
d2.707  opcode descriptions are cross referenced from\endln
\lnie
        the alphabetical opcode list.\endln
\lnie
d2.708  general description of compiler has been moved to\endln
\lnie
        the start of the compiler proper.\endln
\lnie
d2.709  definitions of environment parameters have been\endln
\lnie
        put near the front of the definitions section.\endln
\vfill\break
{\bf minimal--\rm machine independent macro assembly lang.}
\vskip1em
\vfill\break

\lnie
\endln
\lnie
the following sections describe the implementation\endln
\lnie
language originally developed for spitbol but now more\endln
\lnie
widely used. minimal is an assembly language\endln
\lnie
for an idealized machine. the following describes the\endln
\lnie
basic characteristics of this machine.\endln
\lnie
\endln
\lnie
section 1 - configuration parameters\endln
\lnie
\endln
\lnie
there are several parameters which may vary with the\endln
\lnie
target machine. the macro-program is independent of the\endln
\lnie
actual definitions of these parameters.\endln
\lnie
\endln
\lnie
the definitions of these parameters are supplied by\endln
\lnie
the translation program to match the target machine.\endln
\lnie
\endln
\lnie
cfp$a                 number of distinct characters in\endln
\lnie
                      internal alphabet in the range\endln
\lnie
                      64 le cfp$a le mxlen.\endln
\lnie
\endln
\lnie
cfp$b                 number of bytes in a word where a\endln
\lnie
                      byte is the amount of storage\endln
\lnie
                      addressed by the least significant\endln
\lnie
                      address bit.\endln
\lnie
\endln
\lnie
cfp$c                 number of characters which can\endln
\lnie
                      be stored in a single word.\endln
\lnie
\endln
\lnie
cfp$f                 byte offset from start of a string\endln
\lnie
                      block to the first character.\endln
\lnie
                      depends both on target machine and\endln
\lnie
                      string data structure. see plc, psc\endln
\lnie
\endln
\lnie
cfp$i                 number of words in a signed\endln
\lnie
                      integer constant\endln
\lnie
\endln
\lnie
cfp$l                 the largest unsigned integer\endln
\lnie
                      of form 2**n - 1 which can be\endln
\lnie
                      stored in a single word.  n will\endln
\lnie
                      often be cfp$n but need not be.\endln
\lnie
\endln
\lnie
cfp$m                 the largest positive signed integer\endln
\lnie
                      of form 2**n - 1 which can be\endln
\lnie
                      stored in a single word.  n will\endln
\lnie
                      often be cfp$n-1 but need not be.\endln
\lnie
\endln
\lnie
cfp$n                 number of bits which can be stored\endln
\lnie
                      in a one word bit string.\endln
\lnie
\endln
\lnie
cfp$r                 number of words in a real constant\endln
\lnie
\endln
\lnie
cfp$s                 number of significant digits to\endln
\lnie
                      be output in conversion of a real\endln
\lnie
                      quantity.\endln
\ifmac{.cncr}
\asmac{else}
\lnie
                      the integer consisting of\endln
\lnie
                      this number of 9s must not be too\endln
\lnie
                      large to fit in the integer accum.\endln
\asmac{fi}
\lnie
\endln
\ifmac{.cucf}
\lnie
cfp$u                 realistic upper bound on alphabet.\endln
\lnie
\endln
\lnie
\endln
\asmac{fi}
\lnie
cfp$x                 number of digits in real exponent\endln
\vfill\break

\lnie
\endln
\lnie
section 2 - memory\endln
\lnie
\endln
\lnie
memory is organized into words which each contain cfp$b\endln
\lnie
bytes. for word machines cfp$b, which is a configuration\endln
\lnie
parameter, may be one in which case words and bytes are\endln
\lnie
identical. to each word corresponds an address which is\endln
\lnie
a non-negative quantity which is a multiple of cfp$b.\endln
\lnie
data is organized into words as follows.\endln
\lnie
\endln
\lnie
1)   a signed integer value occupies cfp$i consecutive\endln
\lnie
     words (cfp$i is a configuration parameter).\endln
\lnie
     the range may include more negative numbers than\endln
\lnie
     positive (e.g. the twos complement representation).\endln
\lnie
\endln
\lnie
2)   a signed real value occupies cfp$r consecutive\endln
\lnie
     words. (cfp$r is a configuration parameter).\endln
\lnie
\endln
\lnie
3)   cfp$c characters may be stored in a single word\endln
\lnie
     (cfp$c is a configuration parameter).\endln
\lnie
\endln
\lnie
4)   a bit string containing cfp$n bits can be stored in\endln
\lnie
     a single word (cfp$n is a configuration parameter).\endln
\lnie
\endln
\lnie
5)   a word can contain a unsigned integer value in\endln
\lnie
     the range (0 le n le cfp$l). these integer values\endln
\lnie
     may represent addresses of other words and some of\endln
\lnie
     the instructions use this fact to provide indexing\endln
\lnie
     and indirection facilities.\endln
\lnie
\endln
\lnie
6)   program instructions occupy words in an undefined\endln
\lnie
     manner. depending on the actual implementation,\endln
\lnie
     instructions may occupy several words, or part of\endln
\lnie
     a word, or even be split over word boundaries.\endln
\lnie
\endln
\lnie
the following regions of memory are available to the\endln
\lnie
program. each region consists of a series of words with\endln
\lnie
consecutive addresses.\endln
\lnie
\endln
\lnie
1)   constant section           assembled constants\endln
\lnie
2)   working storage section    assembled work areas\endln
\lnie
3)   program section            assembled instructions\endln
\lnie
4)   stack area                 allocated stack area\endln
\lnie
5)   data area                  allocated data area\endln
\vfill\break

\lnie
\endln
\lnie
section 3 - registers\endln
\lnie
\endln
\lnie
there are three index registers called xr,xl,xs. in\endln
\lnie
addition xl may sometimes be referred to by the alias\endln
\lnie
of xt - see section 4. any of the above registers\endln
\lnie
may hold a positive unsigned integer in the range\endln
\lnie
(0 le n le cfp$l). when the index register is used for\endln
\lnie
indexing purposes, this must be an appropriate address.\endln
\lnie
xs is special in that it is used to point to the top\endln
\lnie
item of a stack in memory. the stack may build up or\endln
\lnie
down in memory.since it is required that xs points to the\endln
\lnie
stack top but access to items below the top is permitted,\endln
\lnie
registers xs and xt may be used with suitable offsets\endln
\lnie
to index stacked items. only xs and xt may be used for\endln
\lnie
this purpose since the direction of the offset is\endln
\lnie
target machine dependent. xt is a synonym for xl\endln
\lnie
which therefore cannot be used in code sequences\endln
\lnie
referencing xt.\endln
\lnie
\endln
\lnie
the stack is used for s-r linkage and temporary\endln
\lnie
data storage for which the stack arrangement is suitable.\endln
\lnie
xr,xl can also contain a character pointer in conjunction\endln
\lnie
with the character instructions (see description of plc).\endln
\vfill\break

\lnie
\endln
\lnie
there are three work registers called wa,wb,wc which\endln
\lnie
can contain any data item which can be stored in a\endln
\lnie
single memory word. in fact, the work registers are just\endln
\lnie
like memory locations except that they have no addresses\endln
\lnie
and are referenced in a special way by the instructions.\endln
\lnie
\endln
\lnie
note that registers wa,wb have special uses in connection\endln
\lnie
with the cvd, cvm, mvc, mvw, mwb, cmc, trc instructions.\endln
\lnie
\endln
\lnie
register wc may overlap the integer accumulator (ia) in\endln
\lnie
some implementations. thus any operation changing the\endln
\lnie
value in wc leaves (ia) undefined and vice versa\endln
\lnie
except as noted in the following restriction on simple\endln
\lnie
dump/restore operations.\endln
\lnie
\endln
\lnie
    restriction\endln
\lnie
    -----------\endln
\lnie
\endln
\lnie
if ia and wc overlap then\endln
\lnie
    sti  iasav\endln
\lnie
    ldi  iasav\endln
\lnie
does not change wc, and\endln
\lnie
    mov  wc,wcsav\endln
\lnie
    mov  wcsav,wc\endln
\lnie
does not change ia.\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
there is an integer accumulator (ia) which is capable of\endln
\lnie
holding a signed integer value (cfp$i words long).\endln
\lnie
register wc may overlap the integer accumulator (ia) in\endln
\lnie
some implementations. thus any operation changing the\endln
\lnie
value in wc leaves (ia) undefined and vice versa\endln
\lnie
except as noted in the above restriction on simple\endln
\lnie
dump/restore operations.\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
there is a single real accumulator (ra) which can hold\endln
\lnie
any real value and is completely separate from any of\endln
\lnie
the other registers or program accessible locations.\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
the code pointer register (cp) is a special index\endln
\lnie
register for use in implementations of interpretors.\endln
\lnie
it is used to contain a pseudo-code pointer and can\endln
\lnie
only be affected by icp, lcp, scp and lcw instructions.\endln
\vfill\break

\lnie
section 4 - the stack\endln
\lnie
\endln
\lnie
the following notes are to guide both implementors of\endln
\lnie
systems written in minimal and minimal programmers in\endln
\lnie
dealing with stack manipulation. implementation of a\endln
\lnie
downwards building stack is easiest and in general is\endln
\lnie
to be preferred, in which case it is merely necessary to\endln
\lnie
consider xt as an alternative name for xl.\endln
\lnie
\endln
\lnie
the minimal virtual machine includes a stack and has\endln
\lnie
operand formats -(xs) and (xs)+ for pushing and popping\endln
\lnie
items with an implication that the stack builds down in\endln
\lnie
memory (a d-stack). however on some target machines it is\endln
\lnie
better for the stack to build up (a u-stack).\endln
\lnie
a stack addressed only by push and pop operations can\endln
\lnie
build in either direction with no complication but\endln
\lnie
such a pure scheme of stack access proves restrictive.\endln
\lnie
hence it is permitted to access buried items using an\endln
\lnie
integer offset past the index register pointing to the\endln
\lnie
stack top. on target machines this offset will be\endln
\lnie
positive/negative for d-stacks/u-stacks and this must\endln
\lnie
be allowed for in the translation.\endln
\lnie
a further restriction is that at no time may an item be\endln
\lnie
placed above the stack top. for some operations this\endln
\lnie
makes it convenient to advance the stack pointer and then\endln
\lnie
address items below it using a second index register.\endln
\lnie
the problem of signed offsets past such a register then\endln
\lnie
arises. to distinguish stack offsets, which in some\endln
\lnie
implementations may be negative, from non-stack offsets\endln
\lnie
which are invariably positive, xt, an alias or\endln
\lnie
synonym for xl is used. for a u-stack implementation, the\endln
\lnie
minimal translator should negate the sign of offsets\endln
\lnie
applied to both (xs) and (xt).\endln
\lnie
programmers should note that since xt is not a\endln
\lnie
separate register, xl should not be used in code where\endln
\lnie
xt is referenced. other modifications needed in u-stack\endln
\lnie
translations are in the add, sub, ica, dca opcodes\endln
\lnie
applied to xs, xt. for example\endln
\lnie
\endln
\lnie
minimal           d-stack trans.  u-stack trans.\endln
\lnie
\endln
\lnie
mov  wa,-(xs)     sbi  xs,1       adi  xs,1\endln
\lnie
                  sto  wa,(xs)    sto  wa,(xs)\endln
\lnie
mov  (xt)+,wc     lod  wc,(xl)    lod  wc,(xl)\endln
\lnie
                  adi  xl,1       sbi  xl,1\endln
\lnie
add  =seven,xs    adi  xs,7       sbi  xs,7\endln
\lnie
mov  2(xt),wa     lod  wa,2(xl)   lod  wa,-2(xl)\endln
\lnie
ica  xs           adi  xs,1       sbi  xs,1\endln
\lnie
\endln
\lnie
note that forms such as\endln
\lnie
mov  -(xs),wa\endln
\lnie
add  wa,(xs)+\endln
\lnie
are illegal, since they assume information storage\endln
\lnie
above the stack top.\endln
\vfill\break

\lnie
section 5 - internal character set\endln
\lnie
\endln
\lnie
the internal character set is represented by a set of\endln
\lnie
contiguous codes from 0 to cfp$a-1. the codes for the\endln
\lnie
digits 0-9 must be contiguous and in sequence. other\endln
\lnie
than this, there are no restraints.\endln
\lnie
\endln
\lnie
the following symbols are automatically defined to have\endln
\lnie
the value of the corresponding internal character code.\endln
\lnie
\endln
\lnie
ch$la                 letter a\endln
\lnie
ch$lb                 letter b\endln
\lnie
.                     .\endln
\lnie
ch$l$                 letter z\endln
\lnie
\endln
\lnie
ch$d0                 digit 0\endln
\lnie
.                     .\endln
\lnie
ch$d9                 digit 9\endln
\lnie
\endln
\lnie
ch$am                 ampersand\endln
\lnie
ch$as                 asterisk\endln
\lnie
ch$at                 at\endln
\lnie
ch$bb                 left bracket\endln
\lnie
ch$bl                 blank\endln
\lnie
ch$br                 vertical bar\endln
\lnie
ch$cl                 colon\endln
\lnie
ch$cm                 comma\endln
\lnie
ch$dl                 dollar sign\endln
\lnie
ch$dt                 dot (period)\endln
\lnie
ch$dq                 double quote\endln
\lnie
ch$eq                 equal sign\endln
\lnie
ch$ex                 exclamation mark\endln
\lnie
ch$mn                 minus\endln
\lnie
ch$nm                 number sign\endln
\lnie
ch$nt                 not\endln
\lnie
ch$pc                 percent\endln
\lnie
ch$pl                 plus\endln
\lnie
ch$pp                 left paren\endln
\lnie
ch$rb                 right bracket\endln
\lnie
ch$rp                 right paren\endln
\lnie
ch$qu                 question mark\endln
\lnie
ch$sl                 slash\endln
\lnie
ch$sm                 semi-colon\endln
\lnie
ch$sq                 single quote\endln
\lnie
ch$un                 underline\endln
\lnie
\endln
\lnie
the following optional symbols are incorporated\endln
\lnie
by defining the conditional assembly symbol named.\endln
\lnie
\endln
\lnie
26 shifted letters incorporated by defining .casl\endln
\lnie
\endln
\lnie
ch$$a                 shifted a\endln
\lnie
ch$$b                 shifted b\endln
\lnie
.                     .\endln
\lnie
ch$$$                 shifted z\endln
\lnie
\endln
\lnie
ch$ht                 horizontal tab - define .caht\endln
\lnie
ch$vt                 vertical tab   - define .cavt\endln
\lnie
ch$ey                 up arrow       - define .caex\endln
\vfill\break

\lnie
\endln
\lnie
section 6 - conditional assembly features\endln
\lnie
\endln
\lnie
some features of the interpreter are applicable to only\endln
\lnie
certain target machines. they may be incorporated or\endln
\lnie
omitted by use of conditional assembly. the full\endln
\lnie
form of a condition is -\endln
\lnie
.if    conditional assembly symbol    (cas)\endln
\lnie
.then\endln
\lnie
       minimal statements1   (ms1)\endln
\lnie
.else\endln
\lnie
       minimal statements2   (ms2)\endln
\lnie
.fi\endln
\lnie
the following rules apply\endln
\lnie
1.   the directives .if, .then, .else, .fi must\endln
\lnie
     start in column 1.\endln
\lnie
2.   the conditional assembly symbol must start with a\endln
\lnie
     dot in column 8 followed by 4 letters or digits e.g.\endln
\lnie
        .ca$1\endln
\lnie
3.   .then is redundant and may be omitted if wished.\endln
\lnie
4.   ms1, ms2 are arbitrary sequences of minimal\endln
\lnie
     statements either of which may be null or may\endln
\lnie
     contain further conditions.\endln
\lnie
5.   if ms2 is omitted, .else may also be omitted.\endln
\lnie
6.   .fi is required.\endln
\lnie
7.   conditions may be nested to a depth determined\endln
\lnie
     by the translator (not less than 20, say).\endln
\lnie
\endln
\lnie
selection of the alternatives ms1, ms2 is by means of the\endln
\lnie
define and undefine directives of form -\endln
\lnie
.def   cas\endln
\lnie
.undef cas\endln
\lnie
which obey rules 1. and 2. above and may occur at any\endln
\lnie
point in a minimal program, including within a condition.\endln
\lnie
multiply defining a symbol is an error.\endln
\lnie
undefining a symbol which is not defined is not an error.\endln
\lnie
\endln
\lnie
the effect is that if a symbol is currently defined,\endln
\lnie
then in any condition depending on it, ms1 will be\endln
\lnie
processed and ms2 omitted. conversely if it is undefined,\endln
\lnie
ms1 will be omitted and ms2 processed.\endln
\lnie
\endln
\lnie
nesting of conditions is such that conditions\endln
\lnie
in a section not selected for processing must not be\endln
\lnie
evaluated. nested conditions must remember their\endln
\lnie
environment whilst being processed. effectively this\endln
\lnie
implies use of a scheme based on a stack with .if, .fi\endln
\lnie
matching by the condition processor of the translator.\endln
\vfill\break

\lnie
\endln
\lnie
section 7 - operand formats\endln
\lnie
\endln
\lnie
the following section describes the various possibilities\endln
\lnie
for operands of instructions and assembly operations.\endln
\lnie
\endln
\lnie
01   int              unsigned integer le cfp$l\endln
\lnie
02   dlbl             symbol defined in definitions sec\endln
\lnie
03   wlbl             label in working storage section\endln
\lnie
04   clbl             label in constant section\endln
\lnie
05   elbl             program section entry label\endln
\lnie
06   plbl             program section label (non-entry)\endln
\lnie
07   x                one of the three index registers\endln
\lnie
08   w                one of the three work registers\endln
\lnie
09   (x)              location indexed by x\endln
\lnie
10   (x)+             like (x) but post increment x\endln
\lnie
11   -(x)             like (x) but predecrement x\endln
\lnie
12   int(x)           location int words beyond addr in x\endln
\lnie
13   dlbl(x)          location dlbl words past addr in x\endln
\lnie
14   clbl(x)          location (x) bytes beyond clbl\endln
\lnie
15   wlbl(x)          location (x) bytes beyond wlbl\endln
\lnie
16   integer          signed integer (dic)\endln
\lnie
17   real             signed real (drc)\endln
\lnie
18   =dlbl            location containing dac dlbl\endln
\lnie
19   *dlbl            location containing dac cfp$b*dlbl\endln
\lnie
20   =wlbl            location containing dac wlbl\endln
\lnie
21   =clbl            location containing dac clbl\endln
\lnie
22   =elbl            location containing dac elbl\endln
\lnie
23   pnam             procedure label (on prc instruc)\endln
\lnie
24   eqop             operand for equ instruction\endln
\lnie
25   ptyp             procedure type (see prc)\endln
\lnie
26   text             arbitrary text (erb,err,ttl)\endln
\lnie
27   dtext            delimited text string (dtc)\endln
\lnie
\endln
\lnie
the numbers in the above list are used in subsequent\endln
\lnie
description and in some of the minimal translators.\endln
\vfill\break

\lnie
\endln
\lnie
operand formats (continued)\endln
\lnie
\endln
\lnie
the following special symbols refer to a collection of\endln
\lnie
the listed possibilities\endln
\lnie
\endln
\lnie
val  01,02                      predefined value\endln
\lnie
\endln
\lnie
     val is used to refer to a predefined one word\endln
\lnie
     integer value in the range 0 le n le cfp$l.\endln
\lnie
\endln
\lnie
reg  07,08                      register\endln
\lnie
\endln
\lnie
     reg is used to describe an operand which can be\endln
\lnie
     any of the registers (xl,xr,xs,xt,wa,wb,wc). such\endln
\lnie
     an operand can hold a one word integer (address).\endln
\lnie
\endln
\lnie
opc  09,10,11                   character\endln
\lnie
\endln
\lnie
     opc is used to designate a specific character\endln
\lnie
     operand for use in the lch and sch instructions.\endln
\lnie
     the index register referenced must be either xr or\endln
\lnie
     xl (not xs,xt). see section on character operations.\endln
\lnie
\endln
\lnie
ops  03,04,09,12,13,14,15       memory reference\endln
\lnie
\endln
\lnie
     ops is used to describe an operand which is in\endln
\lnie
     memory. the operand may be one or more words long\endln
\lnie
     depending on the data type. in the case of multiword\endln
\lnie
     operands, the address given is the first word.\endln
\lnie
\endln
\lnie
opw  as for ops + 08,10,11      full word\endln
\lnie
\endln
\lnie
     opw is used to refer to an operand whose capacity is\endln
\lnie
     that of a full memory word. opw includes all the\endln
\lnie
     possibilities for ops (the referenced word is used)\endln
\lnie
     plus the use of one of the three work registers\endln
\lnie
     (wa,wb,wc). in addition, the formats (x)+ and -(x)\endln
\lnie
     allow indexed operations in which the index register\endln
\lnie
     is popped by one word after the reference (x)+,\endln
\lnie
     or pushed by one word before the reference -(x)\endln
\lnie
     these latter two formats provide a facility for\endln
\lnie
     manipulation of stacks. the format does not imply\endln
\lnie
     a particular direction in which stacks must build -\endln
\lnie
     it is used for compactness. note that there is a\endln
\lnie
     restriction which disallows an instruction to use\endln
\lnie
     an index register in one of these formats\endln
\lnie
     in some other manner in the same instruction.\endln
\lnie
     e.g.   mov  xl,(xl)+   is illegal.\endln
\lnie
     the formats -(x) and (x)+ may also be used in\endln
\lnie
     pre-decrementation, post-incrementation to access\endln
\lnie
     the adjacent character of a string.\endln
\vfill\break

\lnie
\endln
\lnie
operand formats (continued)\endln
\lnie
\endln
\lnie
opn  as for opw + 07            one word integer\endln
\lnie
\endln
\lnie
     opn is used to represent an operand location which\endln
\lnie
     can contain a one word integer (e.g. an address).\endln
\lnie
     this includes all the possibilities for opw plus\endln
\lnie
     the use of one of the index registers (xl,xr,xt,\endln
\lnie
     xs). the range of integer values is 0 le n le cfp$l.\endln
\lnie
\endln
\lnie
opv  as for opn + 18-22         one word integer value\endln
\lnie
\endln
\lnie
     opv is used for an operand which can yield a one\endln
\lnie
     word integer value (e.g. an address). it includes\endln
\lnie
     all the possibilities for opn (the current value of\endln
\lnie
     the location is used) plus the use of literals. note\endln
\lnie
     that although the literal formats are described in\endln
\lnie
     terms of a reference to a location containing an\endln
\lnie
     address constant, this location may not actually\endln
\lnie
     exist in some implementations since only the value\endln
\lnie
     is required. a restriction is placed on literals\endln
\lnie
     which may consist only of defined symbols and\endln
\lnie
     certain labels. consequently small integers to be\endln
\lnie
     used as literals must be pre-defined, a discipline\endln
\lnie
     aiding program maintenance and revision.\endln
\lnie
\endln
\lnie
addr 01,02,03,04,05             address\endln
\lnie
\endln
\lnie
     addr is used to describe an explicit address value\endln
\lnie
     (one word integer value) for use with dac.\endln
\lnie
\endln
\lnie
\endln
\lnie
     ****************************************************\endln
\lnie
     *   in the following descriptions the usage --     *\endln
\lnie
     *      (xl),(xr), ... ,(ia)                        *\endln
\lnie
     *   in the descriptive text signifies the          +\endln
\lnie
     *   contents of the stated register.               *\endln
\lnie
     ****************************************************\endln
\vfill\break

\lnie
\endln
\lnie
section 8 - list of instruction mnemonics\endln
\lnie
\endln
\lnie
the following list includes all instruction and\endln
\lnie
assembly operation mnemonics in alphabetical order.\endln
\lnie
the mnemonics are preceded by a number identifying\endln
\lnie
the following section where the instruction is described.\endln
\lnie
a star (*) is appended to the mnemonic if the last\endln
\lnie
operand may optionally be omitted.\endln
\lnie
see section -15- for details of statement format and\endln
\lnie
comment conventions.\endln
\lnie
\endln
\lnie
 2.1  add  opv,opn      add address\endln
\lnie
 4.2  adi  ops          add integer\endln
\lnie
 5.3  adr  ops          add real\endln
\lnie
 7.1  anb  opw,w        and bit string\endln
\lnie
 2.17 aov  opv,opn,plbl add address, fail if overflow\endln
\lnie
 5.16 atn               arctangent of real accum\endln
\lnie
 2.16 bct  w,plbl       branch and count\endln
\lnie
 2.5  beq  opn,opv,plbl branch if address equal\endln
\lnie
 2.18 bev  opn,plbl     branch if address even\endln
\lnie
 2.8  bge  opn,opv,plbl branch if address greater or equl\endln
\lnie
 2.7  bgt  opn,opv,plbl branch if address greater\endln
\lnie
 2.12 bhi  opn,opv,plbl branch if address high\endln
\lnie
 2.10 ble  opn,opv,plbl branch if address less or equal\endln
\lnie
 2.11 blo  opn,opv,plbl branch if address low\endln
\lnie
 2.9  blt  opn,opv,plbl branch if address less than\endln
\lnie
 2.6  bne  opn,opv,plbl branch if address not equal\endln
\lnie
 2.13 bnz  opn,plbl     branch if address non-zero\endln
\lnie
 2.19 bod  opn,plbl     branch if address odd\endln
\lnie
 1.2  brn  plbl         branch unconditional\endln
\lnie
 1.7  bri  opn          branch indirect\endln
\lnie
 1.3  bsw* x,val,plbl   branch on switch value\endln
\lnie
 8.2  btw  reg          convert bytes to words\endln
\lnie
 2.14 bze  opn,plbl     branch if address zero\endln
\lnie
 6.6  ceq  opw,opw,plbl branch if characters equal\endln
\lnie
10.1  chk               check stack overflow\endln
\lnie
 5.17 chp               integer portion of real accum\endln
\lnie
 7.4  cmb  w            complement bit string\endln
\lnie
 6.8  cmc  plbl,plbl    compare character strings\endln
\lnie
 6.7  cne  opw,opw,plbl branch if characters not equal\endln
\lnie
 6.5  csc  x            complete store characters\endln
\lnie
 5.18 cos               cosine of real accum\endln
\lnie
 8.8  ctb  w,val        convert character count to bytes\endln
\lnie
 8.7  ctw  w,val        convert character count to words\endln
\lnie
 8.10 cvd               convert by division\endln
\lnie
 8.9  cvm  plbl         convert by multiplication\endln
\lnie
11.1  dac  addr         define address constant\endln
\lnie
11.5  dbc  val          define bit string constant\endln
\lnie
 2.4  dca  opn          decrement address by one word\endln
\lnie
 1.17 dcv  opn          decrement value by one\endln
\lnie
11.2  dic  integer      define integer constant\endln
\vfill\break

\lnie
\endln
\lnie
alphabetical list of mnemonics (continued)\endln
\lnie
\endln
\lnie
11.3  drc  real         define real constant\endln
\lnie
11.4  dtc  dtext        define text (character) constant\endln
\lnie
 4.5  dvi  ops          divide integer\endln
\lnie
 5.6  dvr  ops          divide real\endln
\lnie
13.1  ejc               eject assembly listing\endln
\lnie
14.2  end               end of assembly\endln
\lnie
 1.13 enp               define end of procedure\endln
\lnie
 1.6  ent* val          define entry point\endln
\lnie
12.1  equ  eqop         define symbolic value\endln
\lnie
 1.15 erb  int,text     assemble error code and branch\endln
\lnie
 1.14 err  int,text     assemble error code\endln
\lnie
 1.5  esw               end of switch list for bsw\endln
\lnie
 5.19 etx               e to the power in the real accum\endln
\lnie
 1.12 exi* int          exit from procedure\endln
\lnie
12.2  exp               define external procedure\endln
\lnie
 6.10 flc  w            fold character to upper case\endln
\lnie
 2.3  ica  opn          increment address by one word\endln
\lnie
 3.4  icp               increment code pointer\endln
\lnie
 1.16 icv  opn          increment value by one\endln
\lnie
 4.11 ieq  plbl         jump if integer zero\endln
\lnie
 1.4  iff  val,plbl     specify branch for bsw\endln
\lnie
 4.12 ige  plbl         jump if integer non-negative\endln
\lnie
 4.13 igt  plbl         jump if integer positive\endln
\lnie
 4.14 ile  plbl         jump if integer negative or zero\endln
\lnie
 4.15 ilt  plbl         jump if integer negative\endln
\lnie
 4.16 ine  plbl         jump if integer non-zero\endln
\lnie
 4.9  ino  plbl         jump if no integer overflow\endln
\lnie
12.3  inp  ptyp,int     internal procedure\endln
\lnie
12.4  inr               internal routine\endln
\lnie
 4.10 iov  plbl         jump if integer overflow\endln
\lnie
 8.5  itr               convert integer to real\endln
\lnie
 1.9  jsr  pnam         call procedure\endln
\lnie
 6.3  lch  reg,opc      load character\endln
\lnie
 2.15 lct  w,opv        load counter for loop\endln
\lnie
 3.1  lcp  reg          load code pointer register\endln
\lnie
 3.3  lcw  reg          load next code word\endln
\lnie
 4.1  ldi  ops          load integer\endln
\lnie
 5.1  ldr  ops          load real\endln
\lnie
 1.8  lei  x            load entry point id\endln
\lnie
 5.20 lnf               natural logorithm of real accum\endln
\lnie
 7.6  lsh  w,val        left shift bit string\endln
\lnie
 7.8  lsx  w,(x)        left shift indexed\endln
\lnie
 9.4  mcb               move characterswords backwards\endln
\lnie
 8.4  mfi* opn,plbl     convert (ia) to address value\endln
\lnie
 4.3  mli  ops          multiply integer\endln
\lnie
 5.5  mlr  ops          multiply real\endln
\lnie
 1.19 mnz  opn          move non-zero\endln
\lnie
 1.1  mov  opv,opn      move\endln
\lnie
 8.3  mti  opn          move address value to (ia)\endln
\lnie
 9.1  mvc               move characters\endln
\lnie
 9.2  mvw               move words\endln
\lnie
 9.3  mwb               move words backwards\endln
\lnie
 4.8  ngi               negate integer\endln
\vfill\break

\lnie
\endln
\lnie
alphabetical list of mnemonics (continued)\endln
\lnie
\endln
\lnie
 5.9  ngr               negate real\endln
\lnie
 7.9  nzb  w,plbl       jump if not all zero bits\endln
\lnie
 7.2  orb  opw,w        or bit strings\endln
\lnie
 6.1  plc* x,opv        prepare to load characters\endln
\lnie
 1.10 ppm* plbl         provide procedure exit parameter\endln
\lnie
 1.11 prc  ptyp,val     define start of procedure\endln
\lnie
 6.2  psc* x,opv        prepare to store characters\endln
\lnie
 5.10 req  plbl         jump if real zero\endln
\lnie
 5.11 rge  plbl         jump if real positive or zero\endln
\lnie
 5.12 rgt  plbl         jump if real positive\endln
\lnie
 5.13 rle  plbl         jump if real negative or zero\endln
\lnie
 5.14 rlt  plbl         jump if real negative\endln
\lnie
 4.6  rmi  ops          remainder integer\endln
\lnie
 5.15 rne  plbl         jump if real non-zero\endln
\lnie
 5.8  rno  plbl         jump if no real overflow\endln
\lnie
 5.7  rov  plbl         jump if real overflow\endln
\lnie
 7.5  rsh  w,val        right shift bit string\endln
\lnie
 7.7  rsx  w,(x)        right shift indexed\endln
\lnie
 8.6  rti* plbl         convert real to integer\endln
\lnie
 1.22 rtn               define start of routine\endln
\lnie
 4.4  sbi  ops          subtract integer\endln
\lnie
 5.4  sbr  ops          subtract reals\endln
\lnie
 6.4  sch  reg,opc      store character\endln
\lnie
 3.2  scp  reg          store code pointer\endln
\lnie
14.1  sec               define start of assembly section\endln
\lnie
 5.21 sin               sine of real accum\endln
\lnie
 5.22 sqr               square root of real accum\endln
\lnie
 1.20 ssl  opw          subroutine stack load\endln
\lnie
 1.21 sss  opw          subroutine stack store\endln
\lnie
 4.7  sti  ops          store integer\endln
\lnie
 5.2  str  ops          store real\endln
\lnie
 2.2  sub  opv,opn      subtract address\endln
\lnie
 5.23 tan               tangent of real accum\endln
\lnie
 6.9  trc               translate character string\endln
\lnie
13.2  ttl  text         supply assembly title\endln
\lnie
 8.1  wtb  reg          convert words to bytes\endln
\lnie
 7.3  xob  opw,w        exclusive or bit strings\endln
\lnie
 1.18 zer  opn          zeroise integer location\endln
\lnie
 7.11 zgb  opn          zeroise garbage bits\endln
\lnie
 7.10 zrb  w,plbl       jump if all zero bits\endln
\vfill\break

\lnie
\endln
\lnie
section 9 - minimal instructions\endln
\lnie
\endln
\lnie
the following descriptions assume the definitions -\endln
\lnie
\endln
\lnie
zeroe  equ  0\endln
\lnie
unity  equ  1\endln
\lnie
\endln
\lnie
-1-  basic instruction set\endln
\lnie
\endln
\lnie
1.1  mov  opv,opn     move one word value\endln
\lnie
\endln
\lnie
     mov causes the value of operand opv to be set as\endln
\lnie
     the new contents of operand location opn. in the\endln
\lnie
     case where opn is not an index register, any value\endln
\lnie
     which can normally occupy a memory word (including\endln
\lnie
     a part of a multiword real or integer value)\endln
\lnie
     can be transferred using mov. if the target location\endln
\lnie
     opn is an index register, then opv must specify an\endln
\lnie
     appropriate one word value or operand containing\endln
\lnie
     such an appropriate value.\endln
\lnie
\endln
\lnie
1.2  brn  plbl        unconditional branch\endln
\lnie
\endln
\lnie
     brn causes control to be passed to the indicated\endln
\lnie
     label in the program section.\endln
\lnie
\endln
\lnie
1.3  bsw  x,val,plbl  branch on switch value\endln
\lnie
1.4  iff  val,plbl    provide branch for switch\endln
\lnie
     iff  val,plbl     ...\endln
\lnie
     ...\endln
\lnie
     ...\endln
\lnie
1.5  esw              end of branch switch table\endln
\lnie
\endln
\lnie
     bsw,iff,esw provide a capability for a switched\endln
\lnie
     branch similar to a fortran computed goto. the\endln
\lnie
     val on the bsw instruction is the maximum number\endln
\lnie
     of branches. the value in x ranges from zero up to\endln
\lnie
     but not including this maximum. each iff provides a\endln
\lnie
     branch. val must be less than that given on the bsw\endln
\lnie
     and control goes to plbl if the value in x matches.\endln
\lnie
     if the value in x does not correspond to any of the\endln
\lnie
     iff entries, then control passes to the plbl on the\endln
\lnie
     bsw. this plbl operand may be omitted if there are\endln
\lnie
     no values missing from the list.\endln
\lnie
\endln
\lnie
     iff and esw may only be used in this context.\endln
\lnie
     execution of bsw may destroy the contents of x.\endln
\lnie
     the iff entries may be in any order and since\endln
\lnie
     a translator may thus need to store and sort them,\endln
\lnie
     the comment field is restricted in length (sec 11).\endln
\vfill\break

\lnie
\endln
\lnie
-1-  basic instructions (continued)\endln
\lnie
\endln
\lnie
1.6  ent  val         define program entry point\endln
\lnie
\endln
\lnie
     the symbol appearing in the label field is defined\endln
\lnie
     to be a program entry point which can subsequently\endln
\lnie
     be used in conjunction with the bri instruction,\endln
\lnie
     which provides the only means of entering the\endln
\lnie
     code. it is illegal to fall into code\endln
\lnie
     identified by an entry point. the\endln
\lnie
     entry symbol is assigned an address which need not\endln
\lnie
     be a multiple of cfp$b but which must be in the\endln
\lnie
     range 0 le cfp$l and the address must not lie within\endln
\lnie
     the address range of the allocated data area.\endln
\lnie
     furthermore, addresses of successive entry points\endln
\lnie
     must be assigned in some ascending sequence so\endln
\lnie
     that the address comparison instructions can be\endln
\lnie
     used to test the order in which two entry points\endln
\lnie
     occur. the symbol val gives an identifying value\endln
\lnie
     to the entry point which can be accessed with the\endln
\lnie
     lei instruction.\endln
\lnie
\endln
\lnie
     note - subject to the restriction below, val may\endln
\lnie
     be omitted if no such identification is needed i.e.\endln
\lnie
     if no lei references the entry point. for this\endln
\lnie
     case, a translation optimisation is possible in\endln
\lnie
     which no memory need be reserved for a null\endln
\lnie
     identification which is never to be referenced, but\endln
\lnie
     only provided this is done so as not to interfere\endln
\lnie
     with the strictly ascending sequence of entry point\endln
\lnie
     addresses. to simplify this optimisation for all\endln
\lnie
     implementors, the following restriction is observed\endln
\lnie
          val may only be omitted if the entry point is\endln
\lnie
          separated from a following entry point by a\endln
\lnie
          non-null minimal code sequence.\endln
\lnie
     entry point addresses are accessible only by use of\endln
\lnie
     literals (=elbl, section 7) or dac constants\endln
\lnie
     (section 8-11.1).\endln
\lnie
\endln
\lnie
1.7  bri  opn         branch indirect\endln
\lnie
\endln
\lnie
     opn contains the address of a program entry point\endln
\lnie
     (see ent). control is passed to the executable\endln
\lnie
     code starting at the entry point address. opn is\endln
\lnie
     left unchanged.\endln
\lnie
\endln
\lnie
1.8  lei  x           load entry point identification\endln
\lnie
\endln
\lnie
     x contains the address of an entry point for which\endln
\lnie
     an identifying value was given on the the ent line.\endln
\lnie
     lei replaces the contents of x by this value.\endln
\vfill\break

\lnie
\endln
\lnie
-1-  basic instructions (continued)\endln
\lnie
\endln
\lnie
1.9  jsr  pnam        call procedure pnam\endln
\lnie
1.10 ppm  plbl        provide exit parameter\endln
\lnie
     ppm  plbl         ...\endln
\lnie
     ...\endln
\lnie
     ppm  plbl         ...\endln
\lnie
\endln
\lnie
     jsr causes control to be passed to the named\endln
\lnie
     procedure. pnam is the label on a prc statement\endln
\lnie
     elsewhere in the program section (see prc)\endln
\lnie
     or has been defined using an exp instruction.\endln
\lnie
     the ppm exit parameters following the call give\endln
\lnie
     names of program locations (plbl-s) to which\endln
\lnie
     alternative exi returns of the called procedure may\endln
\lnie
     pass control. they may optionally be replaced by\endln
\lnie
     error returns (see err). the number of exit\endln
\lnie
     parameters following a jsr must equal the int in the\endln
\lnie
     procedure definition. the operand of ppm may be\endln
\lnie
     omitted if the corresponding exi return is certain\endln
\lnie
     not to be taken.\endln
\lnie
\endln
\lnie
1.11 prc  ptyp,int    define start of procedure\endln
\lnie
\endln
\lnie
     the symbol appearing in the label field is defined\endln
\lnie
     to be the name of a procedure for use with jsr.\endln
\lnie
     a procedure is a contiguous section of instructions\endln
\lnie
     to which control may be passed with a jsr\endln
\lnie
     instruction. this is the only way in which the\endln
\lnie
     instructions in a procedure may be executed. it is\endln
\lnie
     not permitted to fall into a procedure.\endln
\lnie
     all procedures should be named in section 0\endln
\lnie
     inp  statements.\endln
\lnie
\endln
\lnie
     int is the number of exit parameters (ppm-s) to\endln
\lnie
     be used in jsr calls.\endln
\lnie
\endln
\lnie
     there are three possibilities for ptyp, each\endln
\lnie
     consisting of a single letter as follows.\endln
\lnie
\endln
\lnie
     r                recursive\endln
\lnie
\endln
\lnie
     the return point (one or more words) is stored on\endln
\lnie
     the stack as though one or more mov ...,-(xs)\endln
\lnie
     instructions were executed.\endln
\vfill\break

\lnie
\endln
\lnie
-1-  basic instructions (continued)\endln
\lnie
\endln
\lnie
     n                non-recursive\endln
\lnie
\endln
\lnie
     the return point is to be stored either\endln
\lnie
     (1) in a local storage word associated\endln
\lnie
     with the procedure and not directly\endln
\lnie
     available to the program in any other manner or\endln
\lnie
     (2) on a subroutine link stack quite distinct from\endln
\lnie
     the minimal stack addressed by xs.\endln
\lnie
     it is an error to use the stack for n-links, since\endln
\lnie
     procedure parameters or results may be passed via\endln
\lnie
     the stack.\endln
\lnie
     if method (2) is used for links, error exits\endln
\lnie
     (erb,err) from a procedure will necessitate link\endln
\lnie
     stack resetting. the ssl and sss orders provided\endln
\lnie
     for this may be regarded as no-ops for\endln
\lnie
     implementations using method (1).\endln
\lnie
\endln
\lnie
     e                either\endln
\lnie
\endln
\lnie
     the return point may be stored in either manner\endln
\lnie
     according to efficiency requirements of the actual\endln
\lnie
     physical machine used for the implementation. note\endln
\lnie
     that programming of e type procedures must be\endln
\lnie
     independent of the actual implementation.\endln
\lnie
\endln
\lnie
     the actual form of the return point is undefined.\endln
\lnie
     however, each word stored on the stack for an\endln
\lnie
     r-type call must meet the following requirements.\endln
\lnie
\endln
\lnie
     1)               it can be handled as an address\endln
\lnie
                      and placed in an index register.\endln
\lnie
\endln
\lnie
     2)               when used as an operand in an\endln
\lnie
                      address comparison instruction, it\endln
\lnie
                      must not appear to lie within\endln
\lnie
                      the allocated data area.\endln
\lnie
\endln
\lnie
     3)               it is not required to appear\endln
\lnie
                      to lie within the program section.\endln
\vfill\break

\lnie
\endln
\lnie
-1-  basic instructions (continued)\endln
\lnie
\endln
\lnie
1.12 exi  int         exit from procedure\endln
\lnie
\endln
\lnie
     the ppm and err parameters following a jsr are\endln
\lnie
     numbered starting from 1.  exi  int causes control\endln
\lnie
     to be returned to the int-th such param. exi 1 gives\endln
\lnie
     control to the plbl of the first ppm after the jsr.\endln
\lnie
     if int is omitted, control is passed back past the\endln
\lnie
     last exit parameter (or past the jsr if there are\endln
\lnie
     none). for r and e type procedures, the\endln
\lnie
     stack pointer xs must be set to its appropriate\endln
\lnie
     entry value before executing an exi instruction.\endln
\lnie
     in this case, exi removes return points from the\endln
\lnie
     stack if any are stored there so that the stack\endln
\lnie
     pointer is restored to its calling value.\endln
\lnie
\endln
\lnie
1.13 enp              define end of procedure body\endln
\lnie
\endln
\lnie
     enp delimits a procedure body and may not actually\endln
\lnie
     be executed, hence it must have no label.\endln
\lnie
\endln
\lnie
1.14 err  int,text    provide error return\endln
\lnie
\endln
\lnie
     err may replace an exit parameter (ppm) in\endln
\lnie
     any procedure call. the int argument is a unique\endln
\lnie
     error code in 0 to 899.\endln
\lnie
     the text supplied as the other operand is\endln
\lnie
     arbitrary text in the fortran character set and\endln
\lnie
     may be used in constructing a file of error\endln
\lnie
     messages for documenting purposes or for building\endln
\lnie
     a direct access or other file of messages to be\endln
\lnie
     used by the error handling code.\endln
\lnie
     in the event that an exi attempts\endln
\lnie
     to return control via an exit parameter to\endln
\lnie
     an err, control is instead passed to the first\endln
\lnie
     instruction in the error section (which follows the\endln
\lnie
     program section) with the error code in wa.\endln
\lnie
\endln
\lnie
1.15 erb  int,text    error branch\endln
\lnie
\endln
\lnie
     this instruction resembles err except that it may\endln
\lnie
     occur at any point where a branch is permitted.\endln
\lnie
     it effects a transfer of control to the error\endln
\lnie
     section with the error code in wa.\endln
\lnie
\endln
\lnie
1.16 icv  opn         increment value by one\endln
\lnie
\endln
\lnie
     icv increments the value of the operand by unity.\endln
\lnie
     it is equivalent to   add  =unity,opn\endln
\lnie
\endln
\lnie
1.17 dcv  opn         decrement value by one\endln
\lnie
\endln
\lnie
     dcv decrements the value of the operand by unity.\endln
\lnie
     it is equivalent to   sub  =unity,opn\endln
\vfill\break

\lnie
\endln
\lnie
basic instructions (continued)\endln
\lnie
\endln
\lnie
1.18 zer  opn         zeroise opn\endln
\lnie
\endln
\lnie
     zer is equivalent to  mov  =zeroe,opn\endln
\lnie
\endln
\lnie
1.19 mnz  opn         move non-zero to opn\endln
\lnie
\endln
\lnie
     any non-zero collectable value may used, for which\endln
\lnie
     the opcodes bnz/bze will branch/fail to branch.\endln
\lnie
\endln
\lnie
1.20 ssl  opw         subroutine stack load\endln
\lnie
\endln
\lnie
1.21 sss  opw         subroutine stack store\endln
\lnie
\endln
\lnie
     this pair of operations is provided to make possible\endln
\lnie
     the use of a local stack to hold subroutine (s-r)\endln
\lnie
     return links for n-type procedures. sss stores the\endln
\lnie
     s-r stack pointer in opw and ssl loads the s-r\endln
\lnie
     stack pointer from opw. by using sss in the main\endln
\lnie
     program or on entry to a procedure which should\endln
\lnie
     regain control on occurrence of an err or erb and by\endln
\lnie
     use of ssl in the error processing sections the\endln
\lnie
     s-r stack pointer can be restored giving a link\endln
\lnie
     stack cleaned up ready for resumed execution.\endln
\lnie
     the form of the link stack pointer is undefined in\endln
\lnie
     minimal (it is likely to be a private register\endln
\lnie
     known to the translator) and the only requirement\endln
\lnie
     is that it should fit into a single full word.\endln
\lnie
     ssl and sss are no-ops if a private link stack is\endln
\lnie
     not used.\endln
\lnie
\endln
\lnie
1.22 rtn              define start of routine\endln
\lnie
\endln
\lnie
     a routine is a code chunk used for similar purposes\endln
\lnie
     to a procedure. however it is entered by any type of\endln
\lnie
     conditional or unconditional branch (not by jsr). on\endln
\lnie
     termination it passes control by a branch (often\endln
\lnie
     bri through a code word) or even permits control\endln
\lnie
     to drop through to another routine. no return link\endln
\lnie
     exists and the end of a routine is not marked by\endln
\lnie
     an explicit opcode (compare enp).\endln
\lnie
     all routines should be named in section 0\endln
\lnie
     inr  statements.\endln
\vfill\break

\lnie
\endln
\lnie
-2-  operations on one word integer values (addresses)\endln
\lnie
\endln
\lnie
2.1  add  opv,opn     adds opv to the value in opn and\endln
\lnie
                      stores the result in opn. undefined\endln
\lnie
                      if the result exceeds cfp$l.\endln
\lnie
\endln
\lnie
2.2  sub  opv,opn     subtracts opv from opn. stores the\endln
\lnie
                      result in opn. undefined if the\endln
\lnie
                      result is negative.\endln
\lnie
\endln
\lnie
2.3  ica  opn         increment address in opn\endln
\lnie
                      equivalent to add *unity,opn\endln
\lnie
\endln
\lnie
2.4  dca  opn         decrement address in opn\endln
\lnie
                      equivalent to sub *unity,opn\endln
\lnie
\endln
\lnie
2.5  beq  opn,opv,plbl branch to plbl if opn eq opv\endln
\lnie
2.6  bne  opn,opv,plbl branch to plbl if opn ne opv\endln
\lnie
2.7  bgt  opn,opv,plbl branch to plbl if opn gt opv\endln
\lnie
2.8  bge  opn,opv,plbl branch to plbl if opn ge opv\endln
\lnie
2.9  blt  opn,opv,plbl branch to plbl if opn lt opv\endln
\lnie
2.10 ble  opn,opv,plbl branch to plbl if opn le opv\endln
\lnie
2.11 blo  opn,opv,plbl equivalent to blt or ble\endln
\lnie
2.12 bhi  opn,opv,plbl equivalent to bgt or bge\endln
\lnie
\endln
\lnie
     the above instructions compare two address\endln
\lnie
     values as unsigned integer values.\endln
\lnie
     the blo and bhi instructions are used in cases where\endln
\lnie
     the equal condition either does not occur or can\endln
\lnie
     result either in a branch or no branch. this avoids\endln
\lnie
     inefficient translations in some implementations.\endln
\lnie
\endln
\lnie
2.13 bnz  opn,plbl    equivalent to bne opn,=zeroe,plbl\endln
\lnie
\endln
\lnie
2.14 bze  opn,plbl    equivalent to beq opn,=zeroe,plbl\endln
\lnie
\endln
\lnie
\endln
\lnie
2.15 lct  w,opv       load counter for bct\endln
\lnie
\endln
\lnie
     lct loads a counter value for use with the bct\endln
\lnie
     instruction. the value in opv is the number of loops\endln
\lnie
     to be executed. the value in w after this operation\endln
\lnie
     is an undefined one word integer quantity.\endln
\lnie
\endln
\lnie
2.16 bct  w,plbl      branch and count\endln
\lnie
\endln
\lnie
     bct uses the counter value in w to branch the\endln
\lnie
     required number of times and then finally to fall\endln
\lnie
     through to the next instruction. bct can only be\endln
\lnie
     used following an appropriate lct instruction.\endln
\lnie
     the value in w after execution of bct is undefined.\endln
\lnie
\endln
\lnie
2.17 aov  opv,opn,plbl add with carry test\endln
\lnie
\endln
\lnie
     adds opv to the value in opn and stores result in\endln
\lnie
     opn. branches to plbl if result exceeds cfp$l\endln
\lnie
     with result in opn undefined. cf. add.\endln
\lnie
\endln
\lnie
2.18 bev  opn,plbl     branch if even\endln
\lnie
2.19 bod  opn,plbl     branch if odd\endln
\lnie
\endln
\lnie
     these operations are used only if .cepp or .crpp is\endln
\lnie
     defined.  on some implementations, a more efficient\endln
\lnie
     implementation is possible by noting that address of\endln
\lnie
     blocks must always be a multiple of cfp$b. we call\endln
\lnie
     such addresses even.  thus return address on the\endln
\lnie
     stack (.crpp) and entry point addresses (.cepp) can\endln
\lnie
     be distinguished from block addresses if they are\endln
\lnie
     forced to be odd (not a multiple of cfp$b).\endln
\lnie
     bev and bod branch according as operand is even\endln
\lnie
     or odd, respectively.\endln
\vfill\break

\lnie
\endln
\lnie
-3-  operations on the code pointer register (cp)\endln
\lnie
\endln
\lnie
     the code pointer register provides a psuedo\endln
\lnie
     instruction counter for use in an interpretor. it\endln
\lnie
     may be implemented as a real register or as a\endln
\lnie
     memory location, but in either case it is separate\endln
\lnie
     from any other register. the value in the code\endln
\lnie
     pointer register is always a word address (i.e.\endln
\lnie
     a one word integer which is a multiple of cfp$b).\endln
\lnie
\endln
\lnie
3.1  lcp  reg         load code pointer register\endln
\lnie
                      this instruction causes the code\endln
\lnie
                      pointer register to be set from\endln
\lnie
                      the value in reg which is unchanged\endln
\lnie
\endln
\lnie
3.2  scp  reg         store code pointer register\endln
\lnie
                      this instruction loads the current\endln
\lnie
                      value in the code pointer register\endln
\lnie
                      into reg. (cp) is unchanged.\endln
\lnie
\endln
\lnie
3.3  lcw  reg         load next code word\endln
\lnie
                      this instruction causes the word\endln
\lnie
                      pointed to by cp to be loaded into\endln
\lnie
                      the indicated reg. the value in cp\endln
\lnie
                      is then incremented by one word.\endln
\lnie
                      execution of lcw may destroy xl.\endln
\lnie
\endln
\lnie
3.4  icp              increment cp by one word\endln
\lnie
\endln
\lnie
     on machines with more than three index registers,\endln
\lnie
     cp can be treated simply as an index register.\endln
\lnie
     in this case, the following equivalences apply.\endln
\lnie
\endln
\lnie
     lcp reg is like mov reg,cp\endln
\lnie
     scp reg is like mov cp,reg\endln
\lnie
     lcw reg is like mov (cp)+,reg\endln
\lnie
     icp     is like ica cp\endln
\lnie
\endln
\lnie
     since lcw is allowed to destroy xl, the following\endln
\lnie
     implementation using a work location cp$$$ can\endln
\lnie
     also be used.\endln
\lnie
\endln
\lnie
     lcp  reg         mov  reg,cp$$$\endln
\lnie
\endln
\lnie
     scp  reg         mov  cp$$$,reg\endln
\lnie
\endln
\lnie
     lcw  reg         mov  cp$$$,xl\endln
\lnie
                      mov  (xl)+,reg\endln
\lnie
                      mov  xl,cp$$$\endln
\lnie
\endln
\lnie
     icp              ica  cp$$$\endln
\vfill\break

\lnie
\endln
\lnie
-4-  operations on signed integer values\endln
\lnie
\endln
\lnie
4.1  ldi  ops         load integer accumulator from ops\endln
\lnie
4.2  adi  ops         add ops to integer accumulator\endln
\lnie
4.3  mli  ops         multiply integer accumulator by ops\endln
\lnie
4.4  sbi  ops         subtract ops from int accumulator\endln
\lnie
4.5  dvi  ops         divide integer accumulator by ops\endln
\lnie
4.6  rmi  ops         set int accum to mod(intacc,ops)\endln
\lnie
4.7  sti  ops         store integer accumulator at ops\endln
\lnie
4.8  ngi              negate the value in the integer\endln
\lnie
                      accumulator (change its sign)\endln
\lnie
\endln
\lnie
     the equation satisfied by operands and results of\endln
\lnie
     dvi and rmi is\endln
\lnie
            div = qot * ops + rem          where\endln
\lnie
     div = dividend in integer accumulator\endln
\lnie
     qot = quotient left in ia by div\endln
\lnie
     ops = the divisor\endln
\lnie
     rem = remainder left in ia by rmi\endln
\lnie
     the sign of the result of dvi is + if (ia) and (ops)\endln
\lnie
     have the same sign and is - if they have opposite\endln
\lnie
     signs. the sign of (ia) is always used as the sign\endln
\lnie
     of the result of rem.\endln
\lnie
     assuming in each case that ia contains the number\endln
\lnie
     specified in parentheses and that seven and msevn\endln
\lnie
     hold +7 and -7 resp. the algorithm is illustrated\endln
\lnie
     below.\endln
\lnie
     (ia = 13)\endln
\lnie
     dvi  seven       ia = 1\endln
\lnie
     rmi  seven       ia = 6\endln
\lnie
     dvi  msevn       ia = -1\endln
\lnie
     rmi  msevn       ia = 6\endln
\lnie
     (ia = -13)\endln
\lnie
     dvi  seven       ia = -1\endln
\lnie
     rmi  seven       ia = -6\endln
\lnie
     dvi  msevn       ia = 1\endln
\lnie
     rmi  msevn       ia = -6\endln
\vfill\break

\lnie
\endln
\lnie
     the above instructions operate on a full range of\endln
\lnie
     signed integer values. with the exception of ldi and\endln
\lnie
     sti, these instructions may cause integer overflow\endln
\lnie
     by attempting to produce an undefined or out of\endln
\lnie
     range result in which case integer overflow is set,\endln
\lnie
     the result in (ia) is undefined and the following\endln
\lnie
     instruction must be iov or ino.\endln
\lnie
     particular care may be needed on target machines\endln
\lnie
     having distinct overflow and divide by zero\endln
\lnie
     conditions.\endln
\lnie
\endln
\lnie
4.9  ino  plbl        jump to plbl if no integer overflow\endln
\lnie
4.10 iov  plbl        jump to plbl if integer overflow\endln
\lnie
\endln
\lnie
     these instructions can only occur immediately\endln
\lnie
     following an instruction which can cause integer\endln
\lnie
     overflow (adi, sbi, mli, dvi, rmi, ngi) and\endln
\lnie
     test the result of the preceding instruction.\endln
\lnie
     iov and ino may not have labels.\endln
\lnie
\endln
\lnie
4.11 ieq  plbl        jump to plbl if (ia) eq 0\endln
\lnie
4.12 ige  plbl        jump to plbl if (ia) ge 0\endln
\lnie
4.13 igt  plbl        jump to plbl if (ia) gt 0\endln
\lnie
4.14 ile  plbl        jump to plbl if (ia) le 0\endln
\lnie
4.15 ilt  plbl        jump to plbl if (ia) lt 0\endln
\lnie
4.16 ine  plbl        jump to plbl if (ia) ne 0\endln
\lnie
\endln
\lnie
     the above conditional jump instructions do\endln
\lnie
     not change the contents of the accumulator.\endln
\lnie
     on a ones complement machine, it is permissible to\endln
\lnie
     produce negative zero in ia provided these\endln
\lnie
     instructions operate correctly with such a value.\endln
\vfill\break

\lnie
\endln
\lnie
-5-  operations on real values\endln
\lnie
\endln
\lnie
5.1  ldr  ops         load real accumulator from ops\endln
\lnie
5.2  str  ops         store real accumulator at ops\endln
\lnie
5.3  adr  ops         add ops to real accumulator\endln
\lnie
5.4  sbr  ops         subtract ops from real accumulator\endln
\lnie
5.5  mlr  ops         multiply real accumulator by ops\endln
\lnie
5.6  dvr  ops         divide real accumulator by ops\endln
\lnie
\endln
\lnie
     if the result of any of the above operations causes\endln
\lnie
     underflow, the result yielded is 0.0.\endln
\lnie
\endln
\lnie
     if the result of any of the above operations is\endln
\lnie
     undefined or out of range, real overflow is set,\endln
\lnie
     the contents of (ra) are undefined and the following\endln
\lnie
     instruction must be either rov or rno.\endln
\lnie
     particular care may be needed on target machines\endln
\lnie
     having distinct overflow and divide by zero\endln
\lnie
     conditions.\endln
\lnie
\endln
\lnie
5.7  rov  plbl        jump to plbl if real overflow\endln
\lnie
5.8  rno  plbl        jump to plbl if no real overflow\endln
\lnie
\endln
\lnie
     these instructions can only occur immediately\endln
\lnie
     following an instruction which can cause real\endln
\lnie
     overflow (adr,sbr,mlr,dvr).\endln
\lnie
\endln
\lnie
5.9  ngr              negate real accum (change sign)\endln
\lnie
\endln
\lnie
5.10 req  plbl        jump to plbl if (ra) eq 0.0\endln
\lnie
5.11 rge  plbl        jump to plbl if (ra) ge 0.0\endln
\lnie
5.12 rgt  plbl        jump to plbl if (ra) gt 0.0\endln
\lnie
5.13 rle  plbl        jump to plbl if (ra) le 0.0\endln
\lnie
5.14 rlt  plbl        jump to plbl if (ra) lt 0.0\endln
\lnie
5.15 rne  plbl        jump to plbl if (ra) ne 0.0\endln
\lnie
\endln
\lnie
     the above conditional instructions do not affect\endln
\lnie
     the value stored in the real accumulator.\endln
\lnie
     on a ones complement machine, it is permissible to\endln
\lnie
     produce negative zero in ra provided these\endln
\lnie
     instructions operate correctly with such a value.\endln
\ifmac{.cmth}
\lnie
\endln
\lnie
5.16 atn              arctangent of real accum\endln
\lnie
5.17 chp              integer portion of real accum\endln
\lnie
5.18 cos              cosine of real accum\endln
\lnie
5.19 etx              e to the power in the real accum\endln
\lnie
5.20 lnf              natural logorithm of real accum\endln
\lnie
5.21 sin              sine of real accum\endln
\lnie
5.22 sqr              square root of real accum\endln
\lnie
5.23 tan              tangent of real accum\endln
\lnie
\endln
\lnie
     the above orders operate upon the real accumulator,\endln
\lnie
     and replace the contents of the accumulator with the\endln
\lnie
     result.\endln
\lnie
\endln
\lnie
     if the result of any of the above operations is\endln
\lnie
     undefined or out of range, real overflow is set,\endln
\lnie
     the contents of (ra) are undefined and the following\endln
\lnie
     instruction must be either rov or rno.\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
-6-  operations on character values\endln
\lnie
\endln
\lnie
     character operations employ the concept of a\endln
\lnie
     character pointer which uses either\endln
\lnie
     index register xr or xl (not xs).\endln
\lnie
\endln
\lnie
     a character pointer points to a specific character\endln
\lnie
     in a string of characters stored cfp$c chars to a\endln
\lnie
     word. the only operations permitted on a character\endln
\lnie
     pointer are lch and sch. in particular, a character\endln
\lnie
     pointer may not even be moved with mov.\endln
\lnie
\endln
\lnie
        restriction 1.\endln
\lnie
        --------------\endln
\lnie
     it is important when coding in minimal to ensure\endln
\lnie
     that no action occurring between the initial use of\endln
\lnie
     plc or psc and the eventual clearing of xl or xr on\endln
\lnie
     completion of character operations can initiate a\endln
\lnie
     garbage collection. the latter of course could cause\endln
\lnie
     the addressed characters to be moved leaving the\endln
\lnie
     character pointers pointing to rubbish.\endln
\lnie
\endln
\lnie
        restriction 2.\endln
\lnie
        --------------\endln
\lnie
     a further restriction to be observed in code\endln
\lnie
     handling character strings, is that strings built\endln
\lnie
     dynamically should be right padded with zero\endln
\lnie
     characters to a full word boundary to permit easy\endln
\lnie
     hashing and use of ceq or cne in testing strings\endln
\lnie
     for equality.\endln
\lnie
\endln
\lnie
6.1  plc  x,opv       prepare ch ptr for lch,cmc,mvc,trc,\endln
\lnie
                      mcb.\endln
\lnie
\endln
\lnie
6.2  psc  x,opv       prepare char. ptr for sch,mvc,mcb.\endln
\lnie
\endln
\lnie
     opv can be omitted if it is zero.\endln
\lnie
     the char. initially addressed is determined by the\endln
\lnie
     word address in x and the integer offset opv.\endln
\lnie
     there is an automatic implied offset of cfp$f bytes.\endln
\lnie
     cfp$f is used to formally introduce into minimal a\endln
\lnie
     value needed in translating these opcodes which,\endln
\lnie
     since minimal itself does not prescribe a string\endln
\lnie
     structure in detail, depends on the choice of a data\endln
\lnie
     structure for strings in the minimal program.\endln
\lnie
     e.g. if cfp$b = cfp$c = 3, cfp$f = 6, num01 = 1, xl\endln
\lnie
     points to a series of 4 words, abc/def/ghi/jkl, then\endln
\lnie
         plc  xl,=num01\endln
\lnie
     points to h.\endln
\vfill\break

\lnie
\endln
\lnie
-6- operations on character values (continued)\endln
\lnie
\endln
\lnie
6.3  lch  reg,opc     load character into reg\endln
\lnie
\endln
\lnie
6.4  sch  reg,opc     store character from reg\endln
\lnie
\endln
\lnie
     these operations are defined such that the character\endln
\lnie
     is right justified in register reg with zero bits to\endln
\lnie
     the left. after lch for example, it is legitimate\endln
\lnie
     to regard reg as containing the ordinal integer\endln
\lnie
     corresponding to the character.\endln
\lnie
\endln
\lnie
     opc is one of the following three possibilities.\endln
\lnie
\endln
\lnie
     (x)              the character pointed to by the\endln
\lnie
                      character pointer in x. the\endln
\lnie
                      character pointer is not changed.\endln
\lnie
\endln
\lnie
     (x)+             same character as (x) but the\endln
\lnie
                      character pointer is incremented\endln
\lnie
                      to point to the next character\endln
\lnie
                      following execution.\endln
\lnie
\endln
\lnie
     -(x)             the character pointer is decre-\endln
\lnie
                      mented before accessing the\endln
\lnie
                      character so that the previous\endln
\lnie
                      character is referenced.\endln
\lnie
\endln
\lnie
6.5  csc  x           complete store characters\endln
\lnie
\endln
\lnie
     this instruction marks completion of a\endln
\lnie
     psc,sch,sch,...,sch sequence initiated by\endln
\lnie
     a  psc  x instruction. no more sch instructions\endln
\lnie
     using  x  should be obeyed until another psc is\endln
\lnie
     obeyed. it is provided solely as an efficiency aid\endln
\lnie
     on machines without character orders since it\endln
\lnie
     permits use of register buffering of chars in sch\endln
\lnie
     sequences. where csc is not a no-op, it must observe\endln
\lnie
     restriction 2. (e.g. in spitbol, alocs zeroises the\endln
\lnie
     last word of a string frame prior to sch sequence\endln
\lnie
     being started so csc must not nullify this action.)\endln
\lnie
\endln
\lnie
     the following instructions are used to compare\endln
\lnie
     two words containing cfp$c characters.\endln
\lnie
     comparisons distinct from beq,bne are provided as\endln
\lnie
     on some target machines, the possibility of the sign\endln
\lnie
     bit being set may require special action.\endln
\lnie
     note that restriction 2 above, eases use of these\endln
\lnie
     orders in testing complete strings for equality,\endln
\lnie
     since whole word tests are possible.\endln
\lnie
\endln
\lnie
6.6  ceq  opw,opw,plbl jump to plbl if opw eq opw\endln
\lnie
6.7  cne  opw,opw,plbl jump to plbl if opw ne opw\endln
\vfill\break

\lnie
\endln
\lnie
-6- operations on character values (continued)\endln
\lnie
\endln
\lnie
6.8  cmc  plbl,plbl   compare characters\endln
\lnie
\endln
\lnie
     cmc is used to compare two character strings. before\endln
\lnie
     executing cmc, registers are set up as follows.\endln
\lnie
     (xl)             character ptr for first string\endln
\lnie
     (xr)             character pointer for second string\endln
\lnie
     (wa)             character count (must be .gt. zero)\endln
\lnie
     xl and xr should have been prepared by plc.\endln
\lnie
     control passes to first plbl if the first string\endln
\lnie
     is lexically less than the second string, and to\endln
\lnie
     the second plbl if the first string is lexically\endln
\lnie
     greater. control passes to the following instruction\endln
\lnie
     if the strings are identical. after executing this\endln
\lnie
     instruction, the values of xr and xl are set to\endln
\lnie
     zero and the value in (wa) is undefined.\endln
\lnie
     arguments to cmc may be complete or partial\endln
\lnie
     strings, so making optimisation to use whole word\endln
\lnie
     comparisons difficult (dependent in general on\endln
\lnie
     shifts and masking).\endln
\lnie
\endln
\lnie
6.9  trc              translate characters\endln
\lnie
\endln
\lnie
     trc is used to translate a character string using a\endln
\lnie
     supplied translation table. before executing trc the\endln
\lnie
     registers are set as follows.\endln
\lnie
     (xl)             char ptr to string to be translated\endln
\lnie
     (xr)             char ptr to translate table\endln
\lnie
     (wa)             length of string to be translated\endln
\lnie
     xl and xr should have been prepared by plc.\endln
\lnie
     the translate table consists of cfp$a contiguous\endln
\lnie
     characters giving the translations of the cfp$a\endln
\lnie
     characters in the alphabet. on completion, (xr) and\endln
\lnie
     (xl) are set to zero and (wa) is undefined.\endln
\lnie
\endln
\lnie
6.10 flc  w           fold character to upper case\endln
\lnie
     flc is used only if .culc is defined. the character\endln
\lnie
     code value in w is translated to upper case if it\endln
\lnie
     corresponds to a lower case character.\endln
\vfill\break

\lnie
\endln
\lnie
-7-  operations on bit string values\endln
\lnie
\endln
\lnie
7.1  anb  opw,w       and bit string values\endln
\lnie
7.2  orb  opw,w       or bit string values\endln
\lnie
7.3  xob  opw,w       exclusive or bit string values\endln
\lnie
\endln
\lnie
     in the above operations, the logical connective is\endln
\lnie
     applied separately to each of the cfp$n bits.\endln
\lnie
     the result is stored in the second operand location.\endln
\lnie
\endln
\lnie
7.4  cmb  w           complement all bits in opw\endln
\lnie
\endln
\lnie
7.5  rsh  w,val       right shift by val bits\endln
\lnie
7.6  lsh  w,val       left shift by val bits\endln
\lnie
7.7  rsx  w,(x)       right shift w number of bits in x\endln
\lnie
7.8  lsx  w,(x)       left shift w number of bits in x\endln
\lnie
\endln
\lnie
     the above shifts are logical shifts in which bits\endln
\lnie
     shifted out are lost and zero bits supplied as\endln
\lnie
     required. the shift count is in the range 0-cfp$n.\endln
\lnie
\endln
\lnie
7.9  nzb  w,plbl      jump to plbl if w is not\endln
\lnie
                      all zero bits.\endln
\lnie
\endln
\lnie
7.10 zrb  w,plbl      jump to plbl if w is all zero bits\endln
\lnie
\endln
\lnie
7.11 zgb  opn         zeroise garbage bits\endln
\lnie
\endln
\lnie
     opn contains a bit string representing a word\endln
\lnie
     of characters from a string or some function\endln
\lnie
     formed from such characters (e.g. as a result of\endln
\lnie
     hashing). on a machine where the word size is not a\endln
\lnie
     multiple of the character size, some bits in reg may\endln
\lnie
     be undefined. this opcode replaces such bits by the\endln
\lnie
     zero bit. zgb is a no-op if the word size is a\endln
\lnie
     multiple of the character size.\endln
\vfill\break

\lnie
\endln
\lnie
-8-  conversion instructions\endln
\lnie
\endln
\lnie
     the following instructions provide for conversion\endln
\lnie
     between lengths in bytes and lengths in words.\endln
\lnie
\endln
\lnie
8.1  wtb  reg         convert reg from words to bytes.\endln
\lnie
                      that is, multiply by cfp$b. this is\endln
\lnie
                      a no-op if cfp$b is one.\endln
\lnie
\endln
\lnie
8.2  btw  reg         convert reg from bytes to words\endln
\lnie
                      by dividing reg by cfp$b discarding\endln
\lnie
                      the fraction. no-op if cfp$b is one\endln
\lnie
\endln
\lnie
     the following instructions provide for conversion\endln
\lnie
     of one word integer values (addresses) to and\endln
\lnie
     from the full signed integer format.\endln
\lnie
\endln
\lnie
8.3  mti  opn         the value of opn (an address)\endln
\lnie
                      is moved as a positive integer\endln
\lnie
                      to the integer accumulator.\endln
\lnie
\endln
\lnie
8.4  mfi  opn,plbl    the value currently stored in the\endln
\lnie
                      integer accumulator is moved\endln
\lnie
                      to opn as an address if it is in\endln
\lnie
                      the range 0 to cfp$m inclusive.\endln
\lnie
                      if the accumulator value is\endln
\lnie
                      outside this range, then the result\endln
\lnie
                      in opn is undefined and control is\endln
\lnie
                      passed to plbl. mfi destroys the\endln
\lnie
                      value of (ia) whether or not\endln
\lnie
                      integer overflow is signalled.\endln
\lnie
                      plbl may be omitted if overflow\endln
\lnie
                      is impossible.\endln
\lnie
\endln
\lnie
     the following instructions provide for conversion\endln
\lnie
     between real values and integer values.\endln
\lnie
\endln
\lnie
8.5  itr              convert integer value in integer\endln
\lnie
                      accumulator to real and store in\endln
\lnie
                      real accumulator (may lose\endln
\lnie
                      precision in some cases)\endln
\lnie
\endln
\lnie
8.6  rti  plbl        convert the real value in ra to\endln
\lnie
                      an integer and place result in ia.\endln
\lnie
                      conversion is by truncation of the\endln
\lnie
                      fraction - no rounding occurs.\endln
\lnie
                      jump to plbl if out of range. (ra)\endln
\lnie
                      is not changed in either case.\endln
\lnie
                      plbl may be omitted if overflow\endln
\lnie
                      is impossible.\endln
\vfill\break

\lnie
\endln
\lnie
-8-  conversion instructions (continued)\endln
\lnie
\endln
\lnie
     the following instructions provide for computing\endln
\lnie
     the length of storage required for a text string.\endln
\lnie
\endln
\lnie
8.7  ctw  w,val       this instruction computes the sum\endln
\lnie
                      (number of words required to store\endln
\lnie
                      w characters) + (val). the sum\endln
\lnie
                      is stored in w.\endln
\lnie
                      for example, if cfp$c is 5, and wa\endln
\lnie
                      contains 32, then ctw wa,2\endln
\lnie
                      gives a result of 9 in wa.\endln
\lnie
\endln
\lnie
8.8  ctb  w,val       ctb is exactly like ctw except that\endln
\lnie
                      the result is in bytes. it has the\endln
\lnie
                      same effect as ctw w,val  wtb w\endln
\lnie
\endln
\lnie
     the following instructions provide for conversion\endln
\lnie
     from integers to and from numeric digit characters\endln
\lnie
     for use in numeric conversion routines. they employ\endln
\lnie
     negative integer values to allow for proper\endln
\lnie
     conversion of numbers which cannot be complemented.\endln
\lnie
\endln
\lnie
8.9  cvm  plbl        convert by multiplication\endln
\lnie
\endln
\lnie
     the integer accumulator, which is zero or negative,\endln
\lnie
     is multiplied by 10. wb contains the character\endln
\lnie
     code for a digit. the value of this digit is then\endln
\lnie
     subtracted from the result. if the result is out of\endln
\lnie
     range, then control is passed to plbl with the\endln
\lnie
     result in (ia) undefined. execution of cvm leaves\endln
\lnie
     the result in (wb) undefined.\endln
\lnie
\endln
\lnie
8.10 cvd              convert by division\endln
\lnie
\endln
\lnie
     the integer accumulator, which is zero or negative,\endln
\lnie
     is divided by 10. the quotient (zero or negative)\endln
\lnie
     is replaced in the accumulator. the remainder is\endln
\lnie
     converted to the character code of a digit and\endln
\lnie
     placed in wa. for example, an operand of -523 gives\endln
\lnie
     a quotient of -52 and a remainder in wa of ch$d3.\endln
\vfill\break

\lnie
\endln
\lnie
-9-  block move instructions\endln
\lnie
\endln
\lnie
the following instructions are used for transferring\endln
\lnie
data from one area of memory to another in blocks.\endln
\lnie
they can be implemented with the indicated series of\endln
\lnie
other macro-instructions, but more efficient imple-\endln
\lnie
mentations will be possible on most machines.\endln
\lnie
\endln
\lnie
note that in the equivalent code sequence shown below, a\endln
\lnie
zero value in wa will move at least one item, and may\endln
\lnie
may wrap the counter causing a core dump in some imple-\endln
\lnie
mentations.  thus wa should be .gt. 0 prior to invoking\endln
\lnie
any of these block move instructions.\endln
\lnie
\endln
\lnie
9.1  mvc              move characters\endln
\lnie
\endln
\lnie
     before obeying this order wa,xl,xr should have been\endln
\lnie
     set up, the latter two by plc, psc resp.\endln
\lnie
     mvc is equivalent to the sequence\endln
\lnie
\endln
\lnie
            mov  wb,dumpb\endln
\lnie
            lct  wa,wa\endln
\lnie
     loopc  lch  wb,(xl)+\endln
\lnie
            sch  wb,(xr)+\endln
\lnie
            bct  wa,loopc\endln
\lnie
            csc  xr\endln
\lnie
            mov  dumpb,wb\endln
\lnie
\endln
\lnie
     the character pointers are bumped as indicated\endln
\lnie
     and the final value of wa is undefined.\endln
\lnie
\endln
\lnie
\endln
\lnie
9.2  mvw              move words\endln
\lnie
\endln
\lnie
     mvw is equivalent to the sequence\endln
\lnie
\endln
\lnie
     loopw  mov  (xl)+,(xr)+\endln
\lnie
            dca  wa               wa = bytes to move\endln
\lnie
            bnz  wa,loopw\endln
\lnie
\endln
\lnie
     note that this implies that the value in wa is the\endln
\lnie
     length in bytes which is a multiple of cfp$b.\endln
\lnie
     the initial addresses in xr,xl are word addresses.\endln
\lnie
     as indicated, the final xr,xl values point past the\endln
\lnie
     new and old regions of memory respectively.\endln
\lnie
     the final value of wa is undefined.\endln
\lnie
     wa,xl,xr must be set up before obeying mvw.\endln
\lnie
\endln
\lnie
9.3  mwb              move words backwards\endln
\lnie
\endln
\lnie
     mwb is equivalent to the sequence\endln
\lnie
\endln
\lnie
     loopb  mov  -(xl),-(xr)\endln
\lnie
            dca  wa               wa = bytes to move\endln
\lnie
            bnz  wa,loopb\endln
\lnie
\endln
\lnie
     there is a requirement that the initial value in xl\endln
\lnie
     be at least 256 less than the value in xr. this\endln
\lnie
     allows an implementation in which chunks of 256\endln
\lnie
     bytes are moved forward (ibm 360, icl 1900).\endln
\lnie
     the final value of wa is undefined.\endln
\lnie
     wa,xl,xr must be set up before obeying mwb.\endln
\lnie
\endln
\lnie
9.4  mcb              move characters backwards\endln
\lnie
\endln
\lnie
     mcb is equivalent to the sequence\endln
\lnie
\endln
\lnie
            mov  wb,dumpb\endln
\lnie
            lct  wa,wa\endln
\lnie
     loopc  lch  wb,-(xl)\endln
\lnie
            sch  wb,-(xr)\endln
\lnie
            bct  wa,loopc\endln
\lnie
            csc  xr\endln
\lnie
            mov  dumpb,wb\endln
\lnie
\endln
\lnie
     there is a requirement that the initial value in xl\endln
\lnie
     be at least 256 less than the value in xr. this\endln
\lnie
     allows an implementation in which chunks of 256\endln
\lnie
     bytes are moved forward (ibm 360, icl 1900).\endln
\lnie
     the final value of wa is undefined.\endln
\lnie
     wa,xl,xr must be set up before obeying mcb.\endln
\vfill\break

\lnie
\endln
\lnie
-10- operations connected with the stack\endln
\lnie
\endln
\lnie
the stack is an area in memory which is dedicated for use\endln
\lnie
in conjunction with the stack pointer register (xs). as\endln
\lnie
previously described, it is used by the jsr and exi\endln
\lnie
instructions and may be used for storage of any other\endln
\lnie
data as required.\endln
\lnie
\endln
\lnie
the stack builds either way in memory and an important\endln
\lnie
restriction is that the value in (xs) must be the address\endln
\lnie
of the stack front at all times since\endln
\lnie
some implementations may randomly destroy stack locations\endln
\lnie
beyond (xs).\endln
\lnie
\endln
\lnie
the starting stack base address is passed\endln
\lnie
in (xs) at the start of execution. during execution it\endln
\lnie
is necessary to make sure that the stack does not\endln
\lnie
overflow. this is achieved by executing the following\endln
\lnie
instruction periodically.\endln
\lnie
\endln
\lnie
10.1 chk              check stack overflow\endln
\lnie
\endln
\lnie
after successfully executing chk, it is permissible to\endln
\lnie
use up to 100 additional words before issuing another chk\endln
\lnie
thus chk need not be issued every time the stack is\endln
\lnie
expanded. in some implementations, the checking may be\endln
\lnie
automatic and chk will have no effect. following the\endln
\lnie
above rule makes sure that the program will operate\endln
\lnie
correctly in implementations with no automatic check.\endln
\lnie
\endln
\lnie
if stack overflow occurs (detected either automatically\endln
\lnie
or by a chk instruction), then control is passed to the\endln
\lnie
stack overflow section (see program form). note that this\endln
\lnie
transfer may take place following any instruction which\endln
\lnie
stores data at a new location on the stack.\endln
\lnie
after stack overflow, stack is arbitrarily popped\endln
\lnie
to give some space in which the error procedure may\endln
\lnie
operate. otherwise a loop of stack overflows may occur.\endln
\vfill\break

\lnie
\endln
\lnie
-11- data generation instructions\endln
\lnie
\endln
\lnie
the following instructions are used to generate constant\endln
\lnie
values in the constant section and also to assemble\endln
\lnie
initial values in the working storage section. they\endln
\lnie
may not appear except in these two sections.\endln
\lnie
\endln
\lnie
11.1 dac  addr        assemble address constant.\endln
\lnie
                      generates one word containing the\endln
\lnie
                      specified one word integer\endln
\lnie
                      value (address).\endln
\lnie
\endln
\lnie
11.2 dic  integer     generates an integer value which\endln
\lnie
                      occupies cfp$i consecutive words.\endln
\lnie
                      the operand is a digit string with\endln
\lnie
                      a required leading sign.\endln
\lnie
\endln
\lnie
11.3 drc  real        assembles a real constant which\endln
\lnie
                      occupies cfp$r consecutive words.\endln
\lnie
                      the operand form must obey the\endln
\lnie
                      rules for a fortran real constant\endln
\lnie
                      with the extra requirement that a\endln
\lnie
                      leading sign be present.\endln
\lnie
\endln
\lnie
11.4 dtc  dtext       define text constant. dtext\endln
\lnie
                      is started and ended with any\endln
\lnie
                      character not contained in the\endln
\lnie
                      characters to be assembled. the\endln
\lnie
                      constant occupies consecutive words\endln
\lnie
                      as dictated by the configuration\endln
\lnie
                      parameter cfp$c. any unused chars\endln
\lnie
                      in the last word are right filled\endln
\lnie
                      with zeros (i.e. the character\endln
\lnie
                      whose internal code is zero).\endln
\lnie
                      the string contains a sequence of\endln
\lnie
                      letters, digits, blanks and any of\endln
\lnie
                      the following special characters.\endln
\lnie
                      =,$.(*)/+-\endln
\lnie
                      no other characters\endln
\lnie
                      may be used in a dtext operand.\endln
\lnie
\endln
\lnie
11.5 dbc  val         assemble bit string constant. the\endln
\lnie
                      operand is a positive integer\endln
\lnie
                      value which is interpreted in\endln
\lnie
                      binary, right justified and left\endln
\lnie
                      filled with zero bits. thus 5 would\endln
\lnie
                      imply the bit string value 00...101.\endln
\vfill\break

\lnie
\endln
\lnie
-12- symbol definition instructions\endln
\lnie
\endln
\lnie
the following instruction is used to define symbols\endln
\lnie
in the definitions section. it may not be used elsewhere.\endln
\lnie
\endln
\lnie
12.1 equ  eqop        define symbol\endln
\lnie
\endln
\lnie
     the symbol which appears in the label field is\endln
\lnie
     defined to have the absolute value given\endln
\lnie
     by the eqop operand. a given symbol may be defined\endln
\lnie
     only once in this manner, and any symbols occuring\endln
\lnie
     in eqop must be previously defined.\endln
\lnie
\endln
\lnie
     the following are the possibilities for eqop\endln
\lnie
\endln
\lnie
     val              the indicated value is used\endln
\lnie
\endln
\lnie
     val+val          the sum of the two values is used.\endln
\lnie
                      this sum must not exceed cfp$m\endln
\lnie
\endln
\lnie
     val-val          the difference between the two\endln
\lnie
                      values (must be positive) is used.\endln
\lnie
\endln
\lnie
     *                this format defines the label by\endln
\lnie
                      using a value supplied by the\endln
\lnie
                      minimal translator. values are\endln
\lnie
                      required for the\endln
\lnie
     cfp$x            (configuration parameters)\endln
\lnie
     e$xxx            (environment parameters)\endln
\lnie
     ch$xx            (character codes).\endln
\lnie
                      in order for a translator to\endln
\lnie
                      handle this format correctly the\endln
\lnie
                      definitions section must be\endln
\lnie
                      consulted for details of required\endln
\lnie
                      symbols as listed at the front of\endln
\lnie
                      the section.\endln
\vfill\break

\lnie
\endln
\lnie
symbol definition instructions (continued)\endln
\lnie
\endln
\lnie
the following instructions may be used to define symbols\endln
\lnie
in the procedure section. they may not be used in\endln
\lnie
any other part of the program.\endln
\lnie
\endln
\lnie
12.2 exp              define external procedure\endln
\lnie
\endln
\lnie
     exp defines the symbol appearing in the label field\endln
\lnie
     to be the name of an external procedure which can be\endln
\lnie
     referenced in a subsequent jsr instruction. the\endln
\lnie
     coding for the procedure is external to the\endln
\lnie
     coding of the source program in this language.\endln
\lnie
     the code for external procedures may be\endln
\lnie
     referred to collectively as the operating system\endln
\lnie
     interface, or more briefly, osint, and will\endln
\lnie
     frequently be a separately compiled segment of code\endln
\lnie
     loaded with spitbol to produce a complete system.\endln
\lnie
\endln
\lnie
12.3 inp  ptyp,int    define internal procedure\endln
\lnie
\endln
\lnie
     inp defines the symbol appearing in the label field\endln
\lnie
     to be the name of an internal procedure and gives\endln
\lnie
     its type and number of exit parameters. the label\endln
\lnie
     can be referenced in jsr instructions and\endln
\lnie
     it must appear labelling a prc instruction in the\endln
\lnie
     program section.\endln
\lnie
\endln
\lnie
12.4 inr              define internal routine\endln
\lnie
\endln
\lnie
     inr defines the symbol appearing in the label\endln
\lnie
     field to be the name of an internal routine. the\endln
\lnie
     label may be referenced in any type of branch order\endln
\lnie
     and it must appear labelling a rtn instruction in\endln
\lnie
     the program section.\endln
\vfill\break

\lnie
\endln
\lnie
-13- assembly listing layout instructions\endln
\lnie
\endln
\lnie
13.1 ejc              eject to next page\endln
\lnie
\endln
\lnie
13.2 ttl  text        set new assembly title\endln
\lnie
\endln
\lnie
     ttl implies an immediate eject of the\endln
\lnie
     assembly listing to print the new title.\endln
\lnie
\endln
\lnie
     the use of ttl and ejc cards is such that the\endln
\lnie
     program will list neatly if the printer prints\endln
\lnie
     as many as 58 lines per page. in the event that\endln
\lnie
     the printer depth is less than this, or if the\endln
\lnie
     listing contains interspersed lines (such as actual\endln
\lnie
     generated code), then the format may be upset.\endln
\lnie
\endln
\lnie
     lines starting with an asterisk are comment lines\endln
\lnie
     which cause no code to be generated and may occur\endln
\lnie
     freely anywhere in the program. the format for\endln
\lnie
     comment lines is given in section -15-.\endln
\vfill\break

\lnie
\endln
\lnie
-14- program form\endln
\lnie
\endln
\lnie
     the program consists of separate sections separated\endln
\lnie
     by sec operations. the sections must appear in the\endln
\lnie
     following specified order.\endln
\lnie
\endln
\lnie
14.1 sec              start of procedure section\endln
\lnie
\endln
\lnie
     (procedure section)\endln
\lnie
\endln
\lnie
     sec               start of definitions section\endln
\lnie
\endln
\lnie
     (definitions section)\endln
\lnie
\endln
\lnie
     sec               start of constant storage section\endln
\lnie
\endln
\lnie
     (constant storage section)\endln
\lnie
\endln
\lnie
     sec               start of working storage section\endln
\lnie
\endln
\lnie
     (working storage section)\endln
\lnie
\endln
\lnie
     sec               start of program section\endln
\lnie
\endln
\lnie
     (program section)\endln
\lnie
\endln
\lnie
     sec               start of stack overflow section\endln
\lnie
\endln
\lnie
     (stack overflow section)\endln
\lnie
\endln
\lnie
     sec               start of error section\endln
\lnie
\endln
\lnie
     (error section)\endln
\lnie
\endln
\lnie
14.2 end              end of assembly\endln
\vfill\break

\lnie
\endln
\lnie
section 10 - program form\endln
\lnie
\endln
\lnie
procedure section\endln
\lnie
\endln
\lnie
     the procedure section contains all the exp\endln
\lnie
     instructions for externally available procedures\endln
\lnie
     and inp,inr opcodes for internal procedures,routines\endln
\lnie
     so that a single pass minimal translator has advance\endln
\lnie
     knowledge of procedure types when translating calls.\endln
\lnie
\endln
\lnie
definitions section\endln
\lnie
\endln
\lnie
     the definitions section contains equ instructions\endln
\lnie
     which define symbols referenced later on in the\endln
\lnie
     program, constant and work sections.\endln
\lnie
\endln
\lnie
constant storage section\endln
\lnie
\endln
\lnie
     the constant storage section consists entirely\endln
\lnie
     of constants assembled with the dac,dic,drc,dtc,dbc\endln
\lnie
     assembly operations. these constants can be freely\endln
\lnie
     referenced by the program instructions.\endln
\lnie
\endln
\lnie
working storage section\endln
\lnie
\endln
\lnie
     the working storage section consists entirely of\endln
\lnie
     dac,dic,drc,dbc,dtc instructions to define a fixed\endln
\lnie
     length work area. the work locations in this area\endln
\lnie
     can be directly referenced in program instructions.\endln
\lnie
     the area is initialized in accordance with the\endln
\lnie
     values assembled in the instructions.\endln
\lnie
\endln
\lnie
program section\endln
\lnie
\endln
\lnie
     the program section contains program instructions\endln
\lnie
     and associated operations (such as prc, enp, ent).\endln
\lnie
     control is passed to the first instruction in this\endln
\lnie
     section when execution is initiated.\endln
\lnie
\endln
\lnie
stack overflow section\endln
\lnie
\endln
\lnie
     the stack overflow section contains instructions\endln
\lnie
     like the program section. control is passed to the\endln
\lnie
     first instruction in this section following the\endln
\lnie
     occurrence of stack overflow, see chk instruction.\endln
\lnie
\endln
\lnie
error section\endln
\lnie
\endln
\lnie
     the error section contains instructions like the\endln
\lnie
     program section. control is passed to the first\endln
\lnie
     instruction in this section when a procedure exit\endln
\lnie
     corresponds to an error parameter (see err)\endln
\lnie
     or when an erb opcode is obeyed. the error code\endln
\lnie
     must clean up the main stack and cater for the\endln
\lnie
     possibility that a subroutine stack may need clean\endln
\lnie
     up.\endln
\vfill\break

\lnie
osint\endln
\lnie
\endln
\lnie
     though not part of the minimal source, it is useful\endln
\lnie
     to refer to the collection of initialisation and\endln
\lnie
     exp routines as osint (operating system interface).\endln
\lnie
     errors occurring within osint procedures are\endln
\lnie
     usually handled by making an error return. if this\endln
\lnie
     is not feasible or appropriate, osint may use the\endln
\lnie
     minimal error section to report errors directly by\endln
\lnie
     branching to it with a suitable numeric error\endln
\lnie
     code in wa.\endln
\vfill\break

\lnie
\endln
\lnie
section 11 - statement format\endln
\lnie
\endln
\lnie
all labels are exactly five characters long and start\endln
\lnie
with three letters (abcdefghijklmnopqrstuvwxy$) followed\endln
\lnie
by two letters or digits.\endln
\lnie
the letter z may not be used in minimal symbols but $ is\endln
\lnie
permitted.\endln
\lnie
for implementations where $ may not appear in the\endln
\lnie
target code , a simple substitution of z for $\endln
\lnie
may thus be made without risk of producing non-unique\endln
\lnie
symbols.\endln
\lnie
the letter z is however permitted in opcode mnemonics and\endln
\lnie
in comments.\endln
\lnie
\endln
\lnie
minimal statements are in a fixed format as follows.\endln
\lnie
\endln
\lnie
cols 1-5              label if any (else blank)\endln
\lnie
\endln
\lnie
cols 6-7              always blank\endln
\lnie
\endln
\lnie
cols 8-10             operation mnemonic\endln
\lnie
\endln
\lnie
cols 11-12            blanks\endln
\lnie
\endln
\lnie
cols 13-28            operand field, terminated by a\endln
\lnie
                      blank. may occasionally\endln
\lnie
                      extend past column 28.\endln
\lnie
\endln
\lnie
cols 30-64            comment. always separated from the\endln
\lnie
                      operand field by at least one blank\endln
\lnie
                      may occasionally start after column\endln
\lnie
                      30 if the operand extends past 28.\endln
\lnie
                      a special exception occurs for the\endln
\lnie
                      iff instruction, whose comment may\endln
\lnie
                      be only 20 characters long (30-49).\endln
\lnie
\endln
\lnie
cols 65 on            unused\endln
\lnie
\endln
\lnie
\endln
\lnie
comment lines have the following format\endln
\lnie
\endln
\lnie
col 1                 asterisk\endln
\lnie
\endln
\lnie
cols 2-7              blank\endln
\lnie
\endln
\lnie
cols 8-64             arbitrary text, restricted to the\endln
\lnie
                      fortran character set.\endln
\lnie
\endln
\lnie
\endln
\lnie
the fortran character set is a-z 0-9 =,$.(*)-/+\endln
\vfill\break

\lnie
\endln
\lnie
section 12 - program execution\endln
\lnie
\endln
\lnie
execution of the program begins with the first\endln
\lnie
instruction in the program section.\endln
\lnie
\endln
\lnie
in addition to the fixed length memory regions defined\endln
\lnie
by the assembly, there are two dynamically allocated\endln
\lnie
memory regions as follows.\endln
\lnie
\endln
\lnie
data area             this is an area available to the\endln
\lnie
                      program for general storage of data\endln
\lnie
                      any data value may be stored in\endln
\lnie
                      this area except instructions.\endln
\lnie
                      in some implementations, it may be\endln
\lnie
                      possible to increase the size of\endln
\lnie
                      this area dynamically by adding\endln
\lnie
                      words at the top end with a call\endln
\lnie
                      to a system procedure.\endln
\lnie
\endln
\lnie
stack area            this region of memory holds\endln
\lnie
                      the stack used for subroutine calls\endln
\lnie
                      and other storage of one word\endln
\lnie
                      integer values (addresses). this\endln
\lnie
                      is the stack associated with\endln
\lnie
                      index register xs.\endln
\lnie
\endln
\lnie
the locations and sizes of these areas are specified\endln
\lnie
by the values in the registers at the start of program\endln
\lnie
execution as follows.\endln
\lnie
\endln
\lnie
(xs)                  address one past the stack base.\endln
\lnie
                      e.g. if xs is 23456, a d-stack will\endln
\lnie
                      occupy words 23455,23454,...\endln
\lnie
                      whereas a u-stack will occupy\endln
\lnie
                      23457,23458,...\endln
\lnie
\endln
\lnie
(xr)                  address of the first word\endln
\lnie
                      in the data area\endln
\lnie
\endln
\lnie
(xl)                  address of the last word in the\endln
\lnie
                      data area.\endln
\lnie
\endln
\lnie
(wa)                  initial stack pointer\endln
\lnie
\endln
\lnie
(wb,wc,ia,ra,cp)      zero\endln
\lnie
\endln
\lnie
there is no explicit way to terminate the execution of a\endln
\lnie
program. this function is performed by an appropriate\endln
\lnie
system procedure referenced with the sysej instruction.\endln
\vfill\break
{\bf spitbol--\rm basic information}
\vskip1em
\vfill\break

\lnie
\endln
\lnie
general structure\endln
\lnie
-----------------\endln
\lnie
\endln
\lnie
this program is a translator for a version of the snobol4\endln
\lnie
programming language. language details are contained in\endln
\lnie
the manual macro spitbol by dewar and mccann, technical\endln
\lnie
report 90, university of leeds 1976.\endln
\lnie
the implementation is discussed in dewar and mccann,\endln
\lnie
macro spitbol - a snobol4 compiler, software practice and\endln
\lnie
experience, 7, 95-113, 1977.\endln
\lnie
the language is as implemented by the btl translator\endln
\lnie
(griswold, poage and polonsky, prentice hall, 1971)\endln
\lnie
with the following principal exceptions.\endln
\lnie
\endln
\lnie
1)   redefinition of standard system functions and\endln
\lnie
     operators is not permitted.\endln
\lnie
\endln
\lnie
2)   the value function is not provided.\endln
\lnie
\endln
\lnie
3)   access tracing is provided in addition to the\endln
\lnie
     other standard trace modes.\endln
\lnie
\endln
\lnie
4)   the keyword stfcount is not provided.\endln
\lnie
\endln
\lnie
5)   the keyword fullscan is not provided and all pattern\endln
\lnie
     matching takes place in fullscan mode (i.e. with no\endln
\lnie
     heuristics applied).\endln
\lnie
\endln
\lnie
6)   a series of expressions separated by commas may\endln
\lnie
     be grouped within parentheses to provide a selection\endln
\lnie
     capability. the semantics are that the selection\endln
\lnie
     assumes the value of the first expression within it\endln
\lnie
     which succeeds as they are evaluated from the left.\endln
\lnie
     if no expression succeeds the entire statement fails\endln
\lnie
\endln
\lnie
7)   an explicit pattern matching operator is provided.\endln
\lnie
     this is the binary query (see gimpel sigplan oct 74)\endln
\lnie
\endln
\lnie
8)   the assignment operator is introduced as in the\endln
\lnie
     gimpel reference.\endln
\lnie
\endln
\lnie
9)   the exit function is provided for generating load\endln
\lnie
     modules - cf. gimpels sitbol.\endln
\lnie
\endln
\lnie
\endln
\lnie
the method used in this program is to translate the\endln
\lnie
source code into an internal pseudo-code (see following\endln
\lnie
section). an interpretor is then used to execute this\endln
\lnie
generated pseudo-code. the nature of the snobol4 language\endln
\lnie
is such that the latter task is much more complex than\endln
\lnie
the actual translation phase. accordingly, nearly all the\endln
\lnie
code in the program section is concerned with the actual\endln
\lnie
execution of the snobol4 program.\endln
\vfill\break

\lnie
\endln
\lnie
interpretive code format\endln
\lnie
------------------------\endln
\lnie
\endln
\lnie
the interpretive pseudo-code consists of a series of\endln
\lnie
address pointers. the exact format of the code is\endln
\lnie
described in connection with the cdblk format. the\endln
\lnie
purpose of this section is to give general insight into\endln
\lnie
the interpretive approach involved.\endln
\lnie
\endln
\lnie
the basic form of the code is related to reverse polish.\endln
\lnie
in other words, the operands precede the operators which\endln
\lnie
are zero address operators. there are some exceptions to\endln
\lnie
these rules, notably the unary not operator and the\endln
\lnie
selection construction which clearly require advance\endln
\lnie
knowledge of the operator involved.\endln
\lnie
\endln
\lnie
the operands are moved to the top of the main stack and\endln
\lnie
the operators are applied to the top stack entries. like\endln
\lnie
other versions of spitbol, this processor depends on\endln
\lnie
knowing whether operands are required by name or by value\endln
\lnie
and moves the appropriate object to the stack. thus no\endln
\lnie
name/value checks are included in the operator circuits.\endln
\lnie
\endln
\lnie
the actual pointers in the code point to a block whose\endln
\lnie
first word is the address of the interpretor routine\endln
\lnie
to be executed for the code word.\endln
\lnie
\endln
\lnie
in the case of operators, the pointer is to a word which\endln
\lnie
contains the address of the operator to be executed. in\endln
\lnie
the case of operands such as constants, the pointer is to\endln
\lnie
the operand itself. accordingly, all operands contain\endln
\lnie
a field which points to the routine to load the value of\endln
\lnie
the operand onto the stack. in the case of a variable,\endln
\lnie
there are three such pointers. one to load the value,\endln
\lnie
one to store the value and a third to jump to the label.\endln
\lnie
\endln
\lnie
the handling of failure returns deserves special comment.\endln
\lnie
the location flptr contains the pointer to the location\endln
\lnie
on the main stack which contains the failure return\endln
\lnie
which is in the form of a byte offset in the current\endln
\lnie
code block (cdblk or exblk). when a failure occurs, the\endln
\lnie
stack is popped as indicated by the setting of flptr and\endln
\lnie
control is passed to the appropriate location in the\endln
\lnie
current code block with the stack pointer pointing to the\endln
\lnie
failure offset on the stack and flptr unchanged.\endln
\vfill\break

\lnie
\endln
\lnie
internal data representations\endln
\lnie
-----------------------------\endln
\lnie
\endln
\lnie
representation of values\endln
\lnie
\endln
\lnie
a value is represented by a pointer to a block which\endln
\lnie
describes the type and particulars of the data value.\endln
\lnie
in general, a variable is a location containing such a\endln
\lnie
pointer (although in the case of trace associations this\endln
\lnie
is modified, see description of trblk).\endln
\lnie
\endln
\lnie
the following is a list of possible datatypes showing the\endln
\lnie
type of block used to hold the value. the details of\endln
\lnie
each block format are given later.\endln
\lnie
\endln
\lnie
datatype              block type\endln
\lnie
--------              ----------\endln
\lnie
\endln
\lnie
array                 arblk or vcblk\endln
\lnie
\endln
\lnie
code                  cdblk\endln
\lnie
\endln
\lnie
expression            exblk or seblk\endln
\lnie
\endln
\lnie
integer               icblk\endln
\lnie
\endln
\lnie
name                  nmblk\endln
\lnie
\endln
\lnie
pattern               p0blk or p1blk or p2blk\endln
\lnie
\endln
\lnie
real                  rcblk\endln
\lnie
\endln
\lnie
string                scblk\endln
\lnie
\endln
\lnie
table                 tbblk\endln
\lnie
\endln
\lnie
program datatype      pdblk\endln
\vfill\break

\lnie
\endln
\lnie
representation of variables\endln
\lnie
---------------------------\endln
\lnie
\endln
\lnie
during the course of evaluating expressions, it is\endln
\lnie
necessary to generate names of variables (for example\endln
\lnie
on the left side of a binary equals operator). these are\endln
\lnie
not to be confused with objects of datatype name which\endln
\lnie
are in fact values.\endln
\lnie
\endln
\lnie
from a logical point of view, such names could be simply\endln
\lnie
represented by a pointer to the appropriate value cell.\endln
\lnie
however in the case of arrays and program defined\endln
\lnie
datatypes, this would violate the rule that there must be\endln
\lnie
no pointers into the middle of a block in dynamic store.\endln
\lnie
accordingly, a name is always represented by a base and\endln
\lnie
offset. the base points to the start of the block\endln
\lnie
containing the variable value and the offset is the\endln
\lnie
offset within this block in bytes. thus the address\endln
\lnie
of the actual variable is determined by adding the base\endln
\lnie
and offset values.\endln
\lnie
\endln
\lnie
the following are the instances of variables represented\endln
\lnie
in this manner.\endln
\lnie
\endln
\lnie
1)   natural variable base is ptr to vrblk\endln
\lnie
                      offset is *vrval\endln
\lnie
\endln
\lnie
2)   table element    base is ptr to teblk\endln
\lnie
                      offset is *teval\endln
\lnie
\endln
\lnie
3)   array element    base is ptr to arblk\endln
\lnie
                      offset is offset to element\endln
\lnie
\endln
\lnie
4)   vector element   base is ptr to vcblk\endln
\lnie
                      offset is offset to element\endln
\lnie
\endln
\lnie
5)   prog def dtp     base is ptr to pdblk\endln
\lnie
                      offset is offset to field value\endln
\lnie
\endln
\lnie
in addition there are two cases of objects which are\endln
\lnie
like variables but cannot be handled in this manner.\endln
\lnie
these are called pseudo-variables and are represented\endln
\lnie
with a special base pointer as follows=\endln
\lnie
\endln
\lnie
expression variable   ptr to evblk (see evblk)\endln
\lnie
\endln
\lnie
keyword variable      ptr to kvblk (see kvblk)\endln
\lnie
\endln
\lnie
pseudo-variables are handled as special cases by the\endln
\lnie
access procedure (acess) and the assignment procedure\endln
\lnie
(asign). see these two procedures for details.\endln
\vfill\break

\lnie
\endln
\lnie
organization of data area\endln
\lnie
-------------------------\endln
\lnie
\endln
\lnie
the data area is divided into two regions.\endln
\lnie
\endln
\lnie
static area\endln
\lnie
\endln
\lnie
the static area builds up from the bottom and contains\endln
\lnie
data areas which are allocated dynamically but are never\endln
\lnie
deleted or moved around. the macro-program itself\endln
\lnie
uses the static area for the following.\endln
\lnie
\endln
\lnie
1)   all variable blocks (vrblk).\endln
\lnie
\endln
\lnie
2)   the hash table for variable blocks.\endln
\lnie
\endln
\lnie
3)   miscellaneous buffers and work areas (see program\endln
\lnie
     initialization section).\endln
\lnie
\endln
\lnie
in addition, the system procedures may use this area for\endln
\lnie
input/output buffers, external functions etc. space in\endln
\lnie
the static region is allocated by calling procedure alost\endln
\lnie
\endln
\lnie
the following global variables define the current\endln
\lnie
location and size of the static area.\endln
\lnie
\endln
\lnie
statb                 address of start of static area\endln
\lnie
state                 address+1 of last word in area.\endln
\lnie
\endln
\lnie
the minimum size of static is given approximately by\endln
\lnie
     12 + *e$hnb + *e$sts + space for alphabet string\endln
\lnie
     and standard print buffer.\endln
\vfill\break

\lnie
dynamic area\endln
\lnie
\endln
\lnie
the dynamic area is built upwards in memory after the\endln
\lnie
static region. data in this area must all be in standard\endln
\lnie
block formats so that it can be processed by the garbage\endln
\lnie
collector (procedure gbcol). gbcol compacts blocks down\endln
\lnie
in this region as required by space exhaustion and can\endln
\lnie
also move all blocks up to allow for expansion of the\endln
\lnie
static region.\endln
\lnie
with the exception of tables and arrays, no spitbol\endln
\lnie
object once built in dynamic memory is ever subsequently\endln
\lnie
modified. observing this rule necessitates a copying\endln
\lnie
action during string and pattern concatenation.\endln
\lnie
\endln
\lnie
garbage collection is fundamental to the allocation of\endln
\lnie
space for values. spitbol uses a very efficient garbage\endln
\lnie
collector which insists that pointers into dynamic store\endln
\lnie
should be identifiable without use of bit tables,\endln
\lnie
marker bits etc. to satisfy this requirement, dynamic\endln
\lnie
memory must not start at too low an address and lengths\endln
\lnie
of arrays, tables, strings, code and expression blocks\endln
\lnie
may not exceed the numerical value of the lowest dynamic\endln
\lnie
address.\endln
\lnie
\endln
\lnie
to avoid either penalizing users with modest\endln
\lnie
requirements or restricting those with greater needs on\endln
\lnie
host systems where dynamic memory is allocated in low\endln
\lnie
addresses, the minimum dynamic address may be specified\endln
\lnie
sufficiently high to permit arbitrarily large spitbol\endln
\lnie
objects to be created (with the possibility in extreme\endln
\lnie
cases of wasting large amounts of memory below the\endln
\lnie
start address). this minimum value is made available\endln
\lnie
in variable mxlen by a system routine, sysmx.\endln
\lnie
alternatively sysmx may indicate that a\endln
\lnie
default may be used in which dynamic is placed\endln
\lnie
at the lowest possible address following static.\endln
\lnie
\endln
\lnie
the following global work cells define the location and\endln
\lnie
length of the dynamic area.\endln
\lnie
\endln
\lnie
dnamb                 start of dynamic area\endln
\lnie
dnamp                 next available location\endln
\lnie
dname                 last available location + 1\endln
\lnie
\endln
\lnie
dnamb is always higher than state since the alost\endln
\lnie
procedure maintains some expansion space above state.\endln
\lnie
*** dnamb must never be permitted to have a value less\endln
\lnie
than that in mxlen ***\endln
\lnie
\endln
\lnie
space in the dynamic region is allocated by the alloc\endln
\lnie
procedure. the dynamic region may be used by system\endln
\lnie
procedures provided that all the rules are obeyed.\endln
\lnie
some of the rules are subtle so it is preferable for\endln
\lnie
osint to manage its own memory needs. spitbol procs\endln
\lnie
obey rules to ensure that no action can cause a garbage\endln
\lnie
collection except at such times as contents of xl, xr\endln
\lnie
and the stack are +clean+ (see comment before utility\endln
\lnie
procedures and in gbcol for more detail). note\endln
\lnie
that calls of alost may cause garbage collection (shift\endln
\lnie
of memory to free space). spitbol procs which call\endln
\lnie
system routines assume that they cannot precipitate\endln
\lnie
collection and this must be respected.\endln
\vfill\break

\lnie
\endln
\lnie
register usage\endln
\lnie
--------------\endln
\lnie
\endln
\lnie
(cp)                  code pointer register. used to\endln
\lnie
                      hold a pointer to the current\endln
\lnie
                      location in the interpretive pseudo\endln
\lnie
                      code (i.e. ptr into a cdblk).\endln
\lnie
\endln
\lnie
(xl,xr)               general index registers. usually\endln
\lnie
                      used to hold pointers to blocks in\endln
\lnie
                      dynamic storage. an important\endln
\lnie
                      restriction is that the value in\endln
\lnie
                      xl must be collectable for\endln
\lnie
                      a garbage collect call. a value\endln
\lnie
                      is collectable if it either points\endln
\lnie
                      outside the dynamic area, or if it\endln
\lnie
                      points to the start of a block in\endln
\lnie
                      the dynamic area.\endln
\lnie
\endln
\lnie
(xs)                  stack pointer. used to point to\endln
\lnie
                      the stack front. the stack may\endln
\lnie
                      build up or down and is used\endln
\lnie
                      to stack subroutine return points\endln
\lnie
                      and other recursively saved data.\endln
\lnie
\endln
\lnie
(xt)                  an alternative name for xl during\endln
\lnie
                      its use in accessing stacked items.\endln
\lnie
\endln
\lnie
(wa,wb,wc)            general work registers. cannot be\endln
\lnie
                      used for indexing, but may hold\endln
\lnie
                      various types of data.\endln
\lnie
\endln
\lnie
(ia)                  used for all signed integer\endln
\lnie
                      arithmetic, both that used by the\endln
\lnie
                      translator and that arising from\endln
\lnie
                      use of snobol4 arithmetic operators\endln
\lnie
\endln
\lnie
(ra)                  real accumulator. used for all\endln
\lnie
                      floating point arithmetic.\endln
\vfill\break

\lnie
\endln
\lnie
spitbol conditional assembly symbols\endln
\lnie
------------------------------------\endln
\lnie
\endln
\lnie
in the spitbol translator, the following conditional\endln
\lnie
assembly symbols are referred to. to incorporate the\endln
\lnie
features referred to, the minimal source should be\endln
\lnie
prefaced by suitable conditional assembly symbol\endln
\lnie
definitions.\endln
\lnie
in all cases it is permissible to default the definitions\endln
\lnie
in which case the additional features will be omitted\endln
\lnie
from the target code.\endln
\lnie
\endln
\lnie
.caex                 define to allow up arrow for expon.\endln
\lnie
.caht                 define to include horizontal tab\endln
\lnie
.casl                 define to include 26 shifted lettrs\endln
\lnie
.cavt                 define to include vertical tab\endln
\lnie
.cbyt                 define for statistics in bytes\endln
\lnie
.ccmc                 define to include syscm function\endln
\lnie
.ccmk                 define to include compare keyword\endln
\lnie
.cepp                 define if entrys have odd parity\endln
\lnie
.cera                 define to include sysea function\endln
\lnie
.cexp                 define if spitbol pops sysex args\endln
\lnie
.cgbc                 define to include sysgc function\endln
\lnie
.cicc                 define to ignore bad control cards\endln
\lnie
.cinc                 define to add -include control card\endln
\lnie
.ciod                 define to not use default delimiter\endln
\lnie
                        in processing 3rd arg of input()\endln
\lnie
                        and output()\endln
\lnie
.cmth                 define to include math functions\endln
\lnie
.cnbf                 define to omit buffer extension\endln
\lnie
.cnbt                 define to omit batch initialisation\endln
\lnie
.cnci                 define to enable sysci routine\endln
\lnie
.cncr                 define to enable syscr routine\endln
\lnie
.cnex                 define to omit exit() code.\endln
\lnie
.cnld                 define to omit load() code.\endln
\lnie
.cnlf                 define to add file type for load()\endln
\lnie
.cnpf                 define to omit profile stuff\endln
\lnie
.cnra                 define to omit all real arithmetic\endln
\lnie
.cnsc                 define to no numeric-string compare\endln
\lnie
.cnsr                 define to omit sort, rsort\endln
\lnie
.cpol                 define if interface polling desired\endln
\lnie
.crel                 define to include reloc routines\endln
\lnie
.crpp                 define if returns have odd parity\endln
\lnie
.cs16                 define to initialize stlim to 32767\endln
\lnie
.cs32                 define to init stlim to 2147483647\endln
\lnie
                      omit to take default of 50000\endln
\lnie
.csax                 define if sysax is to be called\endln
\lnie
.csed                 define to use sediment in gbcol\endln
\lnie
.csfn                 define to track source file names\endln
\lnie
.csln                 define if line number in code block\endln
\lnie
.csn5                 define to pad stmt nos to 5 chars\endln
\lnie
.csn6                 define to pad stmt nos to 6 chars\endln
\lnie
.csn8                 define to pad stmt nos to 8 chars\endln
\lnie
.csou                 define if output, terminal to sysou\endln
\lnie
.ctet                 define to table entry trace wanted\endln
\lnie
.ctmd                 define if systm unit is decisecond\endln
\lnie
.cucf                 define to include cfp$u\endln
\lnie
.cuej                 define to suppress needless ejects\endln
\lnie
.culk                 define to include &l/ucase keywords\endln
\lnie
.culc                 define to include &case (lc names)\endln
\lnie
                      if cucl defined, must support\endln
\lnie
                      minimal op flc wreg that folds\endln
\lnie
                      argument to upper case\endln
\lnie
.cust                 define to include set() code\endln
\lnie
\endln
\lnie
                      conditional options\endln
\lnie
                      since .undef not allowed if symbol\endln
\lnie
                      not defined, a full comment line\endln
\lnie
                      indicates symbol initially not\endln
\lnie
                      defined.\endln
\lnie
\endln
\inst{.def}{.ca}{}{define to allow up arrow for expon.}
\inst{.def}{.ca}{}{define to include horizontal tab}
\inst{.def}{.ca}{}{define to include 26 shifted lettrs}
\inst{.def}{.ca}{}{define to include vertical tab}
\lnie
.cbyt                 define for statistics in bytes\endln
\lnie
.ccmc                 define to include syscm function\endln
\lnie
.ccmk                 define to include compare keyword\endln
\lnie
.cepp                 define if entrys have odd parity\endln
\lnie
.cera                 define to include sysea function\endln
\lnie
.cexp                 define if spitbol pops sysex args\endln
\inst{.def}{.cg}{}{define to include sysgc function}
\lnie
.cicc                 define to ignore bad control cards\endln
\lnie
.cinc                 define to add -include control card\endln
\inst{.def}{.ci}{}{define to not use default delimiter}
\lnie
                      in processing 3rd arg of input()\endln
\lnie
                      and output()\endln
\lnie
.cmth                 define to include math functions\endln
\inst{.def}{.cn}{}{define to omit buffer extension}
\inst{.def}{.cn}{}{define to omit batch initialisation}
\lnie
.cnci                 define to enable sysci routine\endln
\lnie
.cncr                 define to enable syscr routine\endln
\lnie
.cnex                 define to omit exit() code.\endln
\inst{.def}{.cn}{}{define to omit load() code.}
\lnie
.cnlf                 define to add file type to load()\endln
\lnie
.cnpf                 define to omit profile stuff\endln
\lnie
.cnra                 define to omit all real arithmetic\endln
\lnie
.cnsc                 define if no numeric-string compare\endln
\lnie
.cnsr                 define to omit sort, rsort\endln
\lnie
.cpol                 define if interface polling desired\endln
\lnie
.crel                 define to include reloc routines\endln
\lnie
.crpp                 define if returns have odd parity\endln
\lnie
.cs16                 define to initialize stlim to 32767\endln
\lnie
.cs32                 define to init stlim to 2147483647\endln
\inst{.def}{.cs}{}{define if sysax is to be called}
\lnie
.csed                 define to use sediment in gbcol\endln
\lnie
.csfn                 define to track source file names\endln
\lnie
.csln                 define if line number in code block\endln
\lnie
.csn5                 define to pad stmt nos to 5 chars\endln
\lnie
.csn6                 define to pad stmt nos to 6 chars\endln
\inst{.def}{.cs}{}{define to pad stmt nos to 8 chars}
\lnie
.csou                 define if output, terminal to sysou\endln
\inst{.def}{.ct}{}{define to table entry trace wanted}
\lnie
.ctmd                 define if systm unit is decisecond\endln
\inst{.def}{.cu}{}{define to include cfp$u}
\inst{.def}{.cu}{}{define to suppress needless ejects}
\inst{.def}{.cu}{}{define to include &l/ucase keywords}
\inst{.def}{.cu}{}{define to include &case (lc names)}
\inst{.def}{.cu}{}{define to include set() code}
\lnie
\endln
\lnie
force definition of .ccmk if .ccmc is defined\endln
\lnie
\endln
\ifmac{.ccmc}
\inst{.def}{.cc}{}{}
\asmac{fi}
\vfill\break
{\bf spitbol--\rm procedures section}
\vskip1em
\lnie
\endln
\lnie
this section starts with descriptions of the operating\endln
\lnie
system dependent procedures which are used by the spitbol\endln
\lnie
translator. all such procedures have five letter names\endln
\lnie
beginning with sys. they are listed in alphabetical\endln
\lnie
order.\endln
\lnie
all procedures have a  specification consisting of a\endln
\lnie
model call, preceded by a possibly empty list of register\endln
\lnie
contents giving parameters available to the procedure and\endln
\lnie
followed by a possibly empty list of register contents\endln
\lnie
required on return from the call or which may have had\endln
\lnie
their contents destroyed. only those registers explicitly\endln
\lnie
mentioned in the list after the call may have their\endln
\lnie
values changed.\endln
\lnie
the segment of code providing the external procedures is\endln
\lnie
conveniently referred to as osint (operating system\endln
\lnie
interface). the sysxx procedures it contains provide\endln
\lnie
facilities not usually available as primitives in\endln
\lnie
assembly languages. for particular target machines,\endln
\lnie
implementors may choose for some minimal opcodes which\endln
\lnie
do not have reasonably direct translations, to use calls\endln
\lnie
of additional procedures which they provide in osint.\endln
\lnie
e.g. mwb or trc might be translated as jsr sysmb,\endln
\lnie
jsr systc in some implementations.\endln
\lnie
\endln
\lnie
in the descriptions, reference is made to --blk\endln
\lnie
formats (-- = a pair of letters). see the spitbol\endln
\lnie
definitions section for detailed descriptions of all\endln
\lnie
such block formats except fcblk for which sysfc should\endln
\lnie
be consulted.\endln
\lnie
\endln
\lnie
section 0 contains inp,inr specifications of internal\endln
\lnie
procedures,routines. this gives a single pass translator\endln
\lnie
information making it easy to generate alternative calls\endln
\lnie
in the translation of jsr-s for procedures of different\endln
\lnie
types if this proves necessary.\endln
\lnie
\endln
\inst{}{sec}{}{start of procedures section}
\ifmac{.csax}
\vfill\break

\lnie
\endln
\lnie
sysax -- after execution\endln
\lnie
\endln
\inst{sysax}{exp}{}{define external entry point}
\lnie
\endln
\lnie
if the conditional assembly symbol .csax is defined,\endln
\lnie
this routine is called immediately after execution and\endln
\lnie
before printing of execution statistics or dump output.\endln
\lnie
purpose of call is for implementor to determine and\endln
\lnie
if the call is not required it will be omitted if .csax\endln
\lnie
is undefined. in this case sysax need not be coded.\endln
\lnie
\endln
\lnie
jsr  sysax            call after execution\endln
\asmac{else}
\asmac{fi}
\vfill\break

\ifmac{.cbsp}
\lnie
\endln
\lnie
sysbs -- backspace file\endln
\lnie
\endln
\inst{sysbs}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysbs is used to implement the snobol4 function backspace\endln
\lnie
if the conditional assembly symbol .cbsp is defined.\endln
\lnie
the meaning is system dependent.  in general, backspace\endln
\lnie
repositions the file one record closer to the beginning\endln
\lnie
of file, such that a subsequent read or write will\endln
\lnie
operate on the previous record.\endln
\lnie
\endln
\lnie
(wa)                  ptr to fcblk or zero\endln
\lnie
(xr)                  backspace argument (scblk ptr)\endln
\lnie
jsr  sysbs            call to backspace\endln
\lnie
ppm  loc              return here if file does not exist\endln
\lnie
ppm  loc              return here if backspace not allowed\endln
\lnie
ppm  loc              return here if i/o error\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\lnie
the second error return is used for files for which\endln
\lnie
backspace is not permitted. for example, it may be expected\endln
\lnie
files on character devices are in this category.\endln
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
sysbx -- before execution\endln
\lnie
\endln
\inst{sysbx}{exp}{}{define external entry point}
\lnie
\endln
\lnie
called after initial spitbol compilation and before\endln
\lnie
commencing execution in case osint needs\endln
\lnie
to assign files or perform other necessary services.\endln
\lnie
osint may also choose to send a message to online\endln
\lnie
terminal (if any) indicating that execution is starting.\endln
\lnie
\endln
\lnie
jsr  sysbx            call before execution starts\endln
\vfill\break

\ifmac{.cnci}
\lnie
\endln
\lnie
sysci -- convert integer\endln
\lnie
\endln
\inst{sysci}{exp}{}{}
\lnie
\endln
\lnie
sysci is an optional osint routine that causes spitbol to\endln
\lnie
call sysci to convert integer values to strings, rather\endln
\lnie
than using the internal spitbol conversion code.  this\endln
\lnie
code may be less efficient on machines with hardware\endln
\lnie
conversion instructions and in such cases, it may be an\endln
\lnie
advantage to include sysci.  the symbol .cnci must be\endln
\lnie
defined if this routine is to be used.\endln
\lnie
\endln
\lnie
the rules for converting integers to strings are that\endln
\lnie
positive values are represented without any sign, and\endln
\lnie
there are never any leading blanks or zeros, except in\endln
\lnie
the case of zero itself which is represented as a single\endln
\lnie
zero digit.  negative numbers are represented with a\endln
\lnie
preceeding minus sign.  there are never any trailing\endln
\lnie
blanks, and conversion cannot fail.\endln
\lnie
\endln
\lnie
(ia)                  value to be converted\endln
\lnie
jsr  sysci            call to convert integer value\endln
\lnie
(xl)                  pointer to pseudo-scblk with string\endln
\vfill\break

\asmac{fi}
\ifmac{.ccmc}
\lnie
\endln
\lnie
syscm -- general string comparison function\endln
\lnie
\endln
\inst{syscm}{exp}{}{define external entry point}
\lnie
\endln
\lnie
provides string comparison determined by interface.\endln
\lnie
used for international string comparison.\endln
\lnie
\endln
\lnie
\endln
\lnie
(xr)                  character pointer for first string\endln
\lnie
(xl)                  character pointer for second string\endln
\lnie
(wb)                  character count of first string\endln
\lnie
(wa)                  character count of second string\endln
\lnie
jsr  syscm            call to syscm function\endln
\lnie
ppm  loc              string too long for syscm\endln
\lnie
ppm  loc              first string lexically gt second\endln
\lnie
ppm  loc              first string lexically lt second\endln
\lnie
---                   strings equal\endln
\lnie
(xl)                  zero\endln
\lnie
(xr)                  destroyed\endln
\lnie
\endln
\vfill\break

\asmac{fi}
\ifmac{.cnra}
\asmac{else}
\ifmac{.cncr}
\lnie
\endln
\lnie
syscr -- convert real\endln
\lnie
\endln
\inst{syscr}{exp}{}{}
\lnie
\endln
\lnie
syscr is an optional osint routine that causes spitbol to\endln
\lnie
call syscr to convert real values to strings, rather\endln
\lnie
than using the internal spitbol conversion code.  this\endln
\lnie
code may be desired on machines where the integer size\endln
\lnie
is too small to allow production of a sufficient number\endln
\lnie
of significant digits.  the symbol .cncr must be defined\endln
\lnie
if this routine is to be used.\endln
\lnie
\endln
\lnie
the rules for converting reals to strings are that\endln
\lnie
positive values are represented without any sign, and\endln
\lnie
there are never any leading blanks or zeros, except in\endln
\lnie
the case of zero itself which is represented as a single\endln
\lnie
zero digit.  negative numbers are represented with a\endln
\lnie
preceeding minus sign.  there are never any trailing\endln
\lnie
blanks, or trailing zeros in the fractional part.\endln
\lnie
conversion cannot fail.\endln
\lnie
\endln
\lnie
(ra)                  value to be converted\endln
\lnie
(wa)                  no. of significant digits desired\endln
\lnie
(wb)                  conversion type:\endln
\lnie
                       negative for e-type conversion\endln
\lnie
                       zero for g-type conversion\endln
\lnie
                       positive for f-type conversion\endln
\lnie
(wc)                  character positions in result scblk\endln
\lnie
(xr)                  scblk for result\endln
\lnie
jsr  syscr            call to convert real value\endln
\lnie
(xr)                  result scblk\endln
\lnie
(wa)                  number of result characters\endln
\vfill\break

\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
sysdc -- date check\endln
\lnie
\endln
\inst{sysdc}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysdc is called to check that the expiry date for a trial\endln
\lnie
version of spitbol is unexpired.\endln
\lnie
\endln
\lnie
jsr  sysdc            call to check date\endln
\lnie
return only if date is ok\endln
\vfill\break

\lnie
\endln
\lnie
sysdm  -- dump core\endln
\lnie
\endln
\inst{sysdm}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysdm is called by a spitbol program call of dump(n) with\endln
\lnie
n ge 4.  its purpose is to provide a core dump.\endln
\lnie
n could hold an encoding of the start adrs for dump and\endln
\lnie
amount to be dumped e.g.  n = 256*a + s , s = start adrs\endln
\lnie
in kilowords,  a = kilowords to dump\endln
\lnie
\endln
\lnie
(xr)                  parameter n of call dump(n)\endln
\lnie
jsr  sysdm            call to enter routine\endln
\vfill\break

\lnie
\endln
\lnie
sysdt -- get current date\endln
\lnie
\endln
\inst{sysdt}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysdt is used to obtain the current date. the date is\endln
\lnie
returned as a character string in any format appropriate\endln
\lnie
to the operating system in use. it may also contain the\endln
\lnie
current time of day. sysdt is used to implement the\endln
\lnie
snobol4 function date().\endln
\lnie
\endln
\lnie
(xr)                  parameter n of call date(n)\endln
\lnie
jsr  sysdt            call to get date\endln
\lnie
(xl)                  pointer to block containing date\endln
\lnie
\endln
\lnie
the format of the block is like an scblk except that\endln
\lnie
the first word need not be set. the result is copied\endln
\lnie
into spitbol dynamic memory on return.\endln
\ifmac{.cera}
\vfill\break

\lnie
\endln
\lnie
sysea -- inform osint of compilation and runtime errors\endln
\lnie
\endln
\inst{sysea}{exp}{}{define external entry point}
\lnie
\endln
\lnie
provides means for interface to take special actions on\endln
\lnie
errors\endln
\lnie
\endln
\lnie
(wa)                  error code\endln
\lnie
(wb)                  line number\endln
\lnie
(wc)                  column number\endln
\lnie
(xr)                  system stage\endln
\ifmac{.csfn}
\lnie
(xl)                  file name (scblk)\endln
\asmac{fi}
\lnie
jsr  sysea            call to sysea function\endln
\lnie
ppm  loc              suppress printing of error message\endln
\lnie
(xr)                  message to print (scblk) or 0\endln
\lnie
\endln
\lnie
sysea may not return if interface chooses to retain\endln
\lnie
control.  closing files via the fcb chain will be the\endln
\lnie
responsibility of the interface.\endln
\lnie
\endln
\lnie
all registers preserved\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
sysef -- eject file\endln
\lnie
\endln
\inst{sysef}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysef is used to write a page eject to a named file. it\endln
\lnie
may only be used for files where this concept makes\endln
\lnie
sense. note that sysef is not normally used for the\endln
\lnie
standard output file (see sysep).\endln
\lnie
\endln
\lnie
(wa)                  ptr to fcblk or zero\endln
\lnie
(xr)                  eject argument (scblk ptr)\endln
\lnie
jsr  sysef            call to eject file\endln
\lnie
ppm  loc              return here if file does not exist\endln
\lnie
ppm  loc              return here if inappropriate file\endln
\lnie
ppm  loc              return here if i/o error\endln
\vfill\break

\lnie
\endln
\lnie
sysej -- end of job\endln
\lnie
\endln
\inst{sysej}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysej is called once at the end of execution to\endln
\lnie
terminate the run. the significance of the abend and\endln
\lnie
code values is system dependent. in general, the code\endln
\lnie
value should be made available for testing, and the\endln
\lnie
abend value should cause some post-mortem action such as\endln
\lnie
a dump. note that sysej does not return to its caller.\endln
\lnie
see sysxi for details of fcblk chain\endln
\lnie
\endln
\lnie
(wa)                  value of abend keyword\endln
\lnie
(wb)                  value of code keyword\endln
\lnie
(xl)                  o or ptr to head of fcblk chain\endln
\lnie
jsr  sysej            call to end job\endln
\lnie
\endln
\lnie
the following special values are used as codes in (wb)\endln
\lnie
999  execution suppressed\endln
\lnie
998  standard output file full or unavailable in a sysxi\endln
\lnie
     load module. in these cases (wa) contains the number\endln
\lnie
     of the statement causing premature termination.\endln
\vfill\break

\lnie
\endln
\lnie
sysem -- get error message text\endln
\lnie
\endln
\inst{sysem}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysem is used to obtain the text of err, erb calls in the\endln
\lnie
source program given the error code number. it is allowed\endln
\lnie
to return a null string if this facility is unavailable.\endln
\lnie
\endln
\lnie
(wa)                  error code number\endln
\lnie
jsr  sysem            call to get text\endln
\lnie
(xr)                  text of message\endln
\lnie
\endln
\lnie
the returned value is a pointer to a block in scblk\endln
\lnie
format except that the first word need not be set. the\endln
\lnie
string is copied into dynamic memory on return.\endln
\lnie
if the null string is returned either because sysem does\endln
\lnie
not provide error message texts or because wa is out of\endln
\lnie
range, spitbol will print the string stored in errtext\endln
\lnie
keyword.\endln
\vfill\break

\lnie
\endln
\lnie
sysen -- endfile\endln
\lnie
\endln
\inst{sysen}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysen is used to implement the snobol4 function endfile.\endln
\lnie
the meaning is system dependent. in general, endfile\endln
\lnie
implies that no further i/o operations will be performed,\endln
\lnie
but does not guarantee this to be the case. the file\endln
\lnie
should be closed after the call, a subsequent read\endln
\lnie
or write may reopen the file at the start or it may be\endln
\lnie
necessary to reopen the file via sysio.\endln
\lnie
\endln
\lnie
(wa)                  ptr to fcblk or zero\endln
\lnie
(xr)                  endfile argument (scblk ptr)\endln
\lnie
jsr  sysen            call to endfile\endln
\lnie
ppm  loc              return here if file does not exist\endln
\lnie
ppm  loc              return here if endfile not allowed\endln
\lnie
ppm  loc              return here if i/o error\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\lnie
the second error return is used for files for which\endln
\lnie
endfile is not permitted. for example, it may be expected\endln
\lnie
that the standard input and output files are in this\endln
\lnie
category.\endln
\vfill\break

\lnie
\endln
\lnie
sysep -- eject printer page\endln
\lnie
\endln
\inst{sysep}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysep is called to perform a page eject on the standard\endln
\lnie
printer output file (corresponding to syspr output).\endln
\lnie
\endln
\lnie
jsr  sysep            call to eject printer output\endln
\vfill\break

\lnie
\endln
\lnie
sysex -- call external function\endln
\lnie
\endln
\inst{sysex}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysex is called to pass control to an external function\endln
\lnie
previously loaded with a call to sysld.\endln
\lnie
\endln
\lnie
(xs)                  pointer to arguments on stack\endln
\lnie
(xl)                  pointer to control block (efblk)\endln
\lnie
(wa)                  number of arguments on stack\endln
\lnie
jsr  sysex            call to pass control to function\endln
\lnie
ppm  loc              return here if function call fails\endln
\lnie
ppm  loc              return here if insufficient memory\endln
\lnie
ppm  loc              return here if bad argument type\endln
\ifmac{.cexp}
\asmac{else}
\lnie
(xs)                  popped past arguments\endln
\asmac{fi}
\lnie
(xr)                  result returned\endln
\lnie
\endln
\lnie
the arguments are stored on the stack with\endln
\lnie
the last argument at 0(xs). on return, xs\endln
\lnie
is popped past the arguments.\endln
\lnie
\endln
\lnie
the form of the arguments as passed is that used in the\endln
\lnie
spitbol translator (see definitions and data structures\endln
\lnie
section). the control block format is also described\endln
\lnie
(under efblk) in this section.\endln
\lnie
\endln
\lnie
there are two ways of returning a result.\endln
\lnie
\endln
\lnie
1)   return a pointer to a block in dynamic storage. this\endln
\lnie
     block must be in exactly correct format, including\endln
\lnie
     the first word. only functions written with intimate\endln
\lnie
     knowledge of the system will return in this way.\endln
\lnie
\endln
\lnie
2)   string, integer and real results may be returned by\endln
\lnie
     pointing to a pseudo-block outside dynamic memory.\endln
\lnie
     this block is in icblk, rcblk or scblk format except\endln
\lnie
     that the first word will be overwritten\endln
\lnie
     by a type word on return and so need not\endln
\lnie
     be correctly set. such a result is\endln
\lnie
     copied into main storage before proceeding.\endln
\lnie
     unconverted results may similarly be returned in a\endln
\lnie
     pseudo-block which is in correct format including\endln
\lnie
     type word recognisable by garbage collector since\endln
\lnie
     block is copied into dynamic memory.\endln
\vfill\break

\lnie
\endln
\lnie
sysfc -- file control block routine\endln
\lnie
\endln
\inst{sysfc}{exp}{}{define external entry point}
\lnie
\endln
\lnie
see also sysio\endln
\lnie
input and output have 3 arguments referred to as shown\endln
\lnie
     input(variable name,file arg1,file arg2)\endln
\lnie
     output(variable name,file arg1,file arg2)\endln
\lnie
file arg1 may be an integer or string used to identify\endln
\lnie
an i/o channel. it is converted to a string for checking.\endln
\lnie
the exact significance of file arg2\endln
\lnie
is not rigorously prescribed but to improve portability,\endln
\lnie
the scheme described in the spitbol user manual\endln
\lnie
should be adopted when possible. the preferred form is\endln
\lnie
a string $f$,r$r$,c$c$,i$i$,...,z$z$  where\endln
\lnie
$f$ is an optional file name which is placed first.\endln
\lnie
 remaining items may be omitted or included in any order.\endln
\lnie
$r$ is maximum record length\endln
\lnie
$c$ is a carriage control character or character string\endln
\lnie
$i$ is some form of channel identification used in the\endln
\lnie
   absence of $f$ to associate the variable\endln
\lnie
   with a file allocated dynamically by jcl commands at\endln
\lnie
   spitbol load time.\endln
\lnie
,...,z$z$ are additional fields.\endln
\lnie
if , (comma) cannot be used as a delimiter, .ciod\endln
\lnie
should be defined to introduce by conditional assembly\endln
\lnie
another delimiter (see\endln
\lnie
  iodel  equ  *\endln
\lnie
early in definitions section).\endln
\lnie
sysfc is called when a variable is input or output\endln
\lnie
associated to check file arg1 and file arg2 and\endln
\lnie
to  report whether an fcblk (file control\endln
\lnie
block) is necessary and if so what size it should be.\endln
\lnie
this makes it possible for spitbol rather than osint to\endln
\lnie
allocate such a block in dynamic memory if required\endln
\lnie
or alternatively in static memory.\endln
\lnie
the significance of an fcblk , if one is requested, is\endln
\lnie
entirely up to the system interface. the only restriction\endln
\lnie
is that if the fcblk should appear to lie in dynamic\endln
\lnie
memory, pointers to it should be proper pointers to\endln
\lnie
the start of a recognisable and garbage collectable\endln
\lnie
block (this condition will be met if sysfc requests\endln
\lnie
spitbol to provide an fcblk).\endln
\lnie
an option is provided for osint to return a pointer in\endln
\lnie
xl to an fcblk which it privately allocated. this ptr\endln
\lnie
will be made available when i/o occurs later.\endln
\lnie
private fcblks may have arbitrary contents and spitbol\endln
\lnie
stores nothing in them.\endln
\vfill\break

\lnie
the requested size for an fcblk in dynamic memory\endln
\lnie
should allow a 2 word overhead for block type and\endln
\lnie
length fields. information subsequently stored in the\endln
\lnie
remaining words may be arbitrary if an xnblk (external\endln
\lnie
non-relocatable block) is requested. if the request is\endln
\lnie
for an xrblk (external relocatable block) the\endln
\lnie
contents of words should be collectable (i.e. any\endln
\lnie
apparent pointers into dynamic should be genuine block\endln
\lnie
pointers). these restrictions do not apply if an fcblk\endln
\lnie
is allocated outside dynamic or is not allocated at all.\endln
\lnie
if an fcblk is requested, its fields will be initialised\endln
\lnie
to zero before entry to sysio with the exception of\endln
\lnie
words 0 and 1 in which the block type and length\endln
\lnie
fields are placed for fcblks in dynamic memory only.\endln
\lnie
for the possible use of sysej and sysxi, if fcblks\endln
\lnie
are used, a chain is built so that they may all be\endln
\lnie
found - see sysxi for details.\endln
\lnie
if both file arg1 and file arg2 are null, calls of sysfc\endln
\lnie
and sysio are omitted.\endln
\lnie
if file arg1 is null (standard input/output file), sysfc\endln
\lnie
is called to check non-null file arg2 but any request\endln
\lnie
for an fcblk will be ignored, since spitbol handles the\endln
\lnie
standard files specially and cannot readily keep fcblk\endln
\lnie
pointers for them.\endln
\lnie
filearg1 is type checked by spitbol so further checking\endln
\lnie
may be unneccessary in many implementations.\endln
\lnie
file arg2 is passed so that sysfc may analyse and\endln
\lnie
check it. however to assist in this, spitbol also passes\endln
\lnie
on the stack the components of this argument with\endln
\lnie
file name, $f$ (otherwise null) extracted and stacked\endln
\lnie
first.\endln
\lnie
the other fields, if any, are extracted as substrings,\endln
\lnie
pointers to them are stacked and a count of all items\endln
\lnie
stacked is placed in wc. if an fcblk was earlier\endln
\lnie
allocated and pointed to via file arg1, sysfc is also\endln
\lnie
passed a pointer to this fcblk.\endln
\lnie
\endln
\lnie
(xl)                  file arg1 scblk ptr (2nd arg)\endln
\lnie
(xr)                  filearg2 (3rd arg) or null\endln
\lnie
-(xs)...-(xs)         scblks for $f$,$r$,$c$,...\endln
\lnie
(wc)                  no. of stacked scblks above\endln
\lnie
(wa)                  existing file arg1 fcblk ptr or 0\endln
\lnie
(wb)                  0/3 for input/output assocn\endln
\lnie
jsr  sysfc            call to check need for fcblk\endln
\lnie
ppm  loc              invalid file argument\endln
\lnie
ppm  loc              fcblk already in use\endln
\lnie
(xs)                  popped (wc) times\endln
\lnie
(wa non zero)         byte size of requested fcblk\endln
\lnie
(wa=0,xl non zero)    private fcblk ptr in xl\endln
\lnie
(wa=xl=0)             no fcblk wanted, no private fcblk\endln
\lnie
(wc)                  0/1/2 request alloc of xrblk/xnblk\endln
\lnie
                      /static block for use as fcblk\endln
\lnie
(wb)                  destroyed\endln
\ifmac{.cgbc}
\vfill\break

\lnie
\endln
\lnie
sysgc -- inform interface of garbage collections\endln
\lnie
\endln
\inst{sysgc}{exp}{}{define external entry point}
\lnie
\endln
\lnie
provides means for interface to take special actions\endln
\lnie
prior to and after a garbage collection.\endln
\lnie
\endln
\lnie
possible usages-\endln
\lnie
1. provide visible screen icon of garbage collection\endln
\lnie
   in progress\endln
\lnie
2. inform virtual memory manager to ignore page access\endln
\lnie
   patterns during garbage collection.  such accesses\endln
\lnie
   typically destroy the page working set accumulated\endln
\lnie
   by the program.\endln
\lnie
3. inform virtual memory manager that contents of memory\endln
\lnie
   freed by garbage collection can be discarded.\endln
\lnie
\endln
\lnie
(xr)                  non-zero if beginning gc\endln
\lnie
                      =0 if completing gc\endln
\lnie
(wa)                  dnamb=start of dynamic area\endln
\lnie
(wb)                  dnamp=next available location\endln
\lnie
(wc)                  dname=last available location + 1\endln
\lnie
jsr  sysgc            call to sysgc function\endln
\lnie
all registers preserved\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
syshs -- give access to host computer features\endln
\lnie
\endln
\inst{syshs}{exp}{}{define external entry point}
\lnie
\endln
\lnie
provides means for implementing special features\endln
\lnie
on different host computers. the only defined entry is\endln
\lnie
that where all arguments are null in which case syshs\endln
\lnie
returns an scblk containing name of computer,\endln
\lnie
name of operating system and name of site separated by\endln
\lnie
colons. the scblk need not have a correct first field\endln
\lnie
as this is supplied on copying string to dynamic memory.\endln
\lnie
spitbol does no argument checking but does provide a\endln
\lnie
single error return for arguments checked as erroneous\endln
\lnie
by osint. it also provides a single execution error\endln
\lnie
return. if these are inadequate, use may be made of the\endln
\lnie
minimal error section direct as described in minimal\endln
\lnie
documentation, section 10.\endln
\lnie
several non-error returns are provided. the first\endln
\lnie
corresponds to the defined entry or, for implementation\endln
\lnie
defined entries, any string may be returned. the others\endln
\lnie
permit respectively,  return a null result, return with a\endln
\lnie
result to be stacked which is pointed at by xr, and a\endln
\lnie
return causing spitbol statement failure. if a returned\endln
\lnie
result is in dynamic memory it must obey garbage\endln
\lnie
collector rules. the only results copied on return\endln
\lnie
are strings returned via ppm loc3 return.\endln
\lnie
\endln
\lnie
(wa)                  argument 1\endln
\lnie
(xl)                  argument 2\endln
\lnie
(xr)                  argument 3\endln
\lnie
(wb)                  argument 4\endln
\lnie
(wc)                  argument 5\endln
\lnie
jsr  syshs            call to get host information\endln
\lnie
ppm  loc1             erroneous arg\endln
\lnie
ppm  loc2             execution error\endln
\lnie
ppm  loc3             scblk ptr in xl or 0 if unavailable\endln
\lnie
ppm  loc4             return a null result\endln
\lnie
ppm  loc5             return result in xr\endln
\lnie
ppm  loc6             cause statement failure\endln
\lnie
ppm  loc7             return string at xl, length wa\endln
\lnie
ppm  loc8             return copy of result in xr\endln
\vfill\break

\lnie
\endln
\lnie
sysid -- return system identification\endln
\lnie
\endln
\inst{sysid}{exp}{}{define external entry point}
\lnie
\endln
\lnie
this routine should return strings to head the standard\endln
\lnie
printer output. the first string will be appended to\endln
\lnie
a heading line of the form\endln
\lnie
     macro spitbol version v.v\endln
\lnie
supplied by spitbol itself. v.v are digits giving the\endln
\lnie
major version number and generally at least a minor\endln
\lnie
version number relating to osint should be supplied to\endln
\lnie
give say\endln
\lnie
     macro spitbol version v.v(m.m)\endln
\lnie
the second string should identify at least the machine\endln
\lnie
and operating system.  preferably it should include\endln
\lnie
the date and time of the run.\endln
\lnie
optionally the strings may include site name of the\endln
\lnie
the implementor and/or machine on which run takes place,\endln
\lnie
unique site or copy number and other information as\endln
\lnie
appropriate without making it so long as to be a\endln
\lnie
nuisance to users.\endln
\lnie
the first words of the scblks pointed at need not be\endln
\lnie
correctly set.\endln
\lnie
\endln
\lnie
jsr  sysid            call for system identification\endln
\lnie
(xr)                  scblk ptr for addition to header\endln
\lnie
(xl)                  scblk ptr for second header\endln
\vfill\break

\ifmac{.cinc}
\lnie
\endln
\lnie
sysif -- switch to new include file\endln
\lnie
\endln
\inst{sysif}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysif is used for include file processing, both to inform\endln
\lnie
the interface when a new include file is desired, and\endln
\lnie
when the end of file of an include file has been reached\endln
\lnie
and it is desired to return to reading from the previous\endln
\lnie
nested file.\endln
\lnie
\endln
\lnie
it is the responsibility of sysif to remember the file\endln
\lnie
access path to the present input file before switching to\endln
\lnie
the new include file.\endln
\lnie
\endln
\lnie
(xl)                  ptr to scblk or zero\endln
\lnie
(xr)                  ptr to vacant scblk of length cswin\endln
\lnie
                      (xr not used if xl is zero)\endln
\lnie
jsr  sysif            call to change files\endln
\lnie
ppm  loc              unable to open file\endln
\lnie
(xr)                  scblk with full path name of file\endln
\lnie
                      (xr not used if input xl is zero)\endln
\lnie
\endln
\lnie
register xl points to an scblk containing the name of the\endln
\lnie
include file to which the interface should switch.  data\endln
\lnie
is fetched from the file upon the next call to sysrd.\endln
\lnie
\endln
\lnie
sysif may have the ability to search multiple libraries\endln
\lnie
for the include file named in (xl).  it is therefore\endln
\lnie
required that the full path name of the file where the\endln
\lnie
file was finally located be returned in (xr).  it is this\endln
\lnie
name that is recorded along with the source statements,\endln
\lnie
and will accompany subsequent error messages.\endln
\lnie
\endln
\lnie
register xl is zero to mark conclusion of use of an\endln
\lnie
include file.\endln
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
sysil -- get input record length\endln
\lnie
\endln
\inst{sysil}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysil is used to get the length of the next input record\endln
\lnie
from a file previously input associated with a sysio\endln
\lnie
call. the length returned is used to establish a buffer\endln
\lnie
for a subsequent sysin call.  sysil also indicates to the\endln
\lnie
caller if this is a binary or text file.\endln
\lnie
\endln
\lnie
(wa)                  ptr to fcblk or zero\endln
\lnie
jsr  sysil            call to get record length\endln
\lnie
(wa)                  length or zero if file closed\endln
\lnie
(wc)                  zero if binary, non-zero if text\endln
\lnie
\endln
\lnie
no harm is done if the value returned is too long since\endln
\lnie
unused space will be reclaimed after the sysin call.\endln
\lnie
\endln
\lnie
note that it is the sysil call (not the sysio call) which\endln
\lnie
causes the file to be opened as required for the first\endln
\lnie
record input from the file.\endln
\vfill\break

\lnie
\endln
\lnie
sysin -- read input record\endln
\lnie
\endln
\inst{sysin}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysin is used to read a record from the file which was\endln
\lnie
referenced in a prior call to sysil (i.e. these calls\endln
\lnie
always occur in pairs). the buffer provided is an\endln
\lnie
scblk for a string of length set from the sysil call.\endln
\lnie
if the actual length read is less than this, the length\endln
\lnie
field of the scblk must be modified before returning\endln
\lnie
unless buffer is right padded with zeroes.\endln
\lnie
it is also permissible to take any of the alternative\endln
\lnie
returns after scblk length has been modified.\endln
\lnie
\endln
\lnie
(wa)                  ptr to fcblk or zero\endln
\lnie
(xr)                  pointer to buffer (scblk ptr)\endln
\lnie
jsr  sysin            call to read record\endln
\lnie
ppm  loc              endfile or no i/p file after sysxi\endln
\lnie
ppm  loc              return here if i/o error\endln
\lnie
ppm  loc              return here if record format error\endln
\lnie
(wa,wb,wc)            destroyed\endln
\vfill\break

\lnie
\endln
\lnie
sysio -- input/output file association\endln
\lnie
\endln
\inst{sysio}{exp}{}{define external entry point}
\lnie
\endln
\lnie
see also sysfc.\endln
\lnie
sysio is called in response to a snobol4 input or output\endln
\lnie
function call except when file arg1 and file arg2\endln
\lnie
are both null.\endln
\lnie
its call always follows immediately after a call\endln
\lnie
of sysfc. if sysfc requested allocation\endln
\lnie
of an fcblk, its address will be in wa.\endln
\lnie
for input files, non-zero values of $r$ should be\endln
\lnie
copied to wc for use in allocating input buffers. if $r$\endln
\lnie
is defaulted or not implemented, wc should be zeroised.\endln
\lnie
once a file has been opened, subsequent input(),output()\endln
\lnie
calls in which the second argument is identical with that\endln
\lnie
in a previous call, merely associate the additional\endln
\lnie
variable name (first argument) to the file and do not\endln
\lnie
result in re-opening the file.\endln
\lnie
in subsequent associated accesses to the file a pointer\endln
\lnie
to any fcblk allocated will be made available.\endln
\lnie
\endln
\lnie
(xl)                  file arg1 scblk ptr (2nd arg)\endln
\lnie
(xr)                  file arg2 scblk ptr (3rd arg)\endln
\lnie
(wa)                  fcblk ptr (0 if none)\endln
\lnie
(wb)                  0 for input, 3 for output\endln
\lnie
jsr  sysio            call to associate file\endln
\lnie
ppm  loc              return here if file does not exist\endln
\lnie
ppm  loc              return if input/output not allowed\endln
\lnie
(xl)                  fcblk pointer (0 if none)\endln
\lnie
(wc)                  0 (for default) or max record lngth\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\lnie
the second error return is used if the file named exists\endln
\lnie
but input/output from the file is not allowed. for\endln
\lnie
example, the standard output file may be in this category\endln
\lnie
as regards input association.\endln
\vfill\break

\lnie
\endln
\lnie
sysld -- load external function\endln
\lnie
\endln
\inst{sysld}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysld is called in response to the use of the snobol4\endln
\lnie
load function. the named function is loaded (whatever\endln
\lnie
this means), and a pointer is returned. the pointer will\endln
\lnie
be used on subsequent calls to the function (see sysex).\endln
\lnie
\endln
\lnie
(xr)                  pointer to function name (scblk)\endln
\lnie
(xl)                  pointer to library name (scblk)\endln
\lnie
jsr  sysld            call to load function\endln
\lnie
ppm  loc              return here if func does not exist\endln
\lnie
ppm  loc              return here if i/o error\endln
\lnie
ppm  loc              return here if insufficient memory\endln
\lnie
(xr)                  pointer to loaded code\endln
\lnie
\endln
\lnie
the significance of the pointer returned is up to the\endln
\lnie
system interface routine. the only restriction is that\endln
\lnie
if the pointer is within dynamic storage, it must be\endln
\lnie
a proper block pointer.\endln
\vfill\break

\lnie
\endln
\lnie
sysmm -- get more memory\endln
\lnie
\endln
\inst{sysmm}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysmm is called in an attempt to allocate more dynamic\endln
\lnie
memory. this memory must be allocated contiguously with\endln
\lnie
the current dynamic data area.\endln
\lnie
\endln
\lnie
the amount allocated is up to the system to decide. any\endln
\lnie
value is acceptable including zero if allocation is\endln
\lnie
impossible.\endln
\lnie
\endln
\lnie
jsr  sysmm            call to get more memory\endln
\lnie
(xr)                  number of additional words obtained\endln
\vfill\break

\lnie
\endln
\lnie
sysmx -- supply mxlen\endln
\lnie
\endln
\inst{sysmx}{exp}{}{define external entry point}
\lnie
\endln
\lnie
because of the method of garbage collection, no spitbol\endln
\lnie
object is allowed to occupy more bytes of memory than\endln
\lnie
the integer giving the lowest address of dynamic\endln
\lnie
(garbage collectable) memory. mxlen is the name used to\endln
\lnie
refer to this maximum length of an object and for most\endln
\lnie
users of most implementations, provided dynamic memory\endln
\lnie
starts at an address of at least a few thousand words,\endln
\lnie
there is no problem.\endln
\lnie
if the default starting address is less than say 10000 or\endln
\lnie
20000, then a load time option should be provided where a\endln
\lnie
user can request that he be able to create larger\endln
\lnie
objects. this routine informs spitbol of this request if\endln
\lnie
any. the value returned is either an integer\endln
\lnie
representing the desired value of mxlen (and hence the\endln
\lnie
minimum dynamic store address which may result in\endln
\lnie
non-use of some store) or zero if a default is acceptable\endln
\lnie
in which mxlen is set to the lowest address allocated\endln
\lnie
to dynamic store before compilation starts.\endln
\lnie
if a non-zero value is returned, this is used for keyword\endln
\lnie
maxlngth. otherwise the initial low address of dynamic\endln
\lnie
memory is used for this keyword.\endln
\lnie
\endln
\lnie
jsr  sysmx            call to get mxlen\endln
\lnie
(wa)                  either mxlen or 0 for default\endln
\vfill\break

\lnie
\endln
\lnie
sysou -- output record\endln
\lnie
\endln
\inst{sysou}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysou is used to write a record to a file previously\endln
\lnie
associated with a sysio call.\endln
\lnie
\endln
\lnie
(wa)                  ptr to fcblk\endln
\ifmac{.csou}
\lnie
                      or 0 for terminal or 1 for output\endln
\asmac{fi}
\ifmac{.cnbf}
\lnie
(xr)                  record to be written (scblk)\endln
\asmac{else}
\lnie
(xr)                  record to write (bcblk or scblk)\endln
\asmac{fi}
\lnie
jsr  sysou            call to output record\endln
\lnie
ppm  loc              file full or no file after sysxi\endln
\lnie
ppm  loc              return here if i/o error\endln
\lnie
(wa,wb,wc)            destroyed\endln
\lnie
\endln
\lnie
note that it is the sysou call (not the sysio call) which\endln
\lnie
causes the file to be opened as required for the first\endln
\lnie
record output to the file.\endln
\vfill\break

\lnie
\endln
\lnie
syspi -- print on interactive channel\endln
\lnie
\endln
\inst{syspi}{exp}{}{define external entry point}
\lnie
\endln
\lnie
if spitbol is run from an online terminal, osint can\endln
\lnie
request that messages such as copies of compilation\endln
\lnie
errors be sent to the terminal (see syspp). if relevant\endln
\lnie
reply was made by syspp then syspi is called to send such\endln
\lnie
messages to the interactive channel.\endln
\lnie
syspi is also used for sending output to the terminal\endln
\lnie
through the special variable name, terminal.\endln
\lnie
\endln
\lnie
(xr)                  ptr to line buffer (scblk)\endln
\lnie
(wa)                  line length\endln
\lnie
jsr  syspi            call to print line\endln
\lnie
ppm  loc              failure return\endln
\lnie
(wa,wb)               destroyed\endln
\ifmac{.cpol}
\vfill\break

\lnie
\endln
\lnie
syspl -- provide interactive control of spitbol\endln
\lnie
\endln
\inst{syspl}{exp}{}{define external entry point}
\lnie
\endln
\lnie
provides means for interface to take special actions,\endln
\lnie
such as interrupting execution, breakpointing, stepping,\endln
\lnie
and expression evaluation.  these last three options are\endln
\lnie
not presently implemented by the code calling syspl.\endln
\lnie
\endln
\lnie
\endln
\lnie
(wa)                  opcode as follows-\endln
\lnie
                      =0 poll to allow osint to interrupt\endln
\lnie
                      =1 breakpoint hit\endln
\lnie
                      =2 completion of statement stepping\endln
\lnie
                      =3 expression evaluation result\endln
\lnie
(wb)                  statement number\endln
\lnie
r$fcb                 o or ptr to head of fcblk chain\endln
\lnie
jsr  syspl            call to syspl function\endln
\lnie
ppm  loc              user interruption\endln
\lnie
ppm  loc              step one statement\endln
\lnie
ppm  loc              evaluate expression\endln
\lnie
---                   resume execution\endln
\lnie
                      (wa) = new polling interval\endln
\lnie
\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
syspp -- obtain print parameters\endln
\lnie
\endln
\inst{syspp}{exp}{}{define external entry point}
\lnie
\endln
\lnie
syspp is called once during compilation to obtain\endln
\lnie
parameters required for correct printed output format\endln
\lnie
and to select other options. it may also be called again\endln
\lnie
after sysxi when a load module is resumed. in this\endln
\lnie
case the value returned in wa may be less than or equal\endln
\lnie
to that returned in initial call but may not be\endln
\lnie
greater.\endln
\lnie
the information returned is -\endln
\lnie
1.   line length in chars for standard print file\endln
\lnie
2.   no of lines/page. 0 is preferable for a non-paged\endln
\lnie
     device (e.g. online terminal) in which case listing\endln
\lnie
     page throws are suppressed and page headers\endln
\lnie
     resulting from -title,-stitl lines are kept short.\endln
\lnie
3.   an initial -nolist option to suppress listing unless\endln
\lnie
     the program contains an explicit -list.\endln
\lnie
4.   options to suppress listing of compilation and/or\endln
\lnie
     execution stats (useful for established programs) -\endln
\lnie
     combined with 3. gives possibility of listing\endln
\lnie
     file never being opened.\endln
\lnie
5.   option to have copies of errors sent to an\endln
\lnie
     interactive channel in addition to standard printer.\endln
\lnie
6.   option to keep page headers short (e.g. if listing\endln
\lnie
     to an online terminal).\endln
\lnie
7.   an option to choose extended or compact listing\endln
\lnie
     format. in the former a page eject and in the latter\endln
\lnie
     a few line feeds precede the printing of each\endln
\lnie
     of-- listing, compilation statistics, execution\endln
\lnie
     output and execution statistics.\endln
\lnie
8.   an option to suppress execution as though a\endln
\lnie
     -noexecute card were supplied.\endln
\lnie
9.   an option to request that name /terminal/  be pre-\endln
\lnie
     associated to an online terminal via syspi and sysri\endln
\lnie
10.  an intermediate (standard) listing option requiring\endln
\lnie
     that page ejects occur in source listings. redundant\endln
\lnie
     if extended option chosen but partially extends\endln
\lnie
     compact option.\endln
\lnie
11.  option to suppress sysid identification.\endln
\lnie
\endln
\lnie
jsr  syspp            call to get print parameters\endln
\lnie
(wa)                  print line length in chars\endln
\lnie
(wb)                  number of lines/page\endln
\lnie
(wc)                  bits value ...mlkjihgfedcba where\endln
\lnie
                      a = 1 to send error copy to int.ch.\endln
\lnie
                      b = 1 means std printer is int. ch.\endln
\lnie
                      c = 1 for -nolist option\endln
\lnie
                      d = 1 to suppress compiln. stats\endln
\lnie
\endln
\lnie
                      e = 1 to suppress execn. stats\endln
\lnie
                      f = 1/0 for extnded/compact listing\endln
\lnie
                      g = 1 for -noexecute\endln
\lnie
                      h = 1 pre-associate /terminal/\endln
\lnie
\endln
\lnie
                      i = 1 for standard listing option.\endln
\lnie
                      j = 1 suppresses listing header\endln
\lnie
                      k = 1 for -print\endln
\lnie
                      l = 1 for -noerrors\endln
\ifmac{.culc}
\lnie
\endln
\lnie
                      m = 1 for -case 1\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
syspr -- print line on standard output file\endln
\lnie
\endln
\inst{syspr}{exp}{}{define external entry point}
\lnie
\endln
\lnie
syspr is used to print a single line on the standard\endln
\lnie
output file.\endln
\lnie
\endln
\lnie
(xr)                  pointer to line buffer (scblk)\endln
\lnie
(wa)                  line length\endln
\lnie
jsr  syspr            call to print line\endln
\lnie
ppm  loc              too much o/p or no file after sysxi\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\lnie
the buffer pointed to is the length obtained from the\endln
\lnie
syspp call and is filled out with trailing blanks. the\endln
\lnie
value in wa is the actual line length which may be less\endln
\lnie
than the maximum line length possible. there is no space\endln
\lnie
control associated with the line, all lines are printed\endln
\lnie
single spaced. note that null lines (wa=0) are possible\endln
\lnie
in which case a blank line is to be printed.\endln
\lnie
\endln
\lnie
the error exit is used for systems which limit the amount\endln
\lnie
of printed output. if possible, printing should be\endln
\lnie
permitted after this condition has been signalled once to\endln
\lnie
allow for dump and other diagnostic information.\endln
\lnie
assuming this to be possible, spitbol may make more syspr\endln
\lnie
calls. if the error return occurs another time, execution\endln
\lnie
is terminated by a call of sysej with ending code 998.\endln
\vfill\break

\lnie
\endln
\lnie
sysrd -- read record from standard input file\endln
\lnie
\endln
\inst{sysrd}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysrd is used to read a record from the standard input\endln
\lnie
file. the buffer provided is an scblk for a string the\endln
\lnie
length of which in characters is given in wc, this\endln
\lnie
corresponding to the maximum length of string which\endln
\lnie
spitbol is prepared to receive. at compile time it\endln
\lnie
corresponds to xxx in the most recent -inxxx card\endln
\lnie
(default 72) and at execution time to the most recent\endln
\lnie
,r$r$ (record length) in the third arg of an input()\endln
\lnie
statement for the standard input file (default 80).\endln
\lnie
if fewer than (wc) characters are read, the length\endln
\lnie
field of the scblk must be adjusted before returning\endln
\lnie
unless the buffer is right padded with zeroes.\endln
\lnie
it is also permissible to take the alternative return\endln
\lnie
after such an adjustment has been made.\endln
\lnie
spitbol may continue to make calls after an endfile\endln
\lnie
return so this routine should be prepared to make\endln
\lnie
repeated endfile returns.\endln
\lnie
\endln
\lnie
(xr)                  pointer to buffer (scblk ptr)\endln
\lnie
(wc)                  length of buffer in characters\endln
\lnie
jsr  sysrd            call to read line\endln
\lnie
ppm  loc              endfile or no i/p file after sysxi\endln
\ifmac{.csfn}
\lnie
                      or input file name change.  if\endln
\lnie
                      the former, scblk length is zero.\endln
\lnie
                      if input file name change, length\endln
\lnie
                      is non-zero. caller should re-issue\endln
\lnie
                      sysrd to obtain input record.\endln
\asmac{fi}
\lnie
(wa,wb,wc)            destroyed\endln
\vfill\break

\lnie
\endln
\lnie
sysri -- read record from interactive channel\endln
\lnie
\endln
\inst{sysri}{exp}{}{define external entry point}
\lnie
\endln
\lnie
reads a record from online terminal for spitbol variable,\endln
\lnie
terminal. if online terminal is unavailable then code the\endln
\lnie
endfile return only.\endln
\lnie
the buffer provided is of length 258 characters. sysri\endln
\lnie
should replace the count in the second word of the scblk\endln
\lnie
by the actual character count unless buffer is right\endln
\lnie
padded with zeroes.\endln
\lnie
it is also permissible to take the alternative\endln
\lnie
return after adjusting the count.\endln
\lnie
the end of file return may be used if this makes\endln
\lnie
sense on the target machine (e.g. if there is an\endln
\lnie
eof character.)\endln
\lnie
\endln
\lnie
(xr)                  ptr to 258 char buffer (scblk ptr)\endln
\lnie
jsr  sysri            call to read line from terminal\endln
\lnie
ppm  loc              end of file return\endln
\lnie
(wa,wb,wc)            may be destroyed\endln
\vfill\break

\lnie
\endln
\lnie
sysrw -- rewind file\endln
\lnie
\endln
\inst{sysrw}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysrw is used to rewind a file i.e. reposition the file\endln
\lnie
at the start before the first record. the file should be\endln
\lnie
closed and the next read or write call will open the\endln
\lnie
file at the start.\endln
\lnie
\endln
\lnie
(wa)                  ptr to fcblk or zero\endln
\lnie
(xr)                  rewind arg (scblk ptr)\endln
\lnie
jsr  sysrw            call to rewind file\endln
\lnie
ppm  loc              return here if file does not exist\endln
\lnie
ppm  loc              return here if rewind not allowed\endln
\lnie
ppm  loc              return here if i/o error\endln
\vfill\break

\ifmac{.cust}
\lnie
\endln
\lnie
sysst -- set file pointer\endln
\lnie
\endln
\inst{sysst}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysst is called to change the position of a file\endln
\lnie
pointer. this is accomplished in a system dependent\endln
\lnie
manner, and thus the 2nd and 3rd arguments are passed\endln
\lnie
unconverted.\endln
\lnie
\endln
\lnie
(wa)                  fcblk pointer\endln
\lnie
(wb)                  2nd argument\endln
\lnie
(wc)                  3rd argument\endln
\lnie
jsr  sysst            call to set file pointer\endln
\lnie
ppm  loc              return here if invalid 2nd arg\endln
\lnie
ppm  loc              return here if invalid 3rd arg\endln
\lnie
ppm  loc              return here if file does not exist\endln
\lnie
ppm  loc              return here if set not allowed\endln
\lnie
ppm  loc              return here if i/o error\endln
\lnie
\endln
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
systm -- get execution time so far\endln
\lnie
\endln
\inst{systm}{exp}{}{define external entry point}
\lnie
\endln
\lnie
systm is used to obtain the amount of execution time\endln
\lnie
used so far since spitbol was given control. the units\endln
\lnie
are described as milliseconds in the spitbol output, but\endln
\lnie
the exact meaning is system dependent. where appropriate,\endln
\lnie
this value should relate to processor rather than clock\endln
\lnie
timing values.\endln
\lnie
if the symbol .ctmd is defined, the units are described\endln
\lnie
as deciseconds (0.1 second).\endln
\lnie
\endln
\lnie
jsr  systm            call to get timer value\endln
\lnie
(ia)                  time so far in milliseconds\endln
\lnie
                      (deciseconds if .ctmd defined)\endln
\vfill\break

\lnie
\endln
\lnie
systt -- trace toggle\endln
\lnie
\endln
\inst{systt}{exp}{}{define external entry point}
\lnie
\endln
\lnie
called by spitbol function trace() with no args to\endln
\lnie
toggle the system trace switch.  this permits tracing of\endln
\lnie
labels in spitbol code to be turned on or off.\endln
\lnie
\endln
\lnie
jsr  systt            call to toggle trace switch\endln
\vfill\break

\lnie
\endln
\lnie
sysul -- unload external function\endln
\lnie
\endln
\inst{sysul}{exp}{}{define external entry point}
\lnie
\endln
\lnie
sysul is used to unload a function previously\endln
\lnie
loaded with a call to sysld.\endln
\lnie
\endln
\lnie
(xr)                  ptr to control block (efblk)\endln
\lnie
jsr  sysul            call to unload function\endln
\lnie
\endln
\lnie
the function cannot be called following a sysul call\endln
\lnie
until another sysld call is made for the same function.\endln
\lnie
\endln
\lnie
the efblk contains the function code pointer and also a\endln
\lnie
pointer to the vrblk containing the function name (see\endln
\lnie
definitions and data structures section).\endln
\ifmac{.cnex}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
sysxi -- exit to produce load module\endln
\lnie
\endln
\inst{sysxi}{exp}{}{define external entry point}
\lnie
\endln
\lnie
when sysxi is called, xl contains either a string pointer\endln
\lnie
or zero. in the former case, the string gives the\endln
\lnie
character name of a program. the intention is that\endln
\lnie
spitbol execution should be terminated forthwith and\endln
\lnie
the named program loaded and executed. this type of chain\endln
\lnie
execution is very system dependent and implementors may\endln
\lnie
choose to omit it or find it impossible to provide.\endln
\lnie
if (xl) is zero,ia contains one of the following integers\endln
\lnie
\endln
\lnie
-1, -2, -3, -4\endln
\lnie
     create if possible a load module containing only the\endln
\lnie
     impure area of memory which needs to be loaded with\endln
\lnie
     a compatible pure segment for subsequent executions.\endln
\lnie
     version numbers to check compatibility should be\endln
\lnie
     kept in both segments and checked on loading.\endln
\lnie
     to assist with this check, (xr) on entry is a\endln
\lnie
     pointer to an scblk containing the spitbol major\endln
\lnie
     version number v.v (see sysid).  the file thus\endln
\lnie
     created is called a save file.\endln
\lnie
\endln
\lnie
0    if possible, return control to job control\endln
\lnie
     command level. the effect if available will be\endln
\lnie
     system dependent.\endln
\lnie
\endln
\lnie
+1, +2, +3, +4\endln
\lnie
     create if possible a load module from all of\endln
\lnie
     memory. it should be possible to load and execute\endln
\lnie
     this module directly.\endln
\lnie
\endln
\lnie
in the case of saved load modules, the status of open\endln
\lnie
files is not preserved and implementors may choose to\endln
\lnie
offer means of attaching files before execution of load\endln
\lnie
modules starts or leave it to the user to include\endln
\lnie
suitable input(), output() calls in his program.\endln
\lnie
sysxi should make a note that no i/o channels,\endln
\lnie
including standard files, have files attached so that\endln
\lnie
calls of sysin, sysou, syspr, sysrd should fail unless\endln
\lnie
new associations are made for the load module.\endln
\lnie
at least in the case of the standard output file, it is\endln
\lnie
recommended that either the user be required to attach\endln
\lnie
a file or that a default file is attached, since the\endln
\lnie
problem of error messages generated by the load module\endln
\lnie
is otherwise severe. as a last resort, if spitbol\endln
\lnie
attempts to write to the standard output file and gets a\endln
\lnie
reply indicating that such ouput is unacceptable it stops\endln
\lnie
by using an entry to sysej with ending code 998.\endln
\lnie
as described below, passing of some arguments makes it\endln
\lnie
clear that load module will use a standard output file.\endln
\lnie
\endln
\lnie
if use is made of fcblks for i/o association, spitbol\endln
\lnie
builds a chain so that those in use may be found in sysxi\endln
\lnie
and sysej. the nodes are 4 words long. third word\endln
\lnie
contains link to next node or 0, fourth word contains\endln
\lnie
fcblk pointer.\endln
\vfill\break

\lnie
\endln
\lnie
sysxi (continued)\endln
\lnie
\endln
\lnie
(xl)                  zero or scblk ptr to first argument\endln
\lnie
(xr)                  ptr to v.v scblk\endln
\lnie
(ia)                  signed integer argument\endln
\lnie
(wa)                  scblk ptr to second argument\endln
\lnie
(wb)                  0 or ptr to head of fcblk chain\endln
\lnie
jsr  sysxi            call to exit\endln
\lnie
ppm  loc              requested action not possible\endln
\lnie
ppm  loc              action caused irrecoverable error\endln
\lnie
(wb,wc,ia,xr,xl,cp)   should be preserved over call\endln
\lnie
(wa)                  0 in all cases except sucessful\endln
\lnie
                      performance of exit(4) or exit(-4),\endln
\lnie
                      in which case 1 should be returned.\endln
\lnie
\endln
\lnie
loading and running the load module or returning from\endln
\lnie
jcl command level causes execution to resume at the point\endln
\lnie
after the error returns which follow the call of sysxi.\endln
\lnie
the value passed as exit argument is used to indicate\endln
\lnie
options required on resumption of load module.\endln
\lnie
+1 or -1 require that on resumption, sysid and syspp be\endln
\lnie
called and a heading printed on the standard output file.\endln
\lnie
+2 or -2 indicate that syspp will be called but not sysid\endln
\lnie
and no heading will be put on standard output file.\endln
\lnie
above options have the obvious implication that a\endln
\lnie
standard o/p file must be provided for the load module.\endln
\lnie
+3, +4, -3 or -4 indicate calls of neither sysid nor\endln
\lnie
syspp and no heading will be placed on standard output\endln
\lnie
file.\endln
\lnie
+4 or -4 indicate that execution is to continue after\endln
\lnie
creation of the save file or load module, although all\endln
\lnie
files will be closed by the sysxi action.  this permits\endln
\lnie
the user to checkpoint long-running programs while\endln
\lnie
continuing execution.\endln
\lnie
\endln
\lnie
no return from sysxi is possible if another program\endln
\lnie
is loaded and entered.\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
introduce the internal procedures.\endln
\lnie
\endln
\inst{acess}{inp}{}{}
\inst{acomp}{inp}{}{}
\inst{alloc}{inp}{}{}
\ifmac{.cnbf}
\asmac{else}
\inst{alobf}{inp}{}{}
\asmac{fi}
\inst{alocs}{inp}{}{}
\inst{alost}{inp}{}{}
\ifmac{.cnbf}
\asmac{else}
\inst{apndb}{inp}{}{}
\asmac{fi}
\ifmac{.cnra}
\inst{arith}{inp}{}{}
\asmac{else}
\inst{arith}{inp}{}{}
\asmac{fi}
\inst{asign}{inp}{}{}
\inst{asinp}{inp}{}{}
\inst{blkln}{inp}{}{}
\inst{cdgcg}{inp}{}{}
\inst{cdgex}{inp}{}{}
\inst{cdgnm}{inp}{}{}
\inst{cdgvl}{inp}{}{}
\inst{cdwrd}{inp}{}{}
\inst{cmgen}{inp}{}{}
\inst{cmpil}{inp}{}{}
\inst{cncrd}{inp}{}{}
\inst{copyb}{inp}{}{}
\inst{dffnc}{inp}{}{}
\inst{dtach}{inp}{}{}
\inst{dtype}{inp}{}{}
\inst{dumpr}{inp}{}{}
\ifmac{.ceng}
\inst{enevs}{inp}{}{}
\inst{engts}{inp}{}{}
\asmac{fi}
\inst{ermsg}{inp}{}{}
\inst{ertex}{inp}{}{}
\inst{evali}{inp}{}{}
\inst{evalp}{inp}{}{}
\inst{evals}{inp}{}{}
\inst{evalx}{inp}{}{}
\inst{exbld}{inp}{}{}
\inst{expan}{inp}{}{}
\inst{expap}{inp}{}{}
\inst{expdm}{inp}{}{}
\inst{expop}{inp}{}{}
\ifmac{.csfn}
\inst{filnm}{inp}{}{}
\asmac{fi}
\ifmac{.culc}
\inst{flstg}{inp}{}{}
\asmac{fi}
\inst{gbcol}{inp}{}{}
\inst{gbcpf}{inp}{}{}
\inst{gtarr}{inp}{}{}
\vfill\break

\inst{gtcod}{inp}{}{}
\inst{gtexp}{inp}{}{}
\inst{gtint}{inp}{}{}
\inst{gtnum}{inp}{}{}
\inst{gtnvr}{inp}{}{}
\inst{gtpat}{inp}{}{}
\ifmac{.cnra}
\asmac{else}
\inst{gtrea}{inp}{}{}
\asmac{fi}
\inst{gtsmi}{inp}{}{}
\ifmac{.cnbf}
\asmac{else}
\inst{gtstb}{inp}{}{}
\asmac{fi}
\inst{gtstg}{inp}{}{}
\inst{gtvar}{inp}{}{}
\inst{hashs}{inp}{}{}
\inst{icbld}{inp}{}{}
\inst{ident}{inp}{}{}
\inst{inout}{inp}{}{}
\ifmac{.cnbf}
\asmac{else}
\inst{insbf}{inp}{}{}
\asmac{fi}
\inst{insta}{inp}{}{}
\inst{iofcb}{inp}{}{}
\inst{ioppf}{inp}{}{}
\inst{ioput}{inp}{}{}
\inst{ktrex}{inp}{}{}
\inst{kwnam}{inp}{}{}
\inst{lcomp}{inp}{}{}
\inst{listr}{inp}{}{}
\inst{listt}{inp}{}{}
\ifmac{.csfn}
\inst{newfn}{inp}{}{}
\asmac{fi}
\inst{nexts}{inp}{}{}
\inst{patin}{inp}{}{}
\inst{patst}{inp}{}{}
\inst{pbild}{inp}{}{}
\inst{pconc}{inp}{}{}
\inst{pcopy}{inp}{}{}
\ifmac{.cnpf}
\asmac{else}
\inst{prflr}{inp}{}{}
\inst{prflu}{inp}{}{}
\asmac{fi}
\inst{prpar}{inp}{}{}
\inst{prtch}{inp}{}{}
\inst{prtic}{inp}{}{}
\inst{prtis}{inp}{}{}
\inst{prtin}{inp}{}{}
\inst{prtmi}{inp}{}{}
\inst{prtmm}{inp}{}{}
\inst{prtmx}{inp}{}{}
\inst{prtnl}{inp}{}{}
\inst{prtnm}{inp}{}{}
\inst{prtnv}{inp}{}{}
\inst{prtpg}{inp}{}{}
\inst{prtps}{inp}{}{}
\inst{prtsn}{inp}{}{}
\inst{prtst}{inp}{}{}
\vfill\break

\inst{prttr}{inp}{}{}
\inst{prtvl}{inp}{}{}
\inst{prtvn}{inp}{}{}
\ifmac{.cnra}
\asmac{else}
\inst{rcbld}{inp}{}{}
\asmac{fi}
\inst{readr}{inp}{}{}
\ifmac{.crel}
\inst{relaj}{inp}{}{}
\inst{relcr}{inp}{}{}
\inst{reldn}{inp}{}{}
\inst{reloc}{inp}{}{}
\inst{relst}{inp}{}{}
\inst{relws}{inp}{}{}
\asmac{fi}
\inst{rstrt}{inp}{}{}
\ifmac{.c370}
\inst{sbool}{inp}{}{}
\asmac{fi}
\inst{sbstr}{inp}{}{}
\inst{scane}{inp}{}{}
\inst{scngf}{inp}{}{}
\inst{setvr}{inp}{}{}
\ifmac{.cnsr}
\asmac{else}
\inst{sorta}{inp}{}{}
\inst{sortc}{inp}{}{}
\inst{sortf}{inp}{}{}
\inst{sorth}{inp}{}{}
\asmac{fi}
\inst{start}{inp}{}{}
\inst{stgcc}{inp}{}{}
\inst{tfind}{inp}{}{}
\inst{tmake}{inp}{}{}
\inst{trace}{inp}{}{}
\inst{trbld}{inp}{}{}
\inst{trimr}{inp}{}{}
\inst{trxeq}{inp}{}{}
\inst{vmake}{inp}{}{}
\inst{xscan}{inp}{}{}
\inst{xscni}{inp}{}{}
\lnie
\endln
\lnie
introduce the internal routines\endln
\lnie
\endln
\inst{arref}{inr}{}{}
\inst{cfunc}{inr}{}{}
\inst{exfal}{inr}{}{}
\inst{exint}{inr}{}{}
\inst{exits}{inr}{}{}
\inst{exixr}{inr}{}{}
\inst{exnam}{inr}{}{}
\inst{exnul}{inr}{}{}
\ifmac{.cnra}
\asmac{else}
\inst{exrea}{inr}{}{}
\asmac{fi}
\inst{exsid}{inr}{}{}
\inst{exvnm}{inr}{}{}
\inst{failp}{inr}{}{}
\inst{flpop}{inr}{}{}
\inst{indir}{inr}{}{}
\inst{match}{inr}{}{}
\inst{retrn}{inr}{}{}
\inst{stcov}{inr}{}{}
\inst{stmgo}{inr}{}{}
\inst{stopr}{inr}{}{}
\inst{succp}{inr}{}{}
\inst{sysab}{inr}{}{}
\inst{systu}{inr}{}{}
\vfill\break
{\bf spitbol--\rm definitions and data structures}
\vskip1em
\lnie
this section contains all symbol definitions and also\endln
\lnie
pictures of all data structures used in the system.\endln
\lnie
\endln
\inst{}{sec}{}{start of definitions section}
\lnie
\endln
\lnie
definitions of machine parameters\endln
\lnie
\endln
\lnie
the minimal translator should supply appropriate values\endln
\lnie
for the particular target machine for all the\endln
\lnie
equ  *\endln
\lnie
definitions given at the start of this section.\endln
\lnie
note that even if conditional assembly is used to omit\endln
\lnie
some feature (e.g. real arithmetic) a full set of cfp$-\endln
\lnie
values must be supplied. use dummy values if genuine\endln
\lnie
ones are not needed.\endln
\lnie
\endln
\inst{cfp$a}{equ}{*}{number of characters in alphabet}
\lnie
\endln
\inst{cfp$b}{equ}{*}{bytes/word addressing factor}
\lnie
\endln
\inst{cfp$c}{equ}{*}{number of characters per word}
\lnie
\endln
\inst{cfp$f}{equ}{*}{offset in bytes to chars in}
\lnie
                      scblk. see scblk format.\endln
\lnie
\endln
\inst{cfp$i}{equ}{*}{number of words in integer constant}
\lnie
\endln
\inst{cfp$m}{equ}{*}{max positive integer in one word}
\lnie
\endln
\inst{cfp$n}{equ}{*}{number of bits in one word}
\lnie
\endln
\lnie
the following definitions require the supply of either\endln
\lnie
a single parameter if real arithmetic is omitted or\endln
\lnie
three parameters if real arithmetic is included.\endln
\lnie
\endln
\ifmac{.cnra}
\inst{nstmx}{equ}{*}{no. of decimal digits in cfp$m}
\asmac{else}
\lnie
\endln
\inst{cfp$r}{equ}{*}{number of words in real constant}
\lnie
\endln
\inst{cfp$s}{equ}{*}{number of sig digs for real output}
\lnie
\endln
\inst{cfp$x}{equ}{*}{max digits in real exponent}
\ifmac{.cncr}
\inst{nstmx}{equ}{*}{no. of decimal digits in cfp$m}
\lnie
\endln
\inst{mxdgs}{equ}{cfp$s+cfp$x}{max digits in real number}
\lnie
\endln
\lnie
max space for real (for +0.e+) needs five more places\endln
\lnie
\endln
\inst{nstmr}{equ}{mxdgs+5}{max space for real}
\asmac{else}
\lnie
\endln
\inst{mxdgs}{equ}{cfp$s+cfp$x}{max digits in real number}
\lnie
\endln
\lnie
\endln
\lnie
max space for real (for +0.e+) needs five more places\endln
\lnie
\endln
\inst{nstmx}{equ}{mxdgs+5}{max space for real}
\asmac{fi}
\asmac{fi}
\ifmac{.cucf}
\lnie
\endln
\lnie
the following definition for cfp$u supplies a realistic\endln
\lnie
upper bound on the size of the alphabet.  cfp$u is used\endln
\lnie
to save space in the scane bsw-iff-esw table and to ease\endln
\lnie
translation storage requirements.\endln
\lnie
\endln
\inst{cfp$u}{equ}{*}{realistic upper bound on alphabet}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
environment parameters\endln
\lnie
\endln
\lnie
the spitbol program is essentially independent of\endln
\lnie
the definitions of these parameters. however, the\endln
\lnie
efficiency of the system may be affected. consequently,\endln
\lnie
these parameters may require tuning for a given version\endln
\lnie
the values given in comments have been successfully used.\endln
\lnie
\endln
\lnie
e$srs is the number of words to reserve at the end of\endln
\lnie
storage for end of run processing. it should be\endln
\lnie
set as small as possible without causing memory overflow\endln
\lnie
in critical situations (e.g. memory overflow termination)\endln
\lnie
and should thus reserve sufficient space at least for\endln
\lnie
an scblk containing say 30 characters.\endln
\lnie
\endln
\inst{e$srs}{equ}{*}{30 words}
\lnie
\endln
\lnie
e$sts is the number of words grabbed in a chunk when\endln
\lnie
storage is allocated in the static region. the minimum\endln
\lnie
permitted value is 256/cfp$b. larger values will lead\endln
\lnie
to increased efficiency at the cost of wasting memory.\endln
\lnie
\endln
\inst{e$sts}{equ}{*}{500 words}
\lnie
\endln
\lnie
e$cbs is the size of code block allocated initially and\endln
\lnie
the expansion increment if overflow occurs. if this value\endln
\lnie
is too small or too large, excessive garbage collections\endln
\lnie
will occur during compilation and memory may be lost\endln
\lnie
in the case of a too large value.\endln
\lnie
\endln
\inst{e$cbs}{equ}{*}{500 words}
\lnie
\endln
\lnie
e$hnb is the number of bucket headers in the variable\endln
\lnie
hash table. it should always be odd. larger values will\endln
\lnie
speed up compilation and indirect references at the\endln
\lnie
expense of additional storage for the hash table itself.\endln
\lnie
\endln
\inst{e$hnb}{equ}{*}{127 bucket headers}
\lnie
\endln
\lnie
e$hnw is the maximum number of words of a string\endln
\lnie
name which participate in the string hash algorithm.\endln
\lnie
larger values give a better hash at the expense of taking\endln
\lnie
longer to compute the hash. there is some optimal value.\endln
\lnie
\endln
\inst{e$hnw}{equ}{*}{6 words}
\lnie
\endln
\lnie
e$fsp.  if the amount of free space left after a garbage\endln
\lnie
collection is small compared to the total amount of space\endln
\lnie
in use garbage collector thrashing is likely to occur as\endln
\lnie
this space is used up.  e$fsp is a measure of the\endln
\lnie
minimum percentage of dynamic memory left as free space\endln
\lnie
before the system routine sysmm is called to try to\endln
\lnie
obtain more memory.\endln
\lnie
\endln
\inst{e$fsp}{equ}{*}{15 percent}
\ifmac{.csed}
\lnie
\endln
\lnie
e$sed.  if the amount of free space left in the sediment\endln
\lnie
after a garbage collection is a significant fraction of\endln
\lnie
the new sediment size, the sediment is marked for\endln
\lnie
collection on the next call to the garbage collector.\endln
\lnie
\endln
\inst{e$sed}{equ}{*}{25 percent}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
definitions of codes for letters\endln
\lnie
\endln
\inst{ch$la}{equ}{*}{letter a}
\inst{ch$lb}{equ}{*}{letter b}
\inst{ch$lc}{equ}{*}{letter c}
\inst{ch$ld}{equ}{*}{letter d}
\inst{ch$le}{equ}{*}{letter e}
\inst{ch$lf}{equ}{*}{letter f}
\inst{ch$lg}{equ}{*}{letter g}
\inst{ch$lh}{equ}{*}{letter h}
\inst{ch$li}{equ}{*}{letter i}
\inst{ch$lj}{equ}{*}{letter j}
\inst{ch$lk}{equ}{*}{letter k}
\inst{ch$ll}{equ}{*}{letter l}
\inst{ch$lm}{equ}{*}{letter m}
\inst{ch$ln}{equ}{*}{letter n}
\inst{ch$lo}{equ}{*}{letter o}
\inst{ch$lp}{equ}{*}{letter p}
\inst{ch$lq}{equ}{*}{letter q}
\inst{ch$lr}{equ}{*}{letter r}
\inst{ch$ls}{equ}{*}{letter s}
\inst{ch$lt}{equ}{*}{letter t}
\inst{ch$lu}{equ}{*}{letter u}
\inst{ch$lv}{equ}{*}{letter v}
\inst{ch$lw}{equ}{*}{letter w}
\inst{ch$lx}{equ}{*}{letter x}
\inst{ch$ly}{equ}{*}{letter y}
\inst{ch$l$}{equ}{*}{letter z}
\lnie
\endln
\lnie
definitions of codes for digits\endln
\lnie
\endln
\inst{ch$d0}{equ}{*}{digit 0}
\inst{ch$d1}{equ}{*}{digit 1}
\inst{ch$d2}{equ}{*}{digit 2}
\inst{ch$d3}{equ}{*}{digit 3}
\inst{ch$d4}{equ}{*}{digit 4}
\inst{ch$d5}{equ}{*}{digit 5}
\inst{ch$d6}{equ}{*}{digit 6}
\inst{ch$d7}{equ}{*}{digit 7}
\inst{ch$d8}{equ}{*}{digit 8}
\inst{ch$d9}{equ}{*}{digit 9}
\vfill\break

\lnie
\endln
\lnie
definitions of codes for special characters\endln
\lnie
\endln
\lnie
the names of these characters are related to their\endln
\lnie
original representation in the ebcdic set corresponding\endln
\lnie
to the description in standard snobol4 manuals and texts.\endln
\lnie
\endln
\inst{ch$am}{equ}{*}{keyword operator (ampersand)}
\inst{ch$as}{equ}{*}{multiplication symbol (asterisk)}
\inst{ch$at}{equ}{*}{cursor position operator (at)}
\inst{ch$bb}{equ}{*}{left array bracket (less than)}
\inst{ch$bl}{equ}{*}{blank}
\inst{ch$br}{equ}{*}{alternation operator (vertical bar)}
\inst{ch$cl}{equ}{*}{goto symbol (colon)}
\inst{ch$cm}{equ}{*}{comma}
\inst{ch$dl}{equ}{*}{indirection operator (dollar)}
\inst{ch$dt}{equ}{*}{name operator (dot)}
\inst{ch$dq}{equ}{*}{double quote}
\inst{ch$eq}{equ}{*}{equal sign}
\inst{ch$ex}{equ}{*}{exponentiation operator (exclm)}
\inst{ch$mn}{equ}{*}{minus sign / hyphen}
\inst{ch$nm}{equ}{*}{number sign}
\inst{ch$nt}{equ}{*}{negation operator (not)}
\inst{ch$pc}{equ}{*}{percent}
\inst{ch$pl}{equ}{*}{plus sign}
\inst{ch$pp}{equ}{*}{left parenthesis}
\inst{ch$rb}{equ}{*}{right array bracket (grtr than)}
\inst{ch$rp}{equ}{*}{right parenthesis}
\inst{ch$qu}{equ}{*}{interrogation operator (question)}
\inst{ch$sl}{equ}{*}{slash}
\inst{ch$sm}{equ}{*}{semicolon}
\inst{ch$sq}{equ}{*}{single quote}
\inst{ch$un}{equ}{*}{special identifier char (underline)}
\inst{ch$ob}{equ}{*}{opening bracket}
\inst{ch$cb}{equ}{*}{closing bracket}
\vfill\break

\lnie
\endln
\lnie
remaining chars are optional additions to the standards.\endln
\ifmac{.caht}
\lnie
\endln
\lnie
tab characters - syntactically equivalent to blank\endln
\lnie
\endln
\inst{ch$ht}{equ}{*}{horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{ch$vt}{equ}{*}{vertical tab}
\asmac{fi}
\ifmac{.caex}
\lnie
\endln
\lnie
up arrow same as exclamation mark for exponentiation\endln
\lnie
\endln
\inst{ch$ey}{equ}{*}{up arrow}
\asmac{fi}
\ifmac{.casl}
\lnie
\endln
\lnie
lower case or shifted case alphabetic chars\endln
\lnie
\endln
\inst{ch$$a}{equ}{*}{shifted a}
\inst{ch$$b}{equ}{*}{shifted b}
\inst{ch$$c}{equ}{*}{shifted c}
\inst{ch$$d}{equ}{*}{shifted d}
\inst{ch$$e}{equ}{*}{shifted e}
\inst{ch$$f}{equ}{*}{shifted f}
\inst{ch$$g}{equ}{*}{shifted g}
\inst{ch$$h}{equ}{*}{shifted h}
\inst{ch$$i}{equ}{*}{shifted i}
\inst{ch$$j}{equ}{*}{shifted j}
\inst{ch$$k}{equ}{*}{shifted k}
\inst{ch$$l}{equ}{*}{shifted l}
\inst{ch$$m}{equ}{*}{shifted m}
\inst{ch$$n}{equ}{*}{shifted n}
\inst{ch$$o}{equ}{*}{shifted o}
\inst{ch$$p}{equ}{*}{shifted p}
\inst{ch$$q}{equ}{*}{shifted q}
\inst{ch$$r}{equ}{*}{shifted r}
\inst{ch$$s}{equ}{*}{shifted s}
\inst{ch$$t}{equ}{*}{shifted t}
\inst{ch$$u}{equ}{*}{shifted u}
\inst{ch$$v}{equ}{*}{shifted v}
\inst{ch$$w}{equ}{*}{shifted w}
\inst{ch$$x}{equ}{*}{shifted x}
\inst{ch$$y}{equ}{*}{shifted y}
\inst{ch$$$}{equ}{*}{shifted z}
\asmac{fi}
\lnie
if a delimiter other than ch$cm must be used in\endln
\lnie
the third argument of input(),output() then .ciod should\endln
\lnie
be defined and a parameter supplied for iodel.\endln
\lnie
\endln
\ifmac{.ciod}
\inst{iodel}{equ}{*}{}
\asmac{else}
\inst{iodel}{equ}{*}{}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
data block formats and definitions\endln
\lnie
\endln
\lnie
the following sections describe the detailed format of\endln
\lnie
all possible data blocks in static and dynamic memory.\endln
\lnie
\endln
\lnie
every block has a name of the form xxblk where xx is a\endln
\lnie
unique two character identifier. the first word of every\endln
\lnie
block must contain a pointer to a program location in the\endln
\lnie
interpretor which is immediately preceded by an address\endln
\lnie
constant containing the value bl$xx where xx is the block\endln
\lnie
identifier. this provides a uniform mechanism for\endln
\lnie
distinguishing between the various block types.\endln
\lnie
\endln
\lnie
in some cases, the contents of the first word is constant\endln
\lnie
for a given block type and merely serves as a pointer\endln
\lnie
to the identifying address constant. however, in other\endln
\lnie
cases there are several possibilities for the first\endln
\lnie
word in which case each of the several program entry\endln
\lnie
points must be preceded by the appropriate constant.\endln
\lnie
\endln
\lnie
in each block, some of the fields are relocatable. this\endln
\lnie
means that they may contain a pointer to another block\endln
\lnie
in the dynamic area. (to be more precise, if they contain\endln
\lnie
a pointer within the dynamic area, then it is a pointer\endln
\lnie
to a block). such fields must be modified by the garbage\endln
\lnie
collector (procedure gbcol) whenever blocks are compacted\endln
\lnie
in the dynamic region. the garbage collector (actually\endln
\lnie
procedure gbcpf) requires that all such relocatable\endln
\lnie
fields in a block must be contiguous.\endln
\vfill\break

\lnie
\endln
\lnie
the description format uses the following scheme.\endln
\lnie
\endln
\lnie
1)   block title and two character identifier\endln
\lnie
\endln
\lnie
2)   description of basic use of block and indication\endln
\lnie
     of circumstances under which it is constructed.\endln
\lnie
\endln
\lnie
3)   picture of the block format. in these pictures low\endln
\lnie
     memory addresses are at the top of the page. fixed\endln
\lnie
     length fields are surrounded by i (letter i). fields\endln
\lnie
     which are fixed length but whose length is dependent\endln
\lnie
     on a configuration parameter are surrounded by *\endln
\lnie
     (asterisk). variable length fields are surrounded\endln
\lnie
     by / (slash).\endln
\lnie
\endln
\lnie
4)   definition of symbolic offsets to fields in\endln
\lnie
     block and of the size of the block if fixed length\endln
\lnie
     or of the size of the fixed length fields if the\endln
\lnie
     block is variable length.\endln
\lnie
     note that some routines such as gbcpf assume\endln
\lnie
     certain offsets are equal. the definitions\endln
\lnie
     given here enforce this.  make changes to\endln
\lnie
     them only with due care.\endln
\lnie
\endln
\lnie
definitions of common offsets\endln
\lnie
\endln
\inst{offs1}{equ}{*}{}
\inst{offs2}{equ}{*}{}
\inst{offs3}{equ}{*}{}
\lnie
\endln
\lnie
5)   detailed comments on the significance and formats\endln
\lnie
     of the various fields.\endln
\lnie
\endln
\lnie
the order is alphabetical by identification code.\endln
\vfill\break

\lnie
\endln
\lnie
definitions of block codes\endln
\lnie
\endln
\lnie
this table provides a unique identification code for\endln
\lnie
each separate block type. the first word of a block in\endln
\lnie
the dynamic area always contains the address of a program\endln
\lnie
entry point. the block code is used as the entry point id\endln
\lnie
the order of these codes dictates the order of the table\endln
\lnie
used by the datatype function (scnmt in the constant sec)\endln
\lnie
\endln
\lnie
block codes for accessible datatypes\endln
\lnie
\endln
\lnie
note that real and buffer types are always included, even\endln
\lnie
if they are conditionally excluded elsewhere.  this main-\endln
\lnie
tains block type codes across all versions of spitbol,\endln
\lnie
providing consistancy for external functions.  but note\endln
\lnie
that the bcblk is out of alphabetic order, placed at the\endln
\lnie
end of the list so as not to change the block type\endln
\lnie
ordering in use in existing external functions.\endln
\lnie
\endln
\inst{bl$ar}{equ}{0}{arblk     array}
\inst{bl$cd}{equ}{bl$ar+1}{cdblk     code}
\inst{bl$ex}{equ}{bl$cd+1}{exblk     expression}
\inst{bl$ic}{equ}{bl$ex+1}{icblk     integer}
\inst{bl$nm}{equ}{bl$ic+1}{nmblk     name}
\inst{bl$p0}{equ}{bl$nm+1}{p0blk     pattern}
\inst{bl$p1}{equ}{bl$p0+1}{p1blk     pattern}
\inst{bl$p2}{equ}{bl$p1+1}{p2blk     pattern}
\inst{bl$rc}{equ}{bl$p2+1}{rcblk     real}
\inst{bl$sc}{equ}{bl$rc+1}{scblk     string}
\inst{bl$se}{equ}{bl$sc+1}{seblk     expression}
\inst{bl$tb}{equ}{bl$se+1}{tbblk     table}
\inst{bl$vc}{equ}{bl$tb+1}{vcblk     array}
\inst{bl$xn}{equ}{bl$vc+1}{xnblk     external}
\inst{bl$xr}{equ}{bl$xn+1}{xrblk     external}
\inst{bl$bc}{equ}{bl$xr+1}{bcblk     buffer}
\inst{bl$pd}{equ}{bl$bc+1}{pdblk     program defined datatype}
\lnie
\endln
\inst{bl$$d}{equ}{bl$pd+1}{number of block codes for data}
\lnie
\endln
\lnie
other block codes\endln
\lnie
\endln
\inst{bl$tr}{equ}{bl$pd+1}{trblk}
\inst{bl$bf}{equ}{bl$tr+1}{bfblk}
\inst{bl$cc}{equ}{bl$bf+1}{ccblk}
\inst{bl$cm}{equ}{bl$cc+1}{cmblk}
\inst{bl$ct}{equ}{bl$cm+1}{ctblk}
\inst{bl$df}{equ}{bl$ct+1}{dfblk}
\inst{bl$ef}{equ}{bl$df+1}{efblk}
\inst{bl$ev}{equ}{bl$ef+1}{evblk}
\inst{bl$ff}{equ}{bl$ev+1}{ffblk}
\inst{bl$kv}{equ}{bl$ff+1}{kvblk}
\inst{bl$pf}{equ}{bl$kv+1}{pfblk}
\inst{bl$te}{equ}{bl$pf+1}{teblk}
\lnie
\endln
\inst{bl$$i}{equ}{0}{default identification code}
\inst{bl$$t}{equ}{bl$tr+1}{code for data or trace block}
\inst{bl$$$}{equ}{bl$te+1}{number of block codes}
\vfill\break

\lnie
\endln
\lnie
field references\endln
\lnie
\endln
\lnie
references to the fields of data blocks are symbolic\endln
\lnie
(i.e. use the symbolic offsets) with the following\endln
\lnie
exceptions.\endln
\lnie
\endln
\lnie
1)   references to the first word are usually not\endln
\lnie
     symbolic since they use the (x) operand format.\endln
\lnie
\endln
\lnie
2)   the code which constructs a block is often not\endln
\lnie
     symbolic and should be changed if the corresponding\endln
\lnie
     block format is modified.\endln
\lnie
\endln
\lnie
3)   the plc and psc instructions imply an offset\endln
\lnie
     corresponding to the definition of cfp$f.\endln
\lnie
\endln
\lnie
4)   there are non-symbolic references (easily changed)\endln
\lnie
     in the garbage collector (procedures gbcpf, blkln).\endln
\lnie
\endln
\lnie
5)   the fields idval, fargs appear in several blocks\endln
\lnie
     and any changes must be made in parallel to all\endln
\lnie
     blocks containing the fields. the actual references\endln
\lnie
     to these fields are symbolic with the above\endln
\lnie
     listed exceptions.\endln
\lnie
\endln
\lnie
6)   several spots in the code assume that the\endln
\lnie
     definitions of the fields vrval, teval, trnxt are\endln
\lnie
     the same (these are sections of code which search\endln
\lnie
     out along a trblk chain from a variable).\endln
\lnie
\endln
\lnie
7)   references to the fields of an array block in the\endln
\lnie
     array reference routine arref are non-symbolic.\endln
\lnie
\endln
\lnie
apart from the exceptions listed, references are symbolic\endln
\lnie
as far as possible and modifying the order or number\endln
\lnie
of fields will not require changes.\endln
\vfill\break

\lnie
\endln
\lnie
common fields for function blocks\endln
\lnie
\endln
\lnie
blocks which represent callable functions have two\endln
\lnie
common fields at the start of the block as follows.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fargs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /       rest of function block       /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{fcode}{equ}{0}{pointer to code for function}
\inst{fargs}{equ}{1}{number of arguments}
\lnie
\endln
\lnie
fcode is a pointer to the location in the interpretor\endln
\lnie
program which processes this type of function call.\endln
\lnie
\endln
\lnie
fargs is the expected number of arguments. the actual\endln
\lnie
number of arguments is adjusted to this amount by\endln
\lnie
deleting extra arguments or supplying trailing nulls\endln
\lnie
for missing ones before transferring though fcode.\endln
\lnie
a value of 999 may be used in this field to indicate a\endln
\lnie
variable number of arguments (see svblk field svnar).\endln
\lnie
\endln
\lnie
the block types which follow this scheme are.\endln
\lnie
\endln
\lnie
ffblk                 field function\endln
\lnie
dfblk                 datatype function\endln
\lnie
pfblk                 program defined function\endln
\lnie
efblk                 external loaded function\endln
\vfill\break

\lnie
\endln
\lnie
identification field\endln
\lnie
\endln
\lnie
\endln
\lnie
id   field\endln
\lnie
\endln
\lnie
certain program accessible objects (those which contain\endln
\lnie
other data values and can be copied) are given a unique\endln
\lnie
identification number (see exsid). this id value is an\endln
\lnie
address integer value which is always stored in word two.\endln
\lnie
\endln
\inst{idval}{equ}{1}{id value field}
\lnie
\endln
\lnie
the blocks containing an idval field are.\endln
\lnie
\endln
\lnie
arblk                 array\endln
\ifmac{.cnbf}
\asmac{else}
\lnie
bcblk                 buffer control block\endln
\asmac{fi}
\lnie
pdblk                 program defined datatype\endln
\lnie
tbblk                 table\endln
\lnie
vcblk                 vector block (array)\endln
\lnie
\endln
\lnie
note that a zero idval means that the block is only\endln
\lnie
half built and should not be dumped (see dumpr).\endln
\vfill\break

\lnie
\endln
\lnie
array block (arblk)\endln
\lnie
\endln
\lnie
an array block represents an array value other than one\endln
\lnie
with one dimension whose lower bound is one (see vcblk).\endln
\lnie
an arblk is built with a call to the functions convert\endln
\lnie
(s$cnv) or array (s$arr).\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                artyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                idval               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                arlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                arofs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                arndm               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     *                arlbd               *\endln
\lnie
     +------------------------------------+\endln
\lnie
     *                ardim               *\endln
\lnie
     +------------------------------------+\endln
\lnie
     *                                    *\endln
\lnie
     * above 2 flds repeated for each dim *\endln
\lnie
     *                                    *\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                arpro               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                arvls               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\vfill\break

\lnie
\endln
\lnie
array block (continued)\endln
\lnie
\endln
\inst{artyp}{equ}{0}{pointer to dummy routine b$art}
\inst{arlen}{equ}{idval+1}{length of arblk in bytes}
\inst{arofs}{equ}{arlen+1}{offset in arblk to arpro field}
\inst{arndm}{equ}{arofs+1}{number of dimensions}
\inst{arlbd}{equ}{arndm+1}{low bound (first subscript)}
\inst{ardim}{equ}{arlbd+cfp$i}{dimension (first subscript)}
\inst{arlb2}{equ}{ardim+cfp$i}{low bound (second subscript)}
\inst{ardm2}{equ}{arlb2+cfp$i}{dimension (second subscript)}
\inst{arpro}{equ}{ardim+cfp$i}{array prototype (one dimension)}
\inst{arvls}{equ}{arpro+1}{start of values (one dimension)}
\inst{arpr2}{equ}{ardm2+cfp$i}{array prototype (two dimensions)}
\inst{arvl2}{equ}{arpr2+1}{start of values (two dimensions)}
\inst{arsi$}{equ}{arlbd}{number of standard fields in block}
\inst{ardms}{equ}{arlb2-arlbd}{size of info for one set of bounds}
\lnie
\endln
\lnie
the bounds and dimension fields are signed integer\endln
\lnie
values and each occupy cfp$i words in the arblk.\endln
\lnie
\endln
\lnie
the length of an arblk in bytes may not exceed mxlen.\endln
\lnie
this is required to keep name offsets garbage collectable\endln
\lnie
\endln
\lnie
the actual values are arranged in row-wise order and\endln
\lnie
can contain a data pointer or a pointer to a trblk.\endln
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
buffer control block (bcblk)\endln
\lnie
\endln
\lnie
a bcblk is built for every bfblk.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                bctyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                idval               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                bclen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                bcbuf               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{bctyp}{equ}{0}{ptr to dummy routine b$bct}
\inst{bclen}{equ}{idval+1}{defined buffer length}
\inst{bcbuf}{equ}{bclen+1}{ptr to bfblk}
\inst{bcsi$}{equ}{bcbuf+1}{size of bcblk}
\lnie
\endln
\lnie
a bcblk is an indirect control header for bfblk.\endln
\lnie
the reason for not storing this data directly\endln
\lnie
in the related bfblk is so that the bfblk can\endln
\lnie
maintain the same skeletal structure as an scblk\endln
\lnie
thus facilitating transparent string operations\endln
\lnie
(for the most part).  specifically, cfp$f is the\endln
\lnie
same for a bfblk as for an scblk.  by convention,\endln
\lnie
whereever a buffer value is employed, the bcblk\endln
\lnie
is pointed to.\endln
\lnie
\endln
\lnie
the corresponding bfblk is pointed to by the\endln
\lnie
bcbuf pointer in the bcblk.\endln
\lnie
\endln
\lnie
bclen is the current defined size of the character\endln
\lnie
array in the bfblk.  characters following the offset\endln
\lnie
of bclen are undefined.\endln
\lnie
\endln
\vfill\break

\lnie
\endln
\lnie
string buffer block (bfblk)\endln
\lnie
\endln
\lnie
a bfblk is built by a call to buffer(...)\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                bftyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                bfalc               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                bfchr               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{bftyp}{equ}{0}{ptr to dummy routine b$bft}
\inst{bfalc}{equ}{bftyp+1}{allocated size of buffer}
\inst{bfchr}{equ}{bfalc+1}{characters of string}
\inst{bfsi$}{equ}{bfchr}{size of standard fields in bfblk}
\lnie
\endln
\lnie
the characters in the buffer are stored left justified.\endln
\lnie
the final word of defined characters is always zero\endln
\lnie
(character) padded.  any trailing allocation past the\endln
\lnie
word containing the last character contains\endln
\lnie
unpredictable contents and is never referenced.\endln
\lnie
\endln
\lnie
note that the offset to the characters of the string\endln
\lnie
is given by cfp$f, as with an scblk.  however, the\endln
\lnie
offset which is occupied by the length for an scblk\endln
\lnie
is the total char space for bfblks, and routines which\endln
\lnie
deal with both must account for this difference.\endln
\lnie
\endln
\lnie
the value of bfalc may not exceed mxlen.  the value of\endln
\lnie
bclen is always less than or equal to bfalc.\endln
\lnie
\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
code construction block (ccblk)\endln
\lnie
\endln
\lnie
at any one moment there is at most one ccblk into\endln
\lnie
which the compiler is currently storing code (cdwrd).\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cctyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cclen               i\endln
\ifmac{.csln}
\lnie
     +------------------------------------+\endln
\lnie
     i                ccsln               i\endln
\asmac{fi}
\lnie
     +------------------------------------+\endln
\lnie
     i                ccuse               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                cccod               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{cctyp}{equ}{0}{pointer to dummy routine b$cct}
\inst{cclen}{equ}{cctyp+1}{length of ccblk in bytes}
\ifmac{.csln}
\inst{ccsln}{equ}{cclen+1}{source line number}
\inst{ccuse}{equ}{ccsln+1}{offset past last used word (bytes)}
\asmac{else}
\inst{ccuse}{equ}{cclen+1}{offset past last used word (bytes)}
\asmac{fi}
\inst{cccod}{equ}{ccuse+1}{start of generated code in block}
\lnie
\endln
\lnie
the reason that the ccblk is a separate block type from\endln
\lnie
the usual cdblk is that the garbage collector must\endln
\lnie
only process those fields which have been set (see gbcpf)\endln
\vfill\break

\lnie
\endln
\lnie
code block (cdblk)\endln
\lnie
\endln
\lnie
a code block is built for each statement compiled during\endln
\lnie
the initial compilation or by subsequent calls to code.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cdjmp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cdstm               i\endln
\ifmac{.csln}
\lnie
     +------------------------------------+\endln
\lnie
     i                cdsln               i\endln
\asmac{fi}
\lnie
     +------------------------------------+\endln
\lnie
     i                cdlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cdfal               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                cdcod               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{cdjmp}{equ}{0}{ptr to routine to execute statement}
\inst{cdstm}{equ}{cdjmp+1}{statement number}
\ifmac{.csln}
\inst{cdsln}{equ}{cdstm+1}{source line number}
\inst{cdlen}{equ}{cdsln+1}{length of cdblk in bytes}
\inst{cdfal}{equ}{cdlen+1}{failure exit (see below)}
\asmac{else}
\inst{cdlen}{equ}{offs2}{length of cdblk in bytes}
\inst{cdfal}{equ}{offs3}{failure exit (see below)}
\asmac{fi}
\inst{cdcod}{equ}{cdfal+1}{executable pseudo-code}
\inst{cdsi$}{equ}{cdcod}{number of standard fields in cdblk}
\lnie
\endln
\lnie
cdstm is the statement number of the current statement.\endln
\lnie
\endln
\lnie
cdjmp, cdfal are set as follows.\endln
\lnie
\endln
\lnie
1)   if the failure exit is the next statement\endln
\lnie
\endln
\lnie
     cdjmp = b$cds\endln
\lnie
     cdfal = ptr to cdblk for next statement\endln
\lnie
\endln
\lnie
2)   if the failure exit is a simple label name\endln
\lnie
\endln
\lnie
     cdjmp = b$cds\endln
\lnie
     cdfal is a ptr to the vrtra field of the vrblk\endln
\lnie
\endln
\lnie
3)   if there is no failure exit (-nofail mode)\endln
\lnie
\endln
\lnie
     cdjmp = b$cds\endln
\lnie
     cdfal = o$unf\endln
\lnie
\endln
\lnie
4)   if the failure exit is complex or direct\endln
\lnie
\endln
\lnie
     cdjmp = b$cdc\endln
\lnie
     cdfal is the offset to the o$gof word\endln
\vfill\break

\lnie
\endln
\lnie
code block (continued)\endln
\lnie
\endln
\lnie
cdcod is the start of the actual code. first we describe\endln
\lnie
the code generated for an expression. in an expression,\endln
\lnie
elements are fetched by name or by value. for example,\endln
\lnie
the binary equal operator fetches its left argument\endln
\lnie
by name and its right argument by value. these two\endln
\lnie
cases generate quite different code and are described\endln
\lnie
separately. first we consider the code by value case.\endln
\lnie
\endln
\lnie
generation of code by value for expressions elements.\endln
\lnie
\endln
\lnie
expression            pointer to exblk or seblk\endln
\lnie
\endln
\lnie
integer constant      pointer to icblk\endln
\lnie
\endln
\lnie
null constant         pointer to nulls\endln
\lnie
\endln
\lnie
pattern               (resulting from preevaluation)\endln
\lnie
                      =o$lpt\endln
\lnie
                      pointer to p0blk,p1blk or p2blk\endln
\lnie
\endln
\lnie
real constant         pointer to rcblk\endln
\lnie
\endln
\lnie
string constant       pointer to scblk\endln
\lnie
\endln
\lnie
variable              pointer to vrget field of vrblk\endln
\lnie
\endln
\lnie
addition              value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$add\endln
\lnie
\endln
\lnie
affirmation           value code for operand\endln
\lnie
                      =o$aff\endln
\lnie
\endln
\lnie
alternation           value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$alt\endln
\lnie
\endln
\lnie
array reference       (case of one subscript)\endln
\lnie
                      value code for array operand\endln
\lnie
                      value code for subscript operand\endln
\lnie
                      =o$aov\endln
\lnie
\endln
\lnie
                      (case of more than one subscript)\endln
\lnie
                      value code for array operand\endln
\lnie
                      value code for first subscript\endln
\lnie
                      value code for second subscript\endln
\lnie
                      ...\endln
\lnie
                      value code for last subscript\endln
\lnie
                      =o$amv\endln
\lnie
                      number of subscripts\endln
\vfill\break

\lnie
\endln
\lnie
code block (continued)\endln
\lnie
\endln
\lnie
assignment            (to natural variable)\endln
\lnie
                      value code for right operand\endln
\lnie
                      pointer to vrsto field of vrblk\endln
\lnie
\endln
\lnie
                      (to any other variable)\endln
\lnie
                      name code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$ass\endln
\lnie
\endln
\lnie
compile error         =o$cer\endln
\lnie
\endln
\lnie
\endln
\lnie
complementation       value code for operand\endln
\lnie
                      =o$com\endln
\lnie
\endln
\lnie
concatenation         (case of pred func left operand)\endln
\lnie
                      value code for left operand\endln
\lnie
                      =o$pop\endln
\lnie
                      value code for right operand\endln
\lnie
\endln
\lnie
                      (all other cases)\endln
\lnie
                      value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$cnc\endln
\lnie
\endln
\lnie
cursor assignment     name code for operand\endln
\lnie
                      =o$cas\endln
\lnie
\endln
\lnie
division              value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$dvd\endln
\lnie
\endln
\lnie
exponentiation        value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$exp\endln
\lnie
\endln
\lnie
function call         (case of call to system function)\endln
\lnie
                      value code for first argument\endln
\lnie
                      value code for second argument\endln
\lnie
                      ...\endln
\lnie
                      value code for last argument\endln
\lnie
                      pointer to svfnc field of svblk\endln
\lnie
\endln
\vfill\break

\lnie
\endln
\lnie
code block (continued)\endln
\lnie
\endln
\lnie
function call         (case of non-system function 1 arg)\endln
\lnie
                      value code for argument\endln
\lnie
                      =o$fns\endln
\lnie
                      pointer to vrblk for function\endln
\lnie
\endln
\lnie
                      (non-system function, gt 1 arg)\endln
\lnie
                      value code for first argument\endln
\lnie
                      value code for second argument\endln
\lnie
                      ...\endln
\lnie
                      value code for last argument\endln
\lnie
                      =o$fnc\endln
\lnie
                      number of arguments\endln
\lnie
                      pointer to vrblk for function\endln
\lnie
\endln
\lnie
immediate assignment  value code for left operand\endln
\lnie
                      name code for right operand\endln
\lnie
                      =o$ima\endln
\lnie
\endln
\lnie
indirection           value code for operand\endln
\lnie
                      =o$inv\endln
\lnie
\endln
\lnie
interrogation         value code for operand\endln
\lnie
                      =o$int\endln
\lnie
\endln
\lnie
keyword reference     name code for operand\endln
\lnie
                      =o$kwv\endln
\lnie
\endln
\lnie
multiplication        value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$mlt\endln
\lnie
\endln
\lnie
name reference        (natural variable case)\endln
\lnie
                      pointer to nmblk for name\endln
\lnie
\endln
\lnie
                      (all other cases)\endln
\lnie
                      name code for operand\endln
\lnie
                      =o$nam\endln
\lnie
\endln
\lnie
negation              =o$nta\endln
\lnie
                      cdblk offset of o$ntc word\endln
\lnie
                      value code for operand\endln
\lnie
                      =o$ntb\endln
\lnie
                      =o$ntc\endln
\vfill\break

\lnie
\endln
\lnie
code block (continued)\endln
\lnie
\endln
\lnie
pattern assignment    value code for left operand\endln
\lnie
                      name code for right operand\endln
\lnie
                      =o$pas\endln
\lnie
\endln
\lnie
pattern match         value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$pmv\endln
\lnie
\endln
\lnie
pattern replacement   name code for subject\endln
\lnie
                      value code for pattern\endln
\lnie
                      =o$pmn\endln
\lnie
                      value code for replacement\endln
\lnie
                      =o$rpl\endln
\lnie
\endln
\lnie
selection             (for first alternative)\endln
\lnie
                      =o$sla\endln
\lnie
                      cdblk offset to next o$slc word\endln
\lnie
                      value code for first alternative\endln
\lnie
                      =o$slb\endln
\lnie
                      cdblk offset past alternatives\endln
\lnie
\endln
\lnie
                      (for subsequent alternatives)\endln
\lnie
                      =o$slc\endln
\lnie
                      cdblk offset to next o$slc,o$sld\endln
\lnie
                      value code for alternative\endln
\lnie
                      =o$slb\endln
\lnie
                      offset in cdblk past alternatives\endln
\lnie
\endln
\lnie
                      (for last alternative)\endln
\lnie
                      =o$sld\endln
\lnie
                      value code for last alternative\endln
\lnie
\endln
\lnie
subtraction           value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$sub\endln
\vfill\break

\lnie
\endln
\lnie
code block (continued)\endln
\lnie
\endln
\lnie
generation of code by name for expression elements.\endln
\lnie
\endln
\lnie
variable              =o$lvn\endln
\lnie
                      pointer to vrblk\endln
\lnie
\endln
\lnie
expression            (case of *natural variable)\endln
\lnie
                      =o$lvn\endln
\lnie
                      pointer to vrblk\endln
\lnie
\endln
\lnie
                      (all other cases)\endln
\lnie
                      =o$lex\endln
\lnie
                      pointer to exblk\endln
\lnie
\endln
\lnie
\endln
\lnie
array reference       (case of one subscript)\endln
\lnie
                      value code for array operand\endln
\lnie
                      value code for subscript operand\endln
\lnie
                      =o$aon\endln
\lnie
\endln
\lnie
                      (case of more than one subscript)\endln
\lnie
                      value code for array operand\endln
\lnie
                      value code for first subscript\endln
\lnie
                      value code for second subscript\endln
\lnie
                      ...\endln
\lnie
                      value code for last subscript\endln
\lnie
                      =o$amn\endln
\lnie
                      number of subscripts\endln
\lnie
\endln
\lnie
compile error         =o$cer\endln
\lnie
\endln
\lnie
function call         (same code as for value call)\endln
\lnie
                      =o$fne\endln
\lnie
\endln
\lnie
indirection           value code for operand\endln
\lnie
                      =o$inn\endln
\lnie
\endln
\lnie
keyword reference     name code for operand\endln
\lnie
                      =o$kwn\endln
\lnie
\endln
\lnie
any other operand is an error in a name position\endln
\lnie
\endln
\lnie
note that in this description, =o$xxx refers to the\endln
\lnie
generation of a word containing the address of another\endln
\lnie
word which contains the entry point address o$xxx.\endln
\vfill\break

\lnie
\endln
\lnie
code block (continued)\endln
\lnie
\endln
\lnie
now we consider the overall structure of the code block\endln
\lnie
for a statement with possible goto fields.\endln
\lnie
\endln
\lnie
first comes the code for the statement body.\endln
\lnie
the statement body is an expression to be evaluated\endln
\lnie
by value although the value is not actually required.\endln
\lnie
normal value code is generated for the body of the\endln
\lnie
statement except in the case of a pattern match by\endln
\lnie
value, in which case the following is generated.\endln
\lnie
\endln
\lnie
                      value code for left operand\endln
\lnie
                      value code for right operand\endln
\lnie
                      =o$pms\endln
\lnie
\endln
\lnie
next we have the code for the success goto. there are\endln
\lnie
several cases as follows.\endln
\lnie
\endln
\lnie
1)   no success goto  ptr to cdblk for next statement\endln
\lnie
\endln
\lnie
2)   simple label     ptr to vrtra field of vrblk\endln
\lnie
\endln
\lnie
3)   complex goto     (code by name for goto operand)\endln
\lnie
                      =o$goc\endln
\lnie
\endln
\lnie
4)   direct goto      (code by value for goto operand)\endln
\lnie
                      =o$god\endln
\lnie
\endln
\lnie
following this we generate code for the failure goto if\endln
\lnie
it is direct or if it is complex, simple failure gotos\endln
\lnie
having been handled by an appropriate setting of the\endln
\lnie
cdfal field of the cdblk. the generated code is one\endln
\lnie
of the following.\endln
\lnie
\endln
\lnie
1)   complex fgoto    =o$fif\endln
\lnie
                      =o$gof\endln
\lnie
                      name code for goto operand\endln
\lnie
                      =o$goc\endln
\lnie
\endln
\lnie
2)   direct fgoto     =o$fif\endln
\lnie
                      =o$gof\endln
\lnie
                      value code for goto operand\endln
\lnie
                      =o$god\endln
\lnie
\endln
\lnie
an optimization occurs if the success and failure gotos\endln
\lnie
are identical and either complex or direct. in this case,\endln
\lnie
no code is generated for the success goto and control\endln
\lnie
is allowed to fall into the failure goto on success.\endln
\vfill\break

\lnie
\endln
\lnie
compiler block (cmblk)\endln
\lnie
\endln
\lnie
a compiler block (cmblk) is built by expan to represent\endln
\lnie
one node of a tree structured expression representation.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cmidn               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cmlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cmtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cmopn               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /           cmvls or cmrop           /\endln
\lnie
     /                                    /\endln
\lnie
     /                cmlop               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{cmidn}{equ}{0}{pointer to dummy routine b$cmt}
\inst{cmlen}{equ}{cmidn+1}{length of cmblk in bytes}
\inst{cmtyp}{equ}{cmlen+1}{type (c$xxx, see list below)}
\inst{cmopn}{equ}{cmtyp+1}{operand pointer (see below)}
\inst{cmvls}{equ}{cmopn+1}{operand value pointers (see below)}
\inst{cmrop}{equ}{cmvls}{right (only) operator operand}
\inst{cmlop}{equ}{cmvls+1}{left operator operand}
\inst{cmsi$}{equ}{cmvls}{number of standard fields in cmblk}
\inst{cmus$}{equ}{cmsi$+1}{size of unary operator cmblk}
\inst{cmbs$}{equ}{cmsi$+2}{size of binary operator cmblk}
\inst{cmar1}{equ}{cmvls+1}{array subscript pointers}
\lnie
\endln
\lnie
the cmopn and cmvls fields are set as follows\endln
\lnie
\endln
\lnie
array reference       cmopn = ptr to array operand\endln
\lnie
                      cmvls = ptrs to subscript operands\endln
\lnie
\endln
\lnie
function call         cmopn = ptr to vrblk for function\endln
\lnie
                      cmvls = ptrs to argument operands\endln
\lnie
\endln
\lnie
selection             cmopn = zero\endln
\lnie
                      cmvls = ptrs to alternate operands\endln
\lnie
\endln
\lnie
unary operator        cmopn = ptr to operator dvblk\endln
\lnie
                      cmrop = ptr to operand\endln
\lnie
\endln
\lnie
binary operator       cmopn = ptr to operator dvblk\endln
\lnie
                      cmrop = ptr to right operand\endln
\lnie
                      cmlop = ptr to left operand\endln
\vfill\break

\lnie
\endln
\lnie
cmtyp is set to indicate the type of expression element\endln
\lnie
as shown by the following table of definitions.\endln
\lnie
\endln
\inst{c$arr}{equ}{0}{array reference}
\inst{c$fnc}{equ}{c$arr+1}{function call}
\inst{c$def}{equ}{c$fnc+1}{deferred expression (unary *)}
\inst{c$ind}{equ}{c$def+1}{indirection (unary $)}
\inst{c$key}{equ}{c$ind+1}{keyword reference (unary ampersand)}
\inst{c$ubo}{equ}{c$key+1}{undefined binary operator}
\inst{c$uuo}{equ}{c$ubo+1}{undefined unary operator}
\inst{c$uo$}{equ}{c$uuo+1}{test value (=c$uuo+1=c$ubo+2)}
\inst{c$$nm}{equ}{c$uuo+1}{number of codes for name operands}
\lnie
\endln
\lnie
the remaining types indicate expression elements which\endln
\lnie
can only be evaluated by value (not by name).\endln
\lnie
\endln
\inst{c$bvl}{equ}{c$uuo+1}{binary op with value operands}
\inst{c$uvl}{equ}{c$bvl+1}{unary operator with value operand}
\inst{c$alt}{equ}{c$uvl+1}{alternation (binary bar)}
\inst{c$cnc}{equ}{c$alt+1}{concatenation}
\inst{c$cnp}{equ}{c$cnc+1}{concatenation, not pattern match}
\inst{c$unm}{equ}{c$cnp+1}{unary op with name operand}
\inst{c$bvn}{equ}{c$unm+1}{binary op (operands by value, name)}
\inst{c$ass}{equ}{c$bvn+1}{assignment}
\inst{c$int}{equ}{c$ass+1}{interrogation}
\inst{c$neg}{equ}{c$int+1}{negation (unary not)}
\inst{c$sel}{equ}{c$neg+1}{selection}
\inst{c$pmt}{equ}{c$sel+1}{pattern match}
\lnie
\endln
\inst{c$pr$}{equ}{c$bvn}{last preevaluable code}
\inst{c$$nv}{equ}{c$pmt+1}{number of different cmblk types}
\vfill\break

\lnie
\endln
\lnie
character table block (ctblk)\endln
\lnie
\endln
\lnie
a character table block is used to hold logical character\endln
\lnie
tables for use with any,notany,span,break,breakx\endln
\lnie
patterns. each character table can be used to store\endln
\lnie
cfp$n distinct tables as bit columns. a bit column\endln
\lnie
allocated for each argument of more than one character\endln
\lnie
in length to one of the above listed pattern primitives.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                cttyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     *                                    *\endln
\lnie
     *                                    *\endln
\lnie
     *                ctchs               *\endln
\lnie
     *                                    *\endln
\lnie
     *                                    *\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{cttyp}{equ}{0}{pointer to dummy routine b$ctt}
\inst{ctchs}{equ}{cttyp+1}{start of character table words}
\inst{ctsi$}{equ}{ctchs+cfp$a}{number of words in ctblk}
\lnie
\endln
\lnie
ctchs is cfp$a words long and consists of a one word\endln
\lnie
bit string value for each possible character in the\endln
\lnie
internal alphabet. each of the cfp$n possible bits in\endln
\lnie
a bitstring is used to form a column of bit indicators.\endln
\lnie
a bit is set on if the character is in the table and off\endln
\lnie
if the character is not present.\endln
\vfill\break

\lnie
\endln
\lnie
datatype function block (dfblk)\endln
\lnie
\endln
\lnie
a datatype function is used to control the construction\endln
\lnie
of a program defined datatype object. a call to the\endln
\lnie
system function data builds a dfblk for the datatype name\endln
\lnie
\endln
\lnie
note that these blocks are built in static because pdblk\endln
\lnie
length is got from dflen field.  if dfblk was in dynamic\endln
\lnie
store this would cause trouble during pass two of garbage\endln
\lnie
collection.  scblk referred to by dfnam field is also put\endln
\lnie
in static so that there are no reloc. fields. this cuts\endln
\lnie
garbage collection task appreciably for pdblks which are\endln
\lnie
likely to be present in large numbers.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fargs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                dflen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                dfpdl               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                dfnam               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                dffld               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{dflen}{equ}{fargs+1}{length of dfblk in bytes}
\inst{dfpdl}{equ}{dflen+1}{length of corresponding pdblk}
\inst{dfnam}{equ}{dfpdl+1}{pointer to scblk for datatype name}
\inst{dffld}{equ}{dfnam+1}{start of vrblk ptrs for field names}
\inst{dfflb}{equ}{dffld-1}{offset behind dffld for field func}
\inst{dfsi$}{equ}{dffld}{number of standard fields in dfblk}
\lnie
\endln
\lnie
the fcode field points to the routine b$dfc\endln
\lnie
\endln
\lnie
fargs (the number of arguments) is the number of fields.\endln
\vfill\break

\lnie
\endln
\lnie
dope vector block (dvblk)\endln
\lnie
\endln
\lnie
a dope vector is assembled for each possible operator in\endln
\lnie
the snobol4 language as part of the constant section.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                dvopn               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                dvtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                dvlpr               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                dvrpr               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{dvopn}{equ}{0}{entry address (ptr to o$xxx)}
\inst{dvtyp}{equ}{dvopn+1}{type code (c$xxx, see cmblk)}
\inst{dvlpr}{equ}{dvtyp+1}{left precedence (llxxx, see below)}
\inst{dvrpr}{equ}{dvlpr+1}{right precedence (rrxxx, see below)}
\inst{dvus$}{equ}{dvlpr+1}{size of unary operator dv}
\inst{dvbs$}{equ}{dvrpr+1}{size of binary operator dv}
\inst{dvubs}{equ}{dvus$+dvbs$}{size of unop + binop (see scane)}
\lnie
\endln
\lnie
the contents of the dvtyp field is copied into the cmtyp\endln
\lnie
field of the cmblk for the operator if it is used.\endln
\lnie
\endln
\lnie
the cmopn field of an operator cmblk points to the dvblk\endln
\lnie
itself, providing the required entry address pointer ptr.\endln
\lnie
\endln
\lnie
for normally undefined operators, the dvopn (and cmopn)\endln
\lnie
fields contain a word offset from r$uba of the function\endln
\lnie
block pointer for the operator (instead of o$xxx ptr).\endln
\lnie
for certain special operators, the dvopn field is not\endln
\lnie
required at all and is assembled as zero.\endln
\lnie
\endln
\lnie
the left precedence is used in comparing an operator to\endln
\lnie
the left of some other operator. it therefore governs the\endln
\lnie
precedence of the operator towards its right operand.\endln
\lnie
\endln
\lnie
the right precedence is used in comparing an operator to\endln
\lnie
the right of some other operator. it therefore governs\endln
\lnie
the precedence of the operator towards its left operand.\endln
\lnie
\endln
\lnie
higher precedence values correspond to a tighter binding\endln
\lnie
capability. thus we have the left precedence lower\endln
\lnie
(higher) than the right precedence for right (left)\endln
\lnie
associative binary operators.\endln
\lnie
\endln
\lnie
the left precedence of unary operators is set to an\endln
\lnie
arbitrary high value. the right value is not required and\endln
\lnie
consequently the dvrpr field is omitted for unary ops.\endln
\vfill\break

\lnie
\endln
\lnie
table of operator precedence values\endln
\lnie
\endln
\inst{rrass}{equ}{10}{right     equal}
\inst{llass}{equ}{00}{left      equal}
\inst{rrpmt}{equ}{20}{right     question mark}
\inst{llpmt}{equ}{30}{left      question mark}
\inst{rramp}{equ}{40}{right     ampersand}
\inst{llamp}{equ}{50}{left      ampersand}
\inst{rralt}{equ}{70}{right     vertical bar}
\inst{llalt}{equ}{60}{left      vertical bar}
\inst{rrcnc}{equ}{90}{right     blank}
\inst{llcnc}{equ}{80}{left      blank}
\inst{rrats}{equ}{110}{right     at}
\inst{llats}{equ}{100}{left      at}
\inst{rrplm}{equ}{120}{right     plus, minus}
\inst{llplm}{equ}{130}{left      plus, minus}
\inst{rrnum}{equ}{140}{right     number}
\inst{llnum}{equ}{150}{left      number}
\inst{rrdvd}{equ}{160}{right     slash}
\inst{lldvd}{equ}{170}{left      slash}
\inst{rrmlt}{equ}{180}{right     asterisk}
\inst{llmlt}{equ}{190}{left      asterisk}
\inst{rrpct}{equ}{200}{right     percent}
\inst{llpct}{equ}{210}{left      percent}
\inst{rrexp}{equ}{230}{right     exclamation}
\inst{llexp}{equ}{220}{left      exclamation}
\inst{rrdld}{equ}{240}{right     dollar, dot}
\inst{lldld}{equ}{250}{left      dollar, dot}
\inst{rrnot}{equ}{270}{right     not}
\inst{llnot}{equ}{260}{left      not}
\inst{lluno}{equ}{999}{left      all unary operators}
\lnie
\endln
\lnie
precedences are the same as in btl snobol4 with the\endln
\lnie
following exceptions.\endln
\lnie
\endln
\lnie
1)   binary question mark is lowered and made left assoc-\endln
\lnie
     iative to reflect its new use for pattern matching.\endln
\lnie
\endln
\lnie
2)   alternation and concatenation are made right\endln
\lnie
     associative for greater efficiency in pattern\endln
\lnie
     construction and matching respectively. this change\endln
\lnie
     is transparent to the snobol4 programmer.\endln
\lnie
\endln
\lnie
3)   the equal sign has been added as a low precedence\endln
\lnie
     operator which is right associative to reflect its\endln
\lnie
     more general usage in this version of snobol4.\endln
\vfill\break

\lnie
\endln
\lnie
external function block (efblk)\endln
\lnie
\endln
\lnie
an external function block is used to control the calling\endln
\lnie
of an external function. it is built by a call to load.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fargs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                eflen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                efuse               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                efcod               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                efvar               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                efrsl               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                eftar               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{eflen}{equ}{fargs+1}{length of efblk in bytes}
\inst{efuse}{equ}{eflen+1}{use count (for opsyn)}
\inst{efcod}{equ}{efuse+1}{ptr to code (from sysld)}
\inst{efvar}{equ}{efcod+1}{ptr to associated vrblk}
\inst{efrsl}{equ}{efvar+1}{result type (see below)}
\inst{eftar}{equ}{efrsl+1}{argument types (see below)}
\inst{efsi$}{equ}{eftar}{number of standard fields in efblk}
\lnie
\endln
\lnie
the fcode field points to the routine b$efc.\endln
\lnie
\endln
\lnie
efuse is used to keep track of multiple use when opsyn\endln
\lnie
is employed. the function is automatically unloaded\endln
\lnie
when there are no more references to the function.\endln
\lnie
\endln
\lnie
efrsl and eftar are type codes as follows.\endln
\lnie
\endln
\lnie
     0                type is unconverted\endln
\lnie
     1                type is string\endln
\lnie
     2                type is integer\endln
\ifmac{.cnra}
\ifmac{.cnlf}
\lnie
     3                type is file\endln
\asmac{fi}
\asmac{else}
\lnie
     3                type is real\endln
\ifmac{.cnlf}
\lnie
     4                type is file\endln
\asmac{fi}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
expression variable block (evblk)\endln
\lnie
\endln
\lnie
in this version of spitbol, an expression can be used in\endln
\lnie
any position which would normally expect a name (for\endln
\lnie
example on the left side of equals or as the right\endln
\lnie
argument of binary dot). this corresponds to the creation\endln
\lnie
of a pseudo-variable which is represented by a pointer to\endln
\lnie
an expression variable block as follows.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                evtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                evexp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                evvar               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{evtyp}{equ}{0}{pointer to dummy routine b$evt}
\inst{evexp}{equ}{evtyp+1}{pointer to exblk for expression}
\inst{evvar}{equ}{evexp+1}{pointer to trbev dummy trblk}
\inst{evsi$}{equ}{evvar+1}{size of evblk}
\lnie
\endln
\lnie
the name of an expression variable is represented by a\endln
\lnie
base pointer to the evblk and an offset of evvar. this\endln
\lnie
value appears to be trapped by the dummy trbev block.\endln
\lnie
\endln
\lnie
note that there is no need to allow for the case of an\endln
\lnie
expression variable which references an seblk since a\endln
\lnie
variable which is of the form *var is equivalent to var.\endln
\vfill\break

\lnie
\endln
\lnie
expression block (exblk)\endln
\lnie
\endln
\lnie
an expression block is built for each expression\endln
\lnie
referenced in a program or created by eval or convert\endln
\lnie
during execution of a program.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                extyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                exstm               i\endln
\ifmac{.csln}
\lnie
     +------------------------------------+\endln
\lnie
     i                exsln               i\endln
\asmac{fi}
\lnie
     +------------------------------------+\endln
\lnie
     i                exlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                exflc               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                excod               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{extyp}{equ}{0}{ptr to routine b$exl to load expr}
\inst{exstm}{equ}{cdstm}{stores stmnt no. during evaluation}
\ifmac{.csln}
\inst{exsln}{equ}{exstm+1}{stores line no. during evaluation}
\inst{exlen}{equ}{exsln+1}{length of exblk in bytes}
\asmac{else}
\inst{exlen}{equ}{exstm+1}{length of exblk in bytes}
\asmac{fi}
\inst{exflc}{equ}{exlen+1}{failure code (=o$fex)}
\inst{excod}{equ}{exflc+1}{pseudo-code for expression}
\inst{exsi$}{equ}{excod}{number of standard fields in exblk}
\lnie
\endln
\lnie
there are two cases for excod depending on whether the\endln
\lnie
expression can be evaluated by name (see description\endln
\lnie
of cdblk for details of code for expressions).\endln
\lnie
\endln
\lnie
if the expression can be evaluated by name we have.\endln
\lnie
\endln
\lnie
                      (code for expr by name)\endln
\lnie
                      =o$rnm\endln
\lnie
\endln
\lnie
if the expression can only be evaluated by value.\endln
\lnie
\endln
\lnie
                      (code for expr by value)\endln
\lnie
                      =o$rvl\endln
\vfill\break

\lnie
\endln
\lnie
field function block (ffblk)\endln
\lnie
\endln
\lnie
a field function block is used to control the selection\endln
\lnie
of a field from a program defined datatype block.\endln
\lnie
a call to data creates an ffblk for each field.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fargs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                ffdfp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                ffnxt               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                ffofs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{ffdfp}{equ}{fargs+1}{pointer to associated dfblk}
\inst{ffnxt}{equ}{ffdfp+1}{ptr to next ffblk on chain or zero}
\inst{ffofs}{equ}{ffnxt+1}{offset (bytes) to field in pdblk}
\inst{ffsi$}{equ}{ffofs+1}{size of ffblk in words}
\lnie
\endln
\lnie
the fcode field points to the routine b$ffc.\endln
\lnie
\endln
\lnie
fargs always contains one.\endln
\lnie
\endln
\lnie
ffdfp is used to verify that the correct program defined\endln
\lnie
datatype is being accessed by this call.\endln
\lnie
ffdfp is non-reloc. because dfblk is in static\endln
\lnie
\endln
\lnie
ffofs is used to select the appropriate field. note that\endln
\lnie
it is an actual offset (not a field number)\endln
\lnie
\endln
\lnie
ffnxt is used to point to the next ffblk of the same name\endln
\lnie
in the case where there are several fields of the same\endln
\lnie
name for different datatypes. zero marks the end of chain\endln
\vfill\break

\lnie
\endln
\lnie
integer constant block (icblk)\endln
\lnie
\endln
\lnie
an icblk is created for every integer referenced or\endln
\lnie
created by a program. note however that certain internal\endln
\lnie
integer values are stored as addresses (e.g. the length\endln
\lnie
field in a string constant block)\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                icget               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     *                icval               *\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{icget}{equ}{0}{ptr to routine b$icl to load int}
\inst{icval}{equ}{icget+1}{integer value}
\inst{icsi$}{equ}{icval+cfp$i}{size of icblk}
\lnie
\endln
\lnie
the length of the icval field is cfp$i.\endln
\vfill\break

\lnie
\endln
\lnie
keyword variable block (kvblk)\endln
\lnie
\endln
\lnie
a kvblk is used to represent a keyword pseudo-variable.\endln
\lnie
a kvblk is built for each keyword reference (kwnam).\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                kvtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                kvvar               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                kvnum               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{kvtyp}{equ}{0}{pointer to dummy routine b$kvt}
\inst{kvvar}{equ}{kvtyp+1}{pointer to dummy block trbkv}
\inst{kvnum}{equ}{kvvar+1}{keyword number}
\inst{kvsi$}{equ}{kvnum+1}{size of kvblk}
\lnie
\endln
\lnie
the name of a keyword variable is represented by a\endln
\lnie
base pointer to the kvblk and an offset of kvvar. the\endln
\lnie
value appears to be trapped by the pointer to trbkv.\endln
\vfill\break

\lnie
\endln
\lnie
name block (nmblk)\endln
\lnie
\endln
\lnie
a name block is used wherever a name must be stored as\endln
\lnie
a value following use of the unary dot operator.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                nmtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                nmbas               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                nmofs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{nmtyp}{equ}{0}{ptr to routine b$nml to load name}
\inst{nmbas}{equ}{nmtyp+1}{base pointer for variable}
\inst{nmofs}{equ}{nmbas+1}{offset for variable}
\inst{nmsi$}{equ}{nmofs+1}{size of nmblk}
\lnie
\endln
\lnie
the actual field representing the contents of the name\endln
\lnie
is found nmofs bytes past the address in nmbas.\endln
\lnie
\endln
\lnie
the name is split into base and offset form to avoid\endln
\lnie
creation of a pointer into the middle of a block which\endln
\lnie
could not be handled properly by the garbage collector.\endln
\lnie
\endln
\lnie
a name may be built for any variable (see section on\endln
\lnie
representations of variables) this includes the\endln
\lnie
cases of pseudo-variables.\endln
\vfill\break

\lnie
\endln
\lnie
pattern block, no parameters (p0blk)\endln
\lnie
\endln
\lnie
a p0blk is used to represent pattern nodes which do\endln
\lnie
not require the use of any parameter values.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pthen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{pcode}{equ}{0}{ptr to match routine (p$xxx)}
\inst{pthen}{equ}{pcode+1}{pointer to subsequent node}
\inst{pasi$}{equ}{pthen+1}{size of p0blk}
\lnie
\endln
\lnie
pthen points to the pattern block for the subsequent\endln
\lnie
node to be matched. this is a pointer to the pattern\endln
\lnie
block ndnth if there is no subsequent (end of pattern)\endln
\lnie
\endln
\lnie
pcode is a pointer to the match routine for the node.\endln
\vfill\break

\lnie
\endln
\lnie
pattern block (one parameter)\endln
\lnie
\endln
\lnie
a p1blk is used to represent pattern nodes which\endln
\lnie
require one parameter value.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pthen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                parm1               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{parm1}{equ}{pthen+1}{first parameter value}
\inst{pbsi$}{equ}{parm1+1}{size of p1blk in words}
\lnie
\endln
\lnie
see p0blk for definitions of pcode, pthen\endln
\lnie
\endln
\lnie
parm1 contains a parameter value used in matching the\endln
\lnie
node. for example, in a len pattern, it is the integer\endln
\lnie
argument to len. the details of the use of the parameter\endln
\lnie
field are included in the description of the individual\endln
\lnie
match routines. parm1 is always an address pointer which\endln
\lnie
is processed by the garbage collector.\endln
\vfill\break

\lnie
\endln
\lnie
pattern block (two parameters)\endln
\lnie
\endln
\lnie
a p2blk is used to represent pattern nodes which\endln
\lnie
require two parameter values.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pthen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                parm1               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                parm2               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{parm2}{equ}{parm1+1}{second parameter value}
\inst{pcsi$}{equ}{parm2+1}{size of p2blk in words}
\lnie
\endln
\lnie
see p1blk for definitions of pcode, pthen, parm1\endln
\lnie
\endln
\lnie
parm2 is a parameter which performs the same sort of\endln
\lnie
function as parm1 (see description of p1blk).\endln
\lnie
\endln
\lnie
parm2 is a non-relocatable field and is not\endln
\lnie
processed by the garbage collector. accordingly, it may\endln
\lnie
not contain a pointer to a block in dynamic memory.\endln
\vfill\break

\lnie
\endln
\lnie
program-defined datatype block\endln
\lnie
\endln
\lnie
a pdblk represents the data item formed by a call to a\endln
\lnie
datatype function as defined by the system function data.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pdtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                idval               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pddfp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                pdfld               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{pdtyp}{equ}{0}{ptr to dummy routine b$pdt}
\inst{pddfp}{equ}{idval+1}{ptr to associated dfblk}
\inst{pdfld}{equ}{pddfp+1}{start of field value pointers}
\inst{pdfof}{equ}{dffld-pdfld}{difference in offset to field ptrs}
\inst{pdsi$}{equ}{pdfld}{size of standard fields in pdblk}
\inst{pddfs}{equ}{dfsi$-pdsi$}{difference in dfblk, pdblk sizes}
\lnie
\endln
\lnie
the pddfp pointer may be used to determine the datatype\endln
\lnie
and the names of the fields if required. the dfblk also\endln
\lnie
contains the length of the pdblk in bytes (field dfpdl).\endln
\lnie
pddfp is non-reloc. because dfblk is in static\endln
\lnie
\endln
\lnie
pdfld values are stored in order from left to right.\endln
\lnie
they contain values or pointers to trblk chains.\endln
\vfill\break

\lnie
\endln
\lnie
program defined function block (pfblk)\endln
\lnie
\endln
\lnie
a pfblk is created for each call to the define function\endln
\lnie
and a pointer to the pfblk placed in the proper vrblk.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                fargs               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pflen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pfvbl               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pfnlo               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pfcod               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pfctr               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pfrtr               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                pfarg               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{pflen}{equ}{fargs+1}{length of pfblk in bytes}
\inst{pfvbl}{equ}{pflen+1}{pointer to vrblk for function name}
\inst{pfnlo}{equ}{pfvbl+1}{number of locals}
\inst{pfcod}{equ}{pfnlo+1}{ptr to vrblk for entry label}
\inst{pfctr}{equ}{pfcod+1}{trblk ptr if call traced else 0}
\inst{pfrtr}{equ}{pfctr+1}{trblk ptr if return traced else 0}
\inst{pfarg}{equ}{pfrtr+1}{vrblk ptrs for arguments and locals}
\inst{pfagb}{equ}{pfarg-1}{offset behind pfarg for arg, local}
\inst{pfsi$}{equ}{pfarg}{number of standard fields in pfblk}
\lnie
\endln
\lnie
the fcode field points to the routine b$pfc.\endln
\lnie
\endln
\lnie
pfarg is stored in the following order.\endln
\lnie
\endln
\lnie
     arguments (left to right)\endln
\lnie
     locals (left to right)\endln
\ifmac{.cnra}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
real constant block (rcblk)\endln
\lnie
\endln
\lnie
an rcblk is created for every real referenced or\endln
\lnie
created by a program.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                rcget               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     *                rcval               *\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{rcget}{equ}{0}{ptr to routine b$rcl to load real}
\inst{rcval}{equ}{rcget+1}{real value}
\inst{rcsi$}{equ}{rcval+cfp$r}{size of rcblk}
\lnie
\endln
\lnie
the length of the rcval field is cfp$r.\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
string constant block (scblk)\endln
\lnie
\endln
\lnie
an scblk is built for every string referenced or created\endln
\lnie
by a program.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                scget               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                sclen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                schar               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{scget}{equ}{0}{ptr to routine b$scl to load string}
\inst{sclen}{equ}{scget+1}{length of string in characters}
\inst{schar}{equ}{sclen+1}{characters of string}
\inst{scsi$}{equ}{schar}{size of standard fields in scblk}
\lnie
\endln
\lnie
the characters of the string are stored left justified.\endln
\lnie
the final word is padded on the right with zeros.\endln
\lnie
(i.e. the character whose internal code is zero).\endln
\lnie
\endln
\lnie
the value of sclen may not exceed mxlen. this ensures\endln
\lnie
that character offsets (e.g. the pattern match cursor)\endln
\lnie
can be correctly processed by the garbage collector.\endln
\lnie
\endln
\lnie
note that the offset to the characters of the string\endln
\lnie
is given in bytes by cfp$f and that this value is\endln
\lnie
automatically allowed for in plc, psc.\endln
\lnie
note that for a spitbol scblk, the value of cfp$f\endln
\lnie
is given by cfp$b*schar.\endln
\vfill\break

\lnie
\endln
\lnie
simple expression block (seblk)\endln
\lnie
\endln
\lnie
an seblk is used to represent an expression of the form\endln
\lnie
*(natural variable). all other expressions are exblks.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                setyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                sevar               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{setyp}{equ}{0}{ptr to routine b$sel to load expr}
\inst{sevar}{equ}{setyp+1}{ptr to vrblk for variable}
\inst{sesi$}{equ}{sevar+1}{length of seblk in words}
\vfill\break

\lnie
\endln
\lnie
standard variable block (svblk)\endln
\lnie
\endln
\lnie
an svblk is assembled in the constant section for each\endln
\lnie
variable which satisfies one of the following conditions.\endln
\lnie
\endln
\lnie
1)   it is the name of a system function\endln
\lnie
2)   it has an initial value\endln
\lnie
3)   it has a keyword association\endln
\lnie
4)   it has a standard i/o association\endln
\lnie
6)   it has a standard label association\endln
\lnie
\endln
\lnie
if vrblks are constructed for any of these variables,\endln
\lnie
then the vrsvp field points to the svblk (see vrblk)\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                svbit               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                svlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                svchs               /\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                svknm               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                svfnc               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                svnar               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                svlbl               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                svval               i\endln
\lnie
     +------------------------------------+\endln
\vfill\break

\lnie
\endln
\lnie
standard variable block (continued)\endln
\lnie
\endln
\inst{svbit}{equ}{0}{bit string indicating attributes}
\inst{svlen}{equ}{1}{(=sclen) length of name in chars}
\inst{svchs}{equ}{2}{(=schar) characters of name}
\inst{svsi$}{equ}{2}{number of standard fields in svblk}
\inst{svpre}{equ}{1}{set if preevaluation permitted}
\inst{svffc}{equ}{svpre+svpre}{set on if fast call permitted}
\inst{svckw}{equ}{svffc+svffc}{set on if keyword value constant}
\inst{svprd}{equ}{svckw+svckw}{set on if predicate function}
\inst{svnbt}{equ}{4}{number of bits to right of svknm}
\inst{svknm}{equ}{svprd+svprd}{set on if keyword association}
\inst{svfnc}{equ}{svknm+svknm}{set on if system function}
\inst{svnar}{equ}{svfnc+svfnc}{set on if system function}
\inst{svlbl}{equ}{svnar+svnar}{set on if system label}
\inst{svval}{equ}{svlbl+svlbl}{set on if predefined value}
\lnie
\endln
\lnie
note that the last five bits correspond in order\endln
\lnie
to the fields which are present (see procedure gtnvr).\endln
\lnie
\endln
\lnie
the following definitions are used in the svblk table\endln
\lnie
\endln
\inst{svfnf}{equ}{svfnc+svnar}{function with no fast call}
\inst{svfnn}{equ}{svfnf+svffc}{function with fast call, no preeval}
\inst{svfnp}{equ}{svfnn+svpre}{function allowing preevaluation}
\inst{svfpr}{equ}{svfnn+svprd}{predicate function}
\inst{svfnk}{equ}{svfnn+svknm}{no preeval func + keyword}
\inst{svkwv}{equ}{svknm+svval}{keyword + value}
\inst{svkwc}{equ}{svckw+svknm}{keyword with constant value}
\inst{svkvc}{equ}{svkwv+svckw}{constant keyword + value}
\inst{svkvl}{equ}{svkvc+svlbl}{constant keyword + value + label}
\inst{svfpk}{equ}{svfnp+svkvc}{preeval fcn + const keywd + val}
\lnie
\endln
\lnie
the svpre bit allows the compiler to preevaluate a call\endln
\lnie
to the associated system function if all the arguments\endln
\lnie
are themselves constants. functions in this category\endln
\lnie
must have no side effects and must never cause failure.\endln
\lnie
the call may generate an error condition.\endln
\lnie
\endln
\lnie
the svffc bit allows the compiler to generate the special\endln
\lnie
fast call after adjusting the number of arguments. only\endln
\lnie
the item and apply functions fall outside this category.\endln
\lnie
\endln
\lnie
the svckw bit is set if the associated keyword value is\endln
\lnie
a constant, thus allowing preevaluation for a value call.\endln
\lnie
\endln
\lnie
the svprd bit is set on for all predicate functions to\endln
\lnie
enable the special concatenation code optimization.\endln
\vfill\break

\lnie
\endln
\lnie
svblk (continued)\endln
\lnie
\endln
\lnie
svknm                 keyword number\endln
\lnie
\endln
\lnie
     svknm is present only for a standard keyword assoc.\endln
\lnie
     it contains a keyword number as defined by the\endln
\lnie
     keyword number table given later on.\endln
\lnie
\endln
\lnie
svfnc                 system function pointer\endln
\lnie
\endln
\lnie
     svfnc is present only for a system function assoc.\endln
\lnie
     it is a pointer to the actual code for the system\endln
\lnie
     function. the generated code for a fast call is a\endln
\lnie
     pointer to the svfnc field of the svblk for the\endln
\lnie
     function. the vrfnc field of the vrblk points to\endln
\lnie
     this same field, in which case, it serves as the\endln
\lnie
     fcode field for the function call.\endln
\lnie
\endln
\lnie
svnar                 number of function arguments\endln
\lnie
\endln
\lnie
     svnar is present only for a system function assoc.\endln
\lnie
     it is the number of arguments required for a call\endln
\lnie
     to the system function. the compiler uses this\endln
\lnie
     value to adjust the number of arguments in a fast\endln
\lnie
     call and in the case of a function called through\endln
\lnie
     the vrfnc field of the vrblk, the svnar field\endln
\lnie
     serves as the fargs field for o$fnc. a special\endln
\lnie
     case occurs if this value is set to 999. this is\endln
\lnie
     used to indicate that the function has a variable\endln
\lnie
     number of arguments and causes o$fnc to pass control\endln
\lnie
     without adjusting the argument count. the only\endln
\lnie
     predefined functions using this are apply and item.\endln
\lnie
\endln
\lnie
svlbl                 system label pointer\endln
\lnie
\endln
\lnie
     svlbl is present only for a standard label assoc.\endln
\lnie
     it is a pointer to a system label routine (l$xxx).\endln
\lnie
     the vrlbl field of the corresponding vrblk points to\endln
\lnie
     the svlbl field of the svblk.\endln
\lnie
\endln
\lnie
svval                 system value pointer\endln
\lnie
\endln
\lnie
     svval is present only for a standard value.\endln
\lnie
     it is a pointer to the pattern node (ndxxx) which\endln
\lnie
     is the standard initial value of the variable.\endln
\lnie
     this value is copied to the vrval field of the vrblk\endln
\vfill\break

\lnie
\endln
\lnie
svblk (continued)\endln
\lnie
\endln
\lnie
keyword number table\endln
\lnie
\endln
\lnie
the following table gives symbolic names for keyword\endln
\lnie
numbers. these values are stored in the svknm field of\endln
\lnie
svblks and in the kvnum field of kvblks. see also\endln
\lnie
procedures asign, acess and kwnam.\endln
\lnie
\endln
\lnie
unprotected keywords with one word integer values\endln
\lnie
\endln
\inst{k$abe}{equ}{0}{abend}
\inst{k$anc}{equ}{k$abe+cfp$b}{anchor}
\ifmac{.culc}
\inst{k$cas}{equ}{k$anc+cfp$b}{case}
\inst{k$cod}{equ}{k$cas+cfp$b}{code}
\asmac{else}
\inst{k$cod}{equ}{k$anc+cfp$b}{code}
\asmac{fi}
\ifmac{.ccmk}
\inst{k$com}{equ}{k$cod+cfp$b}{compare}
\inst{k$dmp}{equ}{k$com+cfp$b}{dump}
\asmac{else}
\inst{k$dmp}{equ}{k$cod+cfp$b}{dump}
\asmac{fi}
\inst{k$erl}{equ}{k$dmp+cfp$b}{errlimit}
\inst{k$ert}{equ}{k$erl+cfp$b}{errtype}
\inst{k$ftr}{equ}{k$ert+cfp$b}{ftrace}
\inst{k$fls}{equ}{k$ftr+cfp$b}{fullscan}
\inst{k$inp}{equ}{k$fls+cfp$b}{input}
\inst{k$mxl}{equ}{k$inp+cfp$b}{maxlength}
\inst{k$oup}{equ}{k$mxl+cfp$b}{output}
\ifmac{.cnpf}
\inst{k$tra}{equ}{k$oup+cfp$b}{trace}
\asmac{else}
\inst{k$pfl}{equ}{k$oup+cfp$b}{profile}
\inst{k$tra}{equ}{k$pfl+cfp$b}{trace}
\asmac{fi}
\inst{k$trm}{equ}{k$tra+cfp$b}{trim}
\lnie
\endln
\lnie
protected keywords with one word integer values\endln
\lnie
\endln
\inst{k$fnc}{equ}{k$trm+cfp$b}{fnclevel}
\inst{k$lst}{equ}{k$fnc+cfp$b}{lastno}
\ifmac{.csln}
\inst{k$lln}{equ}{k$lst+cfp$b}{lastline}
\inst{k$lin}{equ}{k$lln+cfp$b}{line}
\inst{k$stn}{equ}{k$lin+cfp$b}{stno}
\asmac{else}
\inst{k$stn}{equ}{k$lst+cfp$b}{stno}
\asmac{fi}
\lnie
\endln
\lnie
keywords with constant pattern values\endln
\lnie
\endln
\inst{k$abo}{equ}{k$stn+cfp$b}{abort}
\inst{k$arb}{equ}{k$abo+pasi$}{arb}
\inst{k$bal}{equ}{k$arb+pasi$}{bal}
\inst{k$fal}{equ}{k$bal+pasi$}{fail}
\inst{k$fen}{equ}{k$fal+pasi$}{fence}
\inst{k$rem}{equ}{k$fen+pasi$}{rem}
\inst{k$suc}{equ}{k$rem+pasi$}{succeed}
\vfill\break

\lnie
\endln
\lnie
keyword number table (continued)\endln
\lnie
\endln
\lnie
special keywords\endln
\lnie
\endln
\inst{k$alp}{equ}{k$suc+1}{alphabet}
\inst{k$rtn}{equ}{k$alp+1}{rtntype}
\inst{k$stc}{equ}{k$rtn+1}{stcount}
\inst{k$etx}{equ}{k$stc+1}{errtext}
\ifmac{.csfn}
\inst{k$fil}{equ}{k$etx+1}{file}
\inst{k$lfl}{equ}{k$fil+1}{lastfile}
\inst{k$stl}{equ}{k$lfl+1}{stlimit}
\asmac{else}
\inst{k$stl}{equ}{k$etx+1}{stlimit}
\asmac{fi}
\ifmac{.culk}
\inst{k$lcs}{equ}{k$stl+1}{lcase}
\inst{k$ucs}{equ}{k$lcs+1}{ucase}
\asmac{fi}
\lnie
\endln
\lnie
relative offsets of special keywords\endln
\lnie
\endln
\inst{k$$al}{equ}{k$alp-k$alp}{alphabet}
\inst{k$$rt}{equ}{k$rtn-k$alp}{rtntype}
\inst{k$$sc}{equ}{k$stc-k$alp}{stcount}
\inst{k$$et}{equ}{k$etx-k$alp}{errtext}
\ifmac{.csfn}
\inst{k$$fl}{equ}{k$fil-k$alp}{file}
\inst{k$$lf}{equ}{k$lfl-k$alp}{lastfile}
\asmac{fi}
\inst{k$$sl}{equ}{k$stl-k$alp}{stlimit}
\ifmac{.culk}
\inst{k$$lc}{equ}{k$lcs-k$alp}{lcase}
\inst{k$$uc}{equ}{k$ucs-k$alp}{ucase}
\inst{k$$n$}{equ}{k$$uc+1}{number of special cases}
\asmac{else}
\inst{k$$n$}{equ}{k$$sl+1}{number of special cases}
\asmac{fi}
\lnie
\endln
\lnie
symbols used in asign and acess procedures\endln
\lnie
\endln
\inst{k$p$$}{equ}{k$fnc}{first protected keyword}
\inst{k$v$$}{equ}{k$abo}{first keyword with constant value}
\inst{k$s$$}{equ}{k$alp}{first keyword with special acess}
\vfill\break

\lnie
\endln
\lnie
format of a table block (tbblk)\endln
\lnie
\endln
\lnie
a table block is used to represent a table value.\endln
\lnie
it is built by a call to the table or convert functions.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                tbtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                idval               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                tblen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                tbinv               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                tbbuk               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{tbtyp}{equ}{0}{pointer to dummy routine b$tbt}
\inst{tblen}{equ}{offs2}{length of tbblk in bytes}
\inst{tbinv}{equ}{offs3}{default initial lookup value}
\inst{tbbuk}{equ}{tbinv+1}{start of hash bucket pointers}
\inst{tbsi$}{equ}{tbbuk}{size of standard fields in tbblk}
\inst{tbnbk}{equ}{11}{default no. of buckets}
\lnie
\endln
\lnie
the table block is a hash table which points to chains\endln
\lnie
of table element blocks representing the elements\endln
\lnie
in the table which hash into the same bucket.\endln
\lnie
\endln
\lnie
tbbuk entries either point to the first teblk on the\endln
\lnie
chain or they point to the tbblk itself to indicate the\endln
\lnie
end of the chain.\endln
\vfill\break

\lnie
\endln
\lnie
table element block (teblk)\endln
\lnie
\endln
\lnie
a table element is used to represent a single entry in\endln
\lnie
a table (see description of tbblk format for hash table)\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                tetyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                tesub               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                teval               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                tenxt               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{tetyp}{equ}{0}{pointer to dummy routine b$tet}
\inst{tesub}{equ}{tetyp+1}{subscript value}
\inst{teval}{equ}{tesub+1}{(=vrval) table element value}
\inst{tenxt}{equ}{teval+1}{link to next teblk}
\lnie
see s$cnv where relation is assumed with tenxt and tbbuk\endln
\inst{tesi$}{equ}{tenxt+1}{size of teblk in words}
\lnie
\endln
\lnie
tenxt points to the next teblk on the hash chain from the\endln
\lnie
tbbuk chain for this hash index. at the end of the chain,\endln
\lnie
tenxt points back to the start of the tbblk.\endln
\lnie
\endln
\lnie
teval contains a data pointer or a trblk pointer.\endln
\lnie
\endln
\lnie
tesub contains a data pointer.\endln
\vfill\break

\lnie
\endln
\lnie
trap block (trblk)\endln
\lnie
\endln
\lnie
a trap block is used to represent a trace or input or\endln
\lnie
output association in response to a call to the trace\endln
\lnie
input or output system functions. see below for details\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                tridn               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                trtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i  trval or trlbl or trnxt or trkvr  i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i       trtag or trter or trtrf      i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i            trfnc or trfpt          i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{tridn}{equ}{0}{pointer to dummy routine b$trt}
\inst{trtyp}{equ}{tridn+1}{trap type code}
\inst{trval}{equ}{trtyp+1}{value of trapped variable (=vrval)}
\inst{trnxt}{equ}{trval}{ptr to next trblk on trblk chain}
\inst{trlbl}{equ}{trval}{ptr to actual label (traced label)}
\inst{trkvr}{equ}{trval}{vrblk pointer for keyword trace}
\inst{trtag}{equ}{trval+1}{trace tag}
\inst{trter}{equ}{trtag}{ptr to terminal vrblk or null}
\inst{trtrf}{equ}{trtag}{ptr to trblk holding fcblk ptr}
\inst{trfnc}{equ}{trtag+1}{trace function vrblk (zero if none)}
\inst{trfpt}{equ}{trfnc}{fcblk ptr for sysio}
\inst{trsi$}{equ}{trfnc+1}{number of words in trblk}
\lnie
\endln
\inst{trtin}{equ}{0}{trace type for input association}
\inst{trtac}{equ}{trtin+1}{trace type for access trace}
\inst{trtvl}{equ}{trtac+1}{trace type for value trace}
\inst{trtou}{equ}{trtvl+1}{trace type for output association}
\inst{trtfc}{equ}{trtou+1}{trace type for fcblk identification}
\vfill\break

\lnie
\endln
\lnie
trap block (continued)\endln
\lnie
\endln
\lnie
variable input association\endln
\lnie
\endln
\lnie
     the value field of the variable points to a trblk\endln
\lnie
     instead of containing the data value. in the case\endln
\lnie
     of a natural variable, the vrget and vrsto fields\endln
\lnie
     contain =b$vra and =b$vrv to activate the check.\endln
\lnie
\endln
\lnie
     trtyp is set to trtin\endln
\lnie
     trnxt points to next trblk or trval has variable val\endln
\lnie
     trter is a pointer to svblk if association is\endln
\lnie
     for input, terminal, else it is null.\endln
\lnie
     trtrf points to the trap block which in turn points\endln
\lnie
     to an fcblk used for i/o association.\endln
\lnie
     trfpt is the fcblk ptr returned by sysio.\endln
\lnie
\endln
\lnie
variable access trace association\endln
\lnie
\endln
\lnie
     the value field of the variable points to a trblk\endln
\lnie
     instead of containing the data value. in the case\endln
\lnie
     of a natural variable, the vrget and vrsto fields\endln
\lnie
     contain =b$vra and =b$vrv to activate the check.\endln
\lnie
\endln
\lnie
     trtyp is set to trtac\endln
\lnie
     trnxt points to next trblk or trval has variable val\endln
\lnie
     trtag is the trace tag (0 if none)\endln
\lnie
     trfnc is the trace function vrblk ptr (0 if none)\endln
\lnie
\endln
\lnie
variable value trace association\endln
\lnie
\endln
\lnie
     the value field of the variable points to a trblk\endln
\lnie
     instead of containing the data value. in the case\endln
\lnie
     of a natural variable, the vrget and vrsto fields\endln
\lnie
     contain =b$vra and =b$vrv to activate the check.\endln
\lnie
\endln
\lnie
     trtyp is set to trtvl\endln
\lnie
     trnxt points to next trblk or trval has variable val\endln
\lnie
     trtag is the trace tag (0 if none)\endln
\lnie
     trfnc is the trace function vrblk ptr (0 if none)\endln
\vfill\break

\lnie
trap block (continued)\endln
\lnie
\endln
\lnie
variable output association\endln
\lnie
\endln
\lnie
     the value field of the variable points to a trblk\endln
\lnie
     instead of containing the data value. in the case\endln
\lnie
     of a natural variable, the vrget and vrsto fields\endln
\lnie
     contain =b$vra and =b$vrv to activate the check.\endln
\lnie
\endln
\lnie
     trtyp is set to trtou\endln
\lnie
     trnxt points to next trblk or trval has variable val\endln
\lnie
     trter is a pointer to svblk if association is\endln
\lnie
     for output, terminal, else it is null.\endln
\lnie
     trtrf points to the trap block which in turn points\endln
\lnie
     to an fcblk used for i/o association.\endln
\lnie
     trfpt is the fcblk ptr returned by sysio.\endln
\lnie
\endln
\lnie
function call trace\endln
\lnie
\endln
\lnie
     the pfctr field of the corresponding pfblk is set\endln
\lnie
     to point to a trblk.\endln
\lnie
\endln
\lnie
     trtyp is set to trtin\endln
\lnie
     trnxt is zero\endln
\lnie
     trtag is the trace tag (0 if none)\endln
\lnie
     trfnc is the trace function vrblk ptr (0 if none)\endln
\lnie
\endln
\lnie
function return trace\endln
\lnie
\endln
\lnie
     the pfrtr field of the corresponding pfblk is set\endln
\lnie
     to point to a trblk\endln
\lnie
\endln
\lnie
     trtyp is set to trtin\endln
\lnie
     trnxt is zero\endln
\lnie
     trtag is the trace tag (0 if none)\endln
\lnie
     trfnc is the trace function vrblk ptr (0 if none)\endln
\lnie
\endln
\lnie
label trace\endln
\lnie
\endln
\lnie
     the vrlbl of the vrblk for the label is\endln
\lnie
     changed to point to a trblk and the vrtra field is\endln
\lnie
     set to b$vrt to activate the check.\endln
\lnie
\endln
\lnie
     trtyp is set to trtin\endln
\lnie
     trlbl points to the actual label (cdblk) value\endln
\lnie
     trtag is the trace tag (0 if none)\endln
\lnie
     trfnc is the trace function vrblk ptr (0 if none)\endln
\vfill\break

\lnie
\endln
\lnie
trap block (continued)\endln
\lnie
\endln
\lnie
keyword trace\endln
\lnie
\endln
\lnie
     keywords which can be traced possess a unique\endln
\lnie
     location which is zero if there is no trace and\endln
\lnie
     points to a trblk if there is a trace. the locations\endln
\lnie
     are as follows.\endln
\lnie
\endln
\lnie
     r$ert            errtype\endln
\lnie
     r$fnc            fnclevel\endln
\lnie
     r$stc            stcount\endln
\lnie
\endln
\lnie
     the format of the trblk is as follows.\endln
\lnie
\endln
\lnie
     trtyp is set to trtin\endln
\lnie
     trkvr is a pointer to the vrblk for the keyword\endln
\lnie
     trtag is the trace tag (0 if none)\endln
\lnie
     trfnc is the trace function vrblk ptr (0 if none)\endln
\lnie
\endln
\lnie
input/output file arg1 trap block\endln
\lnie
\endln
\lnie
     the value field of the variable points to a trblk\endln
\lnie
     instead of containing the data value. in the case of\endln
\lnie
     a natural variable, the vrget and vrsto fields\endln
\lnie
     contain =b$vra and =b$vrv. this trap block is used\endln
\lnie
     to hold a pointer to the fcblk which an\endln
\lnie
     implementation may request to hold information\endln
\lnie
     about a file.\endln
\lnie
\endln
\lnie
     trtyp is set to trtfc\endln
\lnie
     trnext points to next trblk or trval is variable val\endln
\lnie
     trfnm is 0\endln
\lnie
     trfpt is the fcblk pointer.\endln
\lnie
\endln
\lnie
note that when multiple traps are set on a variable\endln
\lnie
the order is in ascending value of trtyp field.\endln
\lnie
\endln
\lnie
input association (if present)\endln
\lnie
access trace (if present)\endln
\lnie
value trace (if present)\endln
\lnie
output association (if present)\endln
\lnie
\endln
\lnie
the actual value of the variable is stored in the trval\endln
\lnie
field of the last trblk on the chain.\endln
\lnie
\endln
\lnie
this implementation does not permit trace or i/o\endln
\lnie
associations to any of the pseudo-variables.\endln
\vfill\break

\lnie
\endln
\lnie
vector block (vcblk)\endln
\lnie
\endln
\lnie
a vcblk is used to represent an array value which has\endln
\lnie
one dimension whose lower bound is one. all other arrays\endln
\lnie
are represented by arblks. a vcblk is created by the\endln
\lnie
system function array (s$arr) when passed an integer arg.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vctyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                idval               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vclen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vcvls               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{vctyp}{equ}{0}{pointer to dummy routine b$vct}
\inst{vclen}{equ}{offs2}{length of vcblk in bytes}
\inst{vcvls}{equ}{offs3}{start of vector values}
\inst{vcsi$}{equ}{vcvls}{size of standard fields in vcblk}
\inst{vcvlb}{equ}{vcvls-1}{offset one word behind vcvls}
\inst{vctbd}{equ}{tbsi$-vcsi$}{difference in sizes - see prtvl}
\lnie
\endln
\lnie
vcvls are either data pointers or trblk pointers\endln
\lnie
\endln
\lnie
the dimension can be deduced from vclen.\endln
\vfill\break

\lnie
\endln
\lnie
variable block (vrblk)\endln
\lnie
\endln
\lnie
a variable block is built in the static memory area\endln
\lnie
for every variable referenced or created by a program.\endln
\lnie
the order of fields is assumed in the model vrblk stnvr.\endln
\lnie
\endln
\lnie
note that since these blocks only occur in the static\endln
\lnie
region, it is permissible to point to any word in\endln
\lnie
the block and this is used to provide three distinct\endln
\lnie
access points from the generated code as follows.\endln
\lnie
\endln
\lnie
1)   point to vrget (first word of vrblk) to load the\endln
\lnie
     value of the variable onto the main stack.\endln
\lnie
\endln
\lnie
2)   point to vrsto (second word of vrblk) to store the\endln
\lnie
     top stack element as the value of the variable.\endln
\lnie
\endln
\lnie
3)   point to vrtra (fourth word of vrblk) to jump to\endln
\lnie
     the label associated with the variable name.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrget               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrsto               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrval               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrtra               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrlbl               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrfnc               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrnxt               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                vrlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /            vrchs = vrsvp           /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\vfill\break

\lnie
\endln
\lnie
variable block (continued)\endln
\lnie
\endln
\inst{vrget}{equ}{0}{pointer to routine to load value}
\inst{vrsto}{equ}{vrget+1}{pointer to routine to store value}
\inst{vrval}{equ}{vrsto+1}{variable value}
\inst{vrvlo}{equ}{vrval-vrsto}{offset to value from store field}
\inst{vrtra}{equ}{vrval+1}{pointer to routine to jump to label}
\inst{vrlbl}{equ}{vrtra+1}{pointer to code for label}
\inst{vrlbo}{equ}{vrlbl-vrtra}{offset to label from transfer field}
\inst{vrfnc}{equ}{vrlbl+1}{pointer to function block}
\inst{vrnxt}{equ}{vrfnc+1}{pointer to next vrblk on hash chain}
\inst{vrlen}{equ}{vrnxt+1}{length of name (or zero)}
\inst{vrchs}{equ}{vrlen+1}{characters of name (vrlen gt 0)}
\inst{vrsvp}{equ}{vrlen+1}{ptr to svblk (vrlen eq 0)}
\inst{vrsi$}{equ}{vrchs+1}{number of standard fields in vrblk}
\inst{vrsof}{equ}{vrlen-sclen}{offset to dummy scblk for name}
\inst{vrsvo}{equ}{vrsvp-vrsof}{pseudo-offset to vrsvp field}
\lnie
\endln
\lnie
vrget = b$vrl if not input associated or access traced\endln
\lnie
vrget = b$vra if input associated or access traced\endln
\lnie
\endln
\lnie
vrsto = b$vrs if not output associated or value traced\endln
\lnie
vrsto = b$vrv if output associated or value traced\endln
\lnie
vrsto = b$vre if value is protected pattern value\endln
\lnie
\endln
\lnie
vrval points to the appropriate value unless the\endln
\lnie
variable is i/o/trace associated in which case, vrval\endln
\lnie
points to an appropriate trblk (trap block) chain.\endln
\lnie
\endln
\lnie
vrtra = b$vrg if the label is not traced\endln
\lnie
vrtra = b$vrt if the label is traced\endln
\lnie
\endln
\lnie
vrlbl points to a cdblk if there is a label\endln
\lnie
vrlbl points to the svblk svlbl field for a system label\endln
\lnie
vrlbl points to stndl for an undefined label\endln
\lnie
vrlbl points to a trblk if the label is traced\endln
\lnie
\endln
\lnie
vrfnc points to a ffblk for a field function\endln
\lnie
vrfnc points to a dfblk for a datatype function\endln
\lnie
vrfnc points to a pfblk for a program defined function\endln
\lnie
vrfnc points to a efblk for an external loaded function\endln
\lnie
vrfnc points to svfnc (svblk) for a system function\endln
\lnie
vrfnc points to stndf if the function is undefined\endln
\lnie
\endln
\lnie
vrnxt points to the next vrblk on this chain unless\endln
\lnie
this is the end of the chain in which case it is zero.\endln
\lnie
\endln
\lnie
vrlen is the name length for a non-system variable.\endln
\lnie
vrlen is zero for a system variable.\endln
\lnie
\endln
\lnie
vrchs is the name (ljrz) if vrlen is non-zero.\endln
\lnie
vrsvp is a ptr to the svblk if vrlen is zero.\endln
\vfill\break

\lnie
\endln
\lnie
format of a non-relocatable external block (xnblk)\endln
\lnie
\endln
\lnie
an xnblk is a block representing an unknown (external)\endln
\lnie
data value. the block contains no pointers to other\endln
\lnie
relocatable blocks. an xnblk is used by external function\endln
\lnie
processing or possibly for system i/o routines etc.\endln
\lnie
the macro-system itself does not use xnblks.\endln
\lnie
this type of block may be used as a file control block.\endln
\lnie
see sysfc,sysin,sysou,s$inp,s$oup for details.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                xntyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                xnlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                xndta               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{xntyp}{equ}{0}{pointer to dummy routine b$xnt}
\inst{xnlen}{equ}{xntyp+1}{length of xnblk in bytes}
\inst{xndta}{equ}{xnlen+1}{data words}
\inst{xnsi$}{equ}{xndta}{size of standard fields in xnblk}
\lnie
\endln
\lnie
note that the term non-relocatable refers to the contents\endln
\lnie
and not the block itself. an xnblk can be moved around if\endln
\lnie
it is built in the dynamic memory area.\endln
\vfill\break

\lnie
\endln
\lnie
relocatable external block (xrblk)\endln
\lnie
\endln
\lnie
an xrblk is a block representing an unknown (external)\endln
\lnie
data value. the data area in this block consists only\endln
\lnie
of address values and any addresses pointing into the\endln
\lnie
dynamic memory area must point to the start of other\endln
\lnie
data blocks. see also description of xnblk.\endln
\lnie
this type of block may be used as a file control block.\endln
\lnie
see sysfc,sysin,sysou,s$inp,s$oup for details.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                xrtyp               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                xrlen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     /                                    /\endln
\lnie
     /                xrptr               /\endln
\lnie
     /                                    /\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\inst{xrtyp}{equ}{0}{pointer to dummy routine b$xrt}
\inst{xrlen}{equ}{xrtyp+1}{length of xrblk in bytes}
\inst{xrptr}{equ}{xrlen+1}{start of address pointers}
\inst{xrsi$}{equ}{xrptr}{size of standard fields in xrblk}
\vfill\break

\lnie
\endln
\lnie
s$cnv (convert) function switch constants.  the values\endln
\lnie
are tied to the order of the entries in the svctb table\endln
\lnie
and hence to the branch table in s$cnv.\endln
\lnie
\endln
\inst{cnvst}{equ}{8}{max standard type code for convert}
\ifmac{.cnra}
\inst{cnvrt}{equ}{cnvst}{no reals - same as standard types}
\asmac{else}
\inst{cnvrt}{equ}{cnvst+1}{convert code for reals}
\asmac{fi}
\ifmac{.cnbf}
\inst{cnvbt}{equ}{cnvrt}{no buffers - same as real code}
\asmac{else}
\inst{cnvbt}{equ}{cnvrt+1}{convert code for buffer}
\asmac{fi}
\inst{cnvtt}{equ}{cnvbt+1}{bsw code for convert}
\lnie
\endln
\lnie
input image length\endln
\lnie
\endln
\inst{iniln}{equ}{1024}{default image length for compiler}
\inst{inils}{equ}{1024}{image length if -sequ in effect}
\lnie
\endln
\inst{ionmb}{equ}{2}{name base used for iochn in sysio}
\inst{ionmo}{equ}{4}{name offset used for iochn in sysio}
\lnie
\endln
\lnie
minimum value for keyword maxlngth\endln
\lnie
should be larger than iniln\endln
\lnie
\endln
\inst{mnlen}{equ}{1024}{min value allowed keyword maxlngth}
\inst{mxern}{equ}{329}{err num inadequate startup memory}
\lnie
\endln
\lnie
in general, meaningful mnemonics should be used for\endln
\lnie
offsets. however for small integers used often in\endln
\lnie
literals the following general definitions are provided.\endln
\lnie
\endln
\inst{num01}{equ}{329}{}
\inst{num02}{equ}{329}{}
\inst{num03}{equ}{329}{}
\inst{num04}{equ}{329}{}
\inst{num05}{equ}{329}{}
\inst{num06}{equ}{329}{}
\inst{num07}{equ}{329}{}
\inst{num08}{equ}{329}{}
\inst{num09}{equ}{329}{}
\inst{num10}{equ}{329}{}
\inst{nm320}{equ}{329}{}
\inst{nm321}{equ}{329}{}
\inst{nini8}{equ}{329}{}
\inst{nini9}{equ}{329}{}
\inst{thsnd}{equ}{329}{}
\vfill\break

\lnie
\endln
\lnie
numbers of undefined spitbol operators\endln
\lnie
\endln
\inst{opbun}{equ}{5}{no. of binary undefined ops}
\inst{opuun}{equ}{6}{no of unary undefined ops}
\lnie
\endln
\lnie
offsets used in prtsn, prtmi and acess\endln
\lnie
\endln
\inst{prsnf}{equ}{13}{offset used in prtsn}
\inst{prtmf}{equ}{21}{offset to col 21 (prtmi)}
\inst{rilen}{equ}{1024}{buffer length for sysri}
\lnie
\endln
\lnie
codes for stages of processing\endln
\lnie
\endln
\inst{stgic}{equ}{0}{initial compile}
\inst{stgxc}{equ}{stgic+1}{execution compile (code)}
\inst{stgev}{equ}{stgxc+1}{expression eval during execution}
\inst{stgxt}{equ}{stgev+1}{execution time}
\inst{stgce}{equ}{stgxt+1}{initial compile after end line}
\inst{stgxe}{equ}{stgce+1}{exec. compile after end line}
\inst{stgnd}{equ}{stgce-stgic}{difference in stage after end}
\inst{stgee}{equ}{stgxe+1}{eval evaluating expression}
\inst{stgno}{equ}{stgee+1}{number of codes}
\vfill\break

\lnie
\endln
\lnie
\endln
\lnie
statement number pad count for listr\endln
\lnie
\endln
\ifmac{.csn6}
\inst{stnpd}{equ}{6}{statement no. pad count}
\asmac{fi}
\ifmac{.csn8}
\inst{stnpd}{equ}{8}{statement no. pad count}
\asmac{fi}
\ifmac{.csn5}
\inst{stnpd}{equ}{5}{statement no. pad count}
\asmac{fi}
\lnie
\endln
\lnie
syntax type codes\endln
\lnie
\endln
\lnie
these codes are returned from the scane procedure.\endln
\lnie
\endln
\lnie
they are spaced 3 apart for the benefit of expan.\endln
\lnie
\endln
\inst{t$uop}{equ}{0}{unary operator}
\inst{t$lpr}{equ}{t$uop+3}{left paren}
\inst{t$lbr}{equ}{t$lpr+3}{left bracket}
\inst{t$cma}{equ}{t$lbr+3}{comma}
\inst{t$fnc}{equ}{t$cma+3}{function call}
\inst{t$var}{equ}{t$fnc+3}{variable}
\inst{t$con}{equ}{t$var+3}{constant}
\inst{t$bop}{equ}{t$con+3}{binary operator}
\inst{t$rpr}{equ}{t$bop+3}{right paren}
\inst{t$rbr}{equ}{t$rpr+3}{right bracket}
\inst{t$col}{equ}{t$rbr+3}{colon}
\inst{t$smc}{equ}{t$col+3}{semi-colon}
\lnie
\endln
\lnie
the following definitions are used only in the goto field\endln
\lnie
\endln
\inst{t$fgo}{equ}{t$smc+1}{failure goto}
\inst{t$sgo}{equ}{t$fgo+1}{success goto}
\lnie
\endln
\lnie
the above codes are grouped so that codes for elements\endln
\lnie
which can legitimately immediately precede a unary\endln
\lnie
operator come first to facilitate operator syntax check.\endln
\lnie
\endln
\inst{t$uok}{equ}{t$fnc}{last code ok before unary operator}
\vfill\break

\lnie
\endln
\lnie
definitions of values for expan jump table\endln
\lnie
\endln
\inst{t$uo0}{equ}{t$uop+0}{unary operator, state zero}
\inst{t$uo1}{equ}{t$uop+1}{unary operator, state one}
\inst{t$uo2}{equ}{t$uop+2}{unary operator, state two}
\inst{t$lp0}{equ}{t$lpr+0}{left paren, state zero}
\inst{t$lp1}{equ}{t$lpr+1}{left paren, state one}
\inst{t$lp2}{equ}{t$lpr+2}{left paren, state two}
\inst{t$lb0}{equ}{t$lbr+0}{left bracket, state zero}
\inst{t$lb1}{equ}{t$lbr+1}{left bracket, state one}
\inst{t$lb2}{equ}{t$lbr+2}{left bracket, state two}
\inst{t$cm0}{equ}{t$cma+0}{comma, state zero}
\inst{t$cm1}{equ}{t$cma+1}{comma, state one}
\inst{t$cm2}{equ}{t$cma+2}{comma, state two}
\inst{t$fn0}{equ}{t$fnc+0}{function call, state zero}
\inst{t$fn1}{equ}{t$fnc+1}{function call, state one}
\inst{t$fn2}{equ}{t$fnc+2}{function call, state two}
\inst{t$va0}{equ}{t$var+0}{variable, state zero}
\inst{t$va1}{equ}{t$var+1}{variable, state one}
\inst{t$va2}{equ}{t$var+2}{variable, state two}
\inst{t$co0}{equ}{t$con+0}{constant, state zero}
\inst{t$co1}{equ}{t$con+1}{constant, state one}
\inst{t$co2}{equ}{t$con+2}{constant, state two}
\inst{t$bo0}{equ}{t$bop+0}{binary operator, state zero}
\inst{t$bo1}{equ}{t$bop+1}{binary operator, state one}
\inst{t$bo2}{equ}{t$bop+2}{binary operator, state two}
\inst{t$rp0}{equ}{t$rpr+0}{right paren, state zero}
\inst{t$rp1}{equ}{t$rpr+1}{right paren, state one}
\inst{t$rp2}{equ}{t$rpr+2}{right paren, state two}
\inst{t$rb0}{equ}{t$rbr+0}{right bracket, state zero}
\inst{t$rb1}{equ}{t$rbr+1}{right bracket, state one}
\inst{t$rb2}{equ}{t$rbr+2}{right bracket, state two}
\inst{t$cl0}{equ}{t$col+0}{colon, state zero}
\inst{t$cl1}{equ}{t$col+1}{colon, state one}
\inst{t$cl2}{equ}{t$col+2}{colon, state two}
\inst{t$sm0}{equ}{t$smc+0}{semicolon, state zero}
\inst{t$sm1}{equ}{t$smc+1}{semicolon, state one}
\inst{t$sm2}{equ}{t$smc+2}{semicolon, state two}
\lnie
\endln
\inst{t$nes}{equ}{t$sm2+1}{number of entries in branch table}
\vfill\break

\lnie
\endln
\lnie
 definition of offsets used in control card processing\endln
\lnie
\endln
\ifmac{.culc}
\inst{cc$ca}{equ}{0}{-case}
\inst{cc$do}{equ}{cc$ca+1}{-double}
\asmac{else}
\inst{cc$do}{equ}{0}{-double}
\asmac{fi}
\ifmac{.ccmk}
\inst{cc$co}{equ}{cc$do+1}{-compare}
\inst{cc$du}{equ}{cc$co+1}{-dump}
\asmac{else}
\inst{cc$du}{equ}{cc$do+1}{-dump}
\asmac{fi}
\ifmac{.cinc}
\inst{cc$cp}{equ}{cc$du+1}{-copy}
\inst{cc$ej}{equ}{cc$cp+1}{-eject}
\asmac{else}
\inst{cc$ej}{equ}{cc$du+1}{-eject}
\asmac{fi}
\inst{cc$er}{equ}{cc$ej+1}{-errors}
\inst{cc$ex}{equ}{cc$er+1}{-execute}
\inst{cc$fa}{equ}{cc$ex+1}{-fail}
\ifmac{.cinc}
\inst{cc$in}{equ}{cc$fa+1}{-include}
\ifmac{.csln}
\inst{cc$ln}{equ}{cc$in+1}{-line}
\inst{cc$li}{equ}{cc$ln+1}{-list}
\asmac{else}
\inst{cc$li}{equ}{cc$in+1}{-list}
\asmac{fi}
\asmac{else}
\ifmac{.csln}
\inst{cc$ln}{equ}{cc$fa+1}{-line}
\inst{cc$li}{equ}{cc$ln+1}{-list}
\asmac{else}
\inst{cc$li}{equ}{cc$fa+1}{-list}
\asmac{fi}
\asmac{fi}
\inst{cc$nr}{equ}{cc$li+1}{-noerrors}
\inst{cc$nx}{equ}{cc$nr+1}{-noexecute}
\inst{cc$nf}{equ}{cc$nx+1}{-nofail}
\inst{cc$nl}{equ}{cc$nf+1}{-nolist}
\inst{cc$no}{equ}{cc$nl+1}{-noopt}
\inst{cc$np}{equ}{cc$no+1}{-noprint}
\inst{cc$op}{equ}{cc$np+1}{-optimise}
\inst{cc$pr}{equ}{cc$op+1}{-print}
\inst{cc$si}{equ}{cc$pr+1}{-single}
\inst{cc$sp}{equ}{cc$si+1}{-space}
\inst{cc$st}{equ}{cc$sp+1}{-stitl}
\inst{cc$ti}{equ}{cc$st+1}{-title}
\inst{cc$tr}{equ}{cc$ti+1}{-trace}
\inst{cc$nc}{equ}{cc$tr+1}{number of control cards}
\inst{ccnoc}{equ}{4}{no. of chars included in match}
\inst{ccofs}{equ}{7}{offset to start of title/subtitle}
\ifmac{.cinc}
\inst{ccinm}{equ}{9}{max depth of include file nesting}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
definitions of stack offsets used in cmpil procedure\endln
\lnie
\endln
\lnie
see description at start of cmpil procedure for details\endln
\lnie
of use of these locations on the stack.\endln
\lnie
\endln
\inst{cmstm}{equ}{0}{tree for statement body}
\inst{cmsgo}{equ}{cmstm+1}{tree for success goto}
\inst{cmfgo}{equ}{cmsgo+1}{tree for fail goto}
\inst{cmcgo}{equ}{cmfgo+1}{conditional goto flag}
\inst{cmpcd}{equ}{cmcgo+1}{previous cdblk pointer}
\inst{cmffp}{equ}{cmpcd+1}{failure fill in flag for previous}
\inst{cmffc}{equ}{cmffp+1}{failure fill in flag for current}
\inst{cmsop}{equ}{cmffc+1}{success fill in offset for previous}
\inst{cmsoc}{equ}{cmsop+1}{success fill in offset for current}
\inst{cmlbl}{equ}{cmsoc+1}{ptr to vrblk for current label}
\inst{cmtra}{equ}{cmlbl+1}{ptr to entry cdblk}
\lnie
\endln
\inst{cmnen}{equ}{cmtra+1}{count of stack entries for cmpil}
\ifmac{.cnpf}
\asmac{else}
\lnie
\endln
\lnie
a few constants used by the profiler\endln
\inst{pfpd1}{equ}{8}{pad positions ...}
\inst{pfpd2}{equ}{20}{... for profile ...}
\inst{pfpd3}{equ}{32}{... printout}
\inst{pf$i2}{equ}{cfp$i+cfp$i}{size of table entry (2 ints)}
\asmac{fi}
\ifmac{.crel}
\vfill\break

\lnie
\endln
\lnie
definition of limits and adjustments that are built by\endln
\lnie
relcr for use by the routines that relocate pointers\endln
\lnie
after a save file is reloaded.  see reloc etc. for usage.\endln
\lnie
\endln
\lnie
a block of information is built that is used in\endln
\lnie
relocating pointers.  there are rnsi$ instances\endln
\lnie
of a rssi$ word structure.  each instance corresponds\endln
\lnie
to one of the regions that a pointer might point into.\endln
\lnie
\endln
\lnie
each structure takes the form:\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i    address past end of section     i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i  adjustment from old to new adrs   i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i    address of start of section     i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\lnie
the instances are ordered thusly:\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i           dynamic storage          i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i           static storage           i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i       working section globals      i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i          constant section          i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i            code section            i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\lnie
symbolic names for these locations as offsets from\endln
\lnie
the first entry are provided here.\endln
\lnie
\endln
\lnie
definitions within a section\endln
\lnie
\endln
\inst{rlend}{equ}{0}{end}
\inst{rladj}{equ}{rlend+1}{adjustment}
\inst{rlstr}{equ}{rladj+1}{start}
\inst{rssi$}{equ}{rlstr+1}{size of section}
\inst{rnsi$}{equ}{5}{number of structures}
\lnie
\endln
\lnie
overall definitions of all structures\endln
\lnie
\endln
\inst{rldye}{equ}{0}{dynamic region end}
\inst{rldya}{equ}{rldye+1}{dynamic region adjustment}
\inst{rldys}{equ}{rldya+1}{dynamic region start}
\inst{rlste}{equ}{rldys+1}{static region end}
\inst{rlsta}{equ}{rlste+1}{static region adjustment}
\inst{rlsts}{equ}{rlsta+1}{static region start}
\inst{rlwke}{equ}{rlsts+1}{working section globals end}
\inst{rlwka}{equ}{rlwke+1}{working section globals adjustment}
\inst{rlwks}{equ}{rlwka+1}{working section globals start}
\inst{rlcne}{equ}{rlwks+1}{constants section end}
\inst{rlcna}{equ}{rlcne+1}{constants section adjustment}
\inst{rlcns}{equ}{rlcna+1}{constants section start}
\inst{rlcde}{equ}{rlcns+1}{code section end}
\inst{rlcda}{equ}{rlcde+1}{code section adjustment}
\inst{rlcds}{equ}{rlcda+1}{code section start}
\inst{rlsi$}{equ}{rlcds+1}{number of fields in structure}
\asmac{fi}
\lnie
\endln
\vfill\break
{\bf spitbol--\rm constant section}
\vskip1em
\lnie
\endln
\lnie
this section consists entirely of assembled constants.\endln
\lnie
\endln
\lnie
all label names are five letters. the order is\endln
\lnie
approximately alphabetical, but in some cases (always\endln
\lnie
documented), constants must be placed in some special\endln
\lnie
order which must not be disturbed.\endln
\lnie
\endln
\lnie
it must also be remembered that there is a requirement\endln
\lnie
for no forward references which also disturbs the\endln
\lnie
alphabetical order in some cases.\endln
\lnie
\endln
\inst{}{sec}{}{start of constant section}
\lnie
\endln
\lnie
start of constant section\endln
\lnie
\endln
\inst{c$aaa}{dac}{0}{first location of constant section}
\lnie
\endln
\lnie
free store percentage (used by alloc)\endln
\lnie
\endln
\inst{alfsp}{dac}{e$fsp}{free store percentage}
\lnie
\endln
\lnie
bit constants for general use\endln
\lnie
\endln
\inst{bits0}{dbc}{0}{all zero bits}
\inst{bits1}{dbc}{1}{one bit in low order position}
\inst{bits2}{dbc}{2}{bit in position 2}
\inst{bits3}{dbc}{4}{bit in position 3}
\inst{bits4}{dbc}{8}{bit in position 4}
\inst{bits5}{dbc}{16}{bit in position 5}
\inst{bits6}{dbc}{32}{bit in position 6}
\inst{bits7}{dbc}{64}{bit in position 7}
\inst{bits8}{dbc}{128}{bit in position 8}
\inst{bits9}{dbc}{256}{bit in position 9}
\inst{bit10}{dbc}{512}{bit in position 10}
\inst{bit11}{dbc}{1024}{bit in position 11}
\inst{bit12}{dbc}{2048}{bit in position 12}
\inst{bitsm}{dbc}{cfp$m}{mask for max integer}
\lnie
\endln
\lnie
bit constants for svblk (svbit field) tests\endln
\lnie
\endln
\inst{btfnc}{dbc}{svfnc}{bit to test for function}
\inst{btknm}{dbc}{svknm}{bit to test for keyword number}
\inst{btlbl}{dbc}{svlbl}{bit to test for label}
\inst{btffc}{dbc}{svffc}{bit to test for fast call}
\inst{btckw}{dbc}{svckw}{bit to test for constant keyword}
\inst{btkwv}{dbc}{svkwv}{bits to test for keword with value}
\inst{btprd}{dbc}{svprd}{bit to test for predicate function}
\inst{btpre}{dbc}{svpre}{bit to test for preevaluation}
\inst{btval}{dbc}{svval}{bit to test for value}
\vfill\break

\lnie
\endln
\lnie
list of names used for control card processing\endln
\lnie
\endln
\ifmac{.culc}
\inst{ccnms}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\asmac{else}
\inst{ccnms}{dtc}{svval}{}
\asmac{fi}
\ifmac{.ccmk}
\inst{}{dtc}{svval}{}
\asmac{fi}
\inst{}{dtc}{svval}{}
\ifmac{.cinc}
\inst{}{dtc}{svval}{}
\asmac{fi}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\ifmac{.cinc}
\inst{}{dtc}{svval}{}
\asmac{fi}
\ifmac{.csln}
\inst{}{dtc}{svval}{}
\asmac{fi}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\inst{}{dtc}{svval}{}
\lnie
\endln
\lnie
header messages for dumpr procedure (scblk format)\endln
\lnie
\endln
\inst{dmhdk}{dac}{b$scl}{dump of keyword values}
\inst{}{dac}{b$scl}{dump of keyword values}
\inst{}{dtc}{/dump of keyword}{values/}
\lnie
\endln
\inst{dmhdv}{dac}{b$scl}{dump of natural variables}
\inst{}{dac}{b$scl}{dump of natural variables}
\inst{}{dtc}{/dump of natural}{variables/}
\vfill\break

\lnie
\endln
\lnie
message text for compilation statistics\endln
\lnie
\endln
\inst{encm1}{dac}{/dump of natural}{}
\ifmac{.cbyt}
\inst{}{dac}{/dump of natural}{}
\inst{}{dtc}{/dump of natural}{}
\lnie
\endln
\inst{encm2}{dac}{/dump of natural}{}
\inst{}{dac}{/dump of natural}{}
\inst{}{dtc}{/dump of natural}{}
\asmac{else}
\inst{}{dac}{/dump of natural}{}
\inst{}{dtc}{/dump of natural}{}
\lnie
\endln
\inst{encm2}{dac}{/dump of natural}{}
\inst{}{dac}{/dump of natural}{}
\inst{}{dtc}{/dump of natural}{}
\asmac{fi}
\lnie
\endln
\inst{encm3}{dac}{/dump of natural}{}
\inst{}{dac}{/dump of natural}{}
\inst{}{dtc}{/dump of natural}{}
\lnie
\endln
\inst{encm4}{dac}{/dump of natural}{}
\ifmac{.ctmd}
\inst{}{dac}{/dump of natural}{}
\inst{}{dtc}{/dump of natural}{}
\asmac{else}
\inst{}{dac}{/dump of natural}{}
\inst{}{dtc}{/dump of natural}{}
\asmac{fi}
\lnie
\endln
\inst{encm5}{dac}{b$scl}{execution suppressed}
\inst{}{dac}{b$scl}{execution suppressed}
\inst{}{dtc}{b$scl}{execution suppressed}
\lnie
\endln
\lnie
string constant for abnormal end\endln
\lnie
\endln
\inst{endab}{dac}{b$scl}{}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\vfill\break

\lnie
\endln
\lnie
memory overflow during initialisation\endln
\lnie
\endln
\inst{endmo}{dac}{b$scl}{}
\inst{endml}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\lnie
\endln
\lnie
string constant for message issued by l$end\endln
\lnie
\endln
\inst{endms}{dac}{b$scl}{}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\lnie
\endln
\lnie
fail message for stack fail section\endln
\lnie
\endln
\inst{endso}{dac}{b$scl}{stack overflow in garbage collector}
\inst{}{dac}{b$scl}{stack overflow in garbage collector}
\inst{}{dtc}{/stack overflow in}{garbage collection/}
\lnie
\endln
\lnie
string constant for time up\endln
\lnie
\endln
\inst{endtu}{dac}{/stack overflow inin}{}
\inst{}{dac}{/stack overflow ininin}{}
\inst{}{dtc}{/stack overflow inininin}{}
\vfill\break

\lnie
\endln
\lnie
string constant for error message (error section)\endln
\lnie
\endln
\inst{ermms}{dac}{b$scl}{error}
\inst{}{dac}{b$scl}{error}
\inst{}{dtc}{b$scl}{error}
\lnie
\endln
\inst{ermns}{dac}{b$scl}{string / -- /}
\inst{}{dac}{b$scl}{string / -- /}
\inst{}{dtc}{b$scl}{string / -- /}
\lnie
\endln
\lnie
string constant for page numbering\endln
\lnie
\endln
\inst{lstms}{dac}{b$scl}{page}
\inst{}{dac}{b$scl}{page}
\inst{}{dtc}{b$scl}{page}
\lnie
\endln
\lnie
listing header message\endln
\lnie
\endln
\inst{headr}{dac}{b$scl}{}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{/macro spitbol version}{3.7/}
\lnie
\endln
\inst{headv}{dac}{b$scl}{for exit() version no. check}
\inst{}{dac}{b$scl}{for exit() version no. check}
\inst{}{dtc}{b$scl}{for exit() version no. check}
\ifmac{.csed}
\lnie
free store percentage (used by gbcol)\endln
\lnie
\endln
\inst{gbsdp}{dac}{e$sed}{sediment percentage}
\asmac{fi}
\lnie
\endln
\lnie
integer constants for general use\endln
\lnie
icbld optimisation uses the first three.\endln
\lnie
\endln
\inst{int$r}{dac}{e$sed}{}
\inst{intv0}{dic}{+0}{0}
\inst{inton}{dac}{+0}{0}
\inst{intv1}{dic}{+1}{1}
\inst{inttw}{dac}{+1}{1}
\inst{intv2}{dic}{+2}{2}
\inst{intvt}{dic}{+10}{10}
\inst{intvh}{dic}{+100}{100}
\inst{intth}{dic}{+1000}{1000}
\lnie
\endln
\lnie
table used in icbld optimisation\endln
\lnie
\endln
\inst{intab}{dac}{int$r}{pointer to 0}
\inst{}{dac}{inton}{pointer to 1}
\inst{}{dac}{inttw}{pointer to 2}
\vfill\break

\lnie
\endln
\lnie
special pattern nodes. the following pattern nodes\endln
\lnie
consist simply of a pcode pointer, see match routines\endln
\lnie
(p$xxx) for full details of their use and format).\endln
\lnie
\endln
\inst{ndabb}{dac}{p$abb}{arbno}
\inst{ndabd}{dac}{p$abd}{arbno}
\inst{ndarc}{dac}{p$arc}{arb}
\inst{ndexb}{dac}{p$exb}{expression}
\inst{ndfnb}{dac}{p$fnb}{fence()}
\inst{ndfnd}{dac}{p$fnd}{fence()}
\inst{ndexc}{dac}{p$exc}{expression}
\inst{ndimb}{dac}{p$imb}{immediate assignment}
\inst{ndimd}{dac}{p$imd}{immediate assignment}
\inst{ndnth}{dac}{p$nth}{pattern end (null pattern)}
\inst{ndpab}{dac}{p$pab}{pattern assignment}
\inst{ndpad}{dac}{p$pad}{pattern assignment}
\inst{nduna}{dac}{p$una}{anchor point movement}
\lnie
\endln
\lnie
keyword constant pattern nodes. the following nodes are\endln
\lnie
used as the values of pattern keywords and the initial\endln
\lnie
values of the corresponding natural variables. all\endln
\lnie
nodes are in p0blk format and the order is tied to the\endln
\lnie
definitions of corresponding k$xxx symbols.\endln
\lnie
\endln
\inst{ndabo}{dac}{p$abo}{abort}
\inst{}{dac}{p$abo}{abort}
\inst{ndarb}{dac}{p$arb}{arb}
\inst{}{dac}{p$arb}{arb}
\inst{ndbal}{dac}{p$bal}{bal}
\inst{}{dac}{p$bal}{bal}
\inst{ndfal}{dac}{p$fal}{fail}
\inst{}{dac}{p$fal}{fail}
\inst{ndfen}{dac}{p$fen}{fence}
\inst{}{dac}{p$fen}{fence}
\inst{ndrem}{dac}{p$rem}{rem}
\inst{}{dac}{p$rem}{rem}
\inst{ndsuc}{dac}{p$suc}{succeed}
\inst{}{dac}{p$suc}{succeed}
\lnie
\endln
\lnie
null string. all null values point to this string. the\endln
\lnie
svchs field contains a blank to provide for easy default\endln
\lnie
processing in trace, stoptr, lpad and rpad.\endln
\lnie
nullw contains 10 blanks which ensures an all blank word\endln
\lnie
but for very exceptional machines.\endln
\lnie
\endln
\inst{nulls}{dac}{b$scl}{null string value}
\inst{}{dac}{0}{sclen = 0}
\inst{nullw}{dtc}{0}{sclen = 0}
\lnie
\endln
\ifmac{.culk}
\lnie
\endln
\lnie
constant strings for lcase and ucase keywords\endln
\lnie
\endln
\inst{lcase}{dac}{0}{}
\inst{}{dac}{0}{}
\inst{}{dtc}{0}{}
\lnie
\endln
\inst{ucase}{dac}{0}{}
\inst{}{dac}{0}{}
\inst{}{dtc}{0}{}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
operator dope vectors (see dvblk format)\endln
\lnie
\endln
\inst{opdvc}{dac}{o$cnc}{concatenation}
\inst{}{dac}{o$cnc}{concatenation}
\inst{}{dac}{o$cnc}{concatenation}
\inst{}{dac}{o$cnc}{concatenation}
\lnie
\endln
\lnie
opdvs is used when scanning below the top level to\endln
\lnie
insure that the concatenation will not be later\endln
\lnie
mistaken for pattern matching\endln
\lnie
\endln
\inst{opdvp}{dac}{o$cnc}{concatenation - not pattern match}
\inst{}{dac}{o$cnc}{concatenation - not pattern match}
\inst{}{dac}{o$cnc}{concatenation - not pattern match}
\inst{}{dac}{o$cnc}{concatenation - not pattern match}
\lnie
\endln
\lnie
note that the order of the remaining entries is tied to\endln
\lnie
the order of the coding in the scane procedure.\endln
\lnie
\endln
\inst{opdvs}{dac}{o$ass}{assignment}
\inst{}{dac}{o$ass}{assignment}
\inst{}{dac}{o$ass}{assignment}
\inst{}{dac}{o$ass}{assignment}
\lnie
\endln
\inst{}{dac}{6}{unary equal}
\inst{}{dac}{6}{unary equal}
\inst{}{dac}{6}{unary equal}
\lnie
\endln
\inst{}{dac}{o$pmv}{pattern match}
\inst{}{dac}{o$pmv}{pattern match}
\inst{}{dac}{o$pmv}{pattern match}
\inst{}{dac}{o$pmv}{pattern match}
\lnie
\endln
\inst{}{dac}{o$int}{interrogation}
\inst{}{dac}{o$int}{interrogation}
\inst{}{dac}{o$int}{interrogation}
\lnie
\endln
\inst{}{dac}{1}{binary ampersand}
\inst{}{dac}{1}{binary ampersand}
\inst{}{dac}{1}{binary ampersand}
\inst{}{dac}{1}{binary ampersand}
\lnie
\endln
\inst{}{dac}{o$kwv}{keyword reference}
\inst{}{dac}{o$kwv}{keyword reference}
\inst{}{dac}{o$kwv}{keyword reference}
\lnie
\endln
\inst{}{dac}{o$alt}{alternation}
\inst{}{dac}{o$alt}{alternation}
\inst{}{dac}{o$alt}{alternation}
\inst{}{dac}{o$alt}{alternation}
\vfill\break

\lnie
\endln
\lnie
operator dope vectors (continued)\endln
\lnie
\endln
\inst{}{dac}{5}{unary vertical bar}
\inst{}{dac}{5}{unary vertical bar}
\inst{}{dac}{5}{unary vertical bar}
\lnie
\endln
\inst{}{dac}{0}{binary at}
\inst{}{dac}{0}{binary at}
\inst{}{dac}{0}{binary at}
\inst{}{dac}{0}{binary at}
\lnie
\endln
\inst{}{dac}{o$cas}{cursor assignment}
\inst{}{dac}{o$cas}{cursor assignment}
\inst{}{dac}{o$cas}{cursor assignment}
\lnie
\endln
\inst{}{dac}{2}{binary number sign}
\inst{}{dac}{2}{binary number sign}
\inst{}{dac}{2}{binary number sign}
\inst{}{dac}{2}{binary number sign}
\lnie
\endln
\inst{}{dac}{7}{unary number sign}
\inst{}{dac}{7}{unary number sign}
\inst{}{dac}{7}{unary number sign}
\lnie
\endln
\inst{}{dac}{o$dvd}{division}
\inst{}{dac}{o$dvd}{division}
\inst{}{dac}{o$dvd}{division}
\inst{}{dac}{o$dvd}{division}
\lnie
\endln
\inst{}{dac}{9}{unary slash}
\inst{}{dac}{9}{unary slash}
\inst{}{dac}{9}{unary slash}
\lnie
\endln
\inst{}{dac}{o$mlt}{multiplication}
\inst{}{dac}{o$mlt}{multiplication}
\inst{}{dac}{o$mlt}{multiplication}
\inst{}{dac}{o$mlt}{multiplication}
\vfill\break

\lnie
\endln
\lnie
operator dope vectors (continued)\endln
\lnie
\endln
\inst{}{dac}{0}{deferred expression}
\inst{}{dac}{0}{deferred expression}
\inst{}{dac}{0}{deferred expression}
\lnie
\endln
\inst{}{dac}{3}{binary percent}
\inst{}{dac}{3}{binary percent}
\inst{}{dac}{3}{binary percent}
\inst{}{dac}{3}{binary percent}
\lnie
\endln
\inst{}{dac}{8}{unary percent}
\inst{}{dac}{8}{unary percent}
\inst{}{dac}{8}{unary percent}
\lnie
\endln
\inst{}{dac}{o$exp}{exponentiation}
\inst{}{dac}{o$exp}{exponentiation}
\inst{}{dac}{o$exp}{exponentiation}
\inst{}{dac}{o$exp}{exponentiation}
\lnie
\endln
\inst{}{dac}{10}{unary exclamation}
\inst{}{dac}{10}{unary exclamation}
\inst{}{dac}{10}{unary exclamation}
\lnie
\endln
\inst{}{dac}{o$ima}{immediate assignment}
\inst{}{dac}{o$ima}{immediate assignment}
\inst{}{dac}{o$ima}{immediate assignment}
\inst{}{dac}{o$ima}{immediate assignment}
\lnie
\endln
\inst{}{dac}{o$inv}{indirection}
\inst{}{dac}{o$inv}{indirection}
\inst{}{dac}{o$inv}{indirection}
\lnie
\endln
\inst{}{dac}{4}{binary not}
\inst{}{dac}{4}{binary not}
\inst{}{dac}{4}{binary not}
\inst{}{dac}{4}{binary not}
\lnie
\endln
\inst{}{dac}{0}{negation}
\inst{}{dac}{0}{negation}
\inst{}{dac}{0}{negation}
\vfill\break

\lnie
\endln
\lnie
operator dope vectors (continued)\endln
\lnie
\endln
\inst{}{dac}{o$sub}{subtraction}
\inst{}{dac}{o$sub}{subtraction}
\inst{}{dac}{o$sub}{subtraction}
\inst{}{dac}{o$sub}{subtraction}
\lnie
\endln
\inst{}{dac}{o$com}{complementation}
\inst{}{dac}{o$com}{complementation}
\inst{}{dac}{o$com}{complementation}
\lnie
\endln
\inst{}{dac}{o$add}{addition}
\inst{}{dac}{o$add}{addition}
\inst{}{dac}{o$add}{addition}
\inst{}{dac}{o$add}{addition}
\lnie
\endln
\inst{}{dac}{o$aff}{affirmation}
\inst{}{dac}{o$aff}{affirmation}
\inst{}{dac}{o$aff}{affirmation}
\lnie
\endln
\inst{}{dac}{o$pas}{pattern assignment}
\inst{}{dac}{o$pas}{pattern assignment}
\inst{}{dac}{o$pas}{pattern assignment}
\inst{}{dac}{o$pas}{pattern assignment}
\lnie
\endln
\inst{}{dac}{o$nam}{name reference}
\inst{}{dac}{o$nam}{name reference}
\inst{}{dac}{o$nam}{name reference}
\lnie
\endln
\lnie
special dvs for goto operators (see procedure scngf)\endln
\lnie
\endln
\inst{opdvd}{dac}{o$god}{direct goto}
\inst{}{dac}{o$god}{direct goto}
\inst{}{dac}{o$god}{direct goto}
\lnie
\endln
\inst{opdvn}{dac}{o$goc}{complex normal goto}
\inst{}{dac}{o$goc}{complex normal goto}
\inst{}{dac}{o$goc}{complex normal goto}
\vfill\break

\lnie
\endln
\lnie
operator entry address pointers, used in code\endln
\lnie
\endln
\inst{oamn$}{dac}{o$amn}{array ref (multi-subs by value)}
\inst{oamv$}{dac}{o$amv}{array ref (multi-subs by value)}
\inst{oaon$}{dac}{o$aon}{array ref (one sub by name)}
\inst{oaov$}{dac}{o$aov}{array ref (one sub by value)}
\inst{ocer$}{dac}{o$cer}{compilation error}
\inst{ofex$}{dac}{o$fex}{failure in expression evaluation}
\inst{ofif$}{dac}{o$fif}{failure during goto evaluation}
\inst{ofnc$}{dac}{o$fnc}{function call (more than one arg)}
\inst{ofne$}{dac}{o$fne}{function name error}
\inst{ofns$}{dac}{o$fns}{function call (single argument)}
\inst{ogof$}{dac}{o$gof}{set goto failure trap}
\inst{oinn$}{dac}{o$inn}{indirection by name}
\inst{okwn$}{dac}{o$kwn}{keyword reference by name}
\inst{olex$}{dac}{o$lex}{load expression by name}
\inst{olpt$}{dac}{o$lpt}{load pattern}
\inst{olvn$}{dac}{o$lvn}{load variable name}
\inst{onta$}{dac}{o$nta}{negation, first entry}
\inst{ontb$}{dac}{o$ntb}{negation, second entry}
\inst{ontc$}{dac}{o$ntc}{negation, third entry}
\inst{opmn$}{dac}{o$pmn}{pattern match by name}
\inst{opms$}{dac}{o$pms}{pattern match (statement)}
\inst{opop$}{dac}{o$pop}{pop top stack item}
\inst{ornm$}{dac}{o$rnm}{return name from expression}
\inst{orpl$}{dac}{o$rpl}{pattern replacement}
\inst{orvl$}{dac}{o$rvl}{return value from expression}
\inst{osla$}{dac}{o$sla}{selection, first entry}
\inst{oslb$}{dac}{o$slb}{selection, second entry}
\inst{oslc$}{dac}{o$slc}{selection, third entry}
\inst{osld$}{dac}{o$sld}{selection, fourth entry}
\inst{ostp$}{dac}{o$stp}{stop execution}
\inst{ounf$}{dac}{o$unf}{unexpected failure}
\vfill\break

\lnie
\endln
\lnie
table of names of undefined binary operators for opsyn\endln
\lnie
\endln
\inst{opsnb}{dac}{ch$at}{at}
\inst{}{dac}{ch$am}{ampersand}
\inst{}{dac}{ch$nm}{number}
\inst{}{dac}{ch$pc}{percent}
\inst{}{dac}{ch$nt}{not}
\lnie
\endln
\lnie
table of names of undefined unary operators for opsyn\endln
\lnie
\endln
\inst{opnsu}{dac}{ch$br}{vertical bar}
\inst{}{dac}{ch$eq}{equal}
\inst{}{dac}{ch$nm}{number}
\inst{}{dac}{ch$pc}{percent}
\inst{}{dac}{ch$sl}{slash}
\inst{}{dac}{ch$ex}{exclamation}
\ifmac{.cnpf}
\asmac{else}
\lnie
\endln
\lnie
address const containing profile table entry size\endln
\lnie
\endln
\inst{pfi2a}{dac}{ch$ex}{}
\lnie
\endln
\lnie
profiler message strings\endln
\lnie
\endln
\inst{pfms1}{dac}{ch$ex}{}
\inst{}{dac}{ch$ex}{}
\inst{}{dtc}{ch$ex}{}
\inst{pfms2}{dac}{ch$ex}{}
\inst{}{dac}{ch$ex}{}
\inst{}{dtc}{/stmt    number of}{    -- execution time --/}
\inst{pfms3}{dac}{/stmt    number ofof}{    -- execution time --/}
\inst{}{dac}{/stmt    number ofofof}{    -- execution time --/}
\inst{}{dtc}{/number  executions}{ total(msec) per excn(mcsec)/}
\asmac{fi}
\lnie
\endln
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
real constants for general use. note that the constants\endln
\lnie
starting at reav1 form a powers of ten table (used in\endln
\lnie
gtnum and gtstg)\endln
\lnie
\endln
\inst{reav0}{drc}{+0.0}{0.0}
\ifmac{.cncr}
\asmac{else}
\inst{reap1}{drc}{+0.1}{0.1}
\inst{reap5}{drc}{+0.5}{0.5}
\asmac{fi}
\inst{reav1}{drc}{+1.0}{10**0}
\inst{reavt}{drc}{+1.0e+1}{10**1}
\inst{}{drc}{+1.0e+2}{10**2}
\inst{}{drc}{+1.0e+3}{10**3}
\inst{}{drc}{+1.0e+4}{10**4}
\inst{}{drc}{+1.0e+5}{10**5}
\inst{}{drc}{+1.0e+6}{10**6}
\inst{}{drc}{+1.0e+7}{10**7}
\inst{}{drc}{+1.0e+8}{10**8}
\inst{}{drc}{+1.0e+9}{10**9}
\inst{reatt}{drc}{+1.0e+10}{10**10}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
string constants (scblk format) for dtype procedure\endln
\lnie
\endln
\inst{scarr}{dac}{b$scl}{array}
\inst{}{dac}{b$scl}{array}
\inst{}{dtc}{b$scl}{array}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\inst{scbuf}{dac}{b$scl}{buffer}
\inst{}{dac}{b$scl}{buffer}
\inst{}{dtc}{b$scl}{buffer}
\asmac{fi}
\lnie
\endln
\inst{sccod}{dac}{b$scl}{code}
\inst{}{dac}{b$scl}{code}
\inst{}{dtc}{b$scl}{code}
\lnie
\endln
\inst{scexp}{dac}{b$scl}{expression}
\inst{}{dac}{b$scl}{expression}
\inst{}{dtc}{b$scl}{expression}
\lnie
\endln
\inst{scext}{dac}{b$scl}{external}
\inst{}{dac}{b$scl}{external}
\inst{}{dtc}{b$scl}{external}
\lnie
\endln
\inst{scint}{dac}{b$scl}{integer}
\inst{}{dac}{b$scl}{integer}
\inst{}{dtc}{b$scl}{integer}
\lnie
\endln
\inst{scnam}{dac}{b$scl}{name}
\inst{}{dac}{b$scl}{name}
\inst{}{dtc}{b$scl}{name}
\lnie
\endln
\inst{scnum}{dac}{b$scl}{numeric}
\inst{}{dac}{b$scl}{numeric}
\inst{}{dtc}{b$scl}{numeric}
\lnie
\endln
\inst{scpat}{dac}{b$scl}{pattern}
\inst{}{dac}{b$scl}{pattern}
\inst{}{dtc}{b$scl}{pattern}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\inst{screa}{dac}{b$scl}{real}
\inst{}{dac}{b$scl}{real}
\inst{}{dtc}{b$scl}{real}
\asmac{fi}
\lnie
\endln
\inst{scstr}{dac}{b$scl}{string}
\inst{}{dac}{b$scl}{string}
\inst{}{dtc}{b$scl}{string}
\lnie
\endln
\inst{sctab}{dac}{b$scl}{table}
\inst{}{dac}{b$scl}{table}
\inst{}{dtc}{b$scl}{table}
\ifmac{.cnlf}
\inst{scfil}{dac}{b$scl}{file (for extended load arguments)}
\inst{}{dac}{b$scl}{file (for extended load arguments)}
\inst{}{dtc}{b$scl}{file (for extended load arguments)}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
string constants (scblk format) for kvrtn (see retrn)\endln
\lnie
\endln
\inst{scfrt}{dac}{b$scl}{freturn}
\inst{}{dac}{b$scl}{freturn}
\inst{}{dtc}{b$scl}{freturn}
\lnie
\endln
\inst{scnrt}{dac}{b$scl}{nreturn}
\inst{}{dac}{b$scl}{nreturn}
\inst{}{dtc}{b$scl}{nreturn}
\lnie
\endln
\inst{scrtn}{dac}{b$scl}{return}
\inst{}{dac}{b$scl}{return}
\inst{}{dtc}{b$scl}{return}
\lnie
\endln
\lnie
datatype name table for dtype procedure. the order of\endln
\lnie
these entries is tied to the b$xxx definitions for blocks\endln
\lnie
\endln
\lnie
note that slots for buffer and real data types are filled\endln
\lnie
even if these data types are conditionalized out of the\endln
\lnie
implementation.  this is done so that the block numbering\endln
\lnie
at bl$ar etc. remains constant in all versions.\endln
\lnie
\endln
\inst{scnmt}{dac}{scarr}{arblk     array}
\inst{}{dac}{sccod}{cdblk     code}
\inst{}{dac}{scexp}{exblk     expression}
\inst{}{dac}{scint}{icblk     integer}
\inst{}{dac}{scnam}{nmblk     name}
\inst{}{dac}{scpat}{p0blk     pattern}
\inst{}{dac}{scpat}{p1blk     pattern}
\inst{}{dac}{scpat}{p2blk     pattern}
\ifmac{.cnra}
\inst{}{dac}{nulls}{rcblk     no real in this version}
\asmac{else}
\inst{}{dac}{screa}{rcblk     real}
\asmac{fi}
\inst{}{dac}{scstr}{scblk     string}
\inst{}{dac}{scexp}{seblk     expression}
\inst{}{dac}{sctab}{tbblk     table}
\inst{}{dac}{scarr}{vcblk     array}
\inst{}{dac}{scext}{xnblk     external}
\inst{}{dac}{scext}{xrblk     external}
\ifmac{.cnbf}
\inst{}{dac}{nulls}{bfblk     no buffer in this version}
\asmac{else}
\inst{}{dac}{scbuf}{bfblk     buffer}
\asmac{fi}
\lnie
\endln
\ifmac{.cnra}
\asmac{else}
\lnie
string constant for real zero\endln
\lnie
\endln
\inst{scre0}{dac}{scbuf}{}
\inst{}{dac}{scbuf}{}
\inst{}{dtc}{scbuf}{}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
used to re-initialise kvstl\endln
\lnie
\endln
\ifmac{.cs16}
\inst{stlim}{dic}{+32767}{default statement limit}
\asmac{else}
\ifmac{.cs32}
\inst{stlim}{dic}{+2147483647}{default statement limit}
\asmac{else}
\inst{stlim}{dic}{+50000}{default statement limit}
\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
dummy function block used for undefined functions\endln
\lnie
\endln
\inst{stndf}{dac}{o$fun}{ptr to undefined function err call}
\inst{}{dac}{0}{dummy fargs count for call circuit}
\lnie
\endln
\lnie
dummy code block used for undefined labels\endln
\lnie
\endln
\inst{stndl}{dac}{l$und}{code ptr points to undefined lbl}
\lnie
\endln
\lnie
dummy operator block used for undefined operators\endln
\lnie
\endln
\inst{stndo}{dac}{o$oun}{ptr to undefined operator err call}
\inst{}{dac}{0}{dummy fargs count for call circuit}
\lnie
\endln
\lnie
standard variable block. this block is used to initialize\endln
\lnie
the first seven fields of a newly constructed vrblk.\endln
\lnie
its format is tied to the vrblk definitions (see gtnvr).\endln
\lnie
\endln
\inst{stnvr}{dac}{b$vrl}{vrget}
\inst{}{dac}{b$vrs}{vrsto}
\inst{}{dac}{nulls}{vrval}
\inst{}{dac}{b$vrg}{vrtra}
\inst{}{dac}{stndl}{vrlbl}
\inst{}{dac}{stndf}{vrfnc}
\inst{}{dac}{0}{vrnxt}
\vfill\break

\lnie
\endln
\lnie
messages used in end of run processing (stopr)\endln
\lnie
\endln
\inst{stpm1}{dac}{b$scl}{in statement}
\inst{}{dac}{b$scl}{in statement}
\inst{}{dtc}{b$scl}{in statement}
\lnie
\endln
\inst{stpm2}{dac}{b$scl}{}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\lnie
\endln
\inst{stpm3}{dac}{b$scl}{}
\ifmac{.ctmd}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\asmac{else}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\asmac{fi}
\lnie
\endln
\inst{stpm4}{dac}{b$scl}{}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\lnie
\endln
\inst{stpm5}{dac}{b$scl}{}
\inst{}{dac}{b$scl}{}
\inst{}{dtc}{b$scl}{}
\ifmac{.csln}
\lnie
\endln
\inst{stpm6}{dac}{b$scl}{in line}
\inst{}{dac}{b$scl}{in line}
\inst{}{dtc}{b$scl}{in line}
\asmac{fi}
\ifmac{.csfn}
\lnie
\endln
\inst{stpm7}{dac}{b$scl}{in file}
\inst{}{dac}{b$scl}{in file}
\inst{}{dtc}{b$scl}{in file}
\asmac{fi}
\lnie
\endln
\lnie
chars for /tu/ ending code\endln
\lnie
\endln
\inst{strtu}{dtc}{b$scl}{}
\lnie
\endln
\lnie
table used by convert function to check datatype name\endln
\lnie
the entries are ordered to correspond to branch table\endln
\lnie
in s$cnv\endln
\lnie
\endln
\inst{svctb}{dac}{scstr}{string}
\inst{}{dac}{scint}{integer}
\inst{}{dac}{scnam}{name}
\inst{}{dac}{scpat}{pattern}
\inst{}{dac}{scarr}{array}
\inst{}{dac}{sctab}{table}
\inst{}{dac}{scexp}{expression}
\inst{}{dac}{sccod}{code}
\inst{}{dac}{scnum}{numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{dac}{screa}{real}
\asmac{fi}
\ifmac{.cnbf}
\asmac{else}
\inst{}{dac}{scbuf}{buffer}
\asmac{fi}
\inst{}{dac}{0}{zero marks end of list}
\vfill\break

\lnie
\endln
\lnie
messages (scblk format) used by trace procedures\endln
\lnie
\endln
\lnie
\endln
\inst{tmasb}{dac}{b$scl}{asterisks for trace statement no}
\inst{}{dac}{b$scl}{asterisks for trace statement no}
\inst{}{dtc}{b$scl}{asterisks for trace statement no}
\lnie
\endln
\inst{tmbeb}{dac}{b$scl}{blank-equal-blank}
\inst{}{dac}{b$scl}{blank-equal-blank}
\inst{}{dtc}{b$scl}{blank-equal-blank}
\lnie
\endln
\lnie
dummy trblk for expression variable\endln
\lnie
\endln
\inst{trbev}{dac}{b$trt}{dummy trblk}
\lnie
\endln
\lnie
dummy trblk for keyword variable\endln
\lnie
\endln
\inst{trbkv}{dac}{b$trt}{dummy trblk}
\lnie
\endln
\lnie
dummy code block to return control to trxeq procedure\endln
\lnie
\endln
\inst{trxdr}{dac}{o$txr}{block points to return routine}
\inst{trxdc}{dac}{trxdr}{pointer to block}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks\endln
\lnie
\endln
\lnie
see svblk format for full details of the format. the\endln
\lnie
vrblks are ordered by length and within each length the\endln
\lnie
order is alphabetical by name of the variable.\endln
\lnie
\endln
\inst{v$eqf}{dbc}{svfpr}{eq}
\inst{}{dac}{svfpr}{eq}
\inst{}{dtc}{svfpr}{eq}
\inst{}{dac}{svfpr}{eq}
\inst{}{dac}{svfpr}{eq}
\lnie
\endln
\inst{v$gef}{dbc}{svfpr}{ge}
\inst{}{dac}{svfpr}{ge}
\inst{}{dtc}{svfpr}{ge}
\inst{}{dac}{svfpr}{ge}
\inst{}{dac}{svfpr}{ge}
\lnie
\endln
\inst{v$gtf}{dbc}{svfpr}{gt}
\inst{}{dac}{svfpr}{gt}
\inst{}{dtc}{svfpr}{gt}
\inst{}{dac}{svfpr}{gt}
\inst{}{dac}{svfpr}{gt}
\lnie
\endln
\inst{v$lef}{dbc}{svfpr}{le}
\inst{}{dac}{svfpr}{le}
\inst{}{dtc}{svfpr}{le}
\inst{}{dac}{svfpr}{le}
\inst{}{dac}{svfpr}{le}
\ifmac{.cmth}
\lnie
\endln
\inst{v$lnf}{dbc}{svfnp}{ln}
\inst{}{dac}{svfnp}{ln}
\inst{}{dtc}{svfnp}{ln}
\inst{}{dac}{svfnp}{ln}
\inst{}{dac}{svfnp}{ln}
\asmac{fi}
\lnie
\endln
\inst{v$ltf}{dbc}{svfpr}{lt}
\inst{}{dac}{svfpr}{lt}
\inst{}{dtc}{svfpr}{lt}
\inst{}{dac}{svfpr}{lt}
\inst{}{dac}{svfpr}{lt}
\lnie
\endln
\inst{v$nef}{dbc}{svfpr}{ne}
\inst{}{dac}{svfpr}{ne}
\inst{}{dtc}{svfpr}{ne}
\inst{}{dac}{svfpr}{ne}
\inst{}{dac}{svfpr}{ne}
\ifmac{.c370}
\lnie
\endln
\inst{v$orf}{dbc}{svfnp}{or}
\inst{}{dac}{svfnp}{or}
\inst{}{dtc}{svfnp}{or}
\inst{}{dac}{svfnp}{or}
\inst{}{dac}{svfnp}{or}
\asmac{fi}
\ifmac{.c370}
\lnie
\endln
\inst{v$abs}{dbc}{svfnp}{abs}
\inst{}{dac}{svfnp}{abs}
\inst{}{dtc}{svfnp}{abs}
\inst{}{dac}{svfnp}{abs}
\inst{}{dac}{svfnp}{abs}
\asmac{fi}
\ifmac{.c370}
\lnie
\endln
\inst{v$and}{dbc}{svfnp}{and}
\inst{}{dac}{svfnp}{and}
\inst{}{dtc}{svfnp}{and}
\inst{}{dac}{svfnp}{and}
\inst{}{dac}{svfnp}{and}
\asmac{fi}
\lnie
\endln
\inst{v$any}{dbc}{svfnp}{any}
\inst{}{dac}{svfnp}{any}
\inst{}{dtc}{svfnp}{any}
\inst{}{dac}{svfnp}{any}
\inst{}{dac}{svfnp}{any}
\lnie
\endln
\inst{v$arb}{dbc}{svkvc}{arb}
\inst{}{dac}{svkvc}{arb}
\inst{}{dtc}{svkvc}{arb}
\inst{}{dac}{svkvc}{arb}
\inst{}{dac}{svkvc}{arb}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$arg}{dbc}{svfnn}{arg}
\inst{}{dac}{svfnn}{arg}
\inst{}{dtc}{svfnn}{arg}
\inst{}{dac}{svfnn}{arg}
\inst{}{dac}{svfnn}{arg}
\lnie
\endln
\inst{v$bal}{dbc}{svkvc}{bal}
\inst{}{dac}{svkvc}{bal}
\inst{}{dtc}{svkvc}{bal}
\inst{}{dac}{svkvc}{bal}
\inst{}{dac}{svkvc}{bal}
\ifmac{.cmth}
\lnie
\endln
\inst{v$cos}{dbc}{svfnp}{cos}
\inst{}{dac}{svfnp}{cos}
\inst{}{dtc}{svfnp}{cos}
\inst{}{dac}{svfnp}{cos}
\inst{}{dac}{svfnp}{cos}
\asmac{fi}
\lnie
\endln
\inst{v$end}{dbc}{svlbl}{end}
\inst{}{dac}{svlbl}{end}
\inst{}{dtc}{svlbl}{end}
\inst{}{dac}{svlbl}{end}
\ifmac{.cmth}
\lnie
\endln
\inst{v$exp}{dbc}{svfnp}{exp}
\inst{}{dac}{svfnp}{exp}
\inst{}{dtc}{svfnp}{exp}
\inst{}{dac}{svfnp}{exp}
\inst{}{dac}{svfnp}{exp}
\asmac{fi}
\lnie
\endln
\inst{v$len}{dbc}{svfnp}{len}
\inst{}{dac}{svfnp}{len}
\inst{}{dtc}{svfnp}{len}
\inst{}{dac}{svfnp}{len}
\inst{}{dac}{svfnp}{len}
\lnie
\endln
\inst{v$leq}{dbc}{svfpr}{leq}
\inst{}{dac}{svfpr}{leq}
\inst{}{dtc}{svfpr}{leq}
\inst{}{dac}{svfpr}{leq}
\inst{}{dac}{svfpr}{leq}
\lnie
\endln
\inst{v$lge}{dbc}{svfpr}{lge}
\inst{}{dac}{svfpr}{lge}
\inst{}{dtc}{svfpr}{lge}
\inst{}{dac}{svfpr}{lge}
\inst{}{dac}{svfpr}{lge}
\lnie
\endln
\inst{v$lgt}{dbc}{svfpr}{lgt}
\inst{}{dac}{svfpr}{lgt}
\inst{}{dtc}{svfpr}{lgt}
\inst{}{dac}{svfpr}{lgt}
\inst{}{dac}{svfpr}{lgt}
\lnie
\endln
\inst{v$lle}{dbc}{svfpr}{lle}
\inst{}{dac}{svfpr}{lle}
\inst{}{dtc}{svfpr}{lle}
\inst{}{dac}{svfpr}{lle}
\inst{}{dac}{svfpr}{lle}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$llt}{dbc}{svfpr}{llt}
\inst{}{dac}{svfpr}{llt}
\inst{}{dtc}{svfpr}{llt}
\inst{}{dac}{svfpr}{llt}
\inst{}{dac}{svfpr}{llt}
\lnie
\endln
\inst{v$lne}{dbc}{svfpr}{lne}
\inst{}{dac}{svfpr}{lne}
\inst{}{dtc}{svfpr}{lne}
\inst{}{dac}{svfpr}{lne}
\inst{}{dac}{svfpr}{lne}
\lnie
\endln
\inst{v$pos}{dbc}{svfnp}{pos}
\inst{}{dac}{svfnp}{pos}
\inst{}{dtc}{svfnp}{pos}
\inst{}{dac}{svfnp}{pos}
\inst{}{dac}{svfnp}{pos}
\lnie
\endln
\inst{v$rem}{dbc}{svkvc}{rem}
\inst{}{dac}{svkvc}{rem}
\inst{}{dtc}{svkvc}{rem}
\inst{}{dac}{svkvc}{rem}
\inst{}{dac}{svkvc}{rem}
\ifmac{.cust}
\lnie
\endln
\inst{v$set}{dbc}{svfnn}{set}
\inst{}{dac}{svfnn}{set}
\inst{}{dtc}{svfnn}{set}
\inst{}{dac}{svfnn}{set}
\inst{}{dac}{svfnn}{set}
\asmac{fi}
\ifmac{.cmth}
\lnie
\endln
\inst{v$sin}{dbc}{svfnp}{sin}
\inst{}{dac}{svfnp}{sin}
\inst{}{dtc}{svfnp}{sin}
\inst{}{dac}{svfnp}{sin}
\inst{}{dac}{svfnp}{sin}
\asmac{fi}
\lnie
\endln
\inst{v$tab}{dbc}{svfnp}{tab}
\inst{}{dac}{svfnp}{tab}
\inst{}{dtc}{svfnp}{tab}
\inst{}{dac}{svfnp}{tab}
\inst{}{dac}{svfnp}{tab}
\ifmac{.cmth}
\lnie
\endln
\inst{v$tan}{dbc}{svfnp}{tan}
\inst{}{dac}{svfnp}{tan}
\inst{}{dtc}{svfnp}{tan}
\inst{}{dac}{svfnp}{tan}
\inst{}{dac}{svfnp}{tan}
\asmac{fi}
\ifmac{.c370}
\lnie
\endln
\inst{v$xor}{dbc}{svfnp}{xor}
\inst{}{dac}{svfnp}{xor}
\inst{}{dtc}{svfnp}{xor}
\inst{}{dac}{svfnp}{xor}
\inst{}{dac}{svfnp}{xor}
\asmac{fi}
\ifmac{.cmth}
\lnie
\endln
\inst{v$atn}{dbc}{svfnp}{atan}
\inst{}{dac}{svfnp}{atan}
\inst{}{dtc}{svfnp}{atan}
\inst{}{dac}{svfnp}{atan}
\inst{}{dac}{svfnp}{atan}
\asmac{fi}
\ifmac{.culc}
\lnie
\endln
\inst{v$cas}{dbc}{svknm}{case}
\inst{}{dac}{svknm}{case}
\inst{}{dtc}{svknm}{case}
\inst{}{dac}{svknm}{case}
\asmac{fi}
\lnie
\endln
\inst{v$chr}{dbc}{svfnp}{char}
\inst{}{dac}{svfnp}{char}
\inst{}{dtc}{svfnp}{char}
\inst{}{dac}{svfnp}{char}
\inst{}{dac}{svfnp}{char}
\lnie
\endln
\ifmac{.cmth}
\lnie
\endln
\inst{v$chp}{dbc}{svfnp}{chop}
\inst{}{dac}{svfnp}{chop}
\inst{}{dtc}{svfnp}{chop}
\inst{}{dac}{svfnp}{chop}
\inst{}{dac}{svfnp}{chop}
\asmac{fi}
\inst{v$cod}{dbc}{svfnk}{code}
\inst{}{dac}{svfnk}{code}
\inst{}{dtc}{svfnk}{code}
\inst{}{dac}{svfnk}{code}
\inst{}{dac}{svfnk}{code}
\inst{}{dac}{svfnk}{code}
\lnie
\endln
\inst{v$cop}{dbc}{svfnn}{copy}
\inst{}{dac}{svfnn}{copy}
\inst{}{dtc}{svfnn}{copy}
\inst{}{dac}{svfnn}{copy}
\inst{}{dac}{svfnn}{copy}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$dat}{dbc}{svfnn}{data}
\inst{}{dac}{svfnn}{data}
\inst{}{dtc}{svfnn}{data}
\inst{}{dac}{svfnn}{data}
\inst{}{dac}{svfnn}{data}
\lnie
\endln
\inst{v$dte}{dbc}{svfnn}{date}
\inst{}{dac}{svfnn}{date}
\inst{}{dtc}{svfnn}{date}
\inst{}{dac}{svfnn}{date}
\inst{}{dac}{svfnn}{date}
\lnie
\endln
\inst{v$dmp}{dbc}{svfnk}{dump}
\inst{}{dac}{svfnk}{dump}
\inst{}{dtc}{svfnk}{dump}
\inst{}{dac}{svfnk}{dump}
\inst{}{dac}{svfnk}{dump}
\inst{}{dac}{svfnk}{dump}
\lnie
\endln
\inst{v$dup}{dbc}{svfnn}{dupl}
\inst{}{dac}{svfnn}{dupl}
\inst{}{dtc}{svfnn}{dupl}
\inst{}{dac}{svfnn}{dupl}
\inst{}{dac}{svfnn}{dupl}
\lnie
\endln
\inst{v$evl}{dbc}{svfnn}{eval}
\inst{}{dac}{svfnn}{eval}
\inst{}{dtc}{svfnn}{eval}
\inst{}{dac}{svfnn}{eval}
\inst{}{dac}{svfnn}{eval}
\ifmac{.cnex}
\asmac{else}
\lnie
\endln
\inst{v$ext}{dbc}{svfnn}{exit}
\inst{}{dac}{svfnn}{exit}
\inst{}{dtc}{svfnn}{exit}
\inst{}{dac}{svfnn}{exit}
\inst{}{dac}{svfnn}{exit}
\asmac{fi}
\lnie
\endln
\inst{v$fal}{dbc}{svkvc}{fail}
\inst{}{dac}{svkvc}{fail}
\inst{}{dtc}{svkvc}{fail}
\inst{}{dac}{svkvc}{fail}
\inst{}{dac}{svkvc}{fail}
\lnie
\endln
\ifmac{.csfn}
\inst{v$fil}{dbc}{svknm}{file}
\inst{}{dac}{svknm}{file}
\inst{}{dtc}{svknm}{file}
\inst{}{dac}{svknm}{file}
\lnie
\endln
\asmac{fi}
\inst{v$hst}{dbc}{svfnn}{host}
\inst{}{dac}{svfnn}{host}
\inst{}{dtc}{svfnn}{host}
\inst{}{dac}{svfnn}{host}
\inst{}{dac}{svfnn}{host}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$itm}{dbc}{svfnf}{item}
\inst{}{dac}{svfnf}{item}
\inst{}{dtc}{svfnf}{item}
\inst{}{dac}{svfnf}{item}
\inst{}{dac}{svfnf}{item}
\ifmac{.csln}
\lnie
\endln
\inst{v$lin}{dbc}{svknm}{line}
\inst{}{dac}{svknm}{line}
\inst{}{dtc}{svknm}{line}
\inst{}{dac}{svknm}{line}
\asmac{fi}
\ifmac{.cnld}
\asmac{else}
\lnie
\endln
\inst{v$lod}{dbc}{svfnn}{load}
\inst{}{dac}{svfnn}{load}
\inst{}{dtc}{svfnn}{load}
\inst{}{dac}{svfnn}{load}
\inst{}{dac}{svfnn}{load}
\asmac{fi}
\lnie
\endln
\inst{v$lpd}{dbc}{svfnp}{lpad}
\inst{}{dac}{svfnp}{lpad}
\inst{}{dtc}{svfnp}{lpad}
\inst{}{dac}{svfnp}{lpad}
\inst{}{dac}{svfnp}{lpad}
\lnie
\endln
\inst{v$rpd}{dbc}{svfnp}{rpad}
\inst{}{dac}{svfnp}{rpad}
\inst{}{dtc}{svfnp}{rpad}
\inst{}{dac}{svfnp}{rpad}
\inst{}{dac}{svfnp}{rpad}
\lnie
\endln
\inst{v$rps}{dbc}{svfnp}{rpos}
\inst{}{dac}{svfnp}{rpos}
\inst{}{dtc}{svfnp}{rpos}
\inst{}{dac}{svfnp}{rpos}
\inst{}{dac}{svfnp}{rpos}
\lnie
\endln
\inst{v$rtb}{dbc}{svfnp}{rtab}
\inst{}{dac}{svfnp}{rtab}
\inst{}{dtc}{svfnp}{rtab}
\inst{}{dac}{svfnp}{rtab}
\inst{}{dac}{svfnp}{rtab}
\lnie
\endln
\inst{v$si$}{dbc}{svfnp}{size}
\inst{}{dac}{svfnp}{size}
\inst{}{dtc}{svfnp}{size}
\inst{}{dac}{svfnp}{size}
\inst{}{dac}{svfnp}{size}
\lnie
\endln
\ifmac{.cnsr}
\asmac{else}
\lnie
\endln
\inst{v$srt}{dbc}{svfnn}{sort}
\inst{}{dac}{svfnn}{sort}
\inst{}{dtc}{svfnn}{sort}
\inst{}{dac}{svfnn}{sort}
\inst{}{dac}{svfnn}{sort}
\asmac{fi}
\inst{v$spn}{dbc}{svfnp}{span}
\inst{}{dac}{svfnp}{span}
\inst{}{dtc}{svfnp}{span}
\inst{}{dac}{svfnp}{span}
\inst{}{dac}{svfnp}{span}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\ifmac{.cmth}
\lnie
\endln
\inst{v$sqr}{dbc}{svfnp}{sqrt}
\inst{}{dac}{svfnp}{sqrt}
\inst{}{dtc}{svfnp}{sqrt}
\inst{}{dac}{svfnp}{sqrt}
\inst{}{dac}{svfnp}{sqrt}
\asmac{fi}
\inst{v$stn}{dbc}{svknm}{stno}
\inst{}{dac}{svknm}{stno}
\inst{}{dtc}{svknm}{stno}
\inst{}{dac}{svknm}{stno}
\lnie
\endln
\inst{v$tim}{dbc}{svfnn}{time}
\inst{}{dac}{svfnn}{time}
\inst{}{dtc}{svfnn}{time}
\inst{}{dac}{svfnn}{time}
\inst{}{dac}{svfnn}{time}
\lnie
\endln
\inst{v$trm}{dbc}{svfnk}{trim}
\inst{}{dac}{svfnk}{trim}
\inst{}{dtc}{svfnk}{trim}
\inst{}{dac}{svfnk}{trim}
\inst{}{dac}{svfnk}{trim}
\inst{}{dac}{svfnk}{trim}
\lnie
\endln
\inst{v$abe}{dbc}{svknm}{abend}
\inst{}{dac}{svknm}{abend}
\inst{}{dtc}{svknm}{abend}
\inst{}{dac}{svknm}{abend}
\lnie
\endln
\inst{v$abo}{dbc}{svkvl}{abort}
\inst{}{dac}{svkvl}{abort}
\inst{}{dtc}{svkvl}{abort}
\inst{}{dac}{svkvl}{abort}
\inst{}{dac}{svkvl}{abort}
\inst{}{dac}{svkvl}{abort}
\lnie
\endln
\inst{v$app}{dbc}{svfnf}{apply}
\inst{}{dac}{svfnf}{apply}
\inst{}{dtc}{svfnf}{apply}
\inst{}{dac}{svfnf}{apply}
\inst{}{dac}{svfnf}{apply}
\lnie
\endln
\inst{v$abn}{dbc}{svfnp}{arbno}
\inst{}{dac}{svfnp}{arbno}
\inst{}{dtc}{svfnp}{arbno}
\inst{}{dac}{svfnp}{arbno}
\inst{}{dac}{svfnp}{arbno}
\lnie
\endln
\inst{v$arr}{dbc}{svfnn}{array}
\inst{}{dac}{svfnn}{array}
\inst{}{dtc}{svfnn}{array}
\inst{}{dac}{svfnn}{array}
\inst{}{dac}{svfnn}{array}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$brk}{dbc}{svfnp}{break}
\inst{}{dac}{svfnp}{break}
\inst{}{dtc}{svfnp}{break}
\inst{}{dac}{svfnp}{break}
\inst{}{dac}{svfnp}{break}
\lnie
\endln
\inst{v$clr}{dbc}{svfnn}{clear}
\inst{}{dac}{svfnn}{clear}
\inst{}{dtc}{svfnn}{clear}
\inst{}{dac}{svfnn}{clear}
\inst{}{dac}{svfnn}{clear}
\ifmac{.c370}
\lnie
\endln
\inst{v$cmp}{dbc}{svfnp}{compl}
\inst{}{dac}{svfnp}{compl}
\inst{}{dtc}{svfnp}{compl}
\inst{}{dac}{svfnp}{compl}
\inst{}{dac}{svfnp}{compl}
\asmac{fi}
\lnie
\endln
\inst{v$ejc}{dbc}{svfnn}{eject}
\inst{}{dac}{svfnn}{eject}
\inst{}{dtc}{svfnn}{eject}
\inst{}{dac}{svfnn}{eject}
\inst{}{dac}{svfnn}{eject}
\lnie
\endln
\inst{v$fen}{dbc}{svfpk}{fence}
\inst{}{dac}{svfpk}{fence}
\inst{}{dtc}{svfpk}{fence}
\inst{}{dac}{svfpk}{fence}
\inst{}{dac}{svfpk}{fence}
\inst{}{dac}{svfpk}{fence}
\inst{}{dac}{svfpk}{fence}
\lnie
\endln
\inst{v$fld}{dbc}{svfnn}{field}
\inst{}{dac}{svfnn}{field}
\inst{}{dtc}{svfnn}{field}
\inst{}{dac}{svfnn}{field}
\inst{}{dac}{svfnn}{field}
\lnie
\endln
\inst{v$idn}{dbc}{svfpr}{ident}
\inst{}{dac}{svfpr}{ident}
\inst{}{dtc}{svfpr}{ident}
\inst{}{dac}{svfpr}{ident}
\inst{}{dac}{svfpr}{ident}
\lnie
\endln
\inst{v$inp}{dbc}{svfnk}{input}
\inst{}{dac}{svfnk}{input}
\inst{}{dtc}{svfnk}{input}
\inst{}{dac}{svfnk}{input}
\inst{}{dac}{svfnk}{input}
\inst{}{dac}{svfnk}{input}
\ifmac{.culk}
\lnie
\endln
\inst{v$lcs}{dbc}{svkwc}{lcase}
\inst{}{dac}{svkwc}{lcase}
\inst{}{dtc}{svkwc}{lcase}
\inst{}{dac}{svkwc}{lcase}
\asmac{fi}
\lnie
\endln
\inst{v$loc}{dbc}{svfnn}{local}
\inst{}{dac}{svfnn}{local}
\inst{}{dtc}{svfnn}{local}
\inst{}{dac}{svfnn}{local}
\inst{}{dac}{svfnn}{local}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$ops}{dbc}{svfnn}{opsyn}
\inst{}{dac}{svfnn}{opsyn}
\inst{}{dtc}{svfnn}{opsyn}
\inst{}{dac}{svfnn}{opsyn}
\inst{}{dac}{svfnn}{opsyn}
\lnie
\endln
\inst{v$rmd}{dbc}{svfnp}{remdr}
\inst{}{dac}{svfnp}{remdr}
\inst{}{dtc}{svfnp}{remdr}
\inst{}{dac}{svfnp}{remdr}
\inst{}{dac}{svfnp}{remdr}
\ifmac{.cnsr}
\asmac{else}
\lnie
\endln
\inst{v$rsr}{dbc}{svfnn}{rsort}
\inst{}{dac}{svfnn}{rsort}
\inst{}{dtc}{svfnn}{rsort}
\inst{}{dac}{svfnn}{rsort}
\inst{}{dac}{svfnn}{rsort}
\asmac{fi}
\lnie
\endln
\inst{v$tbl}{dbc}{svfnn}{table}
\inst{}{dac}{svfnn}{table}
\inst{}{dtc}{svfnn}{table}
\inst{}{dac}{svfnn}{table}
\inst{}{dac}{svfnn}{table}
\lnie
\endln
\inst{v$tra}{dbc}{svfnk}{trace}
\inst{}{dac}{svfnk}{trace}
\inst{}{dtc}{svfnk}{trace}
\inst{}{dac}{svfnk}{trace}
\inst{}{dac}{svfnk}{trace}
\inst{}{dac}{svfnk}{trace}
\ifmac{.culk}
\lnie
\endln
\inst{v$ucs}{dbc}{svkwc}{ucase}
\inst{}{dac}{svkwc}{ucase}
\inst{}{dtc}{svkwc}{ucase}
\inst{}{dac}{svkwc}{ucase}
\asmac{fi}
\lnie
\endln
\inst{v$anc}{dbc}{svknm}{anchor}
\inst{}{dac}{svknm}{anchor}
\inst{}{dtc}{svknm}{anchor}
\inst{}{dac}{svknm}{anchor}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\inst{v$apn}{dbc}{svfnn}{append}
\inst{}{dac}{svfnn}{append}
\inst{}{dtc}{svfnn}{append}
\inst{}{dac}{svfnn}{append}
\inst{}{dac}{svfnn}{append}
\asmac{fi}
\lnie
\endln
\inst{v$bkx}{dbc}{svfnp}{breakx}
\inst{}{dac}{svfnp}{breakx}
\inst{}{dtc}{svfnp}{breakx}
\inst{}{dac}{svfnp}{breakx}
\inst{}{dac}{svfnp}{breakx}
\lnie
\endln
\ifmac{.cnbf}
\asmac{else}
\inst{v$buf}{dbc}{svfnn}{buffer}
\inst{}{dac}{svfnn}{buffer}
\inst{}{dtc}{svfnn}{buffer}
\inst{}{dac}{svfnn}{buffer}
\inst{}{dac}{svfnn}{buffer}
\asmac{fi}
\lnie
\endln
\inst{v$def}{dbc}{svfnn}{define}
\inst{}{dac}{svfnn}{define}
\inst{}{dtc}{svfnn}{define}
\inst{}{dac}{svfnn}{define}
\inst{}{dac}{svfnn}{define}
\lnie
\endln
\inst{v$det}{dbc}{svfnn}{detach}
\inst{}{dac}{svfnn}{detach}
\inst{}{dtc}{svfnn}{detach}
\inst{}{dac}{svfnn}{detach}
\inst{}{dac}{svfnn}{detach}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$dif}{dbc}{svfpr}{differ}
\inst{}{dac}{svfpr}{differ}
\inst{}{dtc}{svfpr}{differ}
\inst{}{dac}{svfpr}{differ}
\inst{}{dac}{svfpr}{differ}
\lnie
\endln
\inst{v$ftr}{dbc}{svknm}{ftrace}
\inst{}{dac}{svknm}{ftrace}
\inst{}{dtc}{svknm}{ftrace}
\inst{}{dac}{svknm}{ftrace}
\lnie
\endln
\ifmac{.cnbf}
\asmac{else}
\inst{v$ins}{dbc}{svfnn}{insert}
\inst{}{dac}{svfnn}{insert}
\inst{}{dtc}{svfnn}{insert}
\inst{}{dac}{svfnn}{insert}
\inst{}{dac}{svfnn}{insert}
\lnie
\endln
\asmac{fi}
\inst{v$lst}{dbc}{svknm}{lastno}
\inst{}{dac}{svknm}{lastno}
\inst{}{dtc}{svknm}{lastno}
\inst{}{dac}{svknm}{lastno}
\lnie
\endln
\inst{v$nay}{dbc}{svfnp}{notany}
\inst{}{dac}{svfnp}{notany}
\inst{}{dtc}{svfnp}{notany}
\inst{}{dac}{svfnp}{notany}
\inst{}{dac}{svfnp}{notany}
\lnie
\endln
\inst{v$oup}{dbc}{svfnk}{output}
\inst{}{dac}{svfnk}{output}
\inst{}{dtc}{svfnk}{output}
\inst{}{dac}{svfnk}{output}
\inst{}{dac}{svfnk}{output}
\inst{}{dac}{svfnk}{output}
\lnie
\endln
\inst{v$ret}{dbc}{svlbl}{return}
\inst{}{dac}{svlbl}{return}
\inst{}{dtc}{svlbl}{return}
\inst{}{dac}{svlbl}{return}
\lnie
\endln
\inst{v$rew}{dbc}{svfnn}{rewind}
\inst{}{dac}{svfnn}{rewind}
\inst{}{dtc}{svfnn}{rewind}
\inst{}{dac}{svfnn}{rewind}
\inst{}{dac}{svfnn}{rewind}
\lnie
\endln
\inst{v$stt}{dbc}{svfnn}{stoptr}
\inst{}{dac}{svfnn}{stoptr}
\inst{}{dtc}{svfnn}{stoptr}
\inst{}{dac}{svfnn}{stoptr}
\inst{}{dac}{svfnn}{stoptr}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$sub}{dbc}{svfnn}{substr}
\inst{}{dac}{svfnn}{substr}
\inst{}{dtc}{svfnn}{substr}
\inst{}{dac}{svfnn}{substr}
\inst{}{dac}{svfnn}{substr}
\lnie
\endln
\inst{v$unl}{dbc}{svfnn}{unload}
\inst{}{dac}{svfnn}{unload}
\inst{}{dtc}{svfnn}{unload}
\inst{}{dac}{svfnn}{unload}
\inst{}{dac}{svfnn}{unload}
\lnie
\endln
\inst{v$col}{dbc}{svfnn}{collect}
\inst{}{dac}{svfnn}{collect}
\inst{}{dtc}{svfnn}{collect}
\inst{}{dac}{svfnn}{collect}
\inst{}{dac}{svfnn}{collect}
\ifmac{.ccmk}
\lnie
\endln
\inst{v$com}{dbc}{svknm}{compare}
\inst{}{dac}{svknm}{compare}
\inst{}{dtc}{svknm}{compare}
\inst{}{dac}{svknm}{compare}
\asmac{fi}
\lnie
\endln
\inst{v$cnv}{dbc}{svfnn}{convert}
\inst{}{dac}{svfnn}{convert}
\inst{}{dtc}{svfnn}{convert}
\inst{}{dac}{svfnn}{convert}
\inst{}{dac}{svfnn}{convert}
\lnie
\endln
\inst{v$enf}{dbc}{svfnn}{endfile}
\inst{}{dac}{svfnn}{endfile}
\inst{}{dtc}{svfnn}{endfile}
\inst{}{dac}{svfnn}{endfile}
\inst{}{dac}{svfnn}{endfile}
\lnie
\endln
\inst{v$etx}{dbc}{svknm}{errtext}
\inst{}{dac}{svknm}{errtext}
\inst{}{dtc}{svknm}{errtext}
\inst{}{dac}{svknm}{errtext}
\lnie
\endln
\inst{v$ert}{dbc}{svknm}{errtype}
\inst{}{dac}{svknm}{errtype}
\inst{}{dtc}{svknm}{errtype}
\inst{}{dac}{svknm}{errtype}
\lnie
\endln
\inst{v$frt}{dbc}{svlbl}{freturn}
\inst{}{dac}{svlbl}{freturn}
\inst{}{dtc}{svlbl}{freturn}
\inst{}{dac}{svlbl}{freturn}
\lnie
\endln
\inst{v$int}{dbc}{svfpr}{integer}
\inst{}{dac}{svfpr}{integer}
\inst{}{dtc}{svfpr}{integer}
\inst{}{dac}{svfpr}{integer}
\inst{}{dac}{svfpr}{integer}
\lnie
\endln
\inst{v$nrt}{dbc}{svlbl}{nreturn}
\inst{}{dac}{svlbl}{nreturn}
\inst{}{dtc}{svlbl}{nreturn}
\inst{}{dac}{svlbl}{nreturn}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\ifmac{.cnpf}
\asmac{else}
\lnie
\endln
\inst{v$pfl}{dbc}{svknm}{profile}
\inst{}{dac}{svknm}{profile}
\inst{}{dtc}{svknm}{profile}
\inst{}{dac}{svknm}{profile}
\asmac{fi}
\lnie
\endln
\inst{v$rpl}{dbc}{svfnp}{replace}
\inst{}{dac}{svfnp}{replace}
\inst{}{dtc}{svfnp}{replace}
\inst{}{dac}{svfnp}{replace}
\inst{}{dac}{svfnp}{replace}
\lnie
\endln
\inst{v$rvs}{dbc}{svfnp}{reverse}
\inst{}{dac}{svfnp}{reverse}
\inst{}{dtc}{svfnp}{reverse}
\inst{}{dac}{svfnp}{reverse}
\inst{}{dac}{svfnp}{reverse}
\lnie
\endln
\inst{v$rtn}{dbc}{svknm}{rtntype}
\inst{}{dac}{svknm}{rtntype}
\inst{}{dtc}{svknm}{rtntype}
\inst{}{dac}{svknm}{rtntype}
\lnie
\endln
\inst{v$stx}{dbc}{svfnn}{setexit}
\inst{}{dac}{svfnn}{setexit}
\inst{}{dtc}{svfnn}{setexit}
\inst{}{dac}{svfnn}{setexit}
\inst{}{dac}{svfnn}{setexit}
\lnie
\endln
\inst{v$stc}{dbc}{svknm}{stcount}
\inst{}{dac}{svknm}{stcount}
\inst{}{dtc}{svknm}{stcount}
\inst{}{dac}{svknm}{stcount}
\lnie
\endln
\inst{v$stl}{dbc}{svknm}{stlimit}
\inst{}{dac}{svknm}{stlimit}
\inst{}{dtc}{svknm}{stlimit}
\inst{}{dac}{svknm}{stlimit}
\lnie
\endln
\inst{v$suc}{dbc}{svkvc}{succeed}
\inst{}{dac}{svkvc}{succeed}
\inst{}{dtc}{svkvc}{succeed}
\inst{}{dac}{svkvc}{succeed}
\inst{}{dac}{svkvc}{succeed}
\lnie
\endln
\inst{v$alp}{dbc}{svkwc}{alphabet}
\inst{}{dac}{svkwc}{alphabet}
\inst{}{dtc}{svkwc}{alphabet}
\inst{}{dac}{svkwc}{alphabet}
\lnie
\endln
\inst{v$cnt}{dbc}{svlbl}{continue}
\inst{}{dac}{svlbl}{continue}
\inst{}{dtc}{svlbl}{continue}
\inst{}{dac}{svlbl}{continue}
\vfill\break

\lnie
\endln
\lnie
standard variable blocks (continued)\endln
\lnie
\endln
\inst{v$dtp}{dbc}{svfnp}{datatype}
\inst{}{dac}{svfnp}{datatype}
\inst{}{dtc}{svfnp}{datatype}
\inst{}{dac}{svfnp}{datatype}
\inst{}{dac}{svfnp}{datatype}
\lnie
\endln
\inst{v$erl}{dbc}{svknm}{errlimit}
\inst{}{dac}{svknm}{errlimit}
\inst{}{dtc}{svknm}{errlimit}
\inst{}{dac}{svknm}{errlimit}
\lnie
\endln
\inst{v$fnc}{dbc}{svknm}{fnclevel}
\inst{}{dac}{svknm}{fnclevel}
\inst{}{dtc}{svknm}{fnclevel}
\inst{}{dac}{svknm}{fnclevel}
\lnie
\endln
\inst{v$fls}{dbc}{svknm}{fullscan}
\inst{}{dac}{svknm}{fullscan}
\inst{}{dtc}{svknm}{fullscan}
\inst{}{dac}{svknm}{fullscan}
\lnie
\endln
\ifmac{.csfn}
\inst{v$lfl}{dbc}{svknm}{lastfile}
\inst{}{dac}{svknm}{lastfile}
\inst{}{dtc}{svknm}{lastfile}
\inst{}{dac}{svknm}{lastfile}
\lnie
\endln
\asmac{fi}
\ifmac{.csln}
\inst{v$lln}{dbc}{svknm}{lastline}
\inst{}{dac}{svknm}{lastline}
\inst{}{dtc}{svknm}{lastline}
\inst{}{dac}{svknm}{lastline}
\lnie
\endln
\asmac{fi}
\inst{v$mxl}{dbc}{svknm}{maxlngth}
\inst{}{dac}{svknm}{maxlngth}
\inst{}{dtc}{svknm}{maxlngth}
\inst{}{dac}{svknm}{maxlngth}
\lnie
\endln
\inst{v$ter}{dbc}{0}{terminal}
\inst{}{dac}{0}{terminal}
\inst{}{dtc}{0}{terminal}
\inst{}{dac}{0}{terminal}
\lnie
\endln
\ifmac{.cbsp}
\inst{v$bsp}{dbc}{svfnn}{backspace}
\inst{}{dac}{svfnn}{backspace}
\inst{}{dtc}{svfnn}{backspace}
\inst{}{dac}{svfnn}{backspace}
\inst{}{dac}{svfnn}{backspace}
\lnie
\endln
\asmac{fi}
\inst{v$pro}{dbc}{svfnn}{prototype}
\inst{}{dac}{svfnn}{prototype}
\inst{}{dtc}{svfnn}{prototype}
\inst{}{dac}{svfnn}{prototype}
\inst{}{dac}{svfnn}{prototype}
\lnie
\endln
\inst{v$scn}{dbc}{svlbl}{scontinue}
\inst{}{dac}{svlbl}{scontinue}
\inst{}{dtc}{svlbl}{scontinue}
\inst{}{dac}{svlbl}{scontinue}
\lnie
\endln
\inst{}{dbc}{0}{dummy entry to end list}
\inst{}{dac}{10}{length gt 9 (scontinue)}
\vfill\break

\lnie
\endln
\lnie
list of svblk pointers for keywords to be dumped. the\endln
\lnie
list is in the order which appears on the dump output.\endln
\lnie
\endln
\inst{vdmkw}{dac}{v$anc}{anchor}
\ifmac{.culc}
\inst{}{dac}{v$cas}{ccase}
\asmac{fi}
\inst{}{dac}{v$cod}{code}
\ifmac{.ccmk}
\ifmac{.ccmc}
\inst{}{dac}{v$com}{compare}
\asmac{else}
\inst{}{dac}{1}{compare not printed}
\asmac{fi}
\asmac{fi}
\inst{}{dac}{v$dmp}{dump}
\inst{}{dac}{v$erl}{errlimit}
\inst{}{dac}{v$etx}{errtext}
\inst{}{dac}{v$ert}{errtype}
\ifmac{.csfn}
\inst{}{dac}{v$fil}{file}
\asmac{fi}
\inst{}{dac}{v$fnc}{fnclevel}
\inst{}{dac}{v$ftr}{ftrace}
\inst{}{dac}{v$fls}{fullscan}
\inst{}{dac}{v$inp}{input}
\ifmac{.csfn}
\inst{}{dac}{v$lfl}{lastfile}
\asmac{fi}
\ifmac{.csln}
\inst{}{dac}{v$lln}{lastline}
\asmac{fi}
\inst{}{dac}{v$lst}{lastno}
\ifmac{.csln}
\inst{}{dac}{v$lin}{line}
\asmac{fi}
\inst{}{dac}{v$mxl}{maxlength}
\inst{}{dac}{v$oup}{output}
\ifmac{.cnpf}
\asmac{else}
\inst{}{dac}{v$pfl}{profile}
\asmac{fi}
\inst{}{dac}{v$rtn}{rtntype}
\inst{}{dac}{v$stc}{stcount}
\inst{}{dac}{v$stl}{stlimit}
\inst{}{dac}{v$stn}{stno}
\inst{}{dac}{v$tra}{trace}
\inst{}{dac}{v$trm}{trim}
\inst{}{dac}{0}{end of list}
\lnie
\endln
\lnie
table used by gtnvr to search svblk lists\endln
\lnie
\endln
\inst{vsrch}{dac}{0}{dummy entry to get proper indexing}
\inst{}{dac}{v$eqf}{start of 1 char variables (none)}
\inst{}{dac}{v$eqf}{start of 2 char variables}
\inst{}{dac}{v$any}{start of 3 char variables}
\ifmac{.cmth}
\inst{}{dac}{v$atn}{start of 4 char variables}
\asmac{else}
\ifmac{.culc}
\inst{}{dac}{v$cas}{start of 4 char variables}
\asmac{else}
\inst{}{dac}{v$chr}{start of 4 char variables}
\asmac{fi}
\asmac{fi}
\inst{}{dac}{v$abe}{start of 5 char variables}
\inst{}{dac}{v$anc}{start of 6 char variables}
\inst{}{dac}{v$col}{start of 7 char variables}
\inst{}{dac}{v$alp}{start of 8 char variables}
\ifmac{.cbsp}
\inst{}{dac}{v$bsp}{start of 9 char variables}
\asmac{else}
\inst{}{dac}{v$pro}{start of 9 char variables}
\asmac{fi}
\lnie
\endln
\lnie
last location in constant section\endln
\lnie
\endln
\inst{c$yyy}{dac}{0}{last location in constant section}
\vfill\break
{\bf spitbol--\rm working storage section}
\vskip1em
\lnie
\endln
\lnie
the working storage section contains areas which are\endln
\lnie
changed during execution of the program. the value\endln
\lnie
assembled is the initial value before execution starts.\endln
\lnie
\endln
\lnie
all these areas are fixed length areas. variable length\endln
\lnie
data is stored in the static or dynamic regions of the\endln
\lnie
allocated data areas.\endln
\lnie
\endln
\lnie
the values in this area are described either as work\endln
\lnie
areas or as global values. a work area is used in an\endln
\lnie
ephemeral manner and the value is not saved from one\endln
\lnie
entry into a routine to another. a global value is a\endln
\lnie
less temporary location whose value is saved from one\endln
\lnie
call to another.\endln
\lnie
\endln
\lnie
w$aaa marks the start of the working section whilst\endln
\lnie
w$yyy marks its end.  g$aaa marks the division between\endln
\lnie
temporary and global values.\endln
\lnie
\endln
\lnie
global values are further subdivided to facilitate\endln
\lnie
processing by the garbage collector. r$aaa through\endln
\lnie
r$yyy are global values that may point into dynamic\endln
\lnie
storage and hence must be relocated after each garbage\endln
\lnie
collection.  they also serve as root pointers to all\endln
\lnie
allocated data that must be preserved.  pointers between\endln
\lnie
a$aaa and r$aaa may point into code, static storage,\endln
\lnie
or mark the limits of dynamic memory.  these pointers\endln
\lnie
must be adjusted when the working section is saved to a\endln
\lnie
file and subsequently reloaded at a different address.\endln
\lnie
\endln
\lnie
a general part of the approach in this program is not\endln
\lnie
to overlap work areas between procedures even though a\endln
\lnie
small amount of space could be saved. such overlap is\endln
\lnie
considered a source of program errors and decreases the\endln
\lnie
information left behind after a system crash of any kind.\endln
\lnie
\endln
\lnie
the names of these locations are labels with five letter\endln
\lnie
(a-y,$) names. as far as possible the order is kept\endln
\lnie
alphabetical by these names but in some cases there\endln
\lnie
are slight departures caused by other order requirements.\endln
\lnie
\endln
\lnie
unless otherwise documented, the order of work areas\endln
\lnie
does not affect the execution of the spitbol program.\endln
\lnie
\endln
\inst{}{sec}{}{start of working storage section}
\vfill\break

\lnie
\endln
\lnie
this area is not cleared by initial code\endln
\lnie
\endln
\inst{cmlab}{dac}{b$scl}{string used to check label legality}
\inst{}{dac}{b$scl}{string used to check label legality}
\inst{}{dtc}{b$scl}{string used to check label legality}
\lnie
\endln
\lnie
label to mark start of work area\endln
\lnie
\endln
\inst{w$aaa}{dac}{b$scl}{}
\lnie
\endln
\lnie
work areas for acess procedure\endln
\lnie
\endln
\inst{actrm}{dac}{0}{trim indicator}
\lnie
\endln
\lnie
work areas for alloc procedure\endln
\lnie
\endln
\inst{aldyn}{dac}{0}{amount of dynamic store}
\inst{allia}{dic}{+0}{dump ia}
\inst{allsv}{dac}{0}{save wb in alloc}
\lnie
\endln
\lnie
work areas for alost procedure\endln
\lnie
\endln
\inst{alsta}{dac}{0}{save wa in alost}
\lnie
\endln
\lnie
work areas for array function (s$arr)\endln
\lnie
\endln
\inst{arcdm}{dac}{0}{count dimensions}
\inst{arnel}{dic}{+0}{count elements}
\inst{arptr}{dac}{0}{offset ptr into arblk}
\inst{arsvl}{dic}{+0}{save integer low bound}
\vfill\break

\lnie
\endln
\lnie
work areas for arref routine\endln
\lnie
\endln
\inst{arfsi}{dic}{+0}{save current evolving subscript}
\inst{arfxs}{dac}{0}{save base stack pointer}
\lnie
\endln
\lnie
work areas for b$efc block routine\endln
\lnie
\endln
\inst{befof}{dac}{0}{save offset ptr into efblk}
\lnie
\endln
\lnie
work areas for b$pfc block routine\endln
\lnie
\endln
\inst{bpfpf}{dac}{0}{save pfblk pointer}
\inst{bpfsv}{dac}{0}{save old function value}
\inst{bpfxt}{dac}{0}{pointer to stacked arguments}
\lnie
\endln
\lnie
work area for collect function (s$col)\endln
\lnie
\endln
\inst{clsvi}{dic}{+0}{save integer argument}
\lnie
\endln
\lnie
work areas value for cncrd\endln
\lnie
\endln
\inst{cnscc}{dac}{0}{pointer to control card string}
\inst{cnswc}{dac}{0}{word count}
\inst{cnr$t}{dac}{0}{pointer to r$ttl or r$stl}
\lnie
\endln
\lnie
work areas for convert function (s$cnv)\endln
\lnie
\endln
\inst{cnvtp}{dac}{0}{save ptr into scvtb}
\lnie
\endln
\lnie
work areas for data function (s$dat)\endln
\lnie
\endln
\inst{datdv}{dac}{0}{save vrblk ptr for datatype name}
\inst{datxs}{dac}{0}{save initial stack pointer}
\lnie
\endln
\lnie
work areas for define function (s$def)\endln
\lnie
\endln
\inst{deflb}{dac}{0}{save vrblk ptr for label}
\inst{defna}{dac}{0}{count function arguments}
\inst{defvr}{dac}{0}{save vrblk ptr for function name}
\inst{defxs}{dac}{0}{save initial stack pointer}
\lnie
\endln
\lnie
work areas for dumpr procedure\endln
\lnie
\endln
\inst{dmarg}{dac}{0}{dump argument}
\inst{dmpsa}{dac}{0}{preserve wa over prtvl call}
\ifmac{.ccmk}
\inst{dmpsb}{dac}{0}{preserve wb over syscm call}
\asmac{fi}
\inst{dmpsv}{dac}{0}{general scratch save}
\inst{dmvch}{dac}{0}{chain pointer for variable blocks}
\inst{dmpch}{dac}{0}{save sorted vrblk chain pointer}
\inst{dmpkb}{dac}{0}{dummy kvblk for use in dumpr}
\inst{dmpkt}{dac}{0}{kvvar trblk ptr (must follow dmpkb)}
\inst{dmpkn}{dac}{0}{keyword number (must follow dmpkt)}
\lnie
\endln
\lnie
work area for dtach\endln
\lnie
\endln
\inst{dtcnb}{dac}{0}{name base}
\inst{dtcnm}{dac}{0}{name ptr}
\lnie
\endln
\lnie
work areas for dupl function (s$dup)\endln
\lnie
\endln
\inst{dupsi}{dic}{+0}{store integer string length}
\lnie
\endln
\lnie
work area for endfile (s$enf)\endln
\lnie
\endln
\inst{enfch}{dac}{0}{for iochn chain head}
\vfill\break

\lnie
\endln
\lnie
work areas for ertex\endln
\lnie
\endln
\inst{ertwa}{dac}{0}{save wa}
\inst{ertwb}{dac}{0}{save wb}
\lnie
\endln
\lnie
work areas for evali\endln
\lnie
\endln
\inst{evlin}{dac}{0}{dummy pattern block pcode}
\inst{evlis}{dac}{0}{then node (must follow evlin)}
\inst{evliv}{dac}{0}{value of parm1 (must follow evlis)}
\inst{evlio}{dac}{0}{ptr to original node}
\inst{evlif}{dac}{0}{flag for simple/complex argument}
\lnie
\endln
\lnie
work area for expan\endln
\lnie
\endln
\inst{expsv}{dac}{0}{save op dope vector pointer}
\lnie
\endln
\lnie
work areas for gbcol procedure\endln
\lnie
\endln
\inst{gbcfl}{dac}{0}{garbage collector active flag}
\inst{gbclm}{dac}{0}{pointer to last move block (pass 3)}
\inst{gbcnm}{dac}{0}{dummy first move block}
\inst{gbcns}{dac}{0}{rest of dummy block (follows gbcnm)}
\ifmac{.csed}
\ifmac{.cepp}
\asmac{else}
\inst{gbcmk}{dac}{0}{bias when marking entry point}
\asmac{fi}
\inst{gbcia}{dic}{+0}{dump ia}
\inst{gbcsd}{dac}{0}{first address beyond sediment}
\inst{gbcsf}{dac}{0}{free space within sediment}
\asmac{fi}
\inst{gbsva}{dac}{0}{save wa}
\inst{gbsvb}{dac}{0}{save wb}
\inst{gbsvc}{dac}{0}{save wc}
\lnie
\endln
\lnie
work areas for gtnvr procedure\endln
\lnie
\endln
\inst{gnvhe}{dac}{0}{ptr to end of hash chain}
\inst{gnvnw}{dac}{0}{number of words in string name}
\inst{gnvsa}{dac}{0}{save wa}
\inst{gnvsb}{dac}{0}{save wb}
\inst{gnvsp}{dac}{0}{pointer into vsrch table}
\inst{gnvst}{dac}{0}{pointer to chars of string}
\lnie
\endln
\lnie
work areas for gtarr\endln
\lnie
\endln
\inst{gtawa}{dac}{0}{save wa}
\lnie
\endln
\lnie
work areas for gtint\endln
\lnie
\endln
\inst{gtina}{dac}{0}{save wa}
\inst{gtinb}{dac}{0}{save wb}
\vfill\break

\lnie
\endln
\lnie
work areas for gtnum procedure\endln
\lnie
\endln
\inst{gtnnf}{dac}{0}{zero/nonzero for result +/-}
\inst{gtnsi}{dic}{+0}{general integer save}
\ifmac{.cnra}
\asmac{else}
\inst{gtndf}{dac}{0}{0/1 for dec point so far no/yes}
\inst{gtnes}{dac}{0}{zero/nonzero exponent +/-}
\inst{gtnex}{dic}{+0}{real exponent}
\inst{gtnsc}{dac}{0}{scale (places after point)}
\inst{gtnsr}{drc}{+0.0}{general real save}
\inst{gtnrd}{dac}{0}{flag for ok real number}
\asmac{fi}
\lnie
\endln
\lnie
work areas for gtpat procedure\endln
\lnie
\endln
\inst{gtpsb}{dac}{0}{save wb}
\lnie
\endln
\lnie
work areas for gtstg procedure\endln
\lnie
\endln
\inst{gtssf}{dac}{0}{0/1 for result +/-}
\inst{gtsvc}{dac}{0}{save wc}
\inst{gtsvb}{dac}{0}{save wb}
\ifmac{.cnra}
\asmac{else}
\ifmac{.cncr}
\asmac{else}
\inst{gtses}{dac}{0}{char + or - for exponent +/-}
\inst{gtsrs}{drc}{+0.0}{general real save}
\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
work areas for gtvar procedure\endln
\lnie
\endln
\inst{gtvrc}{dac}{0}{save wc}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
work areas for insbf\endln
\lnie
\endln
\inst{insab}{dac}{0}{entry wa + entry wb}
\inst{insln}{dac}{0}{length of insertion string}
\inst{inssa}{dac}{0}{save entry wa}
\inst{inssb}{dac}{0}{save entry wb}
\inst{inssc}{dac}{0}{save entry wc}
\asmac{fi}
\lnie
\endln
\lnie
work areas for ioput\endln
\lnie
\endln
\inst{ioptt}{dac}{0}{type of association}
\ifmac{.cnld}
\asmac{else}
\lnie
\endln
\lnie
work areas for load function\endln
\lnie
\endln
\inst{lodfn}{dac}{0}{pointer to vrblk for func name}
\inst{lodna}{dac}{0}{count number of arguments}
\asmac{fi}
\ifmac{.cnpf}
\asmac{else}
\lnie
\endln
\lnie
work area for profiler\endln
\lnie
\endln
\inst{pfsvw}{dac}{0}{to save a w-reg}
\asmac{fi}
\lnie
\endln
\lnie
work areas for prtnm procedure\endln
\lnie
\endln
\inst{prnsi}{dic}{+0}{scratch integer loc}
\lnie
\endln
\lnie
work areas for prtsn procedure\endln
\lnie
\endln
\inst{prsna}{dac}{0}{save wa}
\lnie
\endln
\lnie
work areas for prtst procedure\endln
\lnie
\endln
\inst{prsva}{dac}{0}{save wa}
\inst{prsvb}{dac}{0}{save wb}
\inst{prsvc}{dac}{0}{save char counter}
\lnie
\endln
\lnie
work area for prtnl\endln
\lnie
\endln
\inst{prtsa}{dac}{0}{save wa}
\inst{prtsb}{dac}{0}{save wb}
\lnie
\endln
\lnie
work area for prtvl\endln
\lnie
\endln
\inst{prvsi}{dac}{0}{save idval}
\lnie
\endln
\lnie
work areas for pattern match routines\endln
\lnie
\endln
\inst{psave}{dac}{0}{temporary save for current node ptr}
\inst{psavc}{dac}{0}{save cursor in p$spn, p$str}
\ifmac{.crel}
\lnie
\endln
\lnie
work area for relaj routine\endln
\lnie
\endln
\inst{rlals}{dac}{0}{ptr to list of bounds and adjusts}
\lnie
\endln
\lnie
work area for reldn routine\endln
\lnie
\endln
\inst{rldcd}{dac}{0}{save code adjustment}
\inst{rldst}{dac}{0}{save static adjustment}
\inst{rldls}{dac}{0}{save list pointer}
\asmac{fi}
\lnie
\endln
\lnie
work areas for retrn routine\endln
\lnie
\endln
\inst{rtnbp}{dac}{0}{to save a block pointer}
\inst{rtnfv}{dac}{0}{new function value (result)}
\inst{rtnsv}{dac}{0}{old function value (saved value)}
\lnie
\endln
\lnie
work areas for substr function (s$sub)\endln
\lnie
\endln
\inst{sbssv}{dac}{0}{save third argument}
\lnie
\endln
\lnie
work areas for scan procedure\endln
\lnie
\endln
\inst{scnsa}{dac}{0}{save wa}
\inst{scnsb}{dac}{0}{save wb}
\inst{scnsc}{dac}{0}{save wc}
\inst{scnof}{dac}{0}{save offset}
\ifmac{.cnsr}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
work area used by sorta, sortc, sortf, sorth\endln
\lnie
\endln
\inst{srtdf}{dac}{0}{datatype field name}
\inst{srtfd}{dac}{0}{found dfblk address}
\inst{srtff}{dac}{0}{found field name}
\inst{srtfo}{dac}{0}{offset to field name}
\inst{srtnr}{dac}{0}{number of rows}
\inst{srtof}{dac}{0}{offset within row to sort key}
\inst{srtrt}{dac}{0}{root offset}
\inst{srts1}{dac}{0}{save offset 1}
\inst{srts2}{dac}{0}{save offset 2}
\inst{srtsc}{dac}{0}{save wc}
\inst{srtsf}{dac}{0}{sort array first row offset}
\inst{srtsn}{dac}{0}{save n}
\inst{srtso}{dac}{0}{offset to a(0)}
\inst{srtsr}{dac}{0}{0, non-zero for sort, rsort}
\inst{srtst}{dac}{0}{stride from one row to next}
\inst{srtwc}{dac}{0}{dump wc}
\asmac{fi}
\lnie
\endln
\lnie
work areas for stopr routine\endln
\lnie
\endln
\inst{stpsi}{dic}{+0}{save value of stcount}
\inst{stpti}{dic}{+0}{save time elapsed}
\lnie
\endln
\lnie
work areas for tfind procedure\endln
\lnie
\endln
\inst{tfnsi}{dic}{+0}{number of headers}
\lnie
\endln
\lnie
work areas for xscan procedure\endln
\lnie
\endln
\inst{xscrt}{dac}{0}{save return code}
\inst{xscwb}{dac}{0}{save register wb}
\lnie
\endln
\lnie
start of global values in working section\endln
\lnie
\endln
\inst{g$aaa}{dac}{0}{}
\lnie
\endln
\lnie
global value for alloc procedure\endln
\lnie
\endln
\inst{alfsf}{dic}{+0}{factor in free store pcntage check}
\lnie
\endln
\lnie
global values for cmpil procedure\endln
\lnie
\endln
\inst{cmerc}{dac}{0}{count of initial compile errors}
\inst{cmpln}{dac}{0}{line number of first line of stmt}
\inst{cmpxs}{dac}{0}{save stack ptr in case of errors}
\inst{cmpsn}{dac}{1}{number of next statement to compile}
\lnie
\endln
\lnie
global values for cncrd\endln
\lnie
\endln
\ifmac{.cinc}
\inst{cnsil}{dac}{0}{save scnil during include process.}
\inst{cnind}{dac}{0}{current include file nest level}
\inst{cnspt}{dac}{0}{save scnpt during include process.}
\asmac{fi}
\inst{cnttl}{dac}{0}{flag for -title, -stitl}
\lnie
\endln
\lnie
global flag for suppression of compilation statistics.\endln
\lnie
\endln
\inst{cpsts}{dac}{0}{suppress comp. stats if non zero}
\lnie
\endln
\lnie
global values for control card switches\endln
\lnie
\endln
\inst{cswdb}{dac}{0}{0/1 for -single/-double}
\inst{cswer}{dac}{0}{0/1 for -errors/-noerrors}
\inst{cswex}{dac}{0}{0/1 for -execute/-noexecute}
\inst{cswfl}{dac}{1}{0/1 for -nofail/-fail}
\inst{cswin}{dac}{iniln}{xxx for -inxxx}
\inst{cswls}{dac}{1}{0/1 for -nolist/-list}
\inst{cswno}{dac}{0}{0/1 for -optimise/-noopt}
\inst{cswpr}{dac}{0}{0/1 for -noprint/-print}
\lnie
\endln
\lnie
global location used by patst procedure\endln
\lnie
\endln
\inst{ctmsk}{dbc}{0}{last bit position used in r$ctp}
\inst{curid}{dac}{0}{current id value}
\vfill\break

\lnie
\endln
\lnie
global value for cdwrd procedure\endln
\lnie
\endln
\inst{cwcof}{dac}{0}{next word offset in current ccblk}
\ifmac{.csed}
\lnie
\endln
\lnie
global locations for dynamic storage pointers\endln
\lnie
\endln
\inst{dnams}{dac}{0}{size of sediment in baus}
\asmac{fi}
\lnie
\endln
\lnie
global area for error processing.\endln
\lnie
\endln
\inst{erich}{dac}{0}{copy error reports to int.chan if 1}
\inst{erlst}{dac}{0}{for listr when errors go to int.ch.}
\inst{errft}{dac}{0}{fatal error flag}
\inst{errsp}{dac}{0}{error suppression flag}
\lnie
\endln
\lnie
global flag for suppression of execution stats\endln
\lnie
\endln
\inst{exsts}{dac}{0}{suppress exec stats if set}
\lnie
\endln
\lnie
global values for exfal and return\endln
\lnie
\endln
\inst{flprt}{dac}{0}{location of fail offset for return}
\inst{flptr}{dac}{0}{location of failure offset on stack}
\lnie
\endln
\lnie
global location to count garbage collections (gbcol)\endln
\lnie
\endln
\ifmac{.csed}
\inst{gbsed}{dic}{+0}{factor in sediment pcntage check}
\asmac{fi}
\inst{gbcnt}{dac}{0}{count of garbage collections}
\lnie
\endln
\lnie
global value for gtcod and gtexp\endln
\lnie
\endln
\inst{gtcef}{dac}{0}{save fail ptr in case of error}
\lnie
\endln
\lnie
global locations for gtstg procedure\endln
\lnie
\endln
\ifmac{.cnra}
\asmac{else}
\ifmac{.cncr}
\asmac{else}
\inst{gtsrn}{drc}{+0.0}{rounding factor 0.5*10**-cfp$s}
\inst{gtssc}{drc}{+0.0}{scaling value 10**cfp$s}
\asmac{fi}
\asmac{fi}
\inst{gtswk}{dac}{0}{ptr to work area for gtstg}
\lnie
\endln
\lnie
global flag for header printing\endln
\lnie
\endln
\inst{headp}{dac}{0}{header printed flag}
\lnie
\endln
\lnie
global values for variable hash table\endln
\lnie
\endln
\inst{hshnb}{dic}{+0}{number of hash buckets}
\lnie
\endln
\lnie
global areas for init\endln
\lnie
\endln
\inst{initr}{dac}{0}{save terminal flag}
\vfill\break

\lnie
\endln
\lnie
global values for keyword values which are stored as one\endln
\lnie
word integers. these values must be assembled in the\endln
\lnie
following order (as dictated by k$xxx definition values).\endln
\lnie
\endln
\inst{kvabe}{dac}{0}{abend}
\inst{kvanc}{dac}{0}{anchor}
\ifmac{.culc}
\inst{kvcas}{dac}{0}{case}
\asmac{fi}
\inst{kvcod}{dac}{0}{code}
\ifmac{.ccmk}
\inst{kvcom}{dac}{0}{compare}
\asmac{fi}
\inst{kvdmp}{dac}{0}{dump}
\inst{kverl}{dac}{0}{errlimit}
\inst{kvert}{dac}{0}{errtype}
\inst{kvftr}{dac}{0}{ftrace}
\inst{kvfls}{dac}{1}{fullscan}
\inst{kvinp}{dac}{1}{input}
\inst{kvmxl}{dac}{5000}{maxlength}
\inst{kvoup}{dac}{1}{output}
\ifmac{.cnpf}
\asmac{else}
\inst{kvpfl}{dac}{0}{profile}
\asmac{fi}
\inst{kvtra}{dac}{0}{trace}
\inst{kvtrm}{dac}{0}{trim}
\inst{kvfnc}{dac}{0}{fnclevel}
\inst{kvlst}{dac}{0}{lastno}
\ifmac{.csln}
\inst{kvlln}{dac}{0}{lastline}
\inst{kvlin}{dac}{0}{line}
\asmac{fi}
\inst{kvstn}{dac}{0}{stno}
\lnie
\endln
\lnie
global values for other keywords\endln
\lnie
\endln
\inst{kvalp}{dac}{0}{alphabet}
\inst{kvrtn}{dac}{nulls}{rtntype (scblk pointer)}
\ifmac{.cs16}
\inst{kvstl}{dic}{+32767}{stlimit}
\inst{kvstc}{dic}{+32767}{stcount (counts down from stlimit)}
\asmac{else}
\ifmac{.cs32}
\inst{kvstl}{dic}{+2147483647}{stlimit}
\inst{kvstc}{dic}{+2147483647}{stcount (counts down from stlimit)}
\asmac{else}
\inst{kvstl}{dic}{+50000}{stlimit}
\inst{kvstc}{dic}{+50000}{stcount (counts down from stlimit)}
\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
global values for listr procedure\endln
\lnie
\endln
\ifmac{.cinc}
\inst{lstid}{dac}{0}{include depth of current image}
\asmac{fi}
\inst{lstlc}{dac}{0}{count lines on source list page}
\inst{lstnp}{dac}{0}{max number of lines on page}
\inst{lstpf}{dac}{1}{set nonzero if current image listed}
\inst{lstpg}{dac}{0}{current source list page number}
\inst{lstpo}{dac}{0}{offset to   page nnn   message}
\inst{lstsn}{dac}{0}{remember last stmnum listed}
\lnie
\endln
\lnie
global maximum size of spitbol objects\endln
\lnie
\endln
\inst{mxlen}{dac}{0}{initialised by sysmx call}
\lnie
\endln
\lnie
global execution control variable\endln
\lnie
\endln
\inst{noxeq}{dac}{0}{set non-zero to inhibit execution}
\ifmac{.cnpf}
\asmac{else}
\lnie
\endln
\lnie
global profiler values locations\endln
\lnie
\endln
\inst{pfdmp}{dac}{0}{set non-0 if &profile set non-0}
\inst{pffnc}{dac}{0}{set non-0 if funct just entered}
\inst{pfstm}{dic}{+0}{to store starting time of stmt}
\inst{pfetm}{dic}{+0}{to store ending time of stmt}
\inst{pfnte}{dac}{0}{nr of table entries}
\inst{pfste}{dic}{+0}{gets int rep of table entry size}
\asmac{fi}
\lnie
\endln
\vfill\break

\lnie
\endln
\lnie
global values used in pattern match routines\endln
\lnie
\endln
\inst{pmdfl}{dac}{0}{pattern assignment flag}
\inst{pmhbs}{dac}{0}{history stack base pointer}
\inst{pmssl}{dac}{0}{length of subject string in chars}
\ifmac{.cpol}
\lnie
\endln
\lnie
global values for interface polling (syspl)\endln
\lnie
\endln
\inst{polcs}{dac}{1}{poll interval start value}
\inst{polct}{dac}{1}{poll interval counter}
\asmac{fi}
\lnie
\endln
\lnie
global flags used for standard file listing options\endln
\lnie
\endln
\inst{prich}{dac}{0}{printer on interactive channel}
\inst{prstd}{dac}{0}{tested by prtpg}
\inst{prsto}{dac}{0}{standard listing option flag}
\lnie
\endln
\lnie
global values for print procedures\endln
\lnie
\endln
\inst{prbuf}{dac}{0}{ptr to print bfr in static}
\inst{precl}{dac}{0}{extended/compact listing flag}
\inst{prlen}{dac}{0}{length of print buffer in chars}
\inst{prlnw}{dac}{0}{length of print buffer in words}
\inst{profs}{dac}{0}{offset to next location in prbuf}
\inst{prtef}{dac}{0}{endfile flag}
\vfill\break

\lnie
\endln
\lnie
global area for readr\endln
\lnie
\endln
\inst{rdcln}{dac}{0}{current statement line number}
\inst{rdnln}{dac}{0}{next statement line number}
\lnie
\endln
\lnie
global amount of memory reserved for end of execution\endln
\lnie
\endln
\inst{rsmem}{dac}{0}{reserve memory}
\lnie
\endln
\lnie
global area for stmgo counters\endln
\lnie
\endln
\inst{stmcs}{dac}{1}{counter startup value}
\inst{stmct}{dac}{1}{counter active value}
\lnie
\endln
\lnie
adjustable global values\endln
\lnie
\endln
\lnie
all the pointers in this section can point to the\endln
\lnie
dynamic or the static region.\endln
\lnie
when a save file is reloaded, these pointers must\endln
\lnie
be adjusted if static or dynamic memory is now\endln
\lnie
at a different address.  see routine reloc for\endln
\lnie
additional information.\endln
\lnie
\endln
\lnie
some values cannot be move here because of adjacency\endln
\lnie
constraints.  they are handled specially by reloc et al.\endln
\lnie
these values are kvrtn,\endln
\lnie
\endln
\lnie
values gtswk, kvalp, and prbuf are reinitialized by\endln
\lnie
procedure insta, and do not need to appear here.\endln
\lnie
\endln
\lnie
values flprt, flptr, gtcef, and stbas point into the\endln
\lnie
stack and are explicitly adjusted by osint's restart\endln
\lnie
procedure.\endln
\lnie
\endln
\inst{a$aaa}{dac}{0}{start of adjustable values}
\inst{cmpss}{dac}{0}{save subroutine stack ptr}
\inst{dnamb}{dac}{0}{start of dynamic area}
\inst{dnamp}{dac}{0}{next available loc in dynamic area}
\inst{dname}{dac}{0}{end of available dynamic area}
\inst{hshtb}{dac}{0}{pointer to start of vrblk hash tabl}
\inst{hshte}{dac}{0}{pointer past end of vrblk hash tabl}
\inst{iniss}{dac}{0}{save subroutine stack ptr}
\inst{pftbl}{dac}{0}{gets adrs of (imag) table base}
\inst{prnmv}{dac}{0}{vrblk ptr from last name search}
\inst{statb}{dac}{0}{start of static area}
\inst{state}{dac}{0}{end of static area}
\inst{stxvr}{dac}{nulls}{vrblk pointer or null}
\lnie
\endln
\lnie
relocatable global values\endln
\lnie
\endln
\lnie
all the pointers in this section can point to blocks in\endln
\lnie
the dynamic storage area and must be relocated by the\endln
\lnie
garbage collector. they are identified by r$xxx names.\endln
\lnie
\endln
\inst{r$aaa}{dac}{0}{start of relocatable values}
\inst{r$arf}{dac}{0}{array block pointer for arref}
\inst{r$ccb}{dac}{0}{ptr to ccblk being built (cdwrd)}
\inst{r$cim}{dac}{0}{ptr to current compiler input str}
\inst{r$cmp}{dac}{0}{copy of r$cim used in cmpil}
\inst{r$cni}{dac}{0}{ptr to next compiler input string}
\inst{r$cnt}{dac}{0}{cdblk pointer for setexit continue}
\inst{r$cod}{dac}{0}{pointer to current cdblk or exblk}
\inst{r$ctp}{dac}{0}{ptr to current ctblk for patst}
\inst{r$cts}{dac}{0}{ptr to last string scanned by patst}
\inst{r$ert}{dac}{0}{trblk pointer for errtype trace}
\inst{r$etx}{dac}{nulls}{pointer to errtext string}
\inst{r$exs}{dac}{0}{= save xl in expdm}
\inst{r$fcb}{dac}{0}{fcblk chain head}
\inst{r$fnc}{dac}{0}{trblk pointer for fnclevel trace}
\inst{r$gtc}{dac}{0}{keep code ptr for gtcod,gtexp}
\ifmac{.cinc}
\inst{r$ici}{dac}{0}{saved r$cim during include process.}
\ifmac{.csfn}
\inst{r$ifa}{dac}{0}{array of file names by incl. depth}
\inst{r$ifl}{dac}{0}{array of line nums by include depth}
\asmac{fi}
\inst{r$ifn}{dac}{0}{last include file name}
\inst{r$inc}{dac}{0}{table of include file names seen}
\asmac{fi}
\inst{r$io1}{dac}{0}{file arg1 for ioput}
\inst{r$io2}{dac}{0}{file arg2 for ioput}
\inst{r$iof}{dac}{0}{fcblk ptr or 0}
\inst{r$ion}{dac}{0}{name base ptr}
\inst{r$iop}{dac}{0}{predecessor block ptr for ioput}
\inst{r$iot}{dac}{0}{trblk ptr for ioput}
\ifmac{.cnbf}
\asmac{else}
\inst{r$pmb}{dac}{0}{buffer ptr in pattern match}
\asmac{fi}
\inst{r$pms}{dac}{0}{subject string ptr in pattern match}
\inst{r$ra2}{dac}{0}{replace second argument last time}
\inst{r$ra3}{dac}{0}{replace third argument last time}
\inst{r$rpt}{dac}{0}{ptr to ctblk replace table last usd}
\inst{r$scp}{dac}{0}{save pointer from last scane call}
\ifmac{.csfn}
\inst{r$sfc}{dac}{nulls}{current source file name}
\inst{r$sfn}{dac}{0}{ptr to source file name table}
\asmac{fi}
\inst{r$sxl}{dac}{0}{preserve xl in sortc}
\inst{r$sxr}{dac}{0}{preserve xr in sorta/sortc}
\inst{r$stc}{dac}{0}{trblk pointer for stcount trace}
\inst{r$stl}{dac}{0}{source listing sub-title}
\inst{r$sxc}{dac}{0}{code (cdblk) ptr for setexit trap}
\inst{r$ttl}{dac}{nulls}{source listing title}
\inst{r$xsc}{dac}{0}{string pointer for xscan}
\vfill\break

\lnie
\endln
\lnie
the remaining pointers in this list are used to point\endln
\lnie
to function blocks for normally undefined operators.\endln
\lnie
\endln
\inst{r$uba}{dac}{stndo}{binary at}
\inst{r$ubm}{dac}{stndo}{binary ampersand}
\inst{r$ubn}{dac}{stndo}{binary number sign}
\inst{r$ubp}{dac}{stndo}{binary percent}
\inst{r$ubt}{dac}{stndo}{binary not}
\inst{r$uub}{dac}{stndo}{unary vertical bar}
\inst{r$uue}{dac}{stndo}{unary equal}
\inst{r$uun}{dac}{stndo}{unary number sign}
\inst{r$uup}{dac}{stndo}{unary percent}
\inst{r$uus}{dac}{stndo}{unary slash}
\inst{r$uux}{dac}{stndo}{unary exclamation}
\inst{r$yyy}{dac}{0}{last relocatable location}
\lnie
\endln
\lnie
global locations used in scan procedure\endln
\lnie
\endln
\inst{scnbl}{dac}{0}{set non-zero if scanned past blanks}
\inst{scncc}{dac}{0}{non-zero to scan control card name}
\inst{scngo}{dac}{0}{set non-zero to scan goto field}
\inst{scnil}{dac}{0}{length of current input image}
\inst{scnpt}{dac}{0}{pointer to next location in r$cim}
\inst{scnrs}{dac}{0}{set non-zero to signal rescan}
\inst{scnse}{dac}{0}{start of current element}
\inst{scntp}{dac}{0}{save syntax type from last call}
\lnie
\endln
\lnie
global value for indicating stage (see error section)\endln
\lnie
\endln
\inst{stage}{dac}{0}{initial value = initial compile}
\vfill\break

\lnie
\endln
\lnie
global stack pointer\endln
\lnie
\endln
\inst{stbas}{dac}{0}{pointer past stack base}
\lnie
\endln
\lnie
global values for setexit function (s$stx)\endln
\lnie
\endln
\inst{stxoc}{dac}{0}{code pointer offset}
\inst{stxof}{dac}{0}{failure offset}
\lnie
\endln
\lnie
global value for time keeping\endln
\lnie
\endln
\inst{timsx}{dic}{+0}{time at start of execution}
\inst{timup}{dac}{0}{set when time up occurs}
\lnie
\endln
\lnie
global values for xscan and xscni procedures\endln
\lnie
\endln
\inst{xsofs}{dac}{0}{offset to current location in r$xsc}
\lnie
\endln
\lnie
label to mark end of working section\endln
\lnie
\endln
\inst{w$yyy}{dac}{0}{}
\vfill\break
{\bf spitbol--\rm minimal code}
\vskip1em
\inst{}{sec}{}{start of program section}
\inst{s$aaa}{ent}{bl$$i}{mark start of code}
\ifmac{.crel}
\vfill\break
{\bf spitbol--\rm relocation}
\vskip1em
\lnie
\endln
\lnie
relocation\endln
\lnie
the following section provides services to osint to\endln
\lnie
relocate portions of the workspace.  it is used when\endln
\lnie
a saved memory image must be restarted at a different\endln
\lnie
location.\endln
\lnie
\endln
\lnie
relaj -- relocate a list of pointers\endln
\lnie
\endln
\lnie
(wa)                  ptr past last pointer of list\endln
\lnie
(wb)                  ptr to first pointer of list\endln
\lnie
(xl)                  list of boundaries and adjustments\endln
\lnie
jsr  relaj            call to process list of pointers\endln
\lnie
(wb)                  destroyed\endln
\lnie
\endln
\inst{relaj}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save xr}
\inst{}{mov}{wa,-(xs)}{save wa}
\inst{}{mov}{xl,rlals}{save ptr to list of bounds}
\inst{}{mov}{wb,xr}{ptr to first pointer to process}
\lnie
\endln
\lnie
merge here to check if done\endln
\lnie
\endln
\inst{rlaj0}{mov}{rlals,xl}{restore xl}
\inst{}{bne}{xr,(xs),rlaj1}{proceed if more to do}
\inst{}{mov}{(xs)+,wa}{restore wa}
\inst{}{mov}{(xs)+,xr}{restore xr}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
merge here to process next pointer on list\endln
\lnie
\endln
\inst{rlaj1}{mov}{(xr),wa}{load next pointer on list}
\inst{}{lct}{wb,=rnsi$}{number of sections of adjusters}
\lnie
\endln
\lnie
merge here to process next section of stack list\endln
\lnie
\endln
\inst{rlaj2}{bgt}{wa,rlend(xl),rlaj3}{ok if past end of section}
\inst{}{blt}{wa,rlstr(xl),rlaj3}{or if before start of section}
\inst{}{add}{rladj(xl),wa}{within section, add adjustment}
\inst{}{mov}{wa,(xr)}{return updated ptr to memory}
\inst{}{brn}{rlaj4}{done with this pointer}
\lnie
\endln
\lnie
here if not within section\endln
\lnie
\endln
\inst{rlaj3}{add}{*rssi$,xl}{advance to next section}
\inst{}{bct}{wb,rlaj2}{jump if more to go}
\lnie
\endln
\lnie
here when finished processing one pointer\endln
\lnie
\endln
\inst{rlaj4}{ica}{xr}{increment to next ptr on list}
\inst{}{brn}{rlaj0}{jump to check  for completion}
\inst{}{enp}{}{end procedure relaj}
\vfill\break

\lnie
\endln
\lnie
relcr -- create relocation info after save file reload\endln
\lnie
\endln
\lnie
(wa)                  original s$aaa code section adr\endln
\lnie
(wb)                  original c$aaa constant section adr\endln
\lnie
(wc)                  original g$aaa working section adr\endln
\lnie
(xr)                  ptr to start of static region\endln
\lnie
(cp)                  ptr to start of dynamic region\endln
\lnie
(xl)                  ptr to area to receive information\endln
\lnie
jsr  relcr            create relocation information\endln
\lnie
(wa,wb,wc,xr)         destroyed\endln
\lnie
\endln
\lnie
a block of information is built at (xl) that is used\endln
\lnie
in relocating pointers.  there are rnsi$ instances\endln
\lnie
of a rssi$ word structure.  each instance corresponds\endln
\lnie
to one of the regions that a pointer might point into.\endln
\lnie
the layout of this structure is shown in the definitions\endln
\lnie
section, together with symbolic definitions of the\endln
\lnie
entries as offsets from xl.\endln
\lnie
\endln
\inst{relcr}{prc}{e,0}{entry point}
\inst{}{add}{*rlsi$,xl}{point past build area}
\inst{}{mov}{wa,-(xl)}{save original code address}
\inst{}{mov}{=s$aaa,wa}{compute adjustment}
\inst{}{sub}{(xl),wa}{as new s$aaa minus original s$aaa}
\inst{}{mov}{wa,-(xl)}{save code adjustment}
\inst{}{mov}{=s$yyy,wa}{end of target code section}
\inst{}{sub}{=s$aaa,wa}{length of code section}
\inst{}{add}{num01(xl),wa}{plus original start address}
\inst{}{mov}{wa,-(xl)}{end of original code section}
\inst{}{mov}{wb,-(xl)}{save constant section address}
\inst{}{mov}{=c$aaa,wb}{start of constants section}
\inst{}{mov}{=c$yyy,wa}{end of constants section}
\inst{}{sub}{wb,wa}{length of constants section}
\inst{}{sub}{(xl),wb}{new c$aaa minus original c$aaa}
\inst{}{mov}{wb,-(xl)}{save constant adjustment}
\inst{}{add}{num01(xl),wa}{length plus original start adr}
\inst{}{mov}{wa,-(xl)}{save as end of original constants}
\inst{}{mov}{wc,-(xl)}{save working globals address}
\inst{}{mov}{=g$aaa,wc}{start of working globals section}
\inst{}{mov}{=w$yyy,wa}{end of working section}
\inst{}{sub}{wc,wa}{length of working globals}
\inst{}{sub}{(xl),wc}{new g$aaa minus original g$aaa}
\inst{}{mov}{wc,-(xl)}{save working globals adjustment}
\inst{}{add}{num01(xl),wa}{length plus original start adr}
\inst{}{mov}{wa,-(xl)}{save as end of working globals}
\inst{}{mov}{statb,wb}{old start of static region}
\inst{}{mov}{wb,-(xl)}{save}
\inst{}{sub}{wb,xr}{compute adjustment}
\inst{}{mov}{xr,-(xl)}{save new statb minus old statb}
\inst{}{mov}{state,-(xl)}{old end of static region}
\inst{}{mov}{dnamb,wb}{old start of dynamic region}
\inst{}{mov}{wb,-(xl)}{save}
\inst{}{scp}{wa}{new start of dynamic}
\inst{}{sub}{wb,wa}{compute adjustment}
\inst{}{mov}{wa,-(xl)}{save new dnamb minus old dnamb}
\inst{}{mov}{dnamp,wc}{old end of dynamic region in use}
\inst{}{mov}{wc,-(xl)}{save as end of old dynamic region}
\inst{}{exi}{wc,-(xl)}{save as end of old dynamic region}
\inst{}{enp}{wc,-(xl)}{save as end of old dynamic region}
\vfill\break

\lnie
\endln
\lnie
reldn -- relocate pointers in the dynamic region\endln
\lnie
\endln
\lnie
(xl)                  list of boundaries and adjustments\endln
\lnie
(xr)                  ptr to first location to process\endln
\lnie
(wc)                  ptr past last location to process\endln
\lnie
jsr  reldn            call to process blocks in dynamic\endln
\lnie
(wa,wb,wc,xr)         destroyed\endln
\lnie
\endln
\lnie
processes all blocks in the dynamic region.  within a\endln
\lnie
block, pointers to the code section, constant section,\endln
\lnie
working globals section, static region, and dynamic\endln
\lnie
region are relocated as needed.\endln
\lnie
\endln
\inst{reldn}{prc}{e,0}{entry point}
\inst{}{mov}{rlcda(xl),rldcd}{save code adjustment}
\inst{}{mov}{rlsta(xl),rldst}{save static adjustment}
\inst{}{mov}{xl,rldls}{save list pointer}
\lnie
\endln
\lnie
merge here to process the next block in dynamic\endln
\lnie
\endln
\inst{rld01}{add}{rldcd,(xr)}{adjust block type word}
\inst{}{mov}{(xr),xl}{load block type word}
\inst{}{lei}{xl}{load entry point id (bl$xx)}
\lnie
\endln
\lnie
block type switch. note that blocks with no relocatable\endln
\lnie
fields just return to rld05 to continue to next block.\endln
\lnie
\endln
\lnie
note that dfblks do not appear in dynamic, only in static.\endln
\lnie
ccblks and cmblks are not live when a save file is\endln
\lnie
created, and can be skipped.\endln
\lnie
\endln
\lnie
further note:  static blocks other than vrblks discovered\endln
\lnie
while scanning dynamic must be adjusted at this time.\endln
\lnie
see processing of ffblk for example.\endln
\lnie
\endln
\vfill\break

\lnie
\endln
\lnie
reldn (continued)\endln
\lnie
\endln
\inst{}{bsw}{xl,bl$$$}{switch on block type}
\inst{}{iff}{bl$ar,rld03}{arblk}
\ifmac{.cnbf}
\inst{}{iff}{bl$bc,rld05}{bcblk - dummy to fill out iffs}
\asmac{else}
\inst{}{iff}{bl$bc,rld06}{bcblk}
\asmac{fi}
\inst{}{iff}{bl$bf,rld05}{bfblk}
\inst{}{iff}{bl$cc,rld05}{ccblk}
\inst{}{iff}{bl$cd,rld07}{cdblk}
\inst{}{iff}{bl$cm,rld05}{cmblk}
\inst{}{iff}{bl$ct,rld05}{ctblk}
\inst{}{iff}{bl$df,rld05}{dfblk}
\inst{}{iff}{bl$ef,rld08}{efblk}
\inst{}{iff}{bl$ev,rld09}{evblk}
\inst{}{iff}{bl$ex,rld10}{exblk}
\inst{}{iff}{bl$ff,rld11}{ffblk}
\inst{}{iff}{bl$ic,rld05}{icblk}
\inst{}{iff}{bl$kv,rld13}{kvblk}
\inst{}{iff}{bl$nm,rld13}{nmblk}
\inst{}{iff}{bl$p0,rld13}{p0blk}
\inst{}{iff}{bl$p1,rld14}{p1blk}
\inst{}{iff}{bl$p2,rld14}{p2blk}
\inst{}{iff}{bl$pd,rld15}{pdblk}
\inst{}{iff}{bl$pf,rld16}{pfblk}
\ifmac{.cnra}
\asmac{else}
\inst{}{iff}{bl$rc,rld05}{rcblk}
\asmac{fi}
\inst{}{iff}{bl$sc,rld05}{scblk}
\inst{}{iff}{bl$se,rld13}{seblk}
\inst{}{iff}{bl$tb,rld17}{tbblk}
\inst{}{iff}{bl$te,rld18}{teblk}
\inst{}{iff}{bl$tr,rld19}{trblk}
\inst{}{iff}{bl$vc,rld17}{vcblk}
\inst{}{iff}{bl$xn,rld05}{xnblk}
\inst{}{iff}{bl$xr,rld20}{xrblk}
\inst{}{esw}{}{end of jump table}
\lnie
\endln
\lnie
arblk\endln
\lnie
\endln
\inst{rld03}{mov}{arlen(xr),wa}{load length}
\inst{}{mov}{arofs(xr),wb}{set offset to 1st reloc fld (arpro)}
\lnie
\endln
\lnie
merge here to process pointers in a block\endln
\lnie
\endln
\lnie
(xr)                  ptr to current block\endln
\lnie
(wc)                  ptr past last location to process\endln
\lnie
(wa)                  length (reloc flds + flds at start)\endln
\lnie
(wb)                  offset to first reloc field\endln
\lnie
\endln
\inst{rld04}{add}{xr,wa}{point past last reloc field}
\inst{}{add}{xr,wb}{point to first reloc field}
\inst{}{mov}{rldls,xl}{point to list of bounds}
\inst{}{jsr}{relaj}{adjust pointers}
\vfill\break

\lnie
\endln
\lnie
reldn (continued)\endln
\lnie
\endln
\lnie
\endln
\lnie
merge here to advance to next block\endln
\lnie
\endln
\lnie
(xr)                  ptr to current block\endln
\lnie
(wc)                  ptr past last location to process\endln
\lnie
\endln
\inst{rld05}{mov}{(xr),wa}{block type word}
\inst{}{jsr}{blkln}{get length of block}
\inst{}{add}{wa,xr}{point to next block}
\inst{}{blt}{xr,wc,rld01}{continue if more to process}
\inst{}{mov}{rldls,xl}{restore xl}
\inst{}{exi}{}{return to caller if done}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
bcblk\endln
\lnie
\endln
\inst{rld06}{mov}{*bcsi$,wa}{set length}
\inst{}{mov}{*bcbuf,wb}{and offset}
\inst{}{brn}{rld04}{all set}
\asmac{fi}
\lnie
\endln
\lnie
cdblk\endln
\lnie
\endln
\inst{rld07}{mov}{cdlen(xr),wa}{load length}
\inst{}{mov}{*cdfal,wb}{set offset}
\inst{}{bne}{(xr),=b$cdc,rld04}{jump back if not complex goto}
\inst{}{mov}{*cdcod,wb}{do not process cdfal word}
\inst{}{brn}{rld04}{jump back}
\lnie
\endln
\lnie
efblk\endln
\lnie
\endln
\lnie
if the efcod word points to an xnblk, the xnblk type\endln
\lnie
word will not be adjusted.  since this is implementation\endln
\lnie
dependent, we will not worry about it.\endln
\lnie
\endln
\inst{rld08}{mov}{*efrsl,wa}{set length}
\inst{}{mov}{*efcod,wb}{and offset}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
evblk\endln
\lnie
\endln
\inst{rld09}{mov}{*offs3,wa}{point past third field}
\inst{}{mov}{*evexp,wb}{set offset}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
exblk\endln
\lnie
\endln
\inst{rld10}{mov}{exlen(xr),wa}{load length}
\inst{}{mov}{*exflc,wb}{set offset}
\inst{}{brn}{rld04}{jump back}
\vfill\break

\lnie
\endln
\lnie
reldn (continued)\endln
\lnie
\endln
\lnie
\endln
\lnie
ffblk\endln
\lnie
\endln
\lnie
this block contains a ptr to a dfblk in the static rgn.\endln
\lnie
because there are multiple ffblks pointing to the same\endln
\lnie
dfblk (one for each field name), we only process the\endln
\lnie
dfblk when we encounter the ffblk for the first field.\endln
\lnie
the dfblk in turn contains a pointer to an scblk within\endln
\lnie
static.\endln
\lnie
\endln
\inst{rld11}{bne}{ffofs(xr),*pdfld,rld12}{skip dfblk if not first field}
\inst{}{mov}{xr,-(xs)}{save xr}
\inst{}{mov}{ffdfp(xr),xr}{load old ptr to dfblk}
\inst{}{add}{rldst,xr}{current location of dfblk}
\inst{}{add}{rldcd,(xr)}{adjust dfblk type word}
\inst{}{mov}{dflen(xr),wa}{length of dfblk}
\inst{}{mov}{*dfnam,wb}{offset to dfnam field}
\inst{}{add}{xr,wa}{point past last reloc field}
\inst{}{add}{xr,wb}{point to first reloc field}
\inst{}{mov}{rldls,xl}{point to list of bounds}
\inst{}{jsr}{relaj}{adjust pointers}
\inst{}{mov}{dfnam(xr),xr}{pointer to static scblk}
\inst{}{add}{rldcd,(xr)}{adjust scblk type word}
\inst{}{mov}{(xs)+,xr}{restore ffblk pointer}
\lnie
\endln
\lnie
ffblk (continued)\endln
\lnie
\endln
\lnie
merge here to set up for adjustment of ptrs in ffblk\endln
\lnie
\endln
\inst{rld12}{mov}{*ffofs,wa}{set length}
\inst{}{mov}{*ffdfp,wb}{set offset}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
kvblk, nmblk, p0blk, seblk\endln
\lnie
\endln
\inst{rld13}{mov}{*offs2,wa}{point past second field}
\inst{}{mov}{*offs1,wb}{offset is one (only reloc fld is 2)}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
p1blk, p2blk\endln
\lnie
\endln
\lnie
in p2blks, parm2 contains either a bit mask or the\endln
\lnie
name offset of a variable.  it never requires relocation.\endln
\lnie
\endln
\inst{rld14}{mov}{*parm2,wa}{length (parm2 is non-relocatable)}
\inst{}{mov}{*pthen,wb}{set offset}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
pdblk\endln
\lnie
\endln
\lnie
note that the dfblk pointed to by this pdblk was\endln
\lnie
processed when the ffblk was encountered.  because\endln
\lnie
the data function will be called before any records are\endln
\lnie
defined, the ffblk is encountered before any\endln
\lnie
corresponding pdblk.\endln
\lnie
\endln
\inst{rld15}{mov}{pddfp(xr),xl}{load ptr to dfblk}
\inst{}{add}{rldst,xl}{adjust for static relocation}
\inst{}{mov}{dfpdl(xl),wa}{get pdblk length}
\inst{}{mov}{*pddfp,wb}{set offset}
\inst{}{brn}{rld04}{all set}
\vfill\break

\lnie
\endln
\lnie
reldn (continued)\endln
\lnie
\endln
\lnie
\endln
\lnie
pfblk\endln
\lnie
\endln
\inst{rld16}{add}{rldst,pfvbl(xr)}{adjust non-contiguous field}
\inst{}{mov}{pflen(xr),wa}{get pfblk length}
\inst{}{mov}{*pfcod,wb}{offset to first reloc}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
tbblk, vcblk\endln
\lnie
\endln
\inst{rld17}{mov}{offs2(xr),wa}{load length}
\inst{}{mov}{*offs3,wb}{set offset}
\inst{}{brn}{rld04}{jump back}
\lnie
\endln
\lnie
teblk\endln
\lnie
\endln
\inst{rld18}{mov}{*tesi$,wa}{set length}
\inst{}{mov}{*tesub,wb}{and offset}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
trblk\endln
\lnie
\endln
\inst{rld19}{mov}{*trsi$,wa}{set length}
\inst{}{mov}{*trval,wb}{and offset}
\inst{}{brn}{rld04}{all set}
\lnie
\endln
\lnie
xrblk\endln
\lnie
\endln
\inst{rld20}{mov}{xrlen(xr),wa}{load length}
\inst{}{mov}{*xrptr,wb}{set offset}
\inst{}{brn}{rld04}{jump back}
\inst{}{enp}{}{end procedure reldn}
\vfill\break

\lnie
\endln
\lnie
reloc -- relocate storage after save file reload\endln
\lnie
\endln
\lnie
(xl)                  list of boundaries and adjustments\endln
\lnie
jsr  reloc            relocate all pointers\endln
\lnie
(wa,wb,wc,xr)         destroyed\endln
\lnie
\endln
\lnie
the list of boundaries and adjustments pointed to by\endln
\lnie
register xl is created by a call to relcr, which should\endln
\lnie
be consulted for information on its structure.\endln
\lnie
\endln
\inst{reloc}{prc}{e,0}{entry point}
\inst{}{mov}{rldys(xl),xr}{old start of dynamic}
\inst{}{mov}{rldye(xl),wc}{old end of dynamic}
\inst{}{add}{rldya(xl),xr}{create new start of dynamic}
\inst{}{add}{rldya(xl),wc}{create new end of dynamic}
\inst{}{jsr}{reldn}{relocate pointers in dynamic}
\inst{}{jsr}{relws}{relocate pointers in working sect}
\inst{}{jsr}{relst}{relocate pointers in static}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure reloc}
\vfill\break

\lnie
\endln
\lnie
relst -- relocate pointers in the static region\endln
\lnie
\endln
\lnie
(xl)                  list of boundaries and adjustments\endln
\lnie
jsr  relst            call to process blocks in static\endln
\lnie
(wa,wb,wc,xr)         destroyed\endln
\lnie
\endln
\lnie
only vrblks on the hash chain and any profile block are\endln
\lnie
processed.  other static blocks (dfblks) are processed\endln
\lnie
during processing of dynamic blocks.\endln
\lnie
\endln
\lnie
global work locations will be processed at this point,\endln
\lnie
so pointers there can be relied upon.\endln
\lnie
\endln
\inst{relst}{prc}{e,0}{entry point}
\inst{}{mov}{pftbl,xr}{profile table}
\inst{}{bze}{xr,rls01}{branch if no table allocated}
\inst{}{add}{rlcda(xl),(xr)}{adjust block type word}
\lnie
\endln
\lnie
here after dealing with profiler\endln
\lnie
\endln
\inst{rls01}{mov}{hshtb,wc}{point to start of hash table}
\inst{}{mov}{wc,wb}{point to first hash bucket}
\inst{}{mov}{hshte,wa}{point beyond hash table}
\inst{}{jsr}{relaj}{adjust bucket pointers}
\lnie
\endln
\lnie
loop through slots in hash table\endln
\lnie
\endln
\inst{rls02}{beq}{wc,hshte,rls05}{done if none left}
\inst{}{mov}{wc,xr}{else copy slot pointer}
\inst{}{ica}{wc}{bump slot pointer}
\inst{}{sub}{*vrnxt,xr}{set offset to merge into loop}
\lnie
\endln
\lnie
loop through vrblks on one hash chain\endln
\lnie
\endln
\inst{rls03}{mov}{vrnxt(xr),xr}{point to next vrblk on chain}
\inst{}{bze}{xr,rls02}{jump for next bucket if chain end}
\inst{}{mov}{*vrlen,wa}{offset of first loc past ptr fields}
\inst{}{mov}{*vrget,wb}{offset of first location in vrblk}
\inst{}{bnz}{vrlen(xr),rls04}{jump if not system variable}
\inst{}{mov}{*vrsi$,wa}{offset to include vrsvp field}
\lnie
\endln
\lnie
merge here to process fields of vrblk\endln
\lnie
\endln
\inst{rls04}{add}{xr,wa}{create end ptr}
\inst{}{add}{xr,wb}{create start ptr}
\inst{}{jsr}{relaj}{adjust pointers in vrblk}
\inst{}{brn}{rls03}{check for another vrblk on chain}
\lnie
\endln
\lnie
here when all vrblks processed\endln
\lnie
\endln
\inst{rls05}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure relst}
\vfill\break

\lnie
\endln
\lnie
relws -- relocate pointers in the working section\endln
\lnie
\endln
\lnie
(xl)                  list of boundaries and adjustments\endln
\lnie
jsr  relws            call to process working section\endln
\lnie
(wa,wb,wc,xr)         destroyed\endln
\lnie
\endln
\lnie
pointers between a$aaa and r$yyy are examined and\endln
\lnie
adjusted if necessary.  the pointer kvrtn is also\endln
\lnie
adjusted although it lies outside this range.\endln
\lnie
dname is explicitly adjusted because the limits\endln
\lnie
on dynamic region in stack are to the area actively\endln
\lnie
in use (between dnamb and dnamp), and dname is outside\endln
\lnie
this range.\endln
\lnie
\endln
\inst{relws}{prc}{e,0}{entry point}
\inst{}{mov}{=a$aaa,wb}{point to start of adjustables}
\inst{}{mov}{=r$yyy,wa}{point to end of adjustables}
\inst{}{jsr}{relaj}{relocate adjustable pointers}
\inst{}{add}{rldya(xl),dname}{adjust ptr missed by relaj}
\inst{}{mov}{=kvrtn,wb}{case of kvrtn}
\inst{}{mov}{wb,wa}{handled specially}
\inst{}{ica}{wa}{one value to adjust}
\inst{}{jsr}{relaj}{adjust kvrtn}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure relws}
\asmac{fi}
\vfill\break
{\bf spitbol--\rm initialization}
\vskip1em
\lnie
\endln
\lnie
initialisation\endln
\lnie
the following section receives control from the system\endln
\lnie
at the start of a run with the registers set as follows.\endln
\lnie
\endln
\lnie
(wa)                  initial stack pointer\endln
\lnie
(xr)                  points to first word of data area\endln
\lnie
(xl)                  points to last word of data area\endln
\lnie
\endln
\inst{start}{prc}{e,0}{entry point}
\inst{}{mov}{wa,xs}{discard return}
\inst{}{jsr}{systm}{initialise timer}
\ifmac{.cnbt}
\inst{}{sti}{timsx}{store time}
\inst{}{mov}{xr,statb}{start address of static}
\asmac{else}
\lnie
\endln
\lnie
initialise work area (essential for batched runs)\endln
\lnie
\endln
\inst{}{mov}{xr,wb}{preserve xr}
\inst{}{mov}{=w$yyy,wa}{point to end of work area}
\inst{}{sub}{=w$aaa,wa}{get length of work area}
\inst{}{btw}{wa}{convert to words}
\inst{}{lct}{wa,wa}{count for loop}
\inst{}{mov}{=w$aaa,xr}{set up index register}
\lnie
\endln
\lnie
clear work space\endln
\lnie
\endln
\inst{ini01}{zer}{(xr)+}{clear a word}
\inst{}{bct}{wa,ini01}{loop till done}
\inst{}{mov}{=stndo,wa}{undefined operators pointer}
\inst{}{mov}{=r$yyy,wc}{point to table end}
\inst{}{sub}{=r$uba,wc}{length of undef. operators table}
\inst{}{btw}{wc}{convert to words}
\inst{}{lct}{wc,wc}{loop counter}
\inst{}{mov}{=r$uba,xr}{set up xr}
\lnie
\endln
\lnie
set correct value into undefined operators table\endln
\lnie
\endln
\inst{ini02}{mov}{wa,(xr)+}{store value}
\inst{}{bct}{wc,ini02}{loop till all done}
\inst{}{mov}{=num01,wa}{get a 1}
\ifmac{.cpol}
\inst{}{mov}{wa,polcs}{interface polling interval}
\inst{}{mov}{wa,polct}{interface polling interval}
\asmac{fi}
\inst{}{mov}{wa,cmpsn}{statement no}
\inst{}{mov}{wa,cswfl}{nofail}
\inst{}{mov}{wa,cswls}{list}
\inst{}{mov}{wa,kvinp}{input}
\inst{}{mov}{wa,kvoup}{output}
\inst{}{mov}{wa,lstpf}{nothing for listr yet}
\inst{}{mov}{=iniln,wa}{input image length}
\inst{}{mov}{wa,cswin}{-in72}
\vfill\break

\inst{}{mov}{=nulls,wa}{get null string pointer}
\inst{}{mov}{wa,kvrtn}{return}
\inst{}{mov}{wa,r$etx}{errtext}
\inst{}{mov}{wa,r$ttl}{title for listing}
\inst{}{mov}{wa,stxvr}{setexit}
\inst{}{sti}{timsx}{store time in correct place}
\inst{}{ldi}{stlim}{get default stlimit}
\inst{}{sti}{kvstl}{statement limit}
\inst{}{sti}{kvstc}{statement count}
\inst{}{mov}{wb,statb}{store start adrs of static}
\asmac{fi}
\inst{}{mov}{*e$srs,rsmem}{reserve memory}
\inst{}{mov}{xs,stbas}{store stack base}
\inst{}{sss}{iniss}{save s-r stack ptr}
\lnie
\endln
\lnie
now convert free store percentage to a suitable factor\endln
\lnie
for easy testing in alloc routine.\endln
\lnie
\endln
\inst{}{ldi}{intvh}{get 100}
\inst{}{dvi}{alfsp}{form 100 / alfsp}
\inst{}{sti}{alfsf}{store the factor}
\ifmac{.csed}
\lnie
\endln
\lnie
now convert free sediment percentage to a suitable factor\endln
\lnie
for easy testing in gbcol routine.\endln
\lnie
\endln
\inst{}{ldi}{intvh}{get 100}
\inst{}{dvi}{gbsdp}{form 100 / gbsdp}
\inst{}{sti}{gbsed}{store the factor}
\asmac{fi}
\ifmac{.cnra}
\asmac{else}
\ifmac{.cncr}
\asmac{else}
\lnie
\endln
\lnie
initialize values for real conversion routine\endln
\lnie
\endln
\inst{}{lct}{wb,=cfp$s}{load counter for significant digits}
\inst{}{ldr}{reav1}{load 1.0}
\lnie
\endln
\lnie
loop to compute 10**(max number significant digits)\endln
\lnie
\endln
\inst{ini03}{mlr}{reavt}{* 10.0}
\inst{}{bct}{wb,ini03}{loop till done}
\inst{}{str}{gtssc}{store 10**(max sig digits)}
\inst{}{ldr}{reap5}{load 0.5}
\inst{}{dvr}{gtssc}{compute 0.5*10**(max sig digits)}
\inst{}{str}{gtsrn}{store as rounding bias}
\asmac{fi}
\asmac{fi}
\inst{}{zer}{wc}{set to read parameters}
\inst{}{jsr}{prpar}{read them}
\vfill\break

\lnie
\endln
\lnie
now compute starting address for dynamic store and if\endln
\lnie
necessary request more memory.\endln
\lnie
\endln
\inst{}{sub}{*e$srs,xl}{allow for reserve memory}
\inst{}{mov}{prlen,wa}{get print buffer length}
\inst{}{add}{=cfp$a,wa}{add no. of chars in alphabet}
\inst{}{add}{=nstmx,wa}{add chars for gtstg bfr}
\inst{}{ctb}{wa,8}{convert to bytes, allowing a margin}
\inst{}{mov}{statb,xr}{point to static base}
\inst{}{add}{wa,xr}{increment for above buffers}
\inst{}{add}{*e$hnb,xr}{increment for hash table}
\inst{}{add}{*e$sts,xr}{bump for initial static block}
\inst{}{jsr}{sysmx}{get mxlen}
\inst{}{mov}{wa,kvmxl}{provisionally store as maxlngth}
\inst{}{mov}{wa,mxlen}{and as mxlen}
\inst{}{bgt}{xr,wa,ini06}{skip if static hi exceeds mxlen}
\inst{}{ctb}{wa,1}{round up and make bigger than mxlen}
\inst{}{mov}{wa,xr}{use it instead}
\lnie
\endln
\lnie
here to store values which mark initial division\endln
\lnie
of data area into static and dynamic\endln
\lnie
\endln
\inst{ini06}{mov}{xr,dnamb}{dynamic base adrs}
\inst{}{mov}{xr,dnamp}{dynamic ptr}
\inst{}{bnz}{wa,ini07}{skip if non-zero mxlen}
\inst{}{dca}{xr}{point a word in front}
\inst{}{mov}{xr,kvmxl}{use as maxlngth}
\inst{}{mov}{xr,mxlen}{and as mxlen}
\vfill\break

\lnie
\endln
\lnie
loop here if necessary till enough memory obtained\endln
\lnie
so that dname is above dnamb\endln
\lnie
\endln
\inst{ini07}{mov}{xl,dname}{store dynamic end address}
\inst{}{blt}{dnamb,xl,ini09}{skip if high enough}
\inst{}{jsr}{sysmm}{request more memory}
\inst{}{wtb}{xr}{get as baus (sgd05)}
\inst{}{add}{xr,xl}{bump by amount obtained}
\inst{}{bnz}{xr,ini07}{try again}
\ifmac{.cera}
\inst{}{mov}{=mxern,wa}{insufficient memory for maxlength}
\inst{}{zer}{wb}{no column number info}
\inst{}{zer}{wc}{no line number info}
\inst{}{mov}{=stgic,xr}{initial compile stage}
\ifmac{.csfn}
\inst{}{mov}{=nulls,xl}{no file name}
\asmac{fi}
\inst{}{jsr}{sysea}{advise of error}
\inst{}{ppm}{ini08}{cant use error logic yet}
\inst{}{brn}{ini08}{force termination}
\lnie
\endln
\lnie
insert text for error 329 in error message table\endln
\lnie
\endln
\inst{}{erb}{329,requested maxlngth}{too large}
\asmac{fi}
\inst{ini08}{mov}{=endmo,xr}{point to failure message}
\inst{}{mov}{endml,wa}{message length}
\inst{}{jsr}{syspr}{print it (prtst not yet usable)}
\inst{}{ppm}{}{should not fail}
\inst{}{zer}{xl}{no fcb chain yet}
\inst{}{mov}{=num10,wb}{set special code value}
\inst{}{jsr}{sysej}{pack up (stopr not yet usable)}
\lnie
\endln
\lnie
initialise structures at start of static region\endln
\lnie
\endln
\inst{ini09}{mov}{statb,xr}{point to static again}
\inst{}{jsr}{insta}{initialize static}
\lnie
\endln
\lnie
initialize number of hash headers\endln
\lnie
\endln
\inst{}{mov}{=e$hnb,wa}{get number of hash headers}
\inst{}{mti}{wa}{convert to integer}
\inst{}{sti}{hshnb}{store for use by gtnvr procedure}
\inst{}{lct}{wa,wa}{counter for clearing hash table}
\inst{}{mov}{xr,hshtb}{pointer to hash table}
\lnie
\endln
\lnie
loop to clear hash table\endln
\lnie
\endln
\inst{ini11}{zer}{(xr)+}{blank a word}
\inst{}{bct}{wa,ini11}{loop}
\inst{}{mov}{xr,hshte}{end of hash table adrs is kept}
\inst{}{mov}{xr,state}{store static end address}
\ifmac{.csfn}
\lnie
\endln
\lnie
init table to map statement numbers to source file names\endln
\lnie
\endln
\inst{}{mov}{=num01,wc}{table will have only one bucket}
\inst{}{mov}{=nulls,xl}{default table value}
\inst{}{mov}{xl,r$sfc}{current source file name}
\inst{}{jsr}{tmake}{create table}
\inst{}{mov}{xr,r$sfn}{save ptr to table}
\asmac{fi}
\ifmac{.cinc}
\lnie
\endln
\lnie
initialize table to detect duplicate include file names\endln
\lnie
\endln
\inst{}{mov}{=num01,wc}{table will have only one bucket}
\inst{}{mov}{=nulls,xl}{default table value}
\inst{}{jsr}{tmake}{create table}
\inst{}{mov}{xr,r$inc}{save ptr to table}
\ifmac{.csfn}
\lnie
\endln
\lnie
initialize array to hold names of nested include files\endln
\lnie
\endln
\inst{}{mov}{=ccinm,wa}{maximum nesting level}
\inst{}{mov}{=nulls,xl}{null string default value}
\inst{}{jsr}{vmake}{create array}
\inst{}{ppm}{vmake}{create array}
\inst{}{mov}{xr,r$ifa}{save ptr to array}
\lnie
\endln
\lnie
init array to hold line numbers of nested include files\endln
\lnie
\endln
\inst{}{mov}{=ccinm,wa}{maximum nesting level}
\inst{}{mov}{=inton,xl}{integer one default value}
\inst{}{jsr}{vmake}{create array}
\inst{}{ppm}{vmake}{create array}
\inst{}{mov}{xr,r$ifl}{save ptr to array}
\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
initialize variable blocks for input and output\endln
\lnie
\endln
\inst{}{mov}{=v$inp,xl}{point to string /input/}
\inst{}{mov}{=trtin,wb}{trblk type for input}
\inst{}{jsr}{inout}{perform input association}
\inst{}{mov}{=v$oup,xl}{point to string /output/}
\inst{}{mov}{=trtou,wb}{trblk type for output}
\inst{}{jsr}{inout}{perform output association}
\inst{}{mov}{initr,wc}{terminal flag}
\inst{}{bze}{wc,ini13}{skip if no terminal}
\inst{}{jsr}{prpar}{associate terminal}
\vfill\break

\lnie
\endln
\lnie
check for expiry date\endln
\lnie
\endln
\inst{ini13}{jsr}{sysdc}{call date check}
\inst{}{mov}{xs,flptr}{in case stack overflows in compiler}
\lnie
\endln
\lnie
now compile source input code\endln
\lnie
\endln
\inst{}{jsr}{cmpil}{call compiler}
\inst{}{mov}{xr,r$cod}{set ptr to first code block}
\inst{}{mov}{=nulls,r$ttl}{forget title}
\inst{}{mov}{=nulls,r$stl}{forget sub-title}
\inst{}{zer}{r$cim}{forget compiler input image}
\inst{}{zer}{r$ccb}{forget interim code block}
\ifmac{.cinc}
\inst{}{zer}{cnind}{in case end occurred with include}
\inst{}{zer}{lstid}{listing include depth}
\asmac{fi}
\inst{}{zer}{xl}{clear dud value}
\inst{}{zer}{wb}{dont shift dynamic store up}
\ifmac{.csed}
\inst{}{zer}{dnams}{collect sediment too}
\inst{}{jsr}{gbcol}{clear garbage left from compile}
\inst{}{mov}{xr,dnams}{record new sediment size}
\asmac{else}
\inst{}{jsr}{gbcol}{clear garbage left from compile}
\asmac{fi}
\inst{}{bnz}{cpsts,inix0}{skip if no listing of comp stats}
\inst{}{jsr}{prtpg}{eject page}
\lnie
\endln
\lnie
print compile statistics\endln
\lnie
\endln
\inst{}{jsr}{prtmm}{print memory usage}
\inst{}{mti}{cmerc}{get count of errors as integer}
\inst{}{mov}{=encm3,xr}{point to /compile errors/}
\inst{}{jsr}{prtmi}{print it}
\inst{}{mti}{gbcnt}{garbage collection count}
\inst{}{sbi}{intv1}{adjust for unavoidable collect}
\inst{}{mov}{=stpm5,xr}{point to /storage regenerations/}
\inst{}{jsr}{prtmi}{print gbcol count}
\inst{}{jsr}{systm}{get time}
\inst{}{sbi}{timsx}{get compilation time}
\inst{}{mov}{=encm4,xr}{point to compilation time (msec)/}
\inst{}{jsr}{prtmi}{print message}
\inst{}{add}{=num05,lstlc}{bump line count}
\ifmac{.cuej}
\inst{}{bze}{headp,inix0}{no eject if nothing printed}
\inst{}{jsr}{prtpg}{eject printer}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
prepare now to start execution\endln
\lnie
\endln
\lnie
set default input record length\endln
\lnie
\endln
\inst{inix0}{bgt}{cswin,=iniln,inix1}{skip if not default -in72 used}
\inst{}{mov}{=inils,cswin}{else use default record length}
\lnie
\endln
\lnie
reset timer\endln
\lnie
\endln
\inst{inix1}{jsr}{systm}{get time again}
\inst{}{sti}{timsx}{store for end run processing}
\inst{}{zer}{gbcnt}{initialise collect count}
\inst{}{jsr}{sysbx}{call before starting execution}
\inst{}{add}{cswex,noxeq}{add -noexecute flag}
\inst{}{bnz}{noxeq,inix2}{jump if execution suppressed}
\ifmac{.cuej}
\asmac{else}
\inst{}{bze}{headp,iniy0}{no eject if nothing printed (sgd11)}
\inst{}{jsr}{prtpg}{eject printer}
\asmac{fi}
\lnie
\endln
\lnie
merge when listing file set for execution.  also\endln
\lnie
merge here when restarting a save file or load module.\endln
\lnie
\endln
\inst{iniy0}{mnz}{headp}{mark headers out regardless}
\inst{}{zer}{-(xs)}{set failure location on stack}
\inst{}{mov}{xs,flptr}{save ptr to failure offset word}
\inst{}{mov}{r$cod,xr}{load ptr to entry code block}
\inst{}{mov}{=stgxt,stage}{set stage for execute time}
\ifmac{.cpol}
\inst{}{mov}{=num01,polcs}{reset interface polling interval}
\inst{}{mov}{=num01,polct}{reset interface polling interval}
\asmac{fi}
\ifmac{.cnpf}
\asmac{else}
\inst{}{mov}{cmpsn,pfnte}{copy stmts compiled count in case}
\inst{}{mov}{kvpfl,pfdmp}{start profiling if &profile set}
\inst{}{jsr}{systm}{time yet again}
\inst{}{sti}{systm}{time yet again}
\asmac{fi}
\inst{}{jsr}{stgcc}{compute stmgo countdown counters}
\inst{}{bri}{(xr)}{start xeq with first statement}
\lnie
\endln
\lnie
here if execution is suppressed\endln
\lnie
\endln
\ifmac{.cera}
\inst{inix2}{zer}{wa}{set abend value to zero}
\asmac{else}
\inst{inix2}{jsr}{prtnl}{print a blank line}
\inst{}{mov}{=encm5,xr}{point to /execution suppressed/}
\inst{}{jsr}{prtst}{print string}
\inst{}{jsr}{prtnl}{output line}
\inst{}{zer}{wa}{set abend value to zero}
\asmac{fi}
\inst{}{mov}{=nini9,wb}{set special code value}
\inst{}{zer}{xl}{no fcb chain}
\inst{}{jsr}{sysej}{end of job, exit to system}
\inst{}{enp}{}{end procedure start}
\lnie
\endln
\lnie
here from osint to restart a save file or load module.\endln
\lnie
\endln
\inst{rstrt}{prc}{e,0}{entry point}
\inst{}{mov}{stbas,xs}{discard return}
\inst{}{zer}{xl}{clear xl}
\inst{}{brn}{iniy0}{resume execution}
\inst{}{enp}{}{end procedure rstrt}
\vfill\break
{\bf spitbol--\rm snobol4 operator routines}
\vskip1em
\lnie
\endln
\lnie
this section includes all routines which can be accessed\endln
\lnie
directly from the generated code except system functions.\endln
\lnie
\endln
\lnie
all routines in this section start with a label of the\endln
\lnie
form o$xxx where xxx is three letters. the generated code\endln
\lnie
contains a pointer to the appropriate entry label.\endln
\lnie
\endln
\lnie
since the general form of the generated code consists of\endln
\lnie
pointers to blocks whose first word is the address of the\endln
\lnie
actual entry point label (o$xxx).\endln
\lnie
\endln
\lnie
these routines are in alphabetical order by their\endln
\lnie
entry label names (i.e. by the xxx of the o$xxx name)\endln
\lnie
\endln
\lnie
these routines receive control as follows\endln
\lnie
\endln
\lnie
(cp)                  pointer to next code word\endln
\lnie
(xs)                  current stack pointer\endln
\vfill\break

\lnie
\endln
\lnie
binary plus (addition)\endln
\lnie
\endln
\inst{o$add}{ent}{}{entry point}
\inst{}{jsr}{arith}{fetch arithmetic operands}
\inst{}{err}{001,addition left}{operand is not numeric}
\inst{}{err}{002,addition right}{operand is not numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{ppm}{oadd1}{jump if real operands}
\asmac{fi}
\lnie
\endln
\lnie
here to add two integers\endln
\lnie
\endln
\inst{}{adi}{icval(xl)}{add right operand to left}
\inst{}{ino}{exint}{return integer if no overflow}
\inst{}{erb}{003,addition caused}{integer overflow}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to add two reals\endln
\lnie
\endln
\inst{oadd1}{adr}{rcval(xl)}{add right operand to left}
\inst{}{rno}{exrea}{return real if no overflow}
\inst{}{erb}{261,addition caused}{real overflow}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
unary plus (affirmation)\endln
\lnie
\endln
\inst{o$aff}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load operand}
\inst{}{jsr}{gtnum}{convert to numeric}
\inst{}{err}{004,affirmation operand}{is not numeric}
\inst{}{mov}{xr,-(xs)}{result if converted to numeric}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
binary bar (alternation)\endln
\lnie
\endln
\inst{o$alt}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load right operand}
\inst{}{jsr}{gtpat}{convert to pattern}
\inst{}{err}{005,alternation right}{operand is not pattern}
\lnie
\endln
\lnie
merge here from special (left alternation) case\endln
\lnie
\endln
\inst{oalt1}{mov}{=p$alt,wb}{set pcode for alternative node}
\inst{}{jsr}{pbild}{build alternative node}
\inst{}{mov}{xr,xl}{save address of alternative node}
\inst{}{mov}{(xs)+,xr}{load left operand}
\inst{}{jsr}{gtpat}{convert to pattern}
\inst{}{err}{006,alternation left}{operand is not pattern}
\inst{}{beq}{xr,=p$alt,oalt2}{jump if left arg is alternation}
\inst{}{mov}{xr,pthen(xl)}{set left operand as successor}
\inst{}{mov}{xl,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
come here if left argument is itself an alternation\endln
\lnie
\endln
\lnie
the result is more efficient if we make the replacement\endln
\lnie
\endln
\lnie
(a / b) / c = a / (b / c)\endln
\lnie
\endln
\inst{oalt2}{mov}{parm1(xr),pthen(xl)}{build the (b / c) node}
\inst{}{mov}{pthen(xr),-(xs)}{set a as new left arg}
\inst{}{mov}{xl,xr}{set (b / c) as new right arg}
\inst{}{brn}{oalt1}{merge back to build a / (b / c)}
\vfill\break

\lnie
\endln
\lnie
array reference (multiple subscripts, by name)\endln
\lnie
\endln
\inst{o$amn}{ent}{}{entry point}
\inst{}{lcw}{xr}{load number of subscripts}
\inst{}{mov}{xr,wb}{set flag for by name}
\inst{}{brn}{arref}{jump to array reference routine}
\vfill\break

\lnie
\endln
\lnie
array reference (multiple subscripts, by value)\endln
\lnie
\endln
\inst{o$amv}{ent}{}{entry point}
\inst{}{lcw}{xr}{load number of subscripts}
\inst{}{zer}{wb}{set flag for by value}
\inst{}{brn}{arref}{jump to array reference routine}
\vfill\break

\lnie
\endln
\lnie
array reference (one subscript, by name)\endln
\lnie
\endln
\inst{o$aon}{ent}{}{entry point}
\inst{}{mov}{(xs),xr}{load subscript value}
\inst{}{mov}{num01(xs),xl}{load array value}
\inst{}{mov}{(xl),wa}{load first word of array operand}
\inst{}{beq}{wa,=b$vct,oaon2}{jump if vector reference}
\inst{}{beq}{wa,=b$tbt,oaon3}{jump if table reference}
\lnie
\endln
\lnie
here to use central array reference routine\endln
\lnie
\endln
\inst{oaon1}{mov}{=num01,xr}{set number of subscripts to one}
\inst{}{mov}{xr,wb}{set flag for by name}
\inst{}{brn}{arref}{jump to array reference routine}
\lnie
\endln
\lnie
here if we have a vector reference\endln
\lnie
\endln
\inst{oaon2}{bne}{(xr),=b$icl,oaon1}{use long routine if not integer}
\inst{}{ldi}{icval(xr)}{load integer subscript value}
\inst{}{mfi}{wa,exfal}{copy as address int, fail if ovflo}
\inst{}{bze}{wa,exfal}{fail if zero}
\inst{}{add}{=vcvlb,wa}{compute offset in words}
\inst{}{wtb}{wa}{convert to bytes}
\inst{}{mov}{wa,(xs)}{complete name on stack}
\inst{}{blt}{wa,vclen(xl),oaon4}{exit if subscript not too large}
\inst{}{brn}{exfal}{else fail}
\lnie
\endln
\lnie
here for table reference\endln
\lnie
\endln
\inst{oaon3}{mnz}{wb}{set flag for name reference}
\inst{}{jsr}{tfind}{locate/create table element}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{mov}{xl,num01(xs)}{store name base on stack}
\inst{}{mov}{wa,(xs)}{store name offset on stack}
\lnie
\endln
\lnie
here to exit with result on stack\endln
\lnie
\endln
\inst{oaon4}{lcw}{xr}{result on stack, get code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
array reference (one subscript, by value)\endln
\lnie
\endln
\inst{o$aov}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load subscript value}
\inst{}{mov}{(xs)+,xl}{load array value}
\inst{}{mov}{(xl),wa}{load first word of array operand}
\inst{}{beq}{wa,=b$vct,oaov2}{jump if vector reference}
\inst{}{beq}{wa,=b$tbt,oaov3}{jump if table reference}
\lnie
\endln
\lnie
here to use central array reference routine\endln
\lnie
\endln
\inst{oaov1}{mov}{xl,-(xs)}{restack array value}
\inst{}{mov}{xr,-(xs)}{restack subscript}
\inst{}{mov}{=num01,xr}{set number of subscripts to one}
\inst{}{zer}{wb}{set flag for value call}
\inst{}{brn}{arref}{jump to array reference routine}
\lnie
\endln
\lnie
here if we have a vector reference\endln
\lnie
\endln
\inst{oaov2}{bne}{(xr),=b$icl,oaov1}{use long routine if not integer}
\inst{}{ldi}{icval(xr)}{load integer subscript value}
\inst{}{mfi}{wa,exfal}{move as one word int, fail if ovflo}
\inst{}{bze}{wa,exfal}{fail if zero}
\inst{}{add}{=vcvlb,wa}{compute offset in words}
\inst{}{wtb}{wa}{convert to bytes}
\inst{}{bge}{wa,vclen(xl),exfal}{fail if subscript too large}
\inst{}{jsr}{acess}{access value}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
here for table reference by value\endln
\lnie
\endln
\inst{oaov3}{zer}{wb}{set flag for value reference}
\inst{}{jsr}{tfind}{call table search routine}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
assignment\endln
\lnie
\endln
\inst{o$ass}{ent}{}{entry point}
\lnie
\endln
\lnie
o$rpl (pattern replacement) merges here\endln
\lnie
\endln
\inst{oass0}{mov}{(xs)+,wb}{load value to be assigned}
\inst{}{mov}{(xs)+,wa}{load name offset}
\inst{}{mov}{(xs),xl}{load name base}
\inst{}{mov}{wb,(xs)}{store assigned value as result}
\inst{}{jsr}{asign}{perform assignment}
\inst{}{ppm}{exfal}{fail if assignment fails}
\inst{}{lcw}{xr}{result on stack, get code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
compilation error\endln
\lnie
\endln
\inst{o$cer}{ent}{}{entry point}
\inst{}{erb}{007,compilation error}{encountered during execution}
\vfill\break

\lnie
\endln
\lnie
unary at (cursor assignment)\endln
\lnie
\endln
\inst{o$cas}{ent}{}{entry point}
\inst{}{mov}{(xs)+,wc}{load name offset (parm2)}
\inst{}{mov}{(xs)+,xr}{load name base (parm1)}
\inst{}{mov}{=p$cas,wb}{set pcode for cursor assignment}
\inst{}{jsr}{pbild}{build node}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
concatenation\endln
\lnie
\endln
\inst{o$cnc}{ent}{}{entry point}
\inst{}{mov}{(xs),xr}{load right argument}
\inst{}{beq}{xr,=nulls,ocnc3}{jump if right arg is null}
\inst{}{mov}{1(xs),xl}{load left argument}
\inst{}{beq}{xl,=nulls,ocnc4}{jump if left argument is null}
\inst{}{mov}{=b$scl,wa}{get constant to test for string}
\inst{}{bne}{wa,(xl),ocnc2}{jump if left arg not a string}
\inst{}{bne}{wa,(xr),ocnc2}{jump if right arg not a string}
\lnie
\endln
\lnie
merge here to concatenate two strings\endln
\lnie
\endln
\inst{ocnc1}{mov}{sclen(xl),wa}{load left argument length}
\inst{}{add}{sclen(xr),wa}{compute result length}
\inst{}{jsr}{alocs}{allocate scblk for result}
\inst{}{mov}{xr,1(xs)}{store result ptr over left argument}
\inst{}{psc}{xr}{prepare to store chars of result}
\inst{}{mov}{sclen(xl),wa}{get number of chars in left arg}
\inst{}{plc}{xl}{prepare to load left arg chars}
\inst{}{mvc}{}{move characters of left argument}
\inst{}{mov}{(xs)+,xl}{load right arg pointer, pop stack}
\inst{}{mov}{sclen(xl),wa}{load number of chars in right arg}
\inst{}{plc}{xl}{prepare to load right arg chars}
\inst{}{mvc}{}{move characters of right argument}
\inst{}{zer}{xl}{clear garbage value in xl}
\inst{}{lcw}{xr}{result on stack, get code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
come here if arguments are not both strings\endln
\lnie
\endln
\inst{ocnc2}{jsr}{gtstg}{convert right arg to string}
\inst{}{ppm}{ocnc5}{jump if right arg is not string}
\inst{}{mov}{xr,xl}{save right arg ptr}
\inst{}{jsr}{gtstg}{convert left arg to string}
\inst{}{ppm}{ocnc6}{jump if left arg is not a string}
\inst{}{mov}{xr,-(xs)}{stack left argument}
\inst{}{mov}{xl,-(xs)}{stack right argument}
\inst{}{mov}{xr,xl}{move left arg to proper reg}
\inst{}{mov}{(xs),xr}{move right arg to proper reg}
\inst{}{brn}{ocnc1}{merge back to concatenate strings}
\vfill\break

\lnie
\endln
\lnie
concatenation (continued)\endln
\lnie
\endln
\lnie
come here for null right argument\endln
\lnie
\endln
\inst{ocnc3}{ica}{xs}{remove right arg from stack}
\inst{}{lcw}{xr}{left argument on stack}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
here for null left argument\endln
\lnie
\endln
\inst{ocnc4}{ica}{xs}{unstack one argument}
\inst{}{mov}{xr,(xs)}{store right argument}
\inst{}{lcw}{xr}{result on stack, get code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
here if right argument is not a string\endln
\lnie
\endln
\inst{ocnc5}{mov}{xr,xl}{move right argument ptr}
\inst{}{mov}{(xs)+,xr}{load left arg pointer}
\lnie
\endln
\lnie
merge here when left argument is not a string\endln
\lnie
\endln
\inst{ocnc6}{jsr}{gtpat}{convert left arg to pattern}
\inst{}{err}{008,concatenation}{left operand is not a string or pattern}
\inst{}{mov}{xr,-(xs)}{save result on stack}
\inst{}{mov}{xl,xr}{point to right operand}
\inst{}{jsr}{gtpat}{convert to pattern}
\inst{}{err}{009,concatenation}{right operand is not a string or pattern}
\inst{}{mov}{xr,xl}{move for pconc}
\inst{}{mov}{(xs)+,xr}{reload left operand ptr}
\inst{}{jsr}{pconc}{concatenate patterns}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
complementation\endln
\lnie
\endln
\inst{o$com}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load operand}
\inst{}{mov}{(xr),wa}{load type word}
\lnie
\endln
\lnie
merge back here after conversion\endln
\lnie
\endln
\inst{ocom1}{beq}{wa,=b$icl,ocom2}{jump if integer}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$rcl,ocom3}{jump if real}
\asmac{fi}
\inst{}{jsr}{gtnum}{else convert to numeric}
\inst{}{err}{010,negation operand}{is not numeric}
\inst{}{brn}{ocom1}{back to check cases}
\lnie
\endln
\lnie
here to complement integer\endln
\lnie
\endln
\inst{ocom2}{ldi}{icval(xr)}{load integer value}
\inst{}{ngi}{}{negate}
\inst{}{ino}{exint}{return integer if no overflow}
\inst{}{erb}{011,negation caused}{integer overflow}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to complement real\endln
\lnie
\endln
\inst{ocom3}{ldr}{rcval(xr)}{load real value}
\inst{}{ngr}{}{negate}
\inst{}{brn}{exrea}{return real result}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
binary slash (division)\endln
\lnie
\endln
\inst{o$dvd}{ent}{}{entry point}
\inst{}{jsr}{arith}{fetch arithmetic operands}
\inst{}{err}{012,division left}{operand is not numeric}
\inst{}{err}{013,division right}{operand is not numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{ppm}{odvd2}{jump if real operands}
\asmac{fi}
\lnie
\endln
\lnie
here to divide two integers\endln
\lnie
\endln
\inst{}{dvi}{icval(xl)}{divide left operand by right}
\inst{}{ino}{exint}{result ok if no overflow}
\inst{}{erb}{014,division caused}{integer overflow}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to divide two reals\endln
\lnie
\endln
\inst{odvd2}{dvr}{rcval(xl)}{divide left operand by right}
\inst{}{rno}{exrea}{return real if no overflow}
\inst{}{erb}{262,division caused}{real overflow}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
exponentiation\endln
\lnie
\endln
\inst{o$exp}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load exponent}
\inst{}{jsr}{gtnum}{convert to number}
\inst{}{err}{015,exponentiation}{right operand is not numeric}
\inst{}{mov}{xr,xl}{move exponent to xl}
\inst{}{mov}{(xs)+,xr}{load base}
\inst{}{jsr}{gtnum}{convert to numeric}
\inst{}{err}{016,exponentiation}{left operand is not numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{(xl),=b$rcl,oexp7}{jump if real exponent}
\asmac{fi}
\inst{}{ldi}{icval(xl)}{load exponent}
\inst{}{ilt}{oex12}{jump if negative exponent}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$rcl,oexp3}{jump if base is real}
\asmac{fi}
\lnie
\endln
\lnie
here to exponentiate an integer base and integer exponent\endln
\lnie
\endln
\inst{}{mfi}{wa,oexp2}{convert exponent to 1 word integer}
\inst{}{lct}{wa,wa}{set loop counter}
\inst{}{ldi}{icval(xr)}{load base as initial value}
\inst{}{bnz}{wa,oexp1}{jump into loop if non-zero exponent}
\inst{}{ieq}{oexp4}{error if 0**0}
\inst{}{ldi}{intv1}{nonzero**0}
\inst{}{brn}{exint}{give one as result for nonzero**0}
\lnie
\endln
\lnie
loop to perform exponentiation\endln
\lnie
\endln
\inst{oex13}{mli}{icval(xr)}{multiply by base}
\inst{}{iov}{oexp2}{jump if overflow}
\inst{oexp1}{bct}{wa,oex13}{loop if more to go}
\inst{}{brn}{exint}{else return integer result}
\lnie
\endln
\lnie
here if integer overflow\endln
\lnie
\endln
\inst{oexp2}{erb}{017,exponentiation}{caused integer overflow}
\vfill\break

\lnie
\endln
\lnie
exponentiation (continued)\endln
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to exponentiate a real to an integer power\endln
\lnie
\endln
\inst{oexp3}{mfi}{wa,oexp6}{convert exponent to one word}
\inst{}{lct}{wa,wa}{set loop counter}
\inst{}{ldr}{rcval(xr)}{load base as initial value}
\inst{}{bnz}{wa,oexp5}{jump into loop if non-zero exponent}
\inst{}{req}{oexp4}{error if 0.0**0}
\inst{}{ldr}{reav1}{nonzero**0}
\inst{}{brn}{exrea}{return 1.0 if nonzero**zero}
\asmac{fi}
\lnie
\endln
\lnie
here for error of 0**0 or 0.0**0\endln
\lnie
\endln
\inst{oexp4}{erb}{018,exponentiation}{result is undefined}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
loop to perform exponentiation\endln
\lnie
\endln
\inst{oex14}{mlr}{rcval(xr)}{multiply by base}
\inst{}{rov}{oexp6}{jump if overflow}
\inst{oexp5}{bct}{wa,oex14}{loop till computation complete}
\inst{}{brn}{exrea}{then return real result}
\lnie
\endln
\lnie
here if real overflow\endln
\lnie
\endln
\inst{oexp6}{erb}{266,exponentiation}{caused real overflow}
\lnie
\endln
\lnie
here with real exponent in (xl), numeric base in (xr)\endln
\lnie
\endln
\ifmac{.cmth}
\inst{oexp7}{beq}{(xr),=b$rcl,oexp8}{jump if base real}
\inst{}{ldi}{icval(xr)}{load integer base}
\inst{}{itr}{}{convert to real}
\inst{}{jsr}{rcbld}{create real in (xr)}
\lnie
\endln
\lnie
here with real exponent in (xl)\endln
\lnie
numeric base in (xr) and ra\endln
\lnie
\endln
\inst{oexp8}{zer}{wb}{set positive result flag}
\inst{}{ldr}{rcval(xr)}{load base to ra}
\inst{}{rne}{oexp9}{jump if base non-zero}
\inst{}{ldr}{rcval(xl)}{base is zero.  check exponent}
\inst{}{req}{oexp4}{jump if 0.0 ** 0.0}
\inst{}{ldr}{reav0}{0.0 to non-zero exponent yields 0.0}
\inst{}{brn}{exrea}{return zero result}
\lnie
\endln
\lnie
here with non-zero base in (xr) and ra, exponent in (xl)\endln
\lnie
\endln
\lnie
a negative base is allowed if the exponent is integral.\endln
\lnie
\endln
\inst{oexp9}{rgt}{oex10}{jump if base gt 0.0}
\inst{}{ngr}{}{make base positive}
\inst{}{jsr}{rcbld}{create positive base in (xr)}
\inst{}{ldr}{rcval(xl)}{examine exponent}
\inst{}{chp}{}{chop to integral value}
\inst{}{rti}{oexp6}{convert to integer, br if too large}
\inst{}{sbr}{rcval(xl)}{chop(exponent) - exponent}
\inst{}{rne}{oex11}{non-integral power with neg base}
\inst{}{mfi}{wb}{record even/odd exponent}
\inst{}{anb}{bits1,wb}{odd exponent yields negative result}
\inst{}{ldr}{rcval(xr)}{restore base to ra}
\lnie
\endln
\lnie
here with positive base in ra and (xr), exponent in (xl)\endln
\lnie
\endln
\inst{oex10}{lnf}{}{log of base}
\inst{}{rov}{oexp6}{too large}
\inst{}{mlr}{rcval(xl)}{times exponent}
\inst{}{rov}{oexp6}{too large}
\inst{}{etx}{}{e ** (exponent * ln(base))}
\inst{}{rov}{oexp6}{too large}
\inst{}{bze}{wb,exrea}{if no sign fixup required}
\inst{}{ngr}{}{negative result needed}
\inst{}{brn}{}{negative result needed}
\lnie
\endln
\lnie
here for non-integral exponent with negative base\endln
\lnie
\endln
\inst{oex11}{erb}{311,exponentiation}{of negative base to non-integral power}
\asmac{else}
\inst{oexp7}{erb}{267,exponentiation}{right operand is real not integer}
\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
here with negative integer exponent in ia\endln
\lnie
\endln
\ifmac{.cmth}
\inst{oex12}{mov}{xr,-(xs)}{stack base}
\inst{}{itr}{}{convert to real exponent}
\inst{}{jsr}{rcbld}{real negative exponent in (xr)}
\inst{}{mov}{xr,xl}{put exponent in xl}
\inst{}{mov}{(xs)+,xr}{restore base value}
\inst{}{brn}{oexp7}{process real exponent}
\asmac{else}
\inst{oex12}{erb}{019,exponentiation}{right operand is negative}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
failure in expression evaluation\endln
\lnie
\endln
\lnie
this entry point is used if the evaluation of an\endln
\lnie
expression, initiated by the evalx procedure, fails.\endln
\lnie
control is returned to an appropriate point in evalx.\endln
\lnie
\endln
\inst{o$fex}{ent}{}{entry point}
\inst{}{brn}{evlx6}{jump to failure loc in evalx}
\vfill\break

\lnie
\endln
\lnie
failure during evaluation of a complex or direct goto\endln
\lnie
\endln
\inst{o$fif}{ent}{}{entry point}
\inst{}{erb}{020,goto evaluation}{failure}
\vfill\break

\lnie
\endln
\lnie
function call (more than one argument)\endln
\lnie
\endln
\inst{o$fnc}{ent}{}{entry point}
\inst{}{lcw}{wa}{load number of arguments}
\inst{}{lcw}{xr}{load function vrblk pointer}
\inst{}{mov}{vrfnc(xr),xl}{load function pointer}
\inst{}{bne}{wa,fargs(xl),cfunc}{use central routine if wrong num}
\inst{}{bri}{(xl)}{jump to function if arg count ok}
\vfill\break

\lnie
\endln
\lnie
function name error\endln
\lnie
\endln
\inst{o$fne}{ent}{}{entry point}
\inst{}{lcw}{wa}{get next code word}
\inst{}{bne}{wa,=ornm$,ofne1}{fail if not evaluating expression}
\inst{}{bze}{num02(xs),evlx3}{ok if expr. was wanted by value}
\lnie
\endln
\lnie
here for error\endln
\lnie
\endln
\inst{ofne1}{erb}{021,function called}{by name returned a value}
\vfill\break

\lnie
\endln
\lnie
function call (single argument)\endln
\lnie
\endln
\inst{o$fns}{ent}{}{entry point}
\inst{}{lcw}{xr}{load function vrblk pointer}
\inst{}{mov}{=num01,wa}{set number of arguments to one}
\inst{}{mov}{vrfnc(xr),xl}{load function pointer}
\inst{}{bne}{wa,fargs(xl),cfunc}{use central routine if wrong num}
\inst{}{bri}{(xl)}{jump to function if arg count ok}
\vfill\break

\lnie
call to undefined function\endln
\lnie
\endln
\inst{o$fun}{ent}{}{entry point}
\inst{}{erb}{022,undefined function}{called}
\vfill\break

\lnie
\endln
\lnie
execute complex goto\endln
\lnie
\endln
\inst{o$goc}{ent}{}{entry point}
\inst{}{mov}{num01(xs),xr}{load name base pointer}
\inst{}{bhi}{xr,state,ogoc1}{jump if not natural variable}
\inst{}{add}{*vrtra,xr}{else point to vrtra field}
\inst{}{bri}{(xr)}{and jump through it}
\lnie
\endln
\lnie
here if goto operand is not natural variable\endln
\lnie
\endln
\inst{ogoc1}{erb}{023,goto operand}{is not a natural variable}
\vfill\break

\lnie
\endln
\lnie
execute direct goto\endln
\lnie
\endln
\inst{o$god}{ent}{}{entry point}
\inst{}{mov}{(xs),xr}{load operand}
\inst{}{mov}{(xr),wa}{load first word}
\inst{}{beq}{wa,=b$cds,bcds0}{jump if code block to code routine}
\inst{}{beq}{wa,=b$cdc,bcdc0}{jump if code block to code routine}
\inst{}{erb}{024,goto operand}{in direct goto is not code}
\vfill\break

\lnie
\endln
\lnie
set goto failure trap\endln
\lnie
\endln
\lnie
this routine is executed at the start of a complex or\endln
\lnie
direct failure goto to trap a subsequent fail (see exfal)\endln
\lnie
\endln
\inst{o$gof}{ent}{}{entry point}
\inst{}{mov}{flptr,xr}{point to fail offset on stack}
\inst{}{ica}{(xr)}{point failure to o$fif word}
\inst{}{icp}{}{point to next code word}
\inst{}{lcw}{xr}{fetch next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
binary dollar (immediate assignment)\endln
\lnie
\endln
\lnie
the pattern built by binary dollar is a compound pattern.\endln
\lnie
see description at start of pattern match section for\endln
\lnie
details of the structure which is constructed.\endln
\lnie
\endln
\inst{o$ima}{ent}{}{entry point}
\inst{}{mov}{=p$imc,wb}{set pcode for last node}
\inst{}{mov}{(xs)+,wc}{pop name offset (parm2)}
\inst{}{mov}{(xs)+,xr}{pop name base (parm1)}
\inst{}{jsr}{pbild}{build p$imc node}
\inst{}{mov}{xr,xl}{save ptr to node}
\inst{}{mov}{(xs),xr}{load left argument}
\inst{}{jsr}{gtpat}{convert to pattern}
\inst{}{err}{025,immediate assignment}{left operand is not pattern}
\inst{}{mov}{xr,(xs)}{save ptr to left operand pattern}
\inst{}{mov}{=p$ima,wb}{set pcode for first node}
\inst{}{jsr}{pbild}{build p$ima node}
\inst{}{mov}{(xs)+,pthen(xr)}{set left operand as p$ima successor}
\inst{}{jsr}{pconc}{concatenate to form final pattern}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
indirection (by name)\endln
\lnie
\endln
\inst{o$inn}{ent}{}{entry point}
\inst{}{mnz}{wb}{set flag for result by name}
\inst{}{brn}{indir}{jump to common routine}
\vfill\break

\lnie
\endln
\lnie
interrogation\endln
\lnie
\endln
\inst{o$int}{ent}{}{entry point}
\inst{}{mov}{=nulls,(xs)}{replace operand with null}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
indirection (by value)\endln
\lnie
\endln
\inst{o$inv}{ent}{}{entry point}
\inst{}{zer}{wb}{set flag for by value}
\inst{}{brn}{indir}{jump to common routine}
\vfill\break

\lnie
\endln
\lnie
keyword reference (by name)\endln
\lnie
\endln
\inst{o$kwn}{ent}{}{entry point}
\inst{}{jsr}{kwnam}{get keyword name}
\inst{}{brn}{exnam}{exit with result name}
\vfill\break

\lnie
\endln
\lnie
keyword reference (by value)\endln
\lnie
\endln
\inst{o$kwv}{ent}{}{entry point}
\inst{}{jsr}{kwnam}{get keyword name}
\inst{}{mov}{xr,dnamp}{delete kvblk}
\inst{}{jsr}{acess}{access value}
\inst{}{ppm}{exnul}{dummy (unused) failure return}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
load expression by name\endln
\lnie
\endln
\inst{o$lex}{ent}{}{entry point}
\inst{}{mov}{*evsi$,wa}{set size of evblk}
\inst{}{jsr}{alloc}{allocate space for evblk}
\inst{}{mov}{=b$evt,(xr)}{set type word}
\inst{}{mov}{=trbev,evvar(xr)}{set dummy trblk pointer}
\inst{}{lcw}{wa}{load exblk pointer}
\inst{}{mov}{wa,evexp(xr)}{set exblk pointer}
\inst{}{mov}{xr,xl}{move name base to proper reg}
\inst{}{mov}{*evvar,wa}{set name offset = zero}
\inst{}{brn}{exnam}{exit with name in (xl,wa)}
\vfill\break

\lnie
\endln
\lnie
load pattern value\endln
\lnie
\endln
\inst{o$lpt}{ent}{}{entry point}
\inst{}{lcw}{xr}{load pattern pointer}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
load variable name\endln
\lnie
\endln
\inst{o$lvn}{ent}{}{entry point}
\inst{}{lcw}{wa}{load vrblk pointer}
\inst{}{mov}{wa,-(xs)}{stack vrblk ptr (name base)}
\inst{}{mov}{*vrval,-(xs)}{stack name offset}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
binary asterisk (multiplication)\endln
\lnie
\endln
\inst{o$mlt}{ent}{}{entry point}
\inst{}{jsr}{arith}{fetch arithmetic operands}
\inst{}{err}{026,multiplication}{left operand is not numeric}
\inst{}{err}{027,multiplication}{right operand is not numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{ppm}{omlt1}{jump if real operands}
\asmac{fi}
\lnie
\endln
\lnie
here to multiply two integers\endln
\lnie
\endln
\inst{}{mli}{icval(xl)}{multiply left operand by right}
\inst{}{ino}{exint}{return integer if no overflow}
\inst{}{erb}{028,multiplication}{caused integer overflow}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to multiply two reals\endln
\lnie
\endln
\inst{omlt1}{mlr}{rcval(xl)}{multiply left operand by right}
\inst{}{rno}{exrea}{return real if no overflow}
\inst{}{erb}{263,multiplication}{caused real overflow}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
name reference\endln
\lnie
\endln
\inst{o$nam}{ent}{}{entry point}
\inst{}{mov}{*nmsi$,wa}{set length of nmblk}
\inst{}{jsr}{alloc}{allocate nmblk}
\inst{}{mov}{=b$nml,(xr)}{set name block code}
\inst{}{mov}{(xs)+,nmofs(xr)}{set name offset from operand}
\inst{}{mov}{(xs)+,nmbas(xr)}{set name base from operand}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
negation\endln
\lnie
\endln
\lnie
initial entry\endln
\lnie
\endln
\inst{o$nta}{ent}{}{entry point}
\inst{}{lcw}{wa}{load new failure offset}
\inst{}{mov}{flptr,-(xs)}{stack old failure pointer}
\inst{}{mov}{wa,-(xs)}{stack new failure offset}
\inst{}{mov}{xs,flptr}{set new failure pointer}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
entry after successful evaluation of operand\endln
\lnie
\endln
\inst{o$ntb}{ent}{}{entry point}
\inst{}{mov}{num02(xs),flptr}{restore old failure pointer}
\inst{}{brn}{exfal}{and fail}
\lnie
\endln
\lnie
entry for failure during operand evaluation\endln
\lnie
\endln
\inst{o$ntc}{ent}{}{entry point}
\inst{}{ica}{xs}{pop failure offset}
\inst{}{mov}{(xs)+,flptr}{restore old failure pointer}
\inst{}{brn}{exnul}{exit giving null result}
\vfill\break

\lnie
\endln
\lnie
use of undefined operator\endln
\lnie
\endln
\inst{o$oun}{ent}{}{entry point}
\inst{}{erb}{029,undefined operator}{referenced}
\vfill\break

\lnie
\endln
\lnie
binary dot (pattern assignment)\endln
\lnie
\endln
\lnie
the pattern built by binary dot is a compound pattern.\endln
\lnie
see description at start of pattern match section for\endln
\lnie
details of the structure which is constructed.\endln
\lnie
\endln
\inst{o$pas}{ent}{}{entry point}
\inst{}{mov}{=p$pac,wb}{load pcode for p$pac node}
\inst{}{mov}{(xs)+,wc}{load name offset (parm2)}
\inst{}{mov}{(xs)+,xr}{load name base (parm1)}
\inst{}{jsr}{pbild}{build p$pac node}
\inst{}{mov}{xr,xl}{save ptr to node}
\inst{}{mov}{(xs),xr}{load left operand}
\inst{}{jsr}{gtpat}{convert to pattern}
\inst{}{err}{030,pattern assignment}{left operand is not pattern}
\inst{}{mov}{xr,(xs)}{save ptr to left operand pattern}
\inst{}{mov}{=p$paa,wb}{set pcode for p$paa node}
\inst{}{jsr}{pbild}{build p$paa node}
\inst{}{mov}{(xs)+,pthen(xr)}{set left operand as p$paa successor}
\inst{}{jsr}{pconc}{concatenate to form final pattern}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
pattern match (by name, for replacement)\endln
\lnie
\endln
\inst{o$pmn}{ent}{}{entry point}
\inst{}{zer}{wb}{set type code for match by name}
\inst{}{brn}{match}{jump to routine to start match}
\vfill\break

\lnie
\endln
\lnie
pattern match (statement)\endln
\lnie
\endln
\lnie
o$pms is used in place of o$pmv when the pattern match\endln
\lnie
occurs at the outer (statement) level since in this\endln
\lnie
case the substring value need not be constructed.\endln
\lnie
\endln
\inst{o$pms}{ent}{}{entry point}
\inst{}{mov}{=num02,wb}{set flag for statement to match}
\inst{}{brn}{match}{jump to routine to start match}
\vfill\break

\lnie
\endln
\lnie
pattern match (by value)\endln
\lnie
\endln
\inst{o$pmv}{ent}{}{entry point}
\inst{}{mov}{=num01,wb}{set type code for value match}
\inst{}{brn}{match}{jump to routine to start match}
\vfill\break

\lnie
\endln
\lnie
pop top item on stack\endln
\lnie
\endln
\inst{o$pop}{ent}{}{entry point}
\inst{}{ica}{xs}{pop top stack entry}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
terminate execution (code compiled for end statement)\endln
\lnie
\endln
\inst{o$stp}{ent}{}{entry point}
\inst{}{brn}{lend0}{jump to end circuit}
\vfill\break

\lnie
\endln
\lnie
return name from expression\endln
\lnie
this entry points is used if the evaluation of an\endln
\lnie
expression, initiated by the evalx procedure, returns\endln
\lnie
a name. control is returned to the proper point in evalx.\endln
\lnie
\endln
\inst{o$rnm}{ent}{}{entry point}
\inst{}{brn}{evlx4}{return to evalx procedure}
\vfill\break

\lnie
\endln
\lnie
pattern replacement\endln
\lnie
\endln
\lnie
when this routine gets control, the following stack\endln
\lnie
entries have been made (see end of match routine p$nth)\endln
\lnie
\endln
\lnie
                      subject name base\endln
\lnie
                      subject name offset\endln
\lnie
                      initial cursor value\endln
\lnie
                      final cursor value\endln
\lnie
                      subject string pointer\endln
\lnie
(xs) ---------------- replacement value\endln
\lnie
\endln
\inst{o$rpl}{ent}{}{entry point}
\inst{}{jsr}{gtstg}{convert replacement val to string}
\inst{}{err}{031,pattern replacement}{right operand is not a string}
\lnie
\endln
\lnie
get result length and allocate result scblk\endln
\lnie
\endln
\inst{}{mov}{(xs),xl}{load subject string pointer}
\ifmac{.cnbf}
\asmac{else}
\inst{}{beq}{(xl),=b$bct,orpl4}{branch if buffer assignment}
\asmac{fi}
\inst{}{add}{sclen(xl),wa}{add subject string length}
\inst{}{add}{num02(xs),wa}{add starting cursor}
\inst{}{sub}{num01(xs),wa}{minus final cursor = total length}
\inst{}{bze}{wa,orpl3}{jump if result is null}
\inst{}{mov}{xr,-(xs)}{restack replacement string}
\inst{}{jsr}{alocs}{allocate scblk for result}
\inst{}{mov}{num03(xs),wa}{get initial cursor (part 1 len)}
\inst{}{mov}{xr,num03(xs)}{stack result pointer}
\inst{}{psc}{xr}{point to characters of result}
\lnie
\endln
\lnie
move part 1 (start of subject) to result\endln
\lnie
\endln
\inst{}{bze}{wa,orpl1}{jump if first part is null}
\inst{}{mov}{num01(xs),xl}{else point to subject string}
\inst{}{plc}{xl}{point to subject string chars}
\inst{}{mvc}{}{move first part to result}
\vfill\break

\lnie
pattern replacement (continued)\endln
\lnie
\endln
\lnie
now move in replacement value\endln
\lnie
\endln
\inst{orpl1}{mov}{(xs)+,xl}{load replacement string, pop}
\inst{}{mov}{sclen(xl),wa}{load length}
\inst{}{bze}{wa,orpl2}{jump if null replacement}
\inst{}{plc}{xl}{else point to chars of replacement}
\inst{}{mvc}{}{move in chars (part 2)}
\lnie
\endln
\lnie
now move in remainder of string (part 3)\endln
\lnie
\endln
\inst{orpl2}{mov}{(xs)+,xl}{load subject string pointer, pop}
\inst{}{mov}{(xs)+,wc}{load final cursor, pop}
\inst{}{mov}{sclen(xl),wa}{load subject string length}
\inst{}{sub}{wc,wa}{minus final cursor = part 3 length}
\inst{}{bze}{wa,oass0}{jump to assign if part 3 is null}
\inst{}{plc}{xl,wc}{else point to last part of string}
\inst{}{mvc}{}{move part 3 to result}
\inst{}{brn}{oass0}{jump to perform assignment}
\lnie
\endln
\lnie
here if result is null\endln
\lnie
\endln
\inst{orpl3}{add}{*num02,xs}{pop subject str ptr, final cursor}
\inst{}{mov}{=nulls,(xs)}{set null result}
\inst{}{brn}{oass0}{jump to assign null value}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
here for buffer substring assignment\endln
\lnie
\endln
\inst{orpl4}{mov}{xr,xl}{copy scblk replacement ptr}
\inst{}{mov}{(xs)+,xr}{unstack bcblk ptr}
\inst{}{mov}{(xs)+,wb}{get final cursor value}
\inst{}{mov}{(xs)+,wa}{get initial cursor}
\inst{}{sub}{wa,wb}{get length in wb}
\inst{}{add}{*num01,xs}{get rid of name offset}
\inst{}{mov}{xr,(xs)}{store buffer result over name base}
\inst{}{jsr}{insbf}{insert substring}
\inst{}{ppm}{}{convert fail impossible}
\inst{}{ppm}{exfal}{fail if insert fails}
\inst{}{lcw}{xr}{result on stack, get code word}
\inst{}{bri}{(xr)}{execute next code word}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
return value from expression\endln
\lnie
\endln
\lnie
this entry points is used if the evaluation of an\endln
\lnie
expression, initiated by the evalx procedure, returns\endln
\lnie
a value. control is returned to the proper point in evalx\endln
\lnie
\endln
\inst{o$rvl}{ent}{}{entry point}
\inst{}{brn}{evlx3}{return to evalx procedure}
\vfill\break

\lnie
\endln
\lnie
selection\endln
\lnie
\endln
\lnie
initial entry\endln
\lnie
\endln
\inst{o$sla}{ent}{}{entry point}
\inst{}{lcw}{wa}{load new failure offset}
\inst{}{mov}{flptr,-(xs)}{stack old failure pointer}
\inst{}{mov}{wa,-(xs)}{stack new failure offset}
\inst{}{mov}{xs,flptr}{set new failure pointer}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
entry after successful evaluation of alternative\endln
\lnie
\endln
\inst{o$slb}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load result}
\inst{}{ica}{xs}{pop fail offset}
\inst{}{mov}{(xs),flptr}{restore old failure pointer}
\inst{}{mov}{xr,(xs)}{restack result}
\inst{}{lcw}{wa}{load new code offset}
\inst{}{add}{r$cod,wa}{point to absolute code location}
\inst{}{lcp}{wa}{set new code pointer}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
entry at start of subsequent alternatives\endln
\lnie
\endln
\inst{o$slc}{ent}{}{entry point}
\inst{}{lcw}{wa}{load new fail offset}
\inst{}{mov}{wa,(xs)}{store new fail offset}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
entry at start of last alternative\endln
\lnie
\endln
\inst{o$sld}{ent}{}{entry point}
\inst{}{ica}{xs}{pop failure offset}
\inst{}{mov}{(xs)+,flptr}{restore old failure pointer}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
binary minus (subtraction)\endln
\lnie
\endln
\inst{o$sub}{ent}{}{entry point}
\inst{}{jsr}{arith}{fetch arithmetic operands}
\inst{}{err}{032,subtraction left}{operand is not numeric}
\inst{}{err}{033,subtraction right}{operand is not numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{ppm}{osub1}{jump if real operands}
\asmac{fi}
\lnie
\endln
\lnie
here to subtract two integers\endln
\lnie
\endln
\inst{}{sbi}{icval(xl)}{subtract right operand from left}
\inst{}{ino}{exint}{return integer if no overflow}
\inst{}{erb}{034,subtraction caused}{integer overflow}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to subtract two reals\endln
\lnie
\endln
\inst{osub1}{sbr}{rcval(xl)}{subtract right operand from left}
\inst{}{rno}{exrea}{return real if no overflow}
\inst{}{erb}{264,subtraction caused}{real overflow}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
dummy operator to return control to trxeq procedure\endln
\lnie
\endln
\inst{o$txr}{ent}{}{entry point}
\inst{}{brn}{trxq1}{jump into trxeq procedure}
\vfill\break

\lnie
\endln
\lnie
unexpected failure\endln
\lnie
\endln
\lnie
note that if a setexit trap is operating then\endln
\lnie
transfer to system label continue\endln
\lnie
will result in looping here.  difficult to avoid except\endln
\lnie
with a considerable overhead which is not worthwhile or\endln
\lnie
else by a technique such as setting kverl to zero.\endln
\lnie
\endln
\inst{o$unf}{ent}{}{entry point}
\inst{}{erb}{035,unexpected failure}{in -nofail mode}
\vfill\break
{\bf spitbol--\rm block action routines}
\vskip1em
\lnie
\endln
\lnie
the first word of every block in dynamic storage and the\endln
\lnie
vrget, vrsto and vrtra fields of a vrblk contain a\endln
\lnie
pointer to an entry point in the program. all such entry\endln
\lnie
points are in the following section except those for\endln
\lnie
pattern blocks which are in the pattern matching segment\endln
\lnie
later on (labels of the form p$xxx), and dope vectors\endln
\lnie
(d$xxx) which are in the dope vector section following\endln
\lnie
the pattern routines (dope vectors are used for cmblks).\endln
\lnie
\endln
\lnie
the entry points in this section have labels of the\endln
\lnie
form b$xxy where xx is the two character block type for\endln
\lnie
the corresponding block and y is any letter.\endln
\lnie
\endln
\lnie
in some cases, the pointers serve no other purpose than\endln
\lnie
to identify the block type. in this case the routine\endln
\lnie
is never executed and thus no code is assembled.\endln
\lnie
\endln
\lnie
for each of these entry points corresponding to a block\endln
\lnie
an entry point identification is assembled (bl$xx).\endln
\lnie
\endln
\lnie
the exact entry conditions depend on the manner in\endln
\lnie
which the routine is accessed and are documented with\endln
\lnie
the individual routines as required.\endln
\lnie
\endln
\lnie
the order of these routines is alphabetical with the\endln
\lnie
following exceptions.\endln
\lnie
\endln
\lnie
the routines for seblk and exblk entries occur first so\endln
\lnie
that expressions can be quickly identified from the fact\endln
\lnie
that their routines lie before the symbol b$e$$.\endln
\lnie
\endln
\lnie
these are immediately followed by the routine for a trblk\endln
\lnie
so that the test against the symbol b$t$$ checks for\endln
\lnie
trapped values or expression values (see procedure evalp)\endln
\lnie
\endln
\lnie
the pattern routines lie after this section so that\endln
\lnie
patterns are identified with routines starting at or\endln
\lnie
after the initial instruction in these routines (p$aaa).\endln
\lnie
\endln
\lnie
the symbol b$aaa defines the first location for block\endln
\lnie
routines and the symbol p$yyy (at the end of the pattern\endln
\lnie
match routines section) defines the last such entry point\endln
\lnie
\endln
\inst{b$aaa}{ent}{bl$$i}{entry point of first block routine}
\vfill\break

\lnie
\endln
\lnie
exblk\endln
\lnie
\endln
\lnie
the routine for an exblk loads the expression onto\endln
\lnie
the stack as a value.\endln
\lnie
\endln
\lnie
(xr)                  pointer to exblk\endln
\lnie
\endln
\inst{b$exl}{ent}{bl$ex}{entry point (exblk)}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
seblk\endln
\lnie
\endln
\lnie
the routine for seblk is accessed from the generated\endln
\lnie
code to load the expression value onto the stack.\endln
\lnie
\endln
\inst{b$sel}{ent}{bl$se}{entry point (seblk)}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
define symbol which marks end of entries for expressions\endln
\lnie
\endln
\inst{b$e$$}{ent}{bl$$i}{entry point}
\vfill\break

\lnie
\endln
\lnie
trblk\endln
\lnie
\endln
\lnie
the routine for a trblk is never executed\endln
\lnie
\endln
\inst{b$trt}{ent}{bl$tr}{entry point (trblk)}
\lnie
\endln
\lnie
define symbol marking end of trap and expression blocks\endln
\lnie
\endln
\inst{b$t$$}{ent}{bl$$i}{end of trblk,seblk,exblk entries}
\vfill\break

\lnie
\endln
\lnie
arblk\endln
\lnie
\endln
\lnie
the routine for arblk is never executed\endln
\lnie
\endln
\inst{b$art}{ent}{bl$ar}{entry point (arblk)}
\vfill\break

\lnie
\endln
\lnie
bcblk\endln
\lnie
\endln
\lnie
the routine for a bcblk is never executed\endln
\lnie
\endln
\lnie
(xr)                  pointer to bcblk\endln
\lnie
\endln
\inst{b$bct}{ent}{bl$bc}{entry point (bcblk)}
\vfill\break

\lnie
\endln
\lnie
bfblk\endln
\lnie
\endln
\lnie
the routine for a bfblk is never executed\endln
\lnie
\endln
\lnie
(xr)                  pointer to bfblk\endln
\lnie
\endln
\inst{b$bft}{ent}{bl$bf}{entry point (bfblk)}
\vfill\break

\lnie
\endln
\lnie
ccblk\endln
\lnie
\endln
\lnie
the routine for ccblk is never entered\endln
\lnie
\endln
\inst{b$cct}{ent}{bl$cc}{entry point (ccblk)}
\vfill\break

\lnie
\endln
\lnie
cdblk\endln
\lnie
\endln
\lnie
the cdblk routines are executed from the generated code.\endln
\lnie
there are two cases depending on the form of cdfal.\endln
\lnie
\endln
\lnie
entry for complex failure code at cdfal\endln
\lnie
\endln
\lnie
(xr)                  pointer to cdblk\endln
\lnie
\endln
\inst{b$cdc}{ent}{bl$cd}{entry point (cdblk)}
\inst{bcdc0}{mov}{flptr,xs}{pop garbage off stack}
\inst{}{mov}{cdfal(xr),(xs)}{set failure offset}
\inst{}{brn}{stmgo}{enter stmt}
\vfill\break

\lnie
\endln
\lnie
cdblk (continued)\endln
\lnie
\endln
\lnie
entry for simple failure code at cdfal\endln
\lnie
\endln
\lnie
(xr)                  pointer to cdblk\endln
\lnie
\endln
\inst{b$cds}{ent}{bl$cd}{entry point (cdblk)}
\inst{bcds0}{mov}{flptr,xs}{pop garbage off stack}
\inst{}{mov}{*cdfal,(xs)}{set failure offset}
\inst{}{brn}{stmgo}{enter stmt}
\vfill\break

\lnie
\endln
\lnie
cmblk\endln
\lnie
\endln
\lnie
the routine for a cmblk is never executed\endln
\lnie
\endln
\inst{b$cmt}{ent}{bl$cm}{entry point (cmblk)}
\vfill\break

\lnie
\endln
\lnie
ctblk\endln
\lnie
\endln
\lnie
the routine for a ctblk is never executed\endln
\lnie
\endln
\inst{b$ctt}{ent}{bl$ct}{entry point (ctblk)}
\vfill\break

\lnie
\endln
\lnie
dfblk\endln
\lnie
\endln
\lnie
the routine for a dfblk is accessed from the o$fnc entry\endln
\lnie
to call a datatype function and build a pdblk.\endln
\lnie
\endln
\lnie
(xl)                  pointer to dfblk\endln
\lnie
\endln
\inst{b$dfc}{ent}{bl$df}{entry point}
\inst{}{mov}{dfpdl(xl),wa}{load length of pdblk}
\inst{}{jsr}{alloc}{allocate pdblk}
\inst{}{mov}{=b$pdt,(xr)}{store type word}
\inst{}{mov}{xl,pddfp(xr)}{store dfblk pointer}
\inst{}{mov}{xr,wc}{save pointer to pdblk}
\inst{}{add}{wa,xr}{point past pdblk}
\inst{}{lct}{wa,fargs(xl)}{set to count fields}
\lnie
\endln
\lnie
loop to acquire field values from stack\endln
\lnie
\endln
\inst{bdfc1}{mov}{(xs)+,-(xr)}{move a field value}
\inst{}{bct}{wa,bdfc1}{loop till all moved}
\inst{}{mov}{wc,xr}{recall pointer to pdblk}
\inst{}{brn}{exsid}{exit setting id field}
\vfill\break

\lnie
\endln
\lnie
efblk\endln
\lnie
\endln
\lnie
the routine for an efblk is passed control form the o$fnc\endln
\lnie
entry to call an external function.\endln
\lnie
\endln
\lnie
(xl)                  pointer to efblk\endln
\lnie
\endln
\inst{b$efc}{ent}{bl$ef}{entry point (efblk)}
\ifmac{.cnld}
\asmac{else}
\inst{}{mov}{fargs(xl),wc}{load number of arguments}
\inst{}{wtb}{wc}{convert to offset}
\inst{}{mov}{xl,-(xs)}{save pointer to efblk}
\inst{}{mov}{xs,xt}{copy pointer to arguments}
\lnie
\endln
\lnie
loop to convert arguments\endln
\lnie
\endln
\inst{befc1}{ica}{xt}{point to next entry}
\inst{}{mov}{(xs),xr}{load pointer to efblk}
\inst{}{dca}{wc}{decrement eftar offset}
\inst{}{add}{wc,xr}{point to next eftar entry}
\inst{}{mov}{eftar(xr),xr}{load eftar entry}
\ifmac{.cnra}
\ifmac{.cnlf}
\inst{}{bsw}{xr,4}{switch on type}
\asmac{else}
\inst{}{bsw}{xr,3}{switch on type}
\asmac{fi}
\asmac{else}
\ifmac{.cnlf}
\inst{}{bsw}{xr,5}{switch on type}
\asmac{else}
\inst{}{bsw}{xr,4}{switch on type}
\asmac{fi}
\asmac{fi}
\inst{}{iff}{0,befc7}{no conversion needed}
\inst{}{iff}{1,befc2}{string}
\inst{}{iff}{2,befc3}{integer}
\ifmac{.cnra}
\ifmac{.cnlf}
\inst{}{iff}{3,beff1}{file}
\asmac{fi}
\asmac{else}
\inst{}{iff}{3,befc4}{real}
\ifmac{.cnlf}
\inst{}{iff}{4,beff1}{file}
\asmac{fi}
\asmac{fi}
\inst{}{esw}{}{end of switch on type}
\ifmac{.cnlf}
\lnie
\endln
\lnie
here to convert to file\endln
\lnie
\endln
\inst{beff1}{mov}{xt,-(xs)}{save entry pointer}
\inst{}{mov}{wc,befof}{save offset}
\inst{}{mov}{(xt),-(xs)}{stack arg pointer}
\inst{}{jsr}{iofcb}{convert to fcb}
\inst{}{err}{298,external function}{argument is not file}
\inst{}{err}{298,external function}{argument is not file}
\inst{}{err}{298,external function}{argument is not file}
\inst{}{mov}{wa,xr}{point to fcb}
\inst{}{mov}{(xs)+,xt}{reload entry pointer}
\inst{}{brn}{befc5}{jump to merge}
\asmac{fi}
\lnie
\endln
\lnie
here to convert to string\endln
\lnie
\endln
\inst{befc2}{mov}{(xt),-(xs)}{stack arg ptr}
\inst{}{jsr}{gtstg}{convert argument to string}
\inst{}{err}{039,external function}{argument is not a string}
\inst{}{brn}{befc6}{jump to merge}
\vfill\break

\lnie
\endln
\lnie
efblk (continued)\endln
\lnie
\endln
\lnie
here to convert an integer\endln
\lnie
\endln
\inst{befc3}{mov}{(xt),xr}{load next argument}
\inst{}{mov}{wc,befof}{save offset}
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{err}{040,external function}{argument is not integer}
\ifmac{.cnra}
\asmac{else}
\inst{}{brn}{befc5}{merge with real case}
\lnie
\endln
\lnie
here to convert a real\endln
\lnie
\endln
\inst{befc4}{mov}{(xt),xr}{load next argument}
\inst{}{mov}{wc,befof}{save offset}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{265,external function}{argument is not real}
\asmac{fi}
\lnie
\endln
\lnie
integer case merges here\endln
\lnie
\endln
\inst{befc5}{mov}{befof,wc}{restore offset}
\lnie
\endln
\lnie
string merges here\endln
\lnie
\endln
\inst{befc6}{mov}{xr,(xt)}{store converted result}
\lnie
\endln
\lnie
no conversion merges here\endln
\lnie
\endln
\inst{befc7}{bnz}{wc,befc1}{loop back if more to go}
\lnie
\endln
\lnie
here after converting all the arguments\endln
\lnie
\endln
\inst{}{mov}{(xs)+,xl}{restore efblk pointer}
\inst{}{mov}{fargs(xl),wa}{get number of args}
\inst{}{jsr}{sysex}{call routine to call external fnc}
\inst{}{ppm}{exfal}{fail if failure}
\inst{}{err}{327,calling external}{function - not found}
\inst{}{err}{326,calling external}{function - bad argument type}
\ifmac{.cexp}
\inst{}{wtb}{wa}{convert number of args to bytes}
\inst{}{add}{wa,xs}{remove arguments from stack}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
efblk (continued)\endln
\lnie
\endln
\lnie
return here with result in xr\endln
\lnie
\endln
\lnie
first defend against non-standard null string returned\endln
\lnie
\endln
\inst{}{mov}{efrsl(xl),wb}{get result type id}
\inst{}{bnz}{wb,befa8}{branch if not unconverted}
\inst{}{bne}{(xr),=b$scl,befc8}{jump if not a string}
\inst{}{bze}{sclen(xr),exnul}{return null if null}
\lnie
\endln
\lnie
here if converted result to check for null string\endln
\lnie
\endln
\inst{befa8}{bne}{wb,=num01,befc8}{jump if not a string}
\inst{}{bze}{sclen(xr),exnul}{return null if null}
\lnie
\endln
\lnie
return if result is in dynamic storage\endln
\lnie
\endln
\inst{befc8}{blt}{xr,dnamb,befc9}{jump if not in dynamic storage}
\inst{}{ble}{xr,dnamp,exixr}{return result if already dynamic}
\lnie
\endln
\lnie
here we copy a result into the dynamic region\endln
\lnie
\endln
\inst{befc9}{mov}{(xr),wa}{get possible type word}
\inst{}{bze}{wb,bef11}{jump if unconverted result}
\inst{}{mov}{=b$scl,wa}{string}
\inst{}{beq}{wb,=num01,bef10}{yes jump}
\inst{}{mov}{=b$icl,wa}{integer}
\inst{}{beq}{wb,=num02,bef10}{yes jump}
\ifmac{.cnra}
\asmac{else}
\inst{}{mov}{=b$rcl,wa}{real}
\asmac{fi}
\lnie
\endln
\lnie
store type word in result\endln
\lnie
\endln
\inst{bef10}{mov}{wa,(xr)}{stored before copying to dynamic}
\lnie
\endln
\lnie
merge for unconverted result\endln
\lnie
\endln
\inst{bef11}{beq}{(xr),=b$scl,bef12}{branch if string result}
\inst{}{jsr}{blkln}{get length of block}
\inst{}{mov}{xr,xl}{copy address of old block}
\inst{}{jsr}{alloc}{allocate dynamic block same size}
\inst{}{mov}{xr,-(xs)}{set pointer to new block as result}
\inst{}{mvw}{}{copy old block to dynamic block}
\inst{}{zer}{xl}{clear garbage value}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
here to return a string result that was not in dynamic.\endln
\lnie
cannot use the simple word copy above because it will not\endln
\lnie
guarantee zero padding in the last word.\endln
\lnie
\endln
\inst{bef12}{mov}{xr,xl}{save source string pointer}
\inst{}{mov}{sclen(xr),wa}{fetch string length}
\inst{}{bze}{wa,exnul}{return null string if length zero}
\inst{}{jsr}{alocs}{allocate space for string}
\inst{}{mov}{xr,-(xs)}{save as result pointer}
\inst{}{psc}{xr}{prepare to store chars of result}
\inst{}{plc}{xl}{point to chars in source string}
\inst{}{mov}{wc,wa}{number of characters to copy}
\inst{}{mvc}{}{move characters to result string}
\inst{}{zer}{xl}{clear garbage value}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
evblk\endln
\lnie
\endln
\lnie
the routine for an evblk is never executed\endln
\lnie
\endln
\inst{b$evt}{ent}{bl$ev}{entry point (evblk)}
\vfill\break

\lnie
\endln
\lnie
ffblk\endln
\lnie
\endln
\lnie
the routine for an ffblk is executed from the o$fnc entry\endln
\lnie
to call a field function and extract a field value/name.\endln
\lnie
\endln
\lnie
(xl)                  pointer to ffblk\endln
\lnie
\endln
\inst{b$ffc}{ent}{bl$ff}{entry point (ffblk)}
\inst{}{mov}{xl,xr}{copy ffblk pointer}
\inst{}{lcw}{wc}{load next code word}
\inst{}{mov}{(xs),xl}{load pdblk pointer}
\inst{}{bne}{(xl),=b$pdt,bffc2}{jump if not pdblk at all}
\inst{}{mov}{pddfp(xl),wa}{load dfblk pointer from pdblk}
\lnie
\endln
\lnie
loop to find correct ffblk for this pdblk\endln
\lnie
\endln
\inst{bffc1}{beq}{wa,ffdfp(xr),bffc3}{jump if this is the correct ffblk}
\inst{}{mov}{ffnxt(xr),xr}{else link to next ffblk on chain}
\inst{}{bnz}{xr,bffc1}{loop back if another entry to check}
\lnie
\endln
\lnie
here for bad argument\endln
\lnie
\endln
\inst{bffc2}{erb}{041,field function}{argument is wrong datatype}
\vfill\break

\lnie
\endln
\lnie
ffblk (continued)\endln
\lnie
\endln
\lnie
here after locating correct ffblk\endln
\lnie
\endln
\inst{bffc3}{mov}{ffofs(xr),wa}{load field offset}
\inst{}{beq}{wc,=ofne$,bffc5}{jump if called by name}
\inst{}{add}{wa,xl}{else point to value field}
\inst{}{mov}{(xl),xr}{load value}
\inst{}{bne}{(xr),=b$trt,bffc4}{jump if not trapped}
\inst{}{sub}{wa,xl}{else restore name base,offset}
\inst{}{mov}{wc,(xs)}{save next code word over pdblk ptr}
\inst{}{jsr}{acess}{access value}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{mov}{(xs),wc}{restore next code word}
\lnie
\endln
\lnie
here after getting value in (xr), xl is garbage\endln
\lnie
\endln
\inst{bffc4}{mov}{xr,(xs)}{store value on stack (over pdblk)}
\inst{}{mov}{wc,xr}{copy next code word}
\inst{}{mov}{(xr),xl}{load entry address}
\inst{}{bri}{xl}{jump to routine for next code word}
\lnie
\endln
\lnie
here if called by name\endln
\lnie
\endln
\inst{bffc5}{mov}{wa,-(xs)}{store name offset (base is set)}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
icblk\endln
\lnie
\endln
\lnie
the routine for icblk is executed from the generated\endln
\lnie
code to load an integer value onto the stack.\endln
\lnie
\endln
\lnie
(xr)                  pointer to icblk\endln
\lnie
\endln
\inst{b$icl}{ent}{bl$ic}{entry point (icblk)}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
kvblk\endln
\lnie
\endln
\lnie
the routine for a kvblk is never executed.\endln
\lnie
\endln
\inst{b$kvt}{ent}{bl$kv}{entry point (kvblk)}
\vfill\break

\lnie
\endln
\lnie
nmblk\endln
\lnie
\endln
\lnie
the routine for a nmblk is executed from the generated\endln
\lnie
code for the case of loading a name onto the stack\endln
\lnie
where the name is that of a natural variable which can\endln
\lnie
be preevaluated at compile time.\endln
\lnie
\endln
\lnie
(xr)                  pointer to nmblk\endln
\lnie
\endln
\inst{b$nml}{ent}{bl$nm}{entry point (nmblk)}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
pdblk\endln
\lnie
\endln
\lnie
the routine for a pdblk is never executed\endln
\lnie
\endln
\inst{b$pdt}{ent}{bl$pd}{entry point (pdblk)}
\vfill\break

\lnie
\endln
\lnie
pfblk\endln
\lnie
\endln
\lnie
the routine for a pfblk is executed from the entry o$fnc\endln
\lnie
to call a program defined function.\endln
\lnie
\endln
\lnie
(xl)                  pointer to pfblk\endln
\lnie
\endln
\lnie
the following stack entries are made before passing\endln
\lnie
control to the program defined function.\endln
\lnie
\endln
\lnie
                      saved value of first argument\endln
\lnie
                      .\endln
\lnie
                      saved value of last argument\endln
\lnie
                      saved value of first local\endln
\lnie
                      .\endln
\lnie
                      saved value of last local\endln
\lnie
                      saved value of function name\endln
\lnie
                      saved code block ptr (r$cod)\endln
\lnie
                      saved code pointer (-r$cod)\endln
\lnie
                      saved value of flprt\endln
\lnie
                      saved value of flptr\endln
\lnie
                      pointer to pfblk\endln
\lnie
flptr --------------- zero (to be overwritten with offs)\endln
\lnie
\endln
\inst{b$pfc}{ent}{bl$pf}{entry point (pfblk)}
\inst{}{mov}{xl,bpfpf}{save pfblk ptr (need not be reloc)}
\inst{}{mov}{xl,xr}{copy for the moment}
\inst{}{mov}{pfvbl(xr),xl}{point to vrblk for function}
\lnie
\endln
\lnie
loop to find old value of function\endln
\lnie
\endln
\inst{bpf01}{mov}{xl,wb}{save pointer}
\inst{}{mov}{vrval(xl),xl}{load value}
\inst{}{beq}{(xl),=b$trt,bpf01}{loop if trblk}
\lnie
\endln
\lnie
set value to null and save old function value\endln
\lnie
\endln
\inst{}{mov}{xl,bpfsv}{save old value}
\inst{}{mov}{wb,xl}{point back to block with value}
\inst{}{mov}{=nulls,vrval(xl)}{set value to null}
\inst{}{mov}{fargs(xr),wa}{load number of arguments}
\inst{}{add}{*pfarg,xr}{point to pfarg entries}
\inst{}{bze}{wa,bpf04}{jump if no arguments}
\inst{}{mov}{xs,xt}{ptr to last arg}
\inst{}{wtb}{wa}{convert no. of args to bytes offset}
\inst{}{add}{wa,xt}{point before first arg}
\inst{}{mov}{xt,bpfxt}{remember arg pointer}
\vfill\break

\lnie
\endln
\lnie
pfblk (continued)\endln
\lnie
\endln
\lnie
loop to save old argument values and set new ones\endln
\lnie
\endln
\inst{bpf02}{mov}{(xr)+,xl}{load vrblk ptr for next argument}
\lnie
\endln
\lnie
loop through possible trblk chain to find value\endln
\lnie
\endln
\inst{bpf03}{mov}{xl,wc}{save pointer}
\inst{}{mov}{vrval(xl),xl}{load next value}
\inst{}{beq}{(xl),=b$trt,bpf03}{loop back if trblk}
\lnie
\endln
\lnie
save old value and get new value\endln
\lnie
\endln
\inst{}{mov}{xl,wa}{keep old value}
\inst{}{mov}{bpfxt,xt}{point before next stacked arg}
\inst{}{mov}{-(xt),wb}{load argument (new value)}
\inst{}{mov}{wa,(xt)}{save old value}
\inst{}{mov}{xt,bpfxt}{keep arg ptr for next time}
\inst{}{mov}{wc,xl}{point back to block with value}
\inst{}{mov}{wb,vrval(xl)}{set new value}
\inst{}{bne}{xs,bpfxt,bpf02}{loop if not all done}
\lnie
\endln
\lnie
now process locals\endln
\lnie
\endln
\inst{bpf04}{mov}{bpfpf,xl}{restore pfblk pointer}
\inst{}{mov}{pfnlo(xl),wa}{load number of locals}
\inst{}{bze}{wa,bpf07}{jump if no locals}
\inst{}{mov}{=nulls,wb}{get null constant}
\inst{}{lct}{wa,wa}{set local counter}
\lnie
\endln
\lnie
loop to process locals\endln
\lnie
\endln
\inst{bpf05}{mov}{(xr)+,xl}{load vrblk ptr for next local}
\lnie
\endln
\lnie
loop through possible trblk chain to find value\endln
\lnie
\endln
\inst{bpf06}{mov}{xl,wc}{save pointer}
\inst{}{mov}{vrval(xl),xl}{load next value}
\inst{}{beq}{(xl),=b$trt,bpf06}{loop back if trblk}
\lnie
\endln
\lnie
save old value and set null as new value\endln
\lnie
\endln
\inst{}{mov}{xl,-(xs)}{stack old value}
\inst{}{mov}{wc,xl}{point back to block with value}
\inst{}{mov}{wb,vrval(xl)}{set null as new value}
\inst{}{bct}{wa,bpf05}{loop till all locals processed}
\vfill\break

\lnie
\endln
\lnie
pfblk (continued)\endln
\lnie
\endln
\lnie
here after processing arguments and locals\endln
\lnie
\endln
\ifmac{.cnpf}
\inst{bpf07}{mov}{r$cod,wa}{load old code block pointer}
\asmac{else}
\inst{bpf07}{zer}{xr}{zero reg xr in case}
\inst{}{bze}{kvpfl,bpf7c}{skip if profiling is off}
\inst{}{beq}{kvpfl,=num02,bpf7a}{branch on type of profile}
\lnie
\endln
\lnie
here if &profile = 1\endln
\lnie
\endln
\inst{}{jsr}{systm}{get current time}
\inst{}{sti}{pfetm}{save for a sec}
\inst{}{sbi}{pfstm}{find time used by caller}
\inst{}{jsr}{icbld}{build into an icblk}
\inst{}{ldi}{pfetm}{reload current time}
\inst{}{brn}{bpf7b}{merge}
\lnie
\endln
\lnie
 here if &profile = 2\endln
\lnie
\endln
\inst{bpf7a}{ldi}{pfstm}{get start time of calling stmt}
\inst{}{jsr}{icbld}{assemble an icblk round it}
\inst{}{jsr}{systm}{get now time}
\lnie
\endln
\lnie
both types of profile merge here\endln
\lnie
\endln
\inst{bpf7b}{sti}{pfstm}{set start time of 1st func stmt}
\inst{}{mnz}{pffnc}{flag function entry}
\lnie
\endln
\lnie
no profiling merges here\endln
\lnie
\endln
\inst{bpf7c}{mov}{xr,-(xs)}{stack icblk ptr (or zero)}
\inst{}{mov}{r$cod,wa}{load old code block pointer}
\asmac{fi}
\inst{}{scp}{wb}{get code pointer}
\inst{}{sub}{wa,wb}{make code pointer into offset}
\inst{}{mov}{bpfpf,xl}{recall pfblk pointer}
\inst{}{mov}{bpfsv,-(xs)}{stack old value of function name}
\inst{}{mov}{wa,-(xs)}{stack code block pointer}
\inst{}{mov}{wb,-(xs)}{stack code offset}
\inst{}{mov}{flprt,-(xs)}{stack old flprt}
\inst{}{mov}{flptr,-(xs)}{stack old failure pointer}
\inst{}{mov}{xl,-(xs)}{stack pointer to pfblk}
\inst{}{zer}{-(xs)}{dummy zero entry for fail return}
\inst{}{chk}{}{check for stack overflow}
\inst{}{mov}{xs,flptr}{set new fail return value}
\inst{}{mov}{xs,flprt}{set new flprt}
\inst{}{mov}{kvtra,wa}{load trace value}
\inst{}{add}{kvftr,wa}{add ftrace value}
\inst{}{bnz}{wa,bpf09}{jump if tracing possible}
\inst{}{icv}{kvfnc}{else bump fnclevel}
\lnie
\endln
\lnie
here to actually jump to function\endln
\lnie
\endln
\inst{bpf08}{mov}{pfcod(xl),xr}{point to vrblk of entry label}
\inst{}{mov}{vrlbl(xr),xr}{point to target code}
\inst{}{beq}{xr,=stndl,bpf17}{test for undefined label}
\inst{}{bne}{(xr),=b$trt,bpf8a}{jump if not trapped}
\inst{}{mov}{trlbl(xr),xr}{else load ptr to real label code}
\inst{bpf8a}{bri}{(xr)}{off to execute function}
\lnie
\endln
\lnie
here if tracing is possible\endln
\lnie
\endln
\inst{bpf09}{mov}{pfctr(xl),xr}{load possible call trace trblk}
\inst{}{mov}{pfvbl(xl),xl}{load vrblk pointer for function}
\inst{}{mov}{*vrval,wa}{set name offset for variable}
\inst{}{bze}{kvtra,bpf10}{jump if trace mode is off}
\inst{}{bze}{xr,bpf10}{or if there is no call trace}
\lnie
\endln
\lnie
here if call traced\endln
\lnie
\endln
\inst{}{dcv}{kvtra}{decrement trace count}
\inst{}{bze}{trfnc(xr),bpf11}{jump if print trace}
\inst{}{jsr}{trxeq}{execute function type trace}
\vfill\break

\lnie
\endln
\lnie
pfblk (continued)\endln
\lnie
\endln
\lnie
here to test for ftrace trace\endln
\lnie
\endln
\inst{bpf10}{bze}{kvftr,bpf16}{jump if ftrace is off}
\inst{}{dcv}{kvftr}{else decrement ftrace}
\lnie
\endln
\lnie
here for print trace\endln
\lnie
\endln
\inst{bpf11}{jsr}{prtsn}{print statement number}
\inst{}{jsr}{prtnm}{print function name}
\inst{}{mov}{=ch$pp,wa}{load left paren}
\inst{}{jsr}{prtch}{print left paren}
\inst{}{mov}{num01(xs),xl}{recover pfblk pointer}
\inst{}{bze}{fargs(xl),bpf15}{skip if no arguments}
\inst{}{zer}{wb}{else set argument counter}
\inst{}{brn}{bpf13}{jump into loop}
\lnie
\endln
\lnie
loop to print argument values\endln
\lnie
\endln
\inst{bpf12}{mov}{=ch$cm,wa}{load comma}
\inst{}{jsr}{prtch}{print to separate from last arg}
\lnie
\endln
\lnie
merge here first time (no comma required)\endln
\lnie
\endln
\inst{bpf13}{mov}{wb,(xs)}{save arg ctr (over failoffs is ok)}
\inst{}{wtb}{wb}{convert to byte offset}
\inst{}{add}{wb,xl}{point to next argument pointer}
\inst{}{mov}{pfarg(xl),xr}{load next argument vrblk ptr}
\inst{}{sub}{wb,xl}{restore pfblk pointer}
\inst{}{mov}{vrval(xr),xr}{load next value}
\inst{}{jsr}{prtvl}{print argument value}
\vfill\break

\lnie
\endln
\lnie
here after dealing with one argument\endln
\lnie
\endln
\inst{}{mov}{(xs),wb}{restore argument counter}
\inst{}{icv}{wb}{increment argument counter}
\inst{}{blt}{wb,fargs(xl),bpf12}{loop if more to print}
\lnie
\endln
\lnie
merge here in no args case to print paren\endln
\lnie
\endln
\inst{bpf15}{mov}{=ch$rp,wa}{load right paren}
\inst{}{jsr}{prtch}{print to terminate output}
\inst{}{jsr}{prtnl}{terminate print line}
\lnie
\endln
\lnie
merge here to exit with test for fnclevel trace\endln
\lnie
\endln
\inst{bpf16}{icv}{kvfnc}{increment fnclevel}
\inst{}{mov}{r$fnc,xl}{load ptr to possible trblk}
\inst{}{jsr}{ktrex}{call keyword trace routine}
\lnie
\endln
\lnie
call function after trace tests complete\endln
\lnie
\endln
\inst{}{mov}{num01(xs),xl}{restore pfblk pointer}
\inst{}{brn}{bpf08}{jump back to execute function}
\lnie
\endln
\lnie
here if calling a function whose entry label is undefined\endln
\lnie
\endln
\inst{bpf17}{mov}{num02(xs),flptr}{reset so exfal can return to evalx}
\inst{}{erb}{286,function call}{to undefined entry label}
\ifmac{.cnra}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
rcblk\endln
\lnie
\endln
\lnie
the routine for an rcblk is executed from the generated\endln
\lnie
code to load a real value onto the stack.\endln
\lnie
\endln
\lnie
(xr)                  pointer to rcblk\endln
\lnie
\endln
\inst{b$rcl}{ent}{bl$rc}{entry point (rcblk)}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
scblk\endln
\lnie
\endln
\lnie
the routine for an scblk is executed from the generated\endln
\lnie
code to load a string value onto the stack.\endln
\lnie
\endln
\lnie
(xr)                  pointer to scblk\endln
\lnie
\endln
\inst{b$scl}{ent}{bl$sc}{entry point (scblk)}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
tbblk\endln
\lnie
\endln
\lnie
the routine for a tbblk is never executed\endln
\lnie
\endln
\inst{b$tbt}{ent}{bl$tb}{entry point (tbblk)}
\vfill\break

\lnie
\endln
\lnie
teblk\endln
\lnie
\endln
\lnie
the routine for a teblk is never executed\endln
\lnie
\endln
\inst{b$tet}{ent}{bl$te}{entry point (teblk)}
\vfill\break

\lnie
\endln
\lnie
vcblk\endln
\lnie
\endln
\lnie
the routine for a vcblk is never executed\endln
\lnie
\endln
\inst{b$vct}{ent}{bl$vc}{entry point (vcblk)}
\vfill\break

\lnie
\endln
\lnie
vrblk\endln
\lnie
\endln
\lnie
the vrblk routines are executed from the generated code.\endln
\lnie
there are six entries for vrblk covering various cases\endln
\lnie
\endln
\inst{b$vr$}{ent}{bl$$i}{mark start of vrblk entry points}
\lnie
\endln
\lnie
entry for vrget (trapped case). this routine is called\endln
\lnie
from the generated code to load the value of a variable.\endln
\lnie
this entry point is used if an access trace or input\endln
\lnie
association is currently active.\endln
\lnie
\endln
\lnie
(xr)                  pointer to vrget field of vrblk\endln
\lnie
\endln
\inst{b$vra}{ent}{bl$$i}{entry point}
\inst{}{mov}{xr,xl}{copy name base (vrget = 0)}
\inst{}{mov}{*vrval,wa}{set name offset}
\inst{}{jsr}{acess}{access value}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
vrblk (continued)\endln
\lnie
\endln
\lnie
entry for vrsto (error case. this routine is called from\endln
\lnie
the executed code for an attempt to modify the value\endln
\lnie
of a protected (pattern valued) natural variable.\endln
\lnie
\endln
\inst{b$vre}{ent}{}{entry point}
\inst{}{erb}{042,attempt to change}{value of protected variable}
\vfill\break

\lnie
\endln
\lnie
vrblk (continued)\endln
\lnie
\endln
\lnie
entry for vrtra (untrapped case). this routine is called\endln
\lnie
from the executed code to transfer to a label.\endln
\lnie
\endln
\lnie
(xr)                  pointer to vrtra field of vrblk\endln
\lnie
\endln
\inst{b$vrg}{ent}{}{entry point}
\inst{}{mov}{vrlbo(xr),xr}{load code pointer}
\inst{}{mov}{(xr),xl}{load entry address}
\inst{}{bri}{xl}{jump to routine for next code word}
\vfill\break

\lnie
\endln
\lnie
vrblk (continued)\endln
\lnie
\endln
\lnie
entry for vrget (untrapped case). this routine is called\endln
\lnie
from the generated code to load the value of a variable.\endln
\lnie
\endln
\lnie
(xr)                  points to vrget field of vrblk\endln
\lnie
\endln
\inst{b$vrl}{ent}{}{entry point}
\inst{}{mov}{vrval(xr),-(xs)}{load value onto stack (vrget = 0)}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
vrblk (continued)\endln
\lnie
\endln
\lnie
entry for vrsto (untrapped case). this routine is called\endln
\lnie
from the generated code to store the value of a variable.\endln
\lnie
\endln
\lnie
(xr)                  pointer to vrsto field of vrblk\endln
\lnie
\endln
\inst{b$vrs}{ent}{}{entry point}
\inst{}{mov}{(xs),vrvlo(xr)}{store value, leave on stack}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
vrblk (continued)\endln
\lnie
\endln
\lnie
vrtra (trapped case). this routine is called from the\endln
\lnie
generated code to transfer to a label when a label\endln
\lnie
trace is currently active.\endln
\lnie
\endln
\inst{b$vrt}{ent}{}{entry point}
\inst{}{sub}{*vrtra,xr}{point back to start of vrblk}
\inst{}{mov}{xr,xl}{copy vrblk pointer}
\inst{}{mov}{*vrval,wa}{set name offset}
\inst{}{mov}{vrlbl(xl),xr}{load pointer to trblk}
\inst{}{bze}{kvtra,bvrt2}{jump if trace is off}
\inst{}{dcv}{kvtra}{else decrement trace count}
\inst{}{bze}{trfnc(xr),bvrt1}{jump if print trace case}
\inst{}{jsr}{trxeq}{else execute full trace}
\inst{}{brn}{bvrt2}{merge to jump to label}
\lnie
\endln
\lnie
here for print trace -- print colon ( label name )\endln
\lnie
\endln
\inst{bvrt1}{jsr}{prtsn}{print statement number}
\inst{}{mov}{xl,xr}{copy vrblk pointer}
\inst{}{mov}{=ch$cl,wa}{colon}
\inst{}{jsr}{prtch}{print it}
\inst{}{mov}{=ch$pp,wa}{left paren}
\inst{}{jsr}{prtch}{print it}
\inst{}{jsr}{prtvn}{print label name}
\inst{}{mov}{=ch$rp,wa}{right paren}
\inst{}{jsr}{prtch}{print it}
\inst{}{jsr}{prtnl}{terminate line}
\inst{}{mov}{vrlbl(xl),xr}{point back to trblk}
\lnie
\endln
\lnie
merge here to jump to label\endln
\lnie
\endln
\inst{bvrt2}{mov}{trlbl(xr),xr}{load pointer to actual code}
\inst{}{bri}{(xr)}{execute statement at label}
\vfill\break

\lnie
\endln
\lnie
vrblk (continued)\endln
\lnie
\endln
\lnie
entry for vrsto (trapped case). this routine is called\endln
\lnie
from the generated code to store the value of a variable.\endln
\lnie
this entry is used when a value trace or output\endln
\lnie
association is currently active.\endln
\lnie
\endln
\lnie
(xr)                  pointer to vrsto field of vrblk\endln
\lnie
\endln
\inst{b$vrv}{ent}{}{entry point}
\inst{}{mov}{(xs),wb}{load value (leave copy on stack)}
\inst{}{sub}{*vrsto,xr}{point to vrblk}
\inst{}{mov}{xr,xl}{copy vrblk pointer}
\inst{}{mov}{*vrval,wa}{set offset}
\inst{}{jsr}{asign}{call assignment routine}
\inst{}{ppm}{exfal}{fail if assignment fails}
\inst{}{lcw}{xr}{else get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
xnblk\endln
\lnie
\endln
\lnie
the routine for an xnblk is never executed\endln
\lnie
\endln
\inst{b$xnt}{ent}{bl$xn}{entry point (xnblk)}
\vfill\break

\lnie
\endln
\lnie
xrblk\endln
\lnie
\endln
\lnie
the routine for an xrblk is never executed\endln
\lnie
\endln
\inst{b$xrt}{ent}{bl$xr}{entry point (xrblk)}
\lnie
\endln
\lnie
mark entry address past last block action routine\endln
\lnie
\endln
\inst{b$yyy}{ent}{bl$$i}{last block routine entry point}
\vfill\break
{\bf spitbol--\rm pattern matching routines}
\vskip1em
\lnie
\endln
\lnie
the following section consists of the pattern matching\endln
\lnie
routines. all pattern nodes contain a pointer (pcode)\endln
\lnie
to one of the routines in this section (p$xxx).\endln
\lnie
\endln
\lnie
note that this section follows the b$xxx routines to\endln
\lnie
enable a fast test for the pattern datatype.\endln
\lnie
\endln
\inst{p$aaa}{ent}{bl$$i}{entry to mark first pattern}
\lnie
\endln
\lnie
\endln
\lnie
the entry conditions to the match routine are as follows\endln
\lnie
(see o$pmn, o$pmv, o$pms and procedure match).\endln
\lnie
\endln
\lnie
stack contents.\endln
\lnie
\endln
\lnie
                      name base (o$pmn only)\endln
\lnie
                      name offset (o$pmn only)\endln
\lnie
                      type (0-o$pmn, 1-o$pmv, 2-o$pms)\endln
\lnie
pmhbs --------------- initial cursor (zero)\endln
\lnie
                      initial node pointer\endln
\lnie
xs ------------------ =ndabo (anchored), =nduna (unanch)\endln
\lnie
\endln
\lnie
register values.\endln
\lnie
\endln
\lnie
     (xs)             set as shown in stack diagram\endln
\lnie
     (xr)             pointer to initial pattern node\endln
\lnie
     (wb)             initial cursor (zero)\endln
\lnie
\endln
\lnie
global pattern values\endln
\lnie
\endln
\lnie
     r$pms            pointer to subject string scblk\endln
\lnie
     pmssl            length of subject string in chars\endln
\lnie
     pmdfl            dot flag, initially zero\endln
\lnie
     pmhbs            set as shown in stack diagram\endln
\lnie
\endln
\lnie
control is passed by branching through the pcode\endln
\lnie
field of the initial pattern node (bri (xr)).\endln
\vfill\break

\lnie
\endln
\lnie
description of algorithm\endln
\lnie
\endln
\lnie
a pattern structure is represented as a linked graph\endln
\lnie
of nodes with the following structure.\endln
\lnie
\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pcode               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                pthen               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                parm1               i\endln
\lnie
     +------------------------------------+\endln
\lnie
     i                parm2               i\endln
\lnie
     +------------------------------------+\endln
\lnie
\endln
\lnie
pcode is a pointer to the routine which will perform\endln
\lnie
the match of this particular node type.\endln
\lnie
\endln
\lnie
pthen is a pointer to the successor node. i.e. the node\endln
\lnie
to be matched if the attempt to match this node succeeds.\endln
\lnie
if this is the last node of the pattern pthen points\endln
\lnie
to the dummy node ndnth which initiates pattern exit.\endln
\lnie
\endln
\lnie
parm1, parm2 are parameters whose use varies with the\endln
\lnie
particular node. they are only present if required.\endln
\lnie
\endln
\lnie
alternatives are handled with the special alternative\endln
\lnie
node whose parameter points to the node to be matched\endln
\lnie
if there is a failure on the successor path.\endln
\lnie
\endln
\lnie
the following example illustrates the manner in which\endln
\lnie
the structure is built up. the pattern is\endln
\lnie
\endln
\lnie
(a / b / c) (d / e)   where / is alternation\endln
\lnie
\endln
\lnie
in the diagram, the node marked + represents an\endln
\lnie
alternative node and the dotted line from a + node\endln
\lnie
represents the parameter pointer to the alternative.\endln
\lnie
\endln
\lnie
+---+     +---+     +---+     +---+\endln
\lnie
i + i-----i a i-----i + i-----i d i-----\endln
\lnie
+---+     +---+  i  +---+     +---+\endln
\lnie
  .              i    .\endln
\lnie
  .              i    .\endln
\lnie
+---+     +---+  i  +---+\endln
\lnie
i + i-----i b i--i  i e i-----\endln
\lnie
+---+     +---+  i  +---+\endln
\lnie
  .              i\endln
\lnie
  .              i\endln
\lnie
+---+            i\endln
\lnie
i c i------------i\endln
\lnie
+---+\endln
\vfill\break

\lnie
\endln
\lnie
during the match, the registers are used as follows.\endln
\lnie
\endln
\lnie
(xr)                  points to the current node\endln
\lnie
(xl)                  scratch\endln
\lnie
(xs)                  main stack pointer\endln
\lnie
(wb)                  cursor (number of chars matched)\endln
\lnie
(wa,wc)               scratch\endln
\lnie
\endln
\lnie
to keep track of alternatives, the main stack is used as\endln
\lnie
a history stack and contains two word entries.\endln
\lnie
\endln
\lnie
word 1                saved cursor value\endln
\lnie
word 2                node to match on failure\endln
\lnie
\endln
\lnie
when a failure occurs, the most recent entry on this\endln
\lnie
stack is popped off to restore the cursor and point\endln
\lnie
to the node to be matched as an alternative. the entry\endln
\lnie
at the bottom of the stack points to the following\endln
\lnie
special nodes depending on the scan mode.\endln
\lnie
\endln
\lnie
anchored mode         the bottom entry points to the\endln
\lnie
                      special node ndabo which causes an\endln
\lnie
                      abort. the cursor value stored\endln
\lnie
                      with this entry is always zero.\endln
\lnie
\endln
\lnie
unanchored mode       the bottom entry points to the\endln
\lnie
                      special node nduna which moves the\endln
\lnie
                      anchor point and restarts the match\endln
\lnie
                      the cursor saved with this entry\endln
\lnie
                      is the number of characters which\endln
\lnie
                      lie before the initial anchor point\endln
\lnie
                      (i.e. the number of anchor moves).\endln
\lnie
                      this entry is three words long and\endln
\lnie
                      also contains the initial pattern.\endln
\lnie
\endln
\lnie
entries are made on this history stack by alternative\endln
\lnie
nodes and by some special compound patterns as described\endln
\lnie
later on. the following global locations are used during\endln
\lnie
pattern matching.\endln
\lnie
\endln
\lnie
r$pms                 pointer to subject string\endln
\lnie
pmssl                 length of subject string\endln
\lnie
pmdfl                 flag set non-zero for dot patterns\endln
\lnie
pmhbs                 base ptr for current history stack\endln
\lnie
\endln
\lnie
the following exit points are available to match routines\endln
\lnie
\endln
\lnie
succp                 success in matching current node\endln
\lnie
failp                 failure in matching current node\endln
\vfill\break

\lnie
\endln
\lnie
compound patterns\endln
\lnie
\endln
\lnie
some patterns have implicit alternatives and their\endln
\lnie
representation in the pattern structure consists of a\endln
\lnie
linked set of nodes as indicated by these diagrams.\endln
\lnie
\endln
\lnie
as before, the + represents an alternative node and\endln
\lnie
the dotted line from a + node is the parameter pointer\endln
\lnie
to the alternative pattern.\endln
\lnie
\endln
\lnie
arb\endln
\lnie
---\endln
\lnie
\endln
\lnie
     +---+            this node (p$arb) matches null\endln
\lnie
     i b i-----       and stacks cursor, successor ptr,\endln
\lnie
     +---+            cursor (copy) and a ptr to ndarc.\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
bal\endln
\lnie
---\endln
\lnie
\endln
\lnie
     +---+            the p$bal node scans a balanced\endln
\lnie
     i b i-----       string and then stacks a pointer\endln
\lnie
     +---+            to itself on the history stack.\endln
\vfill\break

\lnie
\endln
\lnie
compound pattern structures (continued)\endln
\lnie
\endln
\lnie
\endln
\lnie
arbno\endln
\lnie
-----\endln
\lnie
\endln
\lnie
     +---+            this alternative node matches null\endln
\lnie
+----i + i-----       the first time and stacks a pointer\endln
\lnie
i    +---+            to the argument pattern x.\endln
\lnie
i      .\endln
\lnie
i      .\endln
\lnie
i    +---+            node (p$aba) to stack cursor\endln
\lnie
i    i a i            and history stack base ptr.\endln
\lnie
i    +---+\endln
\lnie
i      i\endln
\lnie
i      i\endln
\lnie
i    +---+            this is the argument pattern. as\endln
\lnie
i    i x i            indicated, the successor of the\endln
\lnie
i    +---+            pattern is the p$abc node\endln
\lnie
i      i\endln
\lnie
i      i\endln
\lnie
i    +---+            this node (p$abc) pops pmhbs,\endln
\lnie
+----i c i            stacks old pmhbs and ptr to ndabd\endln
\lnie
     +---+            (unless optimization has occurred)\endln
\lnie
\endln
\lnie
structure and execution of this pattern resemble those of\endln
\lnie
recursive pattern matching and immediate assignment.\endln
\lnie
the alternative node at the head of the structure matches\endln
\lnie
null initially but on subsequent failure ensures attempt\endln
\lnie
to match the argument.  before the argument is matched\endln
\lnie
p$aba stacks the cursor, pmhbs and a ptr to p$abb.  if\endln
\lnie
the argument cant be matched , p$abb removes this special\endln
\lnie
stack entry and fails.\endln
\lnie
if argument is matched , p$abc restores the outer pmhbs\endln
\lnie
value (saved by p$aba) .  then if the argument has left\endln
\lnie
alternatives on stack it stacks the inner value of pmhbs\endln
\lnie
and a ptr to ndabd. if argument left nothing on the stack\endln
\lnie
it optimises by removing items stacked by p$aba.  finally\endln
\lnie
a check is made that argument matched more than the null\endln
\lnie
string (check is intended to prevent useless looping).\endln
\lnie
if so the successor is again the alternative node at the\endln
\lnie
head of the structure , ensuring a possible extra attempt\endln
\lnie
to match the arg if necessary.  if not , the successor to\endln
\lnie
alternative is taken so as to terminate the loop.  p$abd\endln
\lnie
restores inner pmhbs ptr and fails , thus trying to match\endln
\lnie
alternatives left by the arbno argument.\endln
\vfill\break

\lnie
\endln
\lnie
compound pattern structures (continued)\endln
\lnie
\endln
\lnie
breakx\endln
\lnie
------\endln
\lnie
\endln
\lnie
     +---+            this node is a break node for\endln
\lnie
+----i b i            the argument to breakx, identical\endln
\lnie
i    +---+            to an ordinary break node.\endln
\lnie
i      i\endln
\lnie
i      i\endln
\lnie
i    +---+            this alternative node stacks a\endln
\lnie
i    i + i-----       pointer to the breakx node to\endln
\lnie
i    +---+            allow for subsequent failure\endln
\lnie
i      .\endln
\lnie
i      .\endln
\lnie
i    +---+            this is the breakx node itself. it\endln
\lnie
+----i x i            matches one character and then\endln
\lnie
     +---+            proceeds back to the break node.\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
fence\endln
\lnie
-----\endln
\lnie
\endln
\lnie
     +---+            the fence node matches null and\endln
\lnie
     i f i-----       stacks a pointer to node ndabo to\endln
\lnie
     +---+            abort on a subsequent rematch\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
succeed\endln
\lnie
-------\endln
\lnie
\endln
\lnie
     +---+            the node for succeed matches null\endln
\lnie
     i s i-----       and stacks a pointer to itself\endln
\lnie
     +---+            to repeat the match on a failure.\endln
\vfill\break

\lnie
\endln
\lnie
compound patterns (continued)\endln
\lnie
\endln
\lnie
binary dot (pattern assignment)\endln
\lnie
-------------------------------\endln
\lnie
\endln
\lnie
     +---+            this node (p$paa) saves the current\endln
\lnie
     i a i            cursor and a pointer to the\endln
\lnie
     +---+            special node ndpab on the stack.\endln
\lnie
       i\endln
\lnie
       i\endln
\lnie
     +---+            this is the structure for the\endln
\lnie
     i x i            pattern left argument of the\endln
\lnie
     +---+            pattern assignment call.\endln
\lnie
       i\endln
\lnie
       i\endln
\lnie
     +---+            this node (p$pac) saves the cursor,\endln
\lnie
     i c i-----       a ptr to itself, the cursor (copy)\endln
\lnie
     +---+            and a ptr to ndpad on the stack.\endln
\lnie
\endln
\lnie
\endln
\lnie
the function of the match routine for ndpab (p$pab)\endln
\lnie
is simply to unstack itself and fail back onto the stack.\endln
\lnie
\endln
\lnie
the match routine for p$pac also sets the global pattern\endln
\lnie
flag pmdfl non-zero to indicate that pattern assignments\endln
\lnie
may have occured in the pattern match\endln
\lnie
\endln
\lnie
if pmdfl is set at the end of the match (see p$nth), the\endln
\lnie
history stack is scanned for matching ndpab-ndpad pairs\endln
\lnie
and the corresponding pattern assignments are executed.\endln
\lnie
\endln
\lnie
the function of the match routine for ndpad (p$pad)\endln
\lnie
is simply to remove its entry from the stack and fail.\endln
\lnie
this includes removing the special node pointer stored\endln
\lnie
in addition to the standard two entries on the stack.\endln
\vfill\break

\lnie
\endln
\lnie
compount pattern structures (continued)\endln
\lnie
\endln
\lnie
fence (function)\endln
\lnie
----------------\endln
\lnie
\endln
\lnie
     +---+            this node (p$fna) saves the\endln
\lnie
     i a i            current history stack and a\endln
\lnie
     +---+            pointer to ndfnb on the stack.\endln
\lnie
       i\endln
\lnie
       i\endln
\lnie
     +---+            this is the pattern structure\endln
\lnie
     i x i            given as the argument to the\endln
\lnie
     +---+            fence function.\endln
\lnie
       i\endln
\lnie
       i\endln
\lnie
     +---+            this node p$fnc restores the outer\endln
\lnie
     i c i            history stack ptr saved in p$fna,\endln
\lnie
     +---+            and stacks the inner stack base\endln
\lnie
                      ptr and a pointer to ndfnd on the\endln
\lnie
                      stack.\endln
\lnie
\endln
\lnie
ndfnb (f$fnb) simply is the failure exit for pattern\endln
\lnie
argument failure, and it pops itself and fails onto the\endln
\lnie
stack.\endln
\lnie
\endln
\lnie
the match routine p$fnc allows for an optimization when\endln
\lnie
the fence pattern leaves no alternatives.  in this case,\endln
\lnie
the ndfnb entry is popped, and the match continues.\endln
\lnie
\endln
\lnie
ndfnd (p$fnd) is entered when the pattern fails after\endln
\lnie
going through a non-optimized p$fnc, and it pops the\endln
\lnie
stack back past the innter stack base created by p$fna\endln
\vfill\break

\lnie
\endln
\lnie
compound patterns (continued)\endln
\lnie
\endln
\lnie
expression patterns (recursive pattern matches)\endln
\lnie
-----------------------------------------------\endln
\lnie
\endln
\lnie
initial entry for a pattern node is to the routine p$exa.\endln
\lnie
if the evaluated result of the expression is itself a\endln
\lnie
pattern, then the following steps are taken to arrange\endln
\lnie
for proper recursive processing.\endln
\lnie
\endln
\lnie
1)   a pointer to the current node (the p$exa node) is\endln
\lnie
     stored on the history stack with a dummy cursor.\endln
\lnie
\endln
\lnie
2)   a special history stack entry is made in which the\endln
\lnie
     node pointer points to ndexb, and the cursor value\endln
\lnie
     is the saved value of pmhbs on entry to this node.\endln
\lnie
     the match routine for ndexb (p$exb) restores pmhbs\endln
\lnie
     from this cursor entry, pops off the p$exa node\endln
\lnie
     pointer and fails.\endln
\lnie
\endln
\lnie
3)   the resulting history stack pointer is saved in\endln
\lnie
     pmhbs to establish a new level of history stack.\endln
\lnie
\endln
\lnie
after matching a pattern, the end of match routine gets\endln
\lnie
control (p$nth). this routine proceeds as follows.\endln
\lnie
\endln
\lnie
1)   load the current value of pmhbs and recognize the\endln
\lnie
     outer level case by the fact that the associated\endln
\lnie
     cursor in this case is the pattern match type code\endln
\lnie
     which is less than 3. terminate the match in this\endln
\lnie
     case and continue execution of the program.\endln
\lnie
\endln
\lnie
2)   otherwise make a special history stack entry in\endln
\lnie
     which the node pointer points to the special node\endln
\lnie
     ndexc and the cursor is the current value of pmhbs.\endln
\lnie
     the match routine for ndexc (p$exc) resets pmhbs to\endln
\lnie
     this (inner) value and and then fails.\endln
\lnie
\endln
\lnie
3)   using the history stack entry made on starting the\endln
\lnie
     expression (accessible with the current value of\endln
\lnie
     pmhbs), restore the p$exa node pointer and the old\endln
\lnie
     pmhbs setting. take the successor and continue.\endln
\lnie
\endln
\lnie
an optimization is possible if the expression pattern\endln
\lnie
makes no entries on the history stack. in this case,\endln
\lnie
instead of building the p$exc node in step 2, it is more\endln
\lnie
efficient to simply pop off the p$exb entry and its\endln
\lnie
associated node pointer. the effect is the same.\endln
\vfill\break

\lnie
\endln
\lnie
compound patterns (continued)\endln
\lnie
\endln
\lnie
binary dollar (immediate assignment)\endln
\lnie
------------------------------------\endln
\lnie
\endln
\lnie
     +---+            this node (p$ima) stacks the cursor\endln
\lnie
     i a i            pmhbs and a ptr to ndimb and resets\endln
\lnie
     +---+            the stack ptr pmhbs.\endln
\lnie
       i\endln
\lnie
       i\endln
\lnie
     +---+            this is the left structure for the\endln
\lnie
     i x i            pattern left argument of the\endln
\lnie
     +---+            immediate assignment call.\endln
\lnie
       i\endln
\lnie
       i\endln
\lnie
     +---+            this node (p$imc) performs the\endln
\lnie
     i c i-----       assignment, pops pmhbs and stacks\endln
\lnie
     +---+            the old pmhbs and a ptr to ndimd.\endln
\lnie
\endln
\lnie
\endln
\lnie
the structure and execution of this pattern are similar\endln
\lnie
to those of the recursive expression pattern matching.\endln
\lnie
\endln
\lnie
the match routine for ndimb (p$imb) restores the outer\endln
\lnie
level value of pmhbs, unstacks the saved cursor and fails\endln
\lnie
\endln
\lnie
the match routine p$imc uses the current value of pmhbs\endln
\lnie
to locate the p$imb entry. this entry is used to make\endln
\lnie
the assignment and restore the outer level value of\endln
\lnie
pmhbs. finally, the inner level value of pmhbs and a\endln
\lnie
pointer to the special node ndimd are stacked.\endln
\lnie
\endln
\lnie
the match routine for ndimd (p$imd) restores the inner\endln
\lnie
level value of pmhbs and fails back into the stack.\endln
\lnie
\endln
\lnie
an optimization occurs if the inner pattern makes no\endln
\lnie
entries on the history stack. in this case, p$imc pops\endln
\lnie
the p$imb entry instead of making a p$imd entry.\endln
\vfill\break

\lnie
\endln
\lnie
arbno\endln
\lnie
\endln
\lnie
see compound patterns section for stucture and\endln
\lnie
algorithm for matching this node type.\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$aba}{ent}{bl$p0}{p0blk}
\inst{}{mov}{wb,-(xs)}{stack cursor}
\inst{}{mov}{xr,-(xs)}{stack dummy node ptr}
\inst{}{mov}{pmhbs,-(xs)}{stack old stack base ptr}
\inst{}{mov}{=ndabb,-(xs)}{stack ptr to node ndabb}
\inst{}{mov}{xs,pmhbs}{store new stack base ptr}
\inst{}{brn}{succp}{succeed}
\vfill\break

\lnie
\endln
\lnie
arbno (remove p$aba special stack entry)\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$abb}{ent}{}{entry point}
\inst{}{mov}{wb,pmhbs}{restore history stack base ptr}
\inst{}{brn}{flpop}{fail and pop dummy node ptr}
\vfill\break

\lnie
\endln
\lnie
arbno (check if arg matched null string)\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$abc}{ent}{bl$p0}{p0blk}
\inst{}{mov}{pmhbs,xt}{keep p$abb stack base}
\inst{}{mov}{num03(xt),wa}{load initial cursor}
\inst{}{mov}{num01(xt),pmhbs}{restore outer stack base ptr}
\inst{}{beq}{xt,xs,pabc1}{jump if no history stack entries}
\inst{}{mov}{xt,-(xs)}{else save inner pmhbs entry}
\inst{}{mov}{=ndabd,-(xs)}{stack ptr to special node ndabd}
\inst{}{brn}{pabc2}{merge}
\lnie
\endln
\lnie
optimise case of no extra entries on stack from arbno arg\endln
\lnie
\endln
\inst{pabc1}{add}{*num04,xs}{remove ndabb entry and cursor}
\lnie
\endln
\lnie
merge to check for matching of null string\endln
\lnie
\endln
\inst{pabc2}{bne}{wa,wb,succp}{allow further attempt if non-null}
\inst{}{mov}{pthen(xr),xr}{bypass alternative node so as to ...}
\inst{}{brn}{succp}{... refuse further match attempts}
\vfill\break

\lnie
\endln
\lnie
arbno (try for alternatives in arbno argument)\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$abd}{ent}{}{entry point}
\inst{}{mov}{wb,pmhbs}{restore inner stack base ptr}
\inst{}{brn}{failp}{and fail}
\vfill\break

\lnie
\endln
\lnie
abort\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$abo}{ent}{bl$p0}{p0blk}
\inst{}{brn}{exfal}{signal statement failure}
\vfill\break

\lnie
\endln
\lnie
alternation\endln
\lnie
\endln
\lnie
parm1                 alternative node\endln
\lnie
\endln
\inst{p$alt}{ent}{bl$p1}{p1blk}
\inst{}{mov}{wb,-(xs)}{stack cursor}
\inst{}{mov}{parm1(xr),-(xs)}{stack pointer to alternative}
\inst{}{chk}{}{check for stack overflow}
\inst{}{brn}{succp}{if all ok, then succeed}
\vfill\break

\lnie
\endln
\lnie
any (one character argument) (1-char string also)\endln
\lnie
\endln
\lnie
parm1                 character argument\endln
\lnie
\endln
\inst{p$ans}{ent}{bl$p1}{p1blk}
\inst{}{beq}{wb,pmssl,failp}{fail if no chars left}
\inst{}{mov}{r$pms,xl}{else point to subject string}
\inst{}{plc}{xl,wb}{point to current character}
\inst{}{lch}{wa,(xl)}{load current character}
\inst{}{bne}{wa,parm1(xr),failp}{fail if no match}
\inst{}{icv}{wb}{else bump cursor}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
any (multi-character argument case)\endln
\lnie
\endln
\lnie
parm1                 pointer to ctblk\endln
\lnie
parm2                 bit mask to select bit in ctblk\endln
\lnie
\endln
\inst{p$any}{ent}{bl$p2}{p2blk}
\lnie
\endln
\lnie
expression argument case merges here\endln
\lnie
\endln
\inst{pany1}{beq}{wb,pmssl,failp}{fail if no characters left}
\inst{}{mov}{r$pms,xl}{else point to subject string}
\inst{}{plc}{xl,wb}{get char ptr to current character}
\inst{}{lch}{wa,(xl)}{load current character}
\inst{}{mov}{parm1(xr),xl}{point to ctblk}
\inst{}{wtb}{wa}{change to byte offset}
\inst{}{add}{wa,xl}{point to entry in ctblk}
\inst{}{mov}{ctchs(xl),wa}{load word from ctblk}
\inst{}{anb}{parm2(xr),wa}{and with selected bit}
\inst{}{zrb}{wa,failp}{fail if no match}
\inst{}{icv}{wb}{else bump cursor}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
any (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$ayd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evals}{evaluate string argument}
\inst{}{err}{043,any evaluated}{argument is not a string}
\inst{}{ppm}{failp}{fail if evaluation failure}
\inst{}{ppm}{pany1}{merge multi-char case if ok}
\vfill\break

\lnie
\endln
\lnie
p$arb                 initial arb match\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\lnie
the p$arb node is part of a compound pattern structure\endln
\lnie
for an arb pattern (see description of compound patterns)\endln
\lnie
\endln
\inst{p$arb}{ent}{bl$p0}{p0blk}
\inst{}{mov}{pthen(xr),xr}{load successor pointer}
\inst{}{mov}{wb,-(xs)}{stack dummy cursor}
\inst{}{mov}{xr,-(xs)}{stack successor pointer}
\inst{}{mov}{wb,-(xs)}{stack cursor}
\inst{}{mov}{=ndarc,-(xs)}{stack ptr to special node ndarc}
\inst{}{bri}{(xr)}{execute next node matching null}
\vfill\break

\lnie
\endln
\lnie
p$arc                 extend arb match\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$arc}{ent}{}{entry point}
\inst{}{beq}{wb,pmssl,flpop}{fail and pop stack to successor}
\inst{}{icv}{wb}{else bump cursor}
\inst{}{mov}{wb,-(xs)}{stack updated cursor}
\inst{}{mov}{xr,-(xs)}{restack pointer to ndarc node}
\inst{}{mov}{num02(xs),xr}{load successor pointer}
\inst{}{bri}{(xr)}{off to reexecute successor node}
\vfill\break

\lnie
\endln
\lnie
bal\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\lnie
the p$bal node is part of the compound structure built\endln
\lnie
for bal (see section on compound patterns).\endln
\lnie
\endln
\inst{p$bal}{ent}{bl$p0}{p0blk}
\inst{}{zer}{wc}{zero parentheses level counter}
\inst{}{mov}{r$pms,xl}{point to subject string}
\inst{}{plc}{xl,wb}{point to current character}
\inst{}{brn}{pbal2}{jump into scan loop}
\lnie
\endln
\lnie
loop to scan out characters\endln
\lnie
\endln
\inst{pbal1}{lch}{wa,(xl)+}{load next character, bump pointer}
\inst{}{icv}{wb}{push cursor for character}
\inst{}{beq}{wa,=ch$pp,pbal3}{jump if left paren}
\inst{}{beq}{wa,=ch$rp,pbal4}{jump if right paren}
\inst{}{bze}{wc,pbal5}{else succeed if at outer level}
\lnie
\endln
\lnie
here after processing one character\endln
\lnie
\endln
\inst{pbal2}{bne}{wb,pmssl,pbal1}{loop back unless end of string}
\inst{}{brn}{failp}{in which case, fail}
\lnie
\endln
\lnie
here on left paren\endln
\lnie
\endln
\inst{pbal3}{icv}{wc}{bump paren level}
\inst{}{brn}{pbal2}{loop back to check end of string}
\lnie
\endln
\lnie
here for right paren\endln
\lnie
\endln
\inst{pbal4}{bze}{wc,failp}{fail if no matching left paren}
\inst{}{dcv}{wc}{else decrement level counter}
\inst{}{bnz}{wc,pbal2}{loop back if not at outer level}
\lnie
\endln
\lnie
here after successfully scanning a balanced string\endln
\lnie
\endln
\inst{pbal5}{mov}{wb,-(xs)}{stack cursor}
\inst{}{mov}{xr,-(xs)}{stack ptr to bal node for extend}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
break (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$bkd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evals}{evaluate string expression}
\inst{}{err}{044,break evaluated}{argument is not a string}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{pbrk1}{merge with multi-char case if ok}
\vfill\break

\lnie
\endln
\lnie
break (one character argument)\endln
\lnie
\endln
\lnie
parm1                 character argument\endln
\lnie
\endln
\inst{p$bks}{ent}{bl$p1}{p1blk}
\inst{}{mov}{pmssl,wc}{get subject string length}
\inst{}{sub}{wb,wc}{get number of characters left}
\inst{}{bze}{wc,failp}{fail if no characters left}
\inst{}{lct}{wc,wc}{set counter for chars left}
\inst{}{mov}{r$pms,xl}{point to subject string}
\inst{}{plc}{xl,wb}{point to current character}
\lnie
\endln
\lnie
loop to scan till break character found\endln
\lnie
\endln
\inst{pbks1}{lch}{wa,(xl)+}{load next char, bump pointer}
\inst{}{beq}{wa,parm1(xr),succp}{succeed if break character found}
\inst{}{icv}{wb}{else push cursor}
\inst{}{bct}{wc,pbks1}{loop back if more to go}
\inst{}{brn}{failp}{fail if end of string, no break chr}
\vfill\break

\lnie
\endln
\lnie
break (multi-character argument)\endln
\lnie
\endln
\lnie
parm1                 pointer to ctblk\endln
\lnie
parm2                 bit mask to select bit column\endln
\lnie
\endln
\inst{p$brk}{ent}{bl$p2}{p2blk}
\lnie
\endln
\lnie
expression argument merges here\endln
\lnie
\endln
\inst{pbrk1}{mov}{pmssl,wc}{load subject string length}
\inst{}{sub}{wb,wc}{get number of characters left}
\inst{}{bze}{wc,failp}{fail if no characters left}
\inst{}{lct}{wc,wc}{set counter for characters left}
\inst{}{mov}{r$pms,xl}{else point to subject string}
\inst{}{plc}{xl,wb}{point to current character}
\inst{}{mov}{xr,psave}{save node pointer}
\lnie
\endln
\lnie
loop to search for break character\endln
\lnie
\endln
\inst{pbrk2}{lch}{wa,(xl)+}{load next char, bump pointer}
\inst{}{mov}{parm1(xr),xr}{load pointer to ctblk}
\inst{}{wtb}{wa}{convert to byte offset}
\inst{}{add}{wa,xr}{point to ctblk entry}
\inst{}{mov}{ctchs(xr),wa}{load ctblk word}
\inst{}{mov}{psave,xr}{restore node pointer}
\inst{}{anb}{parm2(xr),wa}{and with selected bit}
\inst{}{nzb}{wa,succp}{succeed if break character found}
\inst{}{icv}{wb}{else push cursor}
\inst{}{bct}{wc,pbrk2}{loop back unless end of string}
\inst{}{brn}{failp}{fail if end of string, no break chr}
\vfill\break

\lnie
\endln
\lnie
breakx (extension)\endln
\lnie
\endln
\lnie
this is the entry which causes an extension of a breakx\endln
\lnie
match when failure occurs. see section on compound\endln
\lnie
patterns for full details of breakx matching.\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$bkx}{ent}{bl$p0}{p0blk}
\inst{}{icv}{wb}{step cursor past previous break chr}
\inst{}{brn}{succp}{succeed to rematch break}
\vfill\break

\lnie
\endln
\lnie
breakx (expression argument)\endln
\lnie
\endln
\lnie
see section on compound patterns for full structure of\endln
\lnie
breakx pattern. the actual character matching uses a\endln
\lnie
break node. however, the entry for the expression\endln
\lnie
argument case is separated to get proper error messages.\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$bxd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evals}{evaluate string argument}
\inst{}{err}{045,breakx evaluated}{argument is not a string}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{pbrk1}{merge with break if all ok}
\vfill\break

\lnie
\endln
\lnie
cursor assignment\endln
\lnie
\endln
\lnie
parm1                 name base\endln
\lnie
parm2                 name offset\endln
\lnie
\endln
\inst{p$cas}{ent}{bl$p2}{p2blk}
\inst{}{mov}{xr,-(xs)}{save node pointer}
\inst{}{mov}{wb,-(xs)}{save cursor}
\inst{}{mov}{parm1(xr),xl}{load name base}
\inst{}{mti}{wb}{load cursor as integer}
\inst{}{mov}{parm2(xr),wb}{load name offset}
\inst{}{jsr}{icbld}{get icblk for cursor value}
\inst{}{mov}{wb,wa}{move name offset}
\inst{}{mov}{xr,wb}{move value to assign}
\inst{}{jsr}{asinp}{perform assignment}
\inst{}{ppm}{flpop}{fail on assignment failure}
\inst{}{mov}{(xs)+,wb}{else restore cursor}
\inst{}{mov}{(xs)+,xr}{restore node pointer}
\inst{}{brn}{succp}{and succeed matching null}
\vfill\break

\lnie
\endln
\lnie
expression node (p$exa, initial entry)\endln
\lnie
\endln
\lnie
see compound patterns description for the structure and\endln
\lnie
algorithms for handling expression nodes.\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$exa}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evalp}{evaluate expression}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{blo}{wa,=p$aaa,pexa1}{jump if result is not a pattern}
\lnie
\endln
\lnie
here if result of expression is a pattern\endln
\lnie
\endln
\inst{}{mov}{wb,-(xs)}{stack dummy cursor}
\inst{}{mov}{xr,-(xs)}{stack ptr to p$exa node}
\inst{}{mov}{pmhbs,-(xs)}{stack history stack base ptr}
\inst{}{mov}{=ndexb,-(xs)}{stack ptr to special node ndexb}
\inst{}{mov}{xs,pmhbs}{store new stack base pointer}
\inst{}{mov}{xl,xr}{copy node pointer}
\inst{}{bri}{(xr)}{match first node in expression pat}
\lnie
\endln
\lnie
here if result of expression is not a pattern\endln
\lnie
\endln
\inst{pexa1}{beq}{wa,=b$scl,pexa2}{jump if it is already a string}
\inst{}{mov}{xl,-(xs)}{else stack result}
\inst{}{mov}{xr,xl}{save node pointer}
\inst{}{jsr}{gtstg}{convert result to string}
\inst{}{err}{046,expression does}{not evaluate to pattern}
\inst{}{mov}{xr,wc}{copy string pointer}
\inst{}{mov}{xl,xr}{restore node pointer}
\inst{}{mov}{wc,xl}{copy string pointer again}
\lnie
\endln
\lnie
merge here with string pointer in xl\endln
\lnie
\endln
\inst{pexa2}{bze}{sclen(xl),succp}{just succeed if null string}
\inst{}{brn}{pstr1}{else merge with string circuit}
\vfill\break

\lnie
\endln
\lnie
expression node (p$exb, remove ndexb entry)\endln
\lnie
\endln
\lnie
see compound patterns description for the structure and\endln
\lnie
algorithms for handling expression nodes.\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$exb}{ent}{}{entry point}
\inst{}{mov}{wb,pmhbs}{restore outer level stack pointer}
\inst{}{brn}{flpop}{fail and pop p$exa node ptr}
\vfill\break

\lnie
\endln
\lnie
expression node (p$exc, remove ndexc entry)\endln
\lnie
\endln
\lnie
see compound patterns description for the structure and\endln
\lnie
algorithms for handling expression nodes.\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$exc}{ent}{}{entry point}
\inst{}{mov}{wb,pmhbs}{restore inner stack base pointer}
\inst{}{brn}{failp}{and fail into expr pattern alternvs}
\vfill\break

\lnie
\endln
\lnie
fail\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$fal}{ent}{bl$p0}{p0blk}
\inst{}{brn}{failp}{just signal failure}
\vfill\break

\lnie
\endln
\lnie
fence\endln
\lnie
\endln
\lnie
see compound patterns section for the structure and\endln
\lnie
algorithm for matching this node type.\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$fen}{ent}{bl$p0}{p0blk}
\inst{}{mov}{wb,-(xs)}{stack dummy cursor}
\inst{}{mov}{=ndabo,-(xs)}{stack ptr to abort node}
\inst{}{brn}{succp}{and succeed matching null}
\vfill\break

\lnie
\endln
\lnie
fence (function)\endln
\lnie
\endln
\lnie
see compound patterns comments at start of this section\endln
\lnie
for details of scheme\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$fna}{ent}{bl$p0}{p0blk}
\inst{}{mov}{pmhbs,-(xs)}{stack current history stack base}
\inst{}{mov}{=ndfnb,-(xs)}{stack indir ptr to p$fnb (failure)}
\inst{}{mov}{xs,pmhbs}{begin new history stack}
\inst{}{brn}{succp}{succeed}
\vfill\break

\lnie
\endln
\lnie
fence (function) (reset history stack and fail)\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$fnb}{ent}{bl$p0}{p0blk}
\inst{}{mov}{wb,pmhbs}{restore outer pmhbs stack base}
\inst{}{brn}{failp}{...and fail}
\vfill\break

\lnie
\endln
\lnie
fence (function) (make fence trap entry on stack)\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$fnc}{ent}{bl$p0}{p0blk}
\inst{}{mov}{pmhbs,xt}{get inner stack base ptr}
\inst{}{mov}{num01(xt),pmhbs}{restore outer stack base}
\inst{}{beq}{xt,xs,pfnc1}{optimize if no alternatives}
\inst{}{mov}{xt,-(xs)}{else stack inner stack base}
\inst{}{mov}{=ndfnd,-(xs)}{stack ptr to ndfnd}
\inst{}{brn}{succp}{succeed}
\lnie
\endln
\lnie
here when fence function left nothing on the stack\endln
\lnie
\endln
\inst{pfnc1}{add}{*num02,xs}{pop off p$fnb entry}
\inst{}{brn}{succp}{succeed}
\vfill\break

\lnie
\endln
\lnie
fence (function) (skip past alternatives on failure)\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$fnd}{ent}{bl$p0}{p0blk}
\inst{}{mov}{wb,xs}{pop stack to fence() history base}
\inst{}{brn}{flpop}{pop base entry and fail}
\vfill\break

\lnie
\endln
\lnie
immediate assignment (initial entry, save current cursor)\endln
\lnie
\endln
\lnie
see compound patterns description for details of the\endln
\lnie
structure and algorithm for matching this node type.\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$ima}{ent}{bl$p0}{p0blk}
\inst{}{mov}{wb,-(xs)}{stack cursor}
\inst{}{mov}{xr,-(xs)}{stack dummy node pointer}
\inst{}{mov}{pmhbs,-(xs)}{stack old stack base pointer}
\inst{}{mov}{=ndimb,-(xs)}{stack ptr to special node ndimb}
\inst{}{mov}{xs,pmhbs}{store new stack base pointer}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
immediate assignment (remove cursor mark entry)\endln
\lnie
\endln
\lnie
see compound patterns description for details of the\endln
\lnie
structure and algorithms for matching this node type.\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$imb}{ent}{}{entry point}
\inst{}{mov}{wb,pmhbs}{restore history stack base ptr}
\inst{}{brn}{flpop}{fail and pop dummy node ptr}
\vfill\break

\lnie
\endln
\lnie
immediate assignment (perform actual assignment)\endln
\lnie
\endln
\lnie
see compound patterns description for details of the\endln
\lnie
structure and algorithms for matching this node type.\endln
\lnie
\endln
\lnie
parm1                 name base of variable\endln
\lnie
parm2                 name offset of variable\endln
\lnie
\endln
\inst{p$imc}{ent}{bl$p2}{p2blk}
\inst{}{mov}{pmhbs,xt}{load pointer to p$imb entry}
\inst{}{mov}{wb,wa}{copy final cursor}
\inst{}{mov}{num03(xt),wb}{load initial cursor}
\inst{}{mov}{num01(xt),pmhbs}{restore outer stack base pointer}
\inst{}{beq}{xt,xs,pimc1}{jump if no history stack entries}
\inst{}{mov}{xt,-(xs)}{else save inner pmhbs pointer}
\inst{}{mov}{=ndimd,-(xs)}{and a ptr to special node ndimd}
\inst{}{brn}{pimc2}{merge}
\lnie
\endln
\lnie
here if no entries made on history stack\endln
\lnie
\endln
\inst{pimc1}{add}{*num04,xs}{remove ndimb entry and cursor}
\lnie
\endln
\lnie
merge here to perform assignment\endln
\lnie
\endln
\inst{pimc2}{mov}{wa,-(xs)}{save current (final) cursor}
\inst{}{mov}{xr,-(xs)}{save current node pointer}
\inst{}{mov}{r$pms,xl}{point to subject string}
\inst{}{sub}{wb,wa}{compute substring length}
\inst{}{jsr}{sbstr}{build substring}
\inst{}{mov}{xr,wb}{move result}
\inst{}{mov}{(xs),xr}{reload node pointer}
\inst{}{mov}{parm1(xr),xl}{load name base}
\inst{}{mov}{parm2(xr),wa}{load name offset}
\inst{}{jsr}{asinp}{perform assignment}
\inst{}{ppm}{flpop}{fail if assignment fails}
\inst{}{mov}{(xs)+,xr}{else restore node pointer}
\inst{}{mov}{(xs)+,wb}{restore cursor}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
immediate assignment (remove ndimd entry on failure)\endln
\lnie
\endln
\lnie
see compound patterns description for details of the\endln
\lnie
structure and algorithms for matching this node type.\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$imd}{ent}{}{entry point}
\inst{}{mov}{wb,pmhbs}{restore inner stack base pointer}
\inst{}{brn}{failp}{and fail}
\vfill\break

\lnie
\endln
\lnie
len (integer argument)\endln
\lnie
\endln
\lnie
parm1                 integer argument\endln
\lnie
\endln
\inst{p$len}{ent}{bl$p1}{p1blk}
\lnie
\endln
\lnie
expression argument case merges here\endln
\lnie
\endln
\inst{plen1}{add}{parm1(xr),wb}{push cursor indicated amount}
\inst{}{ble}{wb,pmssl,succp}{succeed if not off end}
\inst{}{brn}{failp}{else fail}
\vfill\break

\lnie
\endln
\lnie
len (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$lnd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evali}{evaluate integer argument}
\inst{}{err}{047,len evaluated}{argument is not integer}
\inst{}{err}{048,len evaluated}{argument is negative or too large}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{plen1}{merge with normal circuit if ok}
\vfill\break

\lnie
\endln
\lnie
notany (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$nad}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evals}{evaluate string argument}
\inst{}{err}{049,notany evaluated}{argument is not a string}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{pnay1}{merge with multi-char case if ok}
\vfill\break

\lnie
\endln
\lnie
notany (one character argument)\endln
\lnie
\endln
\lnie
parm1                 character argument\endln
\lnie
\endln
\inst{p$nas}{ent}{bl$p1}{entry point}
\inst{}{beq}{wb,pmssl,failp}{fail if no chars left}
\inst{}{mov}{r$pms,xl}{else point to subject string}
\inst{}{plc}{xl,wb}{point to current character in strin}
\inst{}{lch}{wa,(xl)}{load current character}
\inst{}{beq}{wa,parm1(xr),failp}{fail if match}
\inst{}{icv}{wb}{else bump cursor}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
notany (multi-character string argument)\endln
\lnie
\endln
\lnie
parm1                 pointer to ctblk\endln
\lnie
parm2                 bit mask to select bit column\endln
\lnie
\endln
\inst{p$nay}{ent}{bl$p2}{p2blk}
\lnie
\endln
\lnie
expression argument case merges here\endln
\lnie
\endln
\inst{pnay1}{beq}{wb,pmssl,failp}{fail if no characters left}
\inst{}{mov}{r$pms,xl}{else point to subject string}
\inst{}{plc}{xl,wb}{point to current character}
\inst{}{lch}{wa,(xl)}{load current character}
\inst{}{wtb}{wa}{convert to byte offset}
\inst{}{mov}{parm1(xr),xl}{load pointer to ctblk}
\inst{}{add}{wa,xl}{point to entry in ctblk}
\inst{}{mov}{ctchs(xl),wa}{load entry from ctblk}
\inst{}{anb}{parm2(xr),wa}{and with selected bit}
\inst{}{nzb}{wa,failp}{fail if character is matched}
\inst{}{icv}{wb}{else bump cursor}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
end of pattern match\endln
\lnie
\endln
\lnie
this routine is entered on successful completion.\endln
\lnie
see description of expression patterns in compound\endln
\lnie
pattern section for handling of recursion in matching.\endln
\lnie
\endln
\lnie
this pattern also results from an attempt to convert the\endln
\lnie
null string to a pattern via convert()\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$nth}{ent}{bl$p0}{p0blk (dummy)}
\inst{}{mov}{pmhbs,xt}{load pointer to base of stack}
\inst{}{mov}{num01(xt),wa}{load saved pmhbs (or pattern type)}
\inst{}{ble}{wa,=num02,pnth2}{jump if outer level (pattern type)}
\lnie
\endln
\lnie
here we are at the end of matching an expression pattern\endln
\lnie
\endln
\inst{}{mov}{wa,pmhbs}{restore outer stack base pointer}
\inst{}{mov}{num02(xt),xr}{restore pointer to p$exa node}
\inst{}{beq}{xt,xs,pnth1}{jump if no history stack entries}
\inst{}{mov}{xt,-(xs)}{else stack inner stack base ptr}
\inst{}{mov}{=ndexc,-(xs)}{stack ptr to special node ndexc}
\inst{}{brn}{succp}{and succeed}
\lnie
\endln
\lnie
here if no history stack entries during pattern\endln
\lnie
\endln
\inst{pnth1}{add}{*num04,xs}{remove p$exb entry and node ptr}
\inst{}{brn}{succp}{and succeed}
\lnie
\endln
\lnie
here if end of match at outer level\endln
\lnie
\endln
\inst{pnth2}{mov}{wb,pmssl}{save final cursor in safe place}
\inst{}{bze}{pmdfl,pnth6}{jump if no pattern assignments}
\vfill\break

\lnie
\endln
\lnie
end of pattern match (continued)\endln
\lnie
\endln
\lnie
now we must perform pattern assignments. this is done by\endln
\lnie
scanning the history stack for matching ndpab-ndpad pairs\endln
\lnie
\endln
\inst{pnth3}{dca}{xt}{point past cursor entry}
\inst{}{mov}{-(xt),wa}{load node pointer}
\inst{}{beq}{wa,=ndpad,pnth4}{jump if ndpad entry}
\inst{}{bne}{wa,=ndpab,pnth5}{jump if not ndpab entry}
\lnie
\endln
\lnie
here for ndpab entry, stack initial cursor\endln
\lnie
note that there must be more entries on the stack.\endln
\lnie
\endln
\inst{}{mov}{num01(xt),-(xs)}{stack initial cursor}
\inst{}{chk}{}{check for stack overflow}
\inst{}{brn}{pnth3}{loop back if ok}
\lnie
\endln
\lnie
here for ndpad entry. the starting cursor from the\endln
\lnie
matching ndpad entry is now the top stack entry.\endln
\lnie
\endln
\inst{pnth4}{mov}{num01(xt),wa}{load final cursor}
\inst{}{mov}{(xs),wb}{load initial cursor from stack}
\inst{}{mov}{xt,(xs)}{save history stack scan ptr}
\inst{}{sub}{wb,wa}{compute length of string}
\lnie
\endln
\lnie
build substring and perform assignment\endln
\lnie
\endln
\inst{}{mov}{r$pms,xl}{point to subject string}
\inst{}{jsr}{sbstr}{construct substring}
\inst{}{mov}{xr,wb}{copy substring pointer}
\inst{}{mov}{(xs),xt}{reload history stack scan ptr}
\inst{}{mov}{num02(xt),xl}{load pointer to p$pac node with nam}
\inst{}{mov}{parm2(xl),wa}{load name offset}
\inst{}{mov}{parm1(xl),xl}{load name base}
\inst{}{jsr}{asinp}{perform assignment}
\inst{}{ppm}{exfal}{match fails if name eval fails}
\inst{}{mov}{(xs)+,xt}{else restore history stack ptr}
\vfill\break

\lnie
\endln
\lnie
end of pattern match (continued)\endln
\lnie
\endln
\lnie
here check for end of entries\endln
\lnie
\endln
\inst{pnth5}{bne}{xt,xs,pnth3}{loop if more entries to scan}
\lnie
\endln
\lnie
here after dealing with pattern assignments\endln
\lnie
\endln
\inst{pnth6}{mov}{pmhbs,xs}{wipe out history stack}
\inst{}{mov}{(xs)+,wb}{load initial cursor}
\inst{}{mov}{(xs)+,wc}{load match type code}
\inst{}{mov}{pmssl,wa}{load final cursor value}
\inst{}{mov}{r$pms,xl}{point to subject string}
\inst{}{zer}{r$pms}{clear subject string ptr for gbcol}
\inst{}{bze}{wc,pnth7}{jump if call by name}
\inst{}{beq}{wc,=num02,pnth9}{exit if statement level call}
\lnie
\endln
\lnie
here we have a call by value, build substring\endln
\lnie
\endln
\inst{}{sub}{wb,wa}{compute length of string}
\inst{}{jsr}{sbstr}{build substring}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
here for call by name, make stack entries for o$rpl\endln
\lnie
\endln
\inst{pnth7}{mov}{wb,-(xs)}{stack initial cursor}
\inst{}{mov}{wa,-(xs)}{stack final cursor}
\ifmac{.cnbf}
\asmac{else}
\inst{}{bze}{r$pmb,pnth8}{skip if subject not buffer}
\inst{}{mov}{r$pmb,xl}{else get ptr to bcblk instead}
\asmac{fi}
\lnie
\endln
\lnie
here with xl pointing to scblk or bcblk\endln
\lnie
\endln
\inst{pnth8}{mov}{xl,-(xs)}{stack subject pointer}
\lnie
\endln
\lnie
here to obey next code word\endln
\lnie
\endln
\inst{pnth9}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
pos (integer argument)\endln
\lnie
\endln
\lnie
parm1                 integer argument\endln
\lnie
\endln
\inst{p$pos}{ent}{bl$p1}{p1blk}
\lnie
\endln
\lnie
optimize pos if it is the first pattern element,\endln
\lnie
unanchored mode, cursor is zero and pos argument\endln
\lnie
is not beyond end of string.  force cursor position\endln
\lnie
and number of unanchored moves.\endln
\lnie
\endln
\lnie
this optimization is performed invisible provided\endln
\lnie
the argument is either a simple integer or an\endln
\lnie
expression that is an untraced variable (that is,\endln
\lnie
it has no side effects that would be lost by short-\endln
\lnie
circuiting the normal logic of failing and moving the\endln
\lnie
unanchored starting point.)\endln
\lnie
\endln
\lnie
pos (integer argument)\endln
\lnie
\endln
\lnie
parm1                 integer argument\endln
\lnie
\endln
\inst{}{beq}{wb,parm1(xr),succp}{succeed if at right location}
\inst{}{bnz}{wb,failp}{don't look further if cursor not 0}
\inst{}{mov}{pmhbs,xt}{get history stack base ptr}
\inst{}{bne}{xr,-(xt),failp}{fail if pos is not first node}
\lnie
\endln
\lnie
expression argument circuit merges here\endln
\lnie
\endln
\inst{ppos2}{bne}{-(xt),=nduna,failp}{ fail if not unanchored mode}
\inst{}{mov}{parm1(xr),wb}{get desired cursor position}
\inst{}{bgt}{wb,pmssl,exfal}{abort if off end}
\inst{}{mov}{wb,num02(xt)}{fake number of unanchored moves}
\inst{}{brn}{succp}{continue match with adjusted cursor}
\vfill\break

\lnie
\endln
\lnie
pos (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$psd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evali}{evaluate integer argument}
\inst{}{err}{050,pos evaluated}{argument is not integer}
\inst{}{err}{051,pos evaluated}{argument is negative or too large}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{ppos1}{process expression case}
\lnie
\endln
\inst{ppos1}{beq}{wb,parm1(xr),succp}{succeed if at right location}
\inst{}{bnz}{wb,failp}{don't look further if cursor not 0}
\inst{}{bnz}{evlif,failp}{fail if complex argument}
\inst{}{mov}{pmhbs,xt}{get history stack base ptr}
\inst{}{mov}{evlio,wa}{get original node ptr}
\inst{}{bne}{wa,-(xt),failp}{fail if pos is not first node}
\inst{}{brn}{ppos2}{merge with integer argument code}
\vfill\break

\lnie
\endln
\lnie
pattern assignment (initial entry, save cursor)\endln
\lnie
\endln
\lnie
see compound patterns description for the structure and\endln
\lnie
algorithms for matching this node type.\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$paa}{ent}{bl$p0}{p0blk}
\inst{}{mov}{wb,-(xs)}{stack initial cursor}
\inst{}{mov}{=ndpab,-(xs)}{stack ptr to ndpab special node}
\inst{}{brn}{succp}{and succeed matching null}
\vfill\break

\lnie
\endln
\lnie
pattern assignment (remove saved cursor)\endln
\lnie
\endln
\lnie
see compound patterns description for the structure and\endln
\lnie
algorithms for matching this node type.\endln
\lnie
\endln
\lnie
no parameters (dummy pattern)\endln
\lnie
\endln
\inst{p$pab}{ent}{}{entry point}
\inst{}{brn}{failp}{just fail (entry is already popped)}
\vfill\break

\lnie
\endln
\lnie
pattern assignment (end of match, make assign entry)\endln
\lnie
\endln
\lnie
see compound patterns description for the structure and\endln
\lnie
algorithms for matching this node type.\endln
\lnie
\endln
\lnie
parm1                 name base of variable\endln
\lnie
parm2                 name offset of variable\endln
\lnie
\endln
\inst{p$pac}{ent}{bl$p2}{p2blk}
\inst{}{mov}{wb,-(xs)}{stack dummy cursor value}
\inst{}{mov}{xr,-(xs)}{stack pointer to p$pac node}
\inst{}{mov}{wb,-(xs)}{stack final cursor}
\inst{}{mov}{=ndpad,-(xs)}{stack ptr to special ndpad node}
\inst{}{mnz}{pmdfl}{set dot flag non-zero}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
pattern assignment (remove assign entry)\endln
\lnie
\endln
\lnie
see compound patterns description for the structure and\endln
\lnie
algorithms for matching this node type.\endln
\lnie
\endln
\lnie
no parameters (dummy node)\endln
\lnie
\endln
\inst{p$pad}{ent}{}{entry point}
\inst{}{brn}{flpop}{fail and remove p$pac node}
\vfill\break

\lnie
\endln
\lnie
rem\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$rem}{ent}{bl$p0}{p0blk}
\inst{}{mov}{pmssl,wb}{point cursor to end of string}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
rpos (expression argument)\endln
\lnie
\endln
\lnie
optimize rpos if it is the first pattern element,\endln
\lnie
unanchored mode, cursor is zero and rpos argument\endln
\lnie
is not beyond end of string.  force cursor position\endln
\lnie
and number of unanchored moves.\endln
\lnie
\endln
\lnie
this optimization is performed invisibly provided\endln
\lnie
the argument is either a simple integer or an\endln
\lnie
expression that is an untraced variable (that is,\endln
\lnie
it has no side effects that would be lost by short-\endln
\lnie
circuiting the normal logic of failing and moving the\endln
\lnie
unanchored starting point).\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$rpd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evali}{evaluate integer argument}
\inst{}{err}{052,rpos evaluated}{argument is not integer}
\inst{}{err}{053,rpos evaluated}{argument is negative or too large}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{prps1}{merge with normal case if ok}
\lnie
\endln
\inst{prps1}{mov}{pmssl,wc}{get length of string}
\inst{}{sub}{wb,wc}{get number of characters remaining}
\inst{}{beq}{wc,parm1(xr),succp}{succeed if at right location}
\inst{}{bnz}{wb,failp}{don't look further if cursor not 0}
\inst{}{bnz}{evlif,failp}{fail if complex argument}
\inst{}{mov}{pmhbs,xt}{get history stack base ptr}
\inst{}{mov}{evlio,wa}{get original node ptr}
\inst{}{bne}{wa,-(xt),failp}{fail if pos is not first node}
\inst{}{brn}{prps2}{merge with integer arg code}
\vfill\break

\lnie
\endln
\lnie
rpos (integer argument)\endln
\lnie
\endln
\lnie
parm1                 integer argument\endln
\lnie
\endln
\inst{p$rps}{ent}{bl$p1}{p1blk}
\lnie
\endln
\lnie
rpos (integer argument)\endln
\lnie
\endln
\lnie
parm1                 integer argument\endln
\lnie
\endln
\inst{}{mov}{pmssl,wc}{get length of string}
\inst{}{sub}{wb,wc}{get number of characters remaining}
\inst{}{beq}{wc,parm1(xr),succp}{succeed if at right location}
\inst{}{bnz}{wb,failp}{don't look further if cursor not 0}
\inst{}{mov}{pmhbs,xt}{get history stack base ptr}
\inst{}{bne}{xr,-(xt),failp}{fail if rpos is not first node}
\lnie
\endln
\lnie
expression argument merges here\endln
\lnie
\endln
\inst{prps2}{bne}{-(xt),=nduna,failp}{ fail if not unanchored mode}
\inst{}{mov}{pmssl,wb}{point to end of string}
\inst{}{blt}{wb,parm1(xr),failp}{fail if string not long enough}
\inst{}{sub}{parm1(xr),wb}{else set new cursor}
\inst{}{mov}{wb,num02(xt)}{fake number of unanchored moves}
\inst{}{brn}{succp}{continue match with adjusted cursor}
\vfill\break

\lnie
\endln
\lnie
rtab (integer argument)\endln
\lnie
\endln
\lnie
parm1                 integer argument\endln
\lnie
\endln
\inst{p$rtb}{ent}{bl$p1}{p1blk}
\lnie
\endln
\lnie
expression argument case merges here\endln
\lnie
\endln
\inst{prtb1}{mov}{wb,wc}{save initial cursor}
\inst{}{mov}{pmssl,wb}{point to end of string}
\inst{}{blt}{wb,parm1(xr),failp}{fail if string not long enough}
\inst{}{sub}{parm1(xr),wb}{else set new cursor}
\inst{}{bge}{wb,wc,succp}{and succeed if not too far already}
\inst{}{brn}{failp}{in which case, fail}
\vfill\break

\lnie
\endln
\lnie
rtab (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$rtd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evali}{evaluate integer argument}
\inst{}{err}{054,rtab evaluated}{argument is not integer}
\inst{}{err}{055,rtab evaluated}{argument is negative or too large}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{prtb1}{merge with normal case if success}
\vfill\break

\lnie
\endln
\lnie
span (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$spd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evals}{evaluate string argument}
\inst{}{err}{056,span evaluated}{argument is not a string}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{pspn1}{merge with multi-char case if ok}
\vfill\break

\lnie
\endln
\lnie
span (multi-character argument case)\endln
\lnie
\endln
\lnie
parm1                 pointer to ctblk\endln
\lnie
parm2                 bit mask to select bit column\endln
\lnie
\endln
\inst{p$spn}{ent}{bl$p2}{p2blk}
\lnie
\endln
\lnie
expression argument case merges here\endln
\lnie
\endln
\inst{pspn1}{mov}{pmssl,wc}{copy subject string length}
\inst{}{sub}{wb,wc}{calculate number of characters left}
\inst{}{bze}{wc,failp}{fail if no characters left}
\inst{}{mov}{r$pms,xl}{point to subject string}
\inst{}{plc}{xl,wb}{point to current character}
\inst{}{mov}{wb,psavc}{save initial cursor}
\inst{}{mov}{xr,psave}{save node pointer}
\inst{}{lct}{wc,wc}{set counter for chars left}
\lnie
\endln
\lnie
loop to scan matching characters\endln
\lnie
\endln
\inst{pspn2}{lch}{wa,(xl)+}{load next character, bump pointer}
\inst{}{wtb}{wa}{convert to byte offset}
\inst{}{mov}{parm1(xr),xr}{point to ctblk}
\inst{}{add}{wa,xr}{point to ctblk entry}
\inst{}{mov}{ctchs(xr),wa}{load ctblk entry}
\inst{}{mov}{psave,xr}{restore node pointer}
\inst{}{anb}{parm2(xr),wa}{and with selected bit}
\inst{}{zrb}{wa,pspn3}{jump if no match}
\inst{}{icv}{wb}{else push cursor}
\inst{}{bct}{wc,pspn2}{loop back unless end of string}
\lnie
\endln
\lnie
here after scanning matching characters\endln
\lnie
\endln
\inst{pspn3}{bne}{wb,psavc,succp}{succeed if chars matched}
\inst{}{brn}{failp}{else fail if null string matched}
\vfill\break

\lnie
\endln
\lnie
span (one character argument)\endln
\lnie
\endln
\lnie
parm1                 character argument\endln
\lnie
\endln
\inst{p$sps}{ent}{bl$p1}{p1blk}
\inst{}{mov}{pmssl,wc}{get subject string length}
\inst{}{sub}{wb,wc}{calculate number of characters left}
\inst{}{bze}{wc,failp}{fail if no characters left}
\inst{}{mov}{r$pms,xl}{else point to subject string}
\inst{}{plc}{xl,wb}{point to current character}
\inst{}{mov}{wb,psavc}{save initial cursor}
\inst{}{lct}{wc,wc}{set counter for characters left}
\lnie
\endln
\lnie
loop to scan matching characters\endln
\lnie
\endln
\inst{psps1}{lch}{wa,(xl)+}{load next character, bump pointer}
\inst{}{bne}{wa,parm1(xr),psps2}{jump if no match}
\inst{}{icv}{wb}{else push cursor}
\inst{}{bct}{wc,psps1}{and loop unless end of string}
\lnie
\endln
\lnie
here after scanning matching characters\endln
\lnie
\endln
\inst{psps2}{bne}{wb,psavc,succp}{succeed if chars matched}
\inst{}{brn}{failp}{fail if null string matched}
\vfill\break

\lnie
\endln
\lnie
multi-character string\endln
\lnie
\endln
\lnie
note that one character strings use the circuit for\endln
\lnie
one character any arguments (p$an1).\endln
\lnie
\endln
\lnie
parm1                 pointer to scblk for string arg\endln
\lnie
\endln
\inst{p$str}{ent}{bl$p1}{p1blk}
\inst{}{mov}{parm1(xr),xl}{get pointer to string}
\lnie
\endln
\lnie
merge here after evaluating expression with string value\endln
\lnie
\endln
\inst{pstr1}{mov}{xr,psave}{save node pointer}
\inst{}{mov}{r$pms,xr}{load subject string pointer}
\inst{}{plc}{xr,wb}{point to current character}
\inst{}{add}{sclen(xl),wb}{compute new cursor position}
\inst{}{bgt}{wb,pmssl,failp}{fail if past end of string}
\inst{}{mov}{wb,psavc}{save updated cursor}
\inst{}{mov}{sclen(xl),wa}{get number of chars to compare}
\inst{}{plc}{xl}{point to chars of test string}
\inst{}{cmc}{failp,failp}{compare, fail if not equal}
\inst{}{mov}{psave,xr}{if all matched, restore node ptr}
\inst{}{mov}{psavc,wb}{restore updated cursor}
\inst{}{brn}{succp}{and succeed}
\vfill\break

\lnie
\endln
\lnie
succeed\endln
\lnie
\endln
\lnie
see section on compound patterns for details of the\endln
\lnie
structure and algorithms for matching this node type\endln
\lnie
\endln
\lnie
no parameters\endln
\lnie
\endln
\inst{p$suc}{ent}{bl$p0}{p0blk}
\inst{}{mov}{wb,-(xs)}{stack cursor}
\inst{}{mov}{xr,-(xs)}{stack pointer to this node}
\inst{}{brn}{succp}{succeed matching null}
\vfill\break

\lnie
\endln
\lnie
tab (integer argument)\endln
\lnie
\endln
\lnie
parm1                 integer argument\endln
\lnie
\endln
\inst{p$tab}{ent}{bl$p1}{p1blk}
\lnie
\endln
\lnie
expression argument case merges here\endln
\lnie
\endln
\inst{ptab1}{bgt}{wb,parm1(xr),failp}{fail if too far already}
\inst{}{mov}{parm1(xr),wb}{else set new cursor position}
\inst{}{ble}{wb,pmssl,succp}{succeed if not off end}
\inst{}{brn}{failp}{else fail}
\vfill\break

\lnie
\endln
\lnie
tab (expression argument)\endln
\lnie
\endln
\lnie
parm1                 expression pointer\endln
\lnie
\endln
\inst{p$tbd}{ent}{bl$p1}{p1blk}
\inst{}{jsr}{evali}{evaluate integer argument}
\inst{}{err}{057,tab evaluated}{argument is not integer}
\inst{}{err}{058,tab evaluated}{argument is negative or too large}
\inst{}{ppm}{failp}{fail if evaluation fails}
\inst{}{ppm}{ptab1}{merge with normal case if ok}
\vfill\break

\lnie
\endln
\lnie
anchor movement\endln
\lnie
\endln
\lnie
no parameters (dummy node)\endln
\lnie
\endln
\inst{p$una}{ent}{}{entry point}
\inst{}{mov}{wb,xr}{copy initial pattern node pointer}
\inst{}{mov}{(xs),wb}{get initial cursor}
\inst{}{beq}{wb,pmssl,exfal}{match fails if at end of string}
\inst{}{icv}{wb}{else increment cursor}
\inst{}{mov}{wb,(xs)}{store incremented cursor}
\inst{}{mov}{xr,-(xs)}{restack initial node ptr}
\inst{}{mov}{=nduna,-(xs)}{restack unanchored node}
\inst{}{bri}{(xr)}{rematch first node}
\vfill\break

\lnie
\endln
\lnie
end of pattern match routines\endln
\lnie
\endln
\lnie
the following entry point marks the end of the pattern\endln
\lnie
matching routines and also the end of the entry points\endln
\lnie
referenced from the first word of blocks in dynamic store\endln
\lnie
\endln
\inst{p$yyy}{ent}{bl$$i}{mark last entry in pattern section}
\vfill\break
{\bf spitbol--\rm snobol4 built-in label routines}
\vskip1em
\lnie
\endln
\lnie
the following section contains the routines for labels\endln
\lnie
which have a predefined meaning in snobol4.\endln
\lnie
\endln
\lnie
control is passed directly to the label name entry point.\endln
\lnie
\endln
\lnie
entry names are of the form l$xxx where xxx is the three\endln
\lnie
letter variable name identifier.\endln
\lnie
\endln
\lnie
entries are in alphabetical order\endln
\vfill\break

\lnie
\endln
\lnie
abort\endln
\lnie
\endln
\inst{l$abo}{ent}{}{entry point}
\lnie
\endln
\lnie
merge here if execution terminates in error\endln
\lnie
\endln
\inst{labo1}{mov}{kvert,wa}{load error code}
\inst{}{bze}{wa,labo3}{jump if no error has occured}
\ifmac{.csax}
\inst{}{jsr}{sysax}{call after execution proc}
\asmac{fi}
\ifmac{.cera}
\ifmac{.csfn}
\inst{}{mov}{kvstn,wc}{current statement}
\inst{}{jsr}{filnm}{obtain file name for this statement}
\asmac{fi}
\ifmac{.csln}
\inst{}{mov}{r$cod,xr}{current code block}
\inst{}{mov}{cdsln(xr),wc}{line number}
\asmac{else}
\inst{}{zer}{wc}{line number}
\asmac{fi}
\inst{}{zer}{wb}{column number}
\inst{}{mov}{wb}{column number}
\inst{}{jsr}{sysea}{advise system of error}
\inst{}{ppm}{stpr4}{if system does not want print}
\asmac{fi}
\inst{}{jsr}{prtpg}{else eject printer}
\ifmac{.cera}
\inst{}{bze}{xr,labo2}{did sysea request print}
\inst{}{jsr}{prtst}{print text from sysea}
\asmac{fi}
\inst{labo2}{jsr}{ermsg}{print error message}
\inst{}{zer}{xr}{indicate no message to print}
\inst{}{brn}{stopr}{jump to routine to stop run}
\lnie
\endln
\lnie
here if no error had occured\endln
\lnie
\endln
\inst{labo3}{erb}{036,goto abort with}{no preceding error}
\vfill\break

\lnie
\endln
\lnie
continue\endln
\lnie
\endln
\inst{l$cnt}{ent}{}{entry point}
\lnie
\endln
\lnie
merge here after execution error\endln
\lnie
\endln
\inst{lcnt1}{mov}{r$cnt,xr}{load continuation code block ptr}
\inst{}{bze}{xr,lcnt3}{jump if no previous error}
\inst{}{zer}{r$cnt}{clear flag}
\inst{}{mov}{xr,r$cod}{else store as new code block ptr}
\inst{}{bne}{(xr),=b$cdc,lcnt2}{jump if not complex go}
\inst{}{mov}{stxoc,wa}{get offset of error}
\inst{}{bge}{wa,stxof,lcnt4}{jump if error in goto evaluation}
\lnie
\endln
\lnie
here if error did not occur in complex failure goto\endln
\lnie
\endln
\inst{lcnt2}{add}{stxof,xr}{add failure offset}
\inst{}{lcp}{xr}{load code pointer}
\inst{}{mov}{flptr,xs}{reset stack pointer}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
here if no previous error\endln
\lnie
\endln
\inst{lcnt3}{icv}{errft}{fatal error}
\inst{}{erb}{037,goto continue}{with no preceding error}
\lnie
\endln
\lnie
here if error in evaluation of failure goto.\endln
\lnie
cannot continue back to failure goto!\endln
\lnie
\endln
\inst{lcnt4}{icv}{errft}{fatal error}
\inst{}{erb}{332,goto continue}{with error in failure goto}
\vfill\break

\lnie
\endln
\lnie
end\endln
\lnie
\endln
\inst{l$end}{ent}{}{entry point}
\lnie
\endln
\lnie
merge here from end code circuit\endln
\lnie
\endln
\inst{lend0}{mov}{=endms,xr}{point to message /normal term.../}
\inst{}{brn}{stopr}{jump to routine to stop run}
\vfill\break

\lnie
\endln
\lnie
freturn\endln
\lnie
\endln
\inst{l$frt}{ent}{}{entry point}
\inst{}{mov}{=scfrt,wa}{point to string /freturn/}
\inst{}{brn}{retrn}{jump to common return routine}
\vfill\break

\lnie
\endln
\lnie
nreturn\endln
\lnie
\endln
\inst{l$nrt}{ent}{}{entry point}
\inst{}{mov}{=scnrt,wa}{point to string /nreturn/}
\inst{}{brn}{retrn}{jump to common return routine}
\vfill\break

\lnie
\endln
\lnie
return\endln
\lnie
\endln
\inst{l$rtn}{ent}{}{entry point}
\inst{}{mov}{=scrtn,wa}{point to string /return/}
\inst{}{brn}{retrn}{jump to common return routine}
\vfill\break

\lnie
\endln
\lnie
scontinue\endln
\lnie
\endln
\inst{l$scn}{ent}{}{entry point}
\inst{}{mov}{r$cnt,xr}{load continuation code block ptr}
\inst{}{bze}{xr,lscn2}{jump if no previous error}
\inst{}{zer}{r$cnt}{clear flag}
\inst{}{bne}{kvert,=nm320,lscn1}{error must be user interrupt}
\inst{}{beq}{kvert,=nm321,lscn2}{detect scontinue loop}
\inst{}{mov}{xr,r$cod}{else store as new code block ptr}
\inst{}{add}{stxoc,xr}{add resume offset}
\inst{}{lcp}{xr}{load code pointer}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
here if no user interrupt\endln
\lnie
\endln
\inst{lscn1}{icv}{errft}{fatal error}
\inst{}{erb}{331,goto scontinue}{with no user interrupt}
\lnie
\endln
\lnie
here if in scontinue loop or if no previous error\endln
\lnie
\endln
\inst{lscn2}{icv}{errft}{fatal error}
\inst{}{erb}{321,goto scontinue}{with no preceding error}
\vfill\break

\lnie
\endln
\lnie
undefined label\endln
\lnie
\endln
\inst{l$und}{ent}{}{entry point}
\inst{}{erb}{038,goto undefined}{label}
\vfill\break
{\bf spitbol--\rm predefined snobol4 functions}
\vskip1em
\lnie
\endln
\lnie
the following section contains coding for functions\endln
\lnie
which are predefined and available at the snobol level.\endln
\lnie
\endln
\lnie
these routines receive control directly from the code or\endln
\lnie
indirectly through the o$fnc, o$fns or cfunc routines.\endln
\lnie
in both cases the conditions on entry are as follows\endln
\lnie
\endln
\lnie
the arguments are on the stack. the number of arguments\endln
\lnie
has been adjusted to correspond to the svblk svnar field.\endln
\lnie
\endln
\lnie
in certain functions the direct call is not permitted\endln
\lnie
and in these instances we also have.\endln
\lnie
\endln
\lnie
(wa)                  actual number of arguments in call\endln
\lnie
\endln
\lnie
control returns by placing the function result value on\endln
\lnie
on the stack and continuing execution with the next\endln
\lnie
word from the generated code.\endln
\lnie
\endln
\lnie
the names of the entry points of these functions are of\endln
\lnie
the form s$xxx where xxx is the three letter code for\endln
\lnie
the system variable name. the functions are in order\endln
\lnie
alphabetically by their entry names.\endln
\vfill\break

\ifmac{.c370}
\lnie
\endln
\lnie
abs\endln
\lnie
\endln
\inst{s$abs}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtnum}{make numeric}
\inst{}{err}{xxx,abs argument}{not numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$rcl,sabs1}{jump if real}
\asmac{fi}
\inst{}{ldi}{icval(xr)}{load integer value}
\inst{}{ige}{exixr}{no change if not negative}
\inst{}{ngi}{}{produce absolute value}
\inst{}{ino}{exint}{return integer if no overflow}
\inst{}{erb}{xxx,abs caused integer}{overflow}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to process real argument\endln
\lnie
\endln
\inst{sabs1}{ldr}{rcval(xr)}{load real value}
\inst{}{rge}{exixr}{no change if not negative}
\inst{}{ngr}{}{produce absolute value}
\inst{}{rno}{exrea}{return real if no overflow}
\inst{}{erb}{xxx,abs caused real}{overflow}
\asmac{fi}
\asmac{fi}
\ifmac{.c370}
\lnie
\endln
\lnie
and\endln
\lnie
\endln
\inst{s$and}{ent}{}{entry point}
\inst{}{mnz}{wb}{signal two arguments}
\inst{}{jsr}{sbool}{call string boolean routine}
\inst{}{err}{xxx,and first argument}{is not a string}
\inst{}{err}{xxx,and second argument}{is not a string}
\inst{}{err}{xxx,and arguments}{not same length}
\inst{}{ppm}{exits}{null string arguments}
\lnie
\endln
\lnie
here to process (wc) words.  result is stacked.\endln
\lnie
\endln
\inst{sand1}{mov}{(xl)+,wa}{get next cfp$c chars from arg 1}
\inst{}{anb}{(xr),wa}{and with characters from arg 2}
\inst{}{mov}{wa,(xr)+}{put back in memory}
\inst{}{bct}{wc,sand1}{loop over all words in string block}
\inst{}{brn}{exits}{fetch next code word}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
any\endln
\lnie
\endln
\inst{s$any}{ent}{}{entry point}
\inst{}{mov}{=p$ans,wb}{set pcode for single char case}
\inst{}{mov}{=p$any,xl}{pcode for multi-char case}
\inst{}{mov}{=p$ayd,wc}{pcode for expression case}
\inst{}{jsr}{patst}{call common routine to build node}
\inst{}{err}{059,any argument}{is not a string or expression}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
append\endln
\lnie
\endln
\inst{s$apn}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xl}{get append argument}
\inst{}{mov}{(xs)+,xr}{get bcblk}
\inst{}{beq}{(xr),=b$bct,sapn1}{ok if first arg is bcblk}
\inst{}{erb}{275,append first}{argument is not a buffer}
\lnie
\endln
\lnie
here to do the append\endln
\lnie
\endln
\inst{sapn1}{jsr}{apndb}{do the append}
\inst{}{err}{276,append second}{argument is not a string}
\inst{}{ppm}{exfal}{no room - fail}
\inst{}{brn}{exnul}{exit with null result}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
apply\endln
\lnie
\endln
\lnie
apply does not permit the direct (fast) call so that\endln
\lnie
wa contains the actual number of arguments passed.\endln
\lnie
\endln
\inst{s$app}{ent}{}{entry point}
\inst{}{bze}{wa,sapp3}{jump if no arguments}
\inst{}{dcv}{wa}{else get applied func arg count}
\inst{}{mov}{wa,wb}{copy}
\inst{}{wtb}{wb}{convert to bytes}
\inst{}{mov}{xs,xt}{copy stack pointer}
\inst{}{add}{wb,xt}{point to function argument on stack}
\inst{}{mov}{(xt),xr}{load function ptr (apply 1st arg)}
\inst{}{bze}{wa,sapp2}{jump if no args for applied func}
\inst{}{lct}{wb,wa}{else set counter for loop}
\lnie
\endln
\lnie
loop to move arguments up on stack\endln
\lnie
\endln
\inst{sapp1}{dca}{xt}{point to next argument}
\inst{}{mov}{(xt),num01(xt)}{move argument up}
\inst{}{bct}{wb,sapp1}{loop till all moved}
\lnie
\endln
\lnie
merge here to call function (wa = number of arguments)\endln
\lnie
\endln
\inst{sapp2}{ica}{xs}{adjust stack ptr for apply 1st arg}
\inst{}{jsr}{gtnvr}{get variable block addr for func}
\inst{}{ppm}{sapp3}{jump if not natural variable}
\inst{}{mov}{vrfnc(xr),xl}{else point to function block}
\inst{}{brn}{cfunc}{go call applied function}
\lnie
\endln
\lnie
here for invalid first argument\endln
\lnie
\endln
\inst{sapp3}{erb}{060,apply first arg}{is not natural variable name}
\vfill\break

\lnie
\endln
\lnie
arbno\endln
\lnie
\endln
\lnie
arbno builds a compound pattern. see description at\endln
\lnie
start of pattern matching section for structure formed.\endln
\lnie
\endln
\inst{s$abn}{ent}{}{entry point}
\inst{}{zer}{xr}{set parm1 = 0 for the moment}
\inst{}{mov}{=p$alt,wb}{set pcode for alternative node}
\inst{}{jsr}{pbild}{build alternative node}
\inst{}{mov}{xr,xl}{save ptr to alternative pattern}
\inst{}{mov}{=p$abc,wb}{pcode for p$abc}
\inst{}{zer}{xr}{p0blk}
\inst{}{jsr}{pbild}{build p$abc node}
\inst{}{mov}{xl,pthen(xr)}{put alternative node as successor}
\inst{}{mov}{xl,wa}{remember alternative node pointer}
\inst{}{mov}{xr,xl}{copy p$abc node ptr}
\inst{}{mov}{(xs),xr}{load arbno argument}
\inst{}{mov}{wa,(xs)}{stack alternative node pointer}
\inst{}{jsr}{gtpat}{get arbno argument as pattern}
\inst{}{err}{061,arbno argument}{is not pattern}
\inst{}{jsr}{pconc}{concat arg with p$abc node}
\inst{}{mov}{xr,xl}{remember ptr to concd patterns}
\inst{}{mov}{=p$aba,wb}{pcode for p$aba}
\inst{}{zer}{xr}{p0blk}
\inst{}{jsr}{pbild}{build p$aba node}
\inst{}{mov}{xl,pthen(xr)}{concatenate nodes}
\inst{}{mov}{(xs),xl}{recall ptr to alternative node}
\inst{}{mov}{xr,parm1(xl)}{point alternative back to argument}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
arg\endln
\lnie
\endln
\inst{s$arg}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{get second arg as small integer}
\inst{}{err}{062,arg second argument}{is not integer}
\inst{}{ppm}{exfal}{fail if out of range or negative}
\inst{}{mov}{xr,wa}{save argument number}
\inst{}{mov}{(xs)+,xr}{load first argument}
\inst{}{jsr}{gtnvr}{locate vrblk}
\inst{}{ppm}{sarg1}{jump if not natural variable}
\inst{}{mov}{vrfnc(xr),xr}{else load function block pointer}
\inst{}{bne}{(xr),=b$pfc,sarg1}{jump if not program defined}
\inst{}{bze}{wa,exfal}{fail if arg number is zero}
\inst{}{bgt}{wa,fargs(xr),exfal}{fail if arg number is too large}
\inst{}{wtb}{wa}{else convert to byte offset}
\inst{}{add}{wa,xr}{point to argument selected}
\inst{}{mov}{pfagb(xr),xr}{load argument vrblk pointer}
\inst{}{brn}{exvnm}{exit to build nmblk}
\lnie
\endln
\lnie
here if 1st argument is bad\endln
\lnie
\endln
\inst{sarg1}{erb}{063,arg first argument}{is not program function name}
\vfill\break

\lnie
\endln
\lnie
array\endln
\lnie
\endln
\inst{s$arr}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xl}{load initial element value}
\inst{}{mov}{(xs)+,xr}{load first argument}
\inst{}{jsr}{gtint}{convert first arg to integer}
\inst{}{ppm}{sar02}{jump if not integer}
\lnie
\endln
\lnie
here for integer first argument, build vcblk\endln
\lnie
\endln
\inst{}{ldi}{icval(xr)}{load integer value}
\inst{}{ile}{sar10}{jump if zero or neg (bad dimension)}
\inst{}{mfi}{wa,sar11}{else convert to one word, test ovfl}
\inst{}{jsr}{vmake}{create vector}
\inst{}{ppm}{sar11}{fail if too large}
\inst{}{brn}{exsid}{exit setting idval}
\vfill\break

\lnie
\endln
\lnie
array (continued)\endln
\lnie
\endln
\lnie
here if first argument is not an integer\endln
\lnie
\endln
\inst{sar02}{mov}{xr,-(xs)}{replace argument on stack}
\inst{}{jsr}{xscni}{initialize scan of first argument}
\inst{}{err}{064,array first argument}{is not integer or string}
\inst{}{ppm}{exnul}{dummy (unused) null string exit}
\inst{}{mov}{r$xsc,-(xs)}{save prototype pointer}
\inst{}{mov}{xl,-(xs)}{save default value}
\inst{}{zer}{arcdm}{zero count of dimensions}
\inst{}{zer}{arptr}{zero offset to indicate pass one}
\inst{}{ldi}{intv1}{load integer one}
\inst{}{sti}{arnel}{initialize element count}
\lnie
\endln
\lnie
the following code is executed twice. the first time\endln
\lnie
(arptr eq 0), it is used to count the number of elements\endln
\lnie
and number of dimensions. the second time (arptr gt 0) is\endln
\lnie
used to actually fill in the dim,lbd fields of the arblk.\endln
\lnie
\endln
\inst{sar03}{ldi}{intv1}{load one as default low bound}
\inst{}{sti}{arsvl}{save as low bound}
\inst{}{mov}{=ch$cl,wc}{set delimiter one = colon}
\inst{}{mov}{=ch$cm,xl}{set delimiter two = comma}
\inst{}{zer}{wa}{retain blanks in prototype}
\inst{}{jsr}{xscan}{scan next bound}
\inst{}{bne}{wa,=num01,sar04}{jump if not colon}
\lnie
\endln
\lnie
here we have a colon ending a low bound\endln
\lnie
\endln
\inst{}{jsr}{gtint}{convert low bound}
\inst{}{err}{065,array first argument}{lower bound is not integer}
\inst{}{ldi}{icval(xr)}{load value of low bound}
\inst{}{sti}{arsvl}{store low bound value}
\inst{}{mov}{=ch$cm,wc}{set delimiter one = comma}
\inst{}{mov}{wc,xl}{and delimiter two = comma}
\inst{}{zer}{wa}{retain blanks in prototype}
\inst{}{jsr}{xscan}{scan high bound}
\vfill\break

\lnie
\endln
\lnie
array (continued)\endln
\lnie
\endln
\lnie
merge here to process upper bound\endln
\lnie
\endln
\inst{sar04}{jsr}{gtint}{convert high bound to integer}
\inst{}{err}{066,array first argument}{upper bound is not integer}
\inst{}{ldi}{icval(xr)}{get high bound}
\inst{}{sbi}{arsvl}{subtract lower bound}
\inst{}{iov}{sar10}{bad dimension if overflow}
\inst{}{ilt}{sar10}{bad dimension if negative}
\inst{}{adi}{intv1}{add 1 to get dimension}
\inst{}{iov}{sar10}{bad dimension if overflow}
\inst{}{mov}{arptr,xl}{load offset (also pass indicator)}
\inst{}{bze}{xl,sar05}{jump if first pass}
\lnie
\endln
\lnie
here in second pass to store lbd and dim in arblk\endln
\lnie
\endln
\inst{}{add}{(xs),xl}{point to current location in arblk}
\inst{}{sti}{cfp$i(xl)}{store dimension}
\inst{}{ldi}{arsvl}{load low bound}
\inst{}{sti}{(xl)}{store low bound}
\inst{}{add}{*ardms,arptr}{bump offset to next bounds}
\inst{}{brn}{sar06}{jump to check for end of bounds}
\lnie
\endln
\lnie
here in pass 1\endln
\lnie
\endln
\inst{sar05}{icv}{arcdm}{bump dimension count}
\inst{}{mli}{arnel}{multiply dimension by count so far}
\inst{}{iov}{sar11}{too large if overflow}
\inst{}{sti}{arnel}{else store updated element count}
\lnie
\endln
\lnie
merge here after processing one set of bounds\endln
\lnie
\endln
\inst{sar06}{bnz}{wa,sar03}{loop back unless end of bounds}
\inst{}{bnz}{arptr,sar09}{jump if end of pass 2}
\vfill\break

\lnie
\endln
\lnie
array (continued)\endln
\lnie
\endln
\lnie
here at end of pass one, build arblk\endln
\lnie
\endln
\inst{}{ldi}{arnel}{get number of elements}
\inst{}{mfi}{wb,sar11}{get as addr integer, test ovflo}
\inst{}{wtb}{wb}{else convert to length in bytes}
\inst{}{mov}{*arsi$,wa}{set size of standard fields}
\inst{}{lct}{wc,arcdm}{set dimension count to control loop}
\lnie
\endln
\lnie
loop to allow space for dimensions\endln
\lnie
\endln
\inst{sar07}{add}{*ardms,wa}{allow space for one set of bounds}
\inst{}{bct}{wc,sar07}{loop back till all accounted for}
\inst{}{mov}{wa,xl}{save size (=arofs)}
\lnie
\endln
\lnie
now allocate space for arblk\endln
\lnie
\endln
\inst{}{add}{wb,wa}{add space for elements}
\inst{}{ica}{wa}{allow for arpro prototype field}
\inst{}{bgt}{wa,mxlen,sar11}{fail if too large}
\inst{}{jsr}{alloc}{else allocate arblk}
\inst{}{mov}{(xs),wb}{load default value}
\inst{}{mov}{xr,(xs)}{save arblk pointer}
\inst{}{mov}{wa,wc}{save length in bytes}
\inst{}{btw}{wa}{convert length back to words}
\inst{}{lct}{wa,wa}{set counter to control loop}
\lnie
\endln
\lnie
loop to clear entire arblk to default value\endln
\lnie
\endln
\inst{sar08}{mov}{wb,(xr)+}{set one word}
\inst{}{bct}{wa,sar08}{loop till all set}
\vfill\break

\lnie
\endln
\lnie
array (continued)\endln
\lnie
\endln
\lnie
now set initial fields of arblk\endln
\lnie
\endln
\inst{}{mov}{(xs)+,xr}{reload arblk pointer}
\inst{}{mov}{(xs),wb}{load prototype}
\inst{}{mov}{=b$art,(xr)}{set type word}
\inst{}{mov}{wc,arlen(xr)}{store length in bytes}
\inst{}{zer}{idval(xr)}{zero id till we get it built}
\inst{}{mov}{xl,arofs(xr)}{set prototype field ptr}
\inst{}{mov}{arcdm,arndm(xr)}{set number of dimensions}
\inst{}{mov}{xr,wc}{save arblk pointer}
\inst{}{add}{xl,xr}{point to prototype field}
\inst{}{mov}{wb,(xr)}{store prototype ptr in arblk}
\inst{}{mov}{*arlbd,arptr}{set offset for pass 2 bounds scan}
\inst{}{mov}{wb,r$xsc}{reset string pointer for xscan}
\inst{}{mov}{wc,(xs)}{store arblk pointer on stack}
\inst{}{zer}{xsofs}{reset offset ptr to start of string}
\inst{}{brn}{sar03}{jump back to rescan bounds}
\lnie
\endln
\lnie
here after filling in bounds information (end pass two)\endln
\lnie
\endln
\inst{sar09}{mov}{(xs)+,xr}{reload pointer to arblk}
\inst{}{brn}{exsid}{exit setting idval}
\lnie
\endln
\lnie
here for bad dimension\endln
\lnie
\endln
\inst{sar10}{erb}{067,array dimension}{is zero, negative or out of range}
\lnie
\endln
\lnie
here if array is too large\endln
\lnie
\endln
\inst{sar11}{erb}{068,array size exceeds}{maximum permitted}
\vfill\break

\ifmac{.cmth}
\lnie
\endln
\lnie
atan\endln
\lnie
\endln
\inst{s$atn}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{301,atan argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{atn}{}{take arctangent}
\inst{}{brn}{exrea}{overflow, out of range not possible}
\vfill\break

\asmac{fi}
\ifmac{.cbsp}
\vfill\break

\lnie
\endln
\lnie
backspace\endln
\lnie
\endln
\inst{s$bsp}{ent}{}{entry point}
\inst{}{jsr}{iofcb}{call fcblk routine}
\inst{}{err}{316,backspace argument}{is not a suitable name}
\inst{}{err}{316,backspace argument}{is not a suitable name}
\inst{}{err}{317,backspace file}{does not exist}
\inst{}{jsr}{sysbs}{call backspace file function}
\inst{}{err}{317,backspace file}{does not exist}
\inst{}{err}{318,backspace file}{does not permit backspace}
\inst{}{err}{319,backspace caused}{non-recoverable error}
\inst{}{brn}{exnul}{return null as result}
\vfill\break

\asmac{fi}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
buffer\endln
\lnie
\endln
\inst{s$buf}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xl}{get initial value}
\inst{}{mov}{(xs)+,xr}{get requested allocation}
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{err}{269,buffer first}{argument is not integer}
\inst{}{ldi}{icval(xr)}{get value}
\inst{}{ile}{sbf01}{branch if negative or zero}
\inst{}{mfi}{wa,sbf02}{move with overflow check}
\inst{}{jsr}{alobf}{allocate the buffer}
\inst{}{jsr}{apndb}{copy it in}
\inst{}{err}{270,buffer second}{argument is not a string or buffer}
\inst{}{err}{271,buffer initial}{value too big for allocation}
\inst{}{brn}{exsid}{exit setting idval}
\lnie
\endln
\lnie
here for invalid allocation size\endln
\lnie
\endln
\inst{sbf01}{erb}{272,buffer first}{argument is not positive}
\lnie
\endln
\lnie
here for allocation size integer overflow\endln
\lnie
\endln
\inst{sbf02}{erb}{273,buffer size exceeds}{value of maxlngth keyword}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
break\endln
\lnie
\endln
\inst{s$brk}{ent}{}{entry point}
\inst{}{mov}{=p$bks,wb}{set pcode for single char case}
\inst{}{mov}{=p$brk,xl}{pcode for multi-char case}
\inst{}{mov}{=p$bkd,wc}{pcode for expression case}
\inst{}{jsr}{patst}{call common routine to build node}
\inst{}{err}{069,break argument}{is not a string or expression}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
breakx\endln
\lnie
\endln
\lnie
breakx is a compound pattern. see description at start\endln
\lnie
of pattern matching section for structure formed.\endln
\lnie
\endln
\inst{s$bkx}{ent}{}{entry point}
\inst{}{mov}{=p$bks,wb}{pcode for single char argument}
\inst{}{mov}{=p$brk,xl}{pcode for multi-char argument}
\inst{}{mov}{=p$bxd,wc}{pcode for expression case}
\inst{}{jsr}{patst}{call common routine to build node}
\inst{}{err}{070,breakx argument}{is not a string or expression}
\lnie
\endln
\lnie
now hook breakx node on at front end\endln
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{save ptr to break node}
\inst{}{mov}{=p$bkx,wb}{set pcode for breakx node}
\inst{}{jsr}{pbild}{build it}
\inst{}{mov}{(xs),pthen(xr)}{set break node as successor}
\inst{}{mov}{=p$alt,wb}{set pcode for alternation node}
\inst{}{jsr}{pbild}{build (parm1=alt=breakx node)}
\inst{}{mov}{xr,wa}{save ptr to alternation node}
\inst{}{mov}{(xs),xr}{point to break node}
\inst{}{mov}{wa,pthen(xr)}{set alternate node as successor}
\inst{}{lcw}{xr}{result on stack}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
char\endln
\lnie
\endln
\inst{s$chr}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{convert arg to integer}
\inst{}{err}{281,char argument}{not integer}
\inst{}{ppm}{schr1}{too big error exit}
\inst{}{bge}{wc,=cfp$a,schr1}{see if out of range of host set}
\inst{}{mov}{=num01,wa}{if not set scblk allocation}
\inst{}{mov}{wc,wb}{save char code}
\inst{}{jsr}{alocs}{allocate 1 bau scblk}
\inst{}{mov}{xr,xl}{copy scblk pointer}
\inst{}{psc}{xl}{get set to stuff char}
\inst{}{sch}{wb,(xl)}{stuff it}
\inst{}{csc}{xl}{complete store character}
\inst{}{zer}{xl}{clear slop in xl}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
here if char argument is out of range\endln
\lnie
\endln
\inst{schr1}{erb}{282,char argument}{not in range}
\vfill\break

\ifmac{.cmth}
\lnie
\endln
\lnie
chop\endln
\lnie
\endln
\inst{s$chp}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{302,chop argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{chp}{}{truncate to integer valued real}
\inst{}{brn}{exrea}{no overflow possible}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
clear\endln
\lnie
\endln
\inst{s$clr}{ent}{}{entry point}
\inst{}{jsr}{xscni}{initialize to scan argument}
\inst{}{err}{071,clear argument}{is not a string}
\inst{}{ppm}{sclr2}{jump if null}
\lnie
\endln
\lnie
loop to scan out names in first argument. variables in\endln
\lnie
the list are flagged by setting vrget of vrblk to zero.\endln
\lnie
\endln
\inst{sclr1}{mov}{=ch$cm,wc}{set delimiter one = comma}
\inst{}{mov}{wc,xl}{delimiter two = comma}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan next variable name}
\inst{}{jsr}{gtnvr}{locate vrblk}
\inst{}{err}{072,clear argument}{has null variable name}
\inst{}{zer}{vrget(xr)}{else flag by zeroing vrget field}
\inst{}{bnz}{wa,sclr1}{loop back if stopped by comma}
\lnie
\endln
\lnie
here after flagging variables in argument list\endln
\lnie
\endln
\inst{sclr2}{mov}{hshtb,wb}{point to start of hash table}
\lnie
\endln
\lnie
loop through slots in hash table\endln
\lnie
\endln
\inst{sclr3}{beq}{wb,hshte,exnul}{exit returning null if none left}
\inst{}{mov}{wb,xr}{else copy slot pointer}
\inst{}{ica}{wb}{bump slot pointer}
\inst{}{sub}{*vrnxt,xr}{set offset to merge into loop}
\lnie
\endln
\lnie
loop through vrblks on one hash chain\endln
\lnie
\endln
\inst{sclr4}{mov}{vrnxt(xr),xr}{point to next vrblk on chain}
\inst{}{bze}{xr,sclr3}{jump for next bucket if chain end}
\inst{}{bnz}{vrget(xr),sclr5}{jump if not flagged}
\vfill\break

\lnie
\endln
\lnie
clear (continued)\endln
\lnie
\endln
\lnie
here for flagged variable, do not set value to null\endln
\lnie
\endln
\inst{}{jsr}{setvr}{for flagged var, restore vrget}
\inst{}{brn}{sclr4}{and loop back for next vrblk}
\lnie
\endln
\lnie
here to set value of a variable to null\endln
\lnie
protected variables (arb, etc) are exempt\endln
\lnie
\endln
\inst{sclr5}{beq}{vrsto(xr),=b$vre,sclr4}{check for protected variable}
\inst{}{mov}{xr,xl}{copy vrblk pointer}
\lnie
\endln
\lnie
loop to locate value at end of possible trblk chain\endln
\lnie
\endln
\inst{sclr6}{mov}{xl,wa}{save block pointer}
\inst{}{mov}{vrval(xl),xl}{load next value field}
\inst{}{beq}{(xl),=b$trt,sclr6}{loop back if trapped}
\lnie
\endln
\lnie
now store the null value\endln
\lnie
\endln
\inst{}{mov}{wa,xl}{restore block pointer}
\inst{}{mov}{=nulls,vrval(xl)}{store null constant value}
\inst{}{brn}{sclr4}{loop back for next vrblk}
\vfill\break

\lnie
\endln
\lnie
code\endln
\lnie
\endln
\inst{s$cod}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{jsr}{gtcod}{convert to code}
\inst{}{ppm}{exfal}{fail if conversion is impossible}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{zer}{r$ccb}{forget interim code block}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
collect\endln
\lnie
\endln
\inst{s$col}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{err}{073,collect argument}{is not integer}
\inst{}{ldi}{icval(xr)}{load collect argument}
\inst{}{sti}{clsvi}{save collect argument}
\inst{}{zer}{wb}{set no move up}
\inst{}{zer}{r$ccb}{forget interim code block}
\ifmac{.csed}
\inst{}{zer}{dnams}{collect sediment too}
\inst{}{jsr}{gbcol}{perform garbage collection}
\inst{}{mov}{xr,dnams}{record new sediment size}
\asmac{else}
\inst{}{jsr}{gbcol}{perform garbage collection}
\asmac{fi}
\inst{}{mov}{dname,wa}{point to end of memory}
\inst{}{sub}{dnamp,wa}{subtract next location}
\inst{}{btw}{wa}{convert bytes to words}
\inst{}{mti}{wa}{convert words available as integer}
\inst{}{sbi}{clsvi}{subtract argument}
\inst{}{iov}{exfal}{fail if overflow}
\inst{}{ilt}{exfal}{fail if not enough}
\inst{}{adi}{clsvi}{else recompute available}
\inst{}{brn}{exint}{and exit with integer result}
\vfill\break

\ifmac{.c370}
\lnie
\endln
\lnie
compl\endln
\lnie
\endln
\inst{s$cmp}{ent}{}{entry point}
\inst{}{zer}{wb}{signal one argument}
\inst{}{jsr}{sbool}{call string boolean routine}
\inst{}{ppm}{}{only one argument, cannot get here}
\inst{}{err}{xxx,compl argument}{is not a string}
\inst{}{ppm}{}{cannot have two strings unequal}
\inst{}{ppm}{exits}{null string argument}
\lnie
\endln
\lnie
here to process (wa) characters.  result is stacked.\endln
\lnie
\endln
\inst{}{lct}{wc,wa}{prepare count}
\inst{}{plc}{xl}{prepare to load chars from (xl)}
\inst{}{psc}{xr}{prepare to store chars into (xr)}
\inst{scmp1}{lch}{wa,(xl)+}{get next char from arg 1}
\inst{}{cmb}{wa}{complement}
\inst{}{sch}{wa,(xr)+}{store into result}
\inst{}{bct}{wc,scmp1}{loop over all chars in string block}
\inst{}{csc}{}{complete store character}
\inst{}{brn}{exits}{fetch next code word.}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
convert\endln
\lnie
\endln
\inst{s$cnv}{ent}{}{entry point}
\inst{}{jsr}{gtstg}{convert second argument to string}
\inst{}{ppm}{scv29}{error if second argument not string}
\inst{}{bze}{wa,scv29}{or if null string}
\ifmac{.culc}
\inst{}{jsr}{flstg}{fold lower case to upper case}
\asmac{fi}
\inst{}{mov}{(xs),xl}{load first argument}
\inst{}{bne}{(xl),=b$pdt,scv01}{jump if not program defined}
\lnie
\endln
\lnie
here for program defined datatype\endln
\lnie
\endln
\inst{}{mov}{pddfp(xl),xl}{point to dfblk}
\inst{}{mov}{dfnam(xl),xl}{load datatype name}
\inst{}{jsr}{ident}{compare with second arg}
\inst{}{ppm}{exits}{exit if ident with arg as result}
\inst{}{brn}{exfal}{else fail}
\lnie
\endln
\lnie
here if not program defined datatype\endln
\lnie
\endln
\inst{scv01}{mov}{xr,-(xs)}{save string argument}
\inst{}{mov}{=svctb,xl}{point to table of names to compare}
\inst{}{zer}{wb}{initialize counter}
\inst{}{mov}{wa,wc}{save length of argument string}
\lnie
\endln
\lnie
loop through table entries\endln
\lnie
\endln
\inst{scv02}{mov}{(xl)+,xr}{load next table entry, bump pointer}
\inst{}{bze}{xr,exfal}{fail if zero marking end of list}
\inst{}{bne}{wc,sclen(xr),scv05}{jump if wrong length}
\inst{}{mov}{xl,cnvtp}{else store table pointer}
\inst{}{plc}{xr}{point to chars of table entry}
\inst{}{mov}{(xs),xl}{load pointer to string argument}
\inst{}{plc}{xl}{point to chars of string arg}
\inst{}{mov}{wc,wa}{set number of chars to compare}
\inst{}{cmc}{scv04,scv04}{compare, jump if no match}
\vfill\break

\lnie
\endln
\lnie
convert (continued)\endln
\lnie
\endln
\lnie
here we have a match\endln
\lnie
\endln
\inst{scv03}{mov}{wb,xl}{copy entry number}
\inst{}{ica}{xs}{pop string arg off stack}
\inst{}{mov}{(xs)+,xr}{load first argument}
\inst{}{bsw}{xl,cnvtt}{jump to appropriate routine}
\inst{}{iff}{0,scv06}{string}
\inst{}{iff}{1,scv07}{integer}
\inst{}{iff}{2,scv09}{name}
\inst{}{iff}{3,scv10}{pattern}
\inst{}{iff}{4,scv11}{array}
\inst{}{iff}{5,scv19}{table}
\inst{}{iff}{6,scv25}{expression}
\inst{}{iff}{7,scv26}{code}
\inst{}{iff}{8,scv27}{numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{iff}{cnvrt,scv08}{real}
\asmac{fi}
\ifmac{.cnbf}
\asmac{else}
\inst{}{iff}{cnvbt,scv28}{buffer}
\asmac{fi}
\inst{}{esw}{}{end of switch table}
\lnie
\endln
\lnie
here if no match with table entry\endln
\lnie
\endln
\inst{scv04}{mov}{cnvtp,xl}{restore table pointer, merge}
\lnie
\endln
\lnie
merge here if lengths did not match\endln
\lnie
\endln
\inst{scv05}{icv}{wb}{bump entry number}
\inst{}{brn}{scv02}{loop back to check next entry}
\lnie
\endln
\lnie
here to convert to string\endln
\lnie
\endln
\inst{scv06}{mov}{xr,-(xs)}{replace string argument on stack}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{exfal}{fail if conversion not possible}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
convert (continued)\endln
\lnie
\endln
\lnie
here to convert to integer\endln
\lnie
\endln
\inst{scv07}{jsr}{gtint}{convert to integer}
\inst{}{ppm}{exfal}{fail if conversion not possible}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to convert to real\endln
\lnie
\endln
\inst{scv08}{jsr}{gtrea}{convert to real}
\inst{}{ppm}{exfal}{fail if conversion not possible}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\asmac{fi}
\lnie
\endln
\lnie
here to convert to name\endln
\lnie
\endln
\inst{scv09}{beq}{(xr),=b$nml,exixr}{return if already a name}
\inst{}{jsr}{gtnvr}{else try string to name convert}
\inst{}{ppm}{exfal}{fail if conversion not possible}
\inst{}{brn}{exvnm}{else exit building nmblk for vrblk}
\lnie
\endln
\lnie
here to convert to pattern\endln
\lnie
\endln
\inst{scv10}{jsr}{gtpat}{convert to pattern}
\inst{}{ppm}{exfal}{fail if conversion not possible}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
convert to array\endln
\lnie
\endln
\lnie
if the first argument is a table, then we go through\endln
\lnie
an intermediate array of addresses that is sorted to\endln
\lnie
provide a result ordered by time of entry in the\endln
\lnie
original table.  see c3.762.\endln
\lnie
\endln
\inst{scv11}{mov}{xr,-(xs)}{save argument on stack}
\inst{}{zer}{wa}{use table chain block addresses}
\inst{}{jsr}{gtarr}{get an array}
\inst{}{ppm}{exfal}{fail if empty table}
\inst{}{ppm}{exfal}{fail if not convertible}
\inst{}{mov}{(xs)+,xl}{reload original arg}
\inst{}{bne}{(xl),=b$tbt,exsid}{exit if original not a table}
\inst{}{mov}{xr,-(xs)}{sort the intermediate array}
\inst{}{mov}{=nulls,-(xs)}{on first column}
\inst{}{zer}{wa}{sort ascending}
\inst{}{jsr}{sorta}{do sort}
\inst{}{ppm}{exfal}{if sort fails, so shall we}
\inst{}{mov}{xr,wb}{save array result}
\inst{}{ldi}{ardim(xr)}{load dim 1 (number of elements)}
\inst{}{mfi}{wa}{get as one word integer}
\inst{}{lct}{wa,wa}{copy to control loop}
\inst{}{add}{*arvl2,xr}{point to first element in array}
\lnie
\endln
\lnie
here for each row of this 2-column array\endln
\lnie
\endln
\inst{scv12}{mov}{(xr),xl}{get teblk address}
\inst{}{mov}{tesub(xl),(xr)+}{replace with subscript}
\inst{}{mov}{teval(xl),(xr)+}{replace with value}
\inst{}{bct}{wa,scv12}{loop till all copied over}
\inst{}{mov}{wb,xr}{retrieve array address}
\inst{}{brn}{exsid}{exit setting id field}
\lnie
\endln
\lnie
convert to table\endln
\lnie
\endln
\inst{scv19}{mov}{(xr),wa}{load first word of block}
\inst{}{mov}{xr,-(xs)}{replace arblk pointer on stack}
\inst{}{beq}{wa,=b$tbt,exits}{return arg if already a table}
\inst{}{bne}{wa,=b$art,exfal}{else fail if not an array}
\vfill\break

\lnie
\endln
\lnie
convert (continued)\endln
\lnie
\endln
\lnie
here to convert an array to table\endln
\lnie
\endln
\inst{}{bne}{arndm(xr),=num02,exfal}{fail if not 2-dim array}
\inst{}{ldi}{ardm2(xr)}{load dim 2}
\inst{}{sbi}{intv2}{subtract 2 to compare}
\inst{}{ine}{exfal}{fail if dim2 not 2}
\lnie
\endln
\lnie
here we have an arblk of the right shape\endln
\lnie
\endln
\inst{}{ldi}{ardim(xr)}{load dim 1 (number of elements)}
\inst{}{mfi}{wa}{get as one word integer}
\inst{}{lct}{wb,wa}{copy to control loop}
\inst{}{add}{=tbsi$,wa}{add space for standard fields}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{jsr}{alloc}{allocate space for tbblk}
\inst{}{mov}{xr,wc}{copy tbblk pointer}
\inst{}{mov}{xr,-(xs)}{save tbblk pointer}
\inst{}{mov}{=b$tbt,(xr)+}{store type word}
\inst{}{zer}{(xr)+}{store zero for idval for now}
\inst{}{mov}{wa,(xr)+}{store length}
\inst{}{mov}{=nulls,(xr)+}{null initial lookup value}
\lnie
\endln
\lnie
loop to initialize bucket ptrs to point to table\endln
\lnie
\endln
\inst{scv20}{mov}{wc,(xr)+}{set bucket ptr to point to tbblk}
\inst{}{bct}{wb,scv20}{loop till all initialized}
\inst{}{mov}{*arvl2,wb}{set offset to first arblk element}
\lnie
\endln
\lnie
loop to copy elements from array to table\endln
\lnie
\endln
\inst{scv21}{mov}{num01(xs),xl}{point to arblk}
\inst{}{beq}{wb,arlen(xl),scv24}{jump if all moved}
\inst{}{add}{wb,xl}{else point to current location}
\inst{}{add}{*num02,wb}{bump offset}
\inst{}{mov}{(xl),xr}{load subscript name}
\inst{}{dca}{xl}{adjust ptr to merge (trval=1+1)}
\vfill\break

\lnie
\endln
\lnie
convert (continued)\endln
\lnie
\endln
\lnie
loop to chase down trblk chain for value\endln
\lnie
\endln
\inst{scv22}{mov}{trval(xl),xl}{point to next value}
\inst{}{beq}{(xl),=b$trt,scv22}{loop back if trapped}
\lnie
\endln
\lnie
here with name in xr, value in xl\endln
\lnie
\endln
\inst{scv23}{mov}{xl,-(xs)}{stack value}
\inst{}{mov}{num01(xs),xl}{load tbblk pointer}
\inst{}{jsr}{tfind}{build teblk (note wb gt 0 by name)}
\inst{}{ppm}{exfal}{fail if acess fails}
\inst{}{mov}{(xs)+,teval(xl)}{store value in teblk}
\inst{}{brn}{scv21}{loop back for next element}
\lnie
\endln
\lnie
here after moving all elements to tbblk\endln
\lnie
\endln
\inst{scv24}{mov}{(xs)+,xr}{load tbblk pointer}
\inst{}{ica}{xs}{pop arblk pointer}
\inst{}{brn}{exsid}{exit setting idval}
\lnie
\endln
\lnie
convert to expression\endln
\lnie
\endln
\ifmac{.cevb}
\inst{scv25}{zer}{wb}{by value}
\inst{}{jsr}{gtexp}{convert to expression}
\asmac{else}
\inst{scv25}{jsr}{gtexp}{convert to expression}
\asmac{fi}
\inst{}{ppm}{exfal}{fail if conversion not possible}
\inst{}{zer}{r$ccb}{forget interim code block}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
convert to code\endln
\lnie
\endln
\inst{scv26}{jsr}{gtcod}{convert to code}
\inst{}{ppm}{exfal}{fail if conversion is not possible}
\inst{}{zer}{r$ccb}{forget interim code block}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
convert to numeric\endln
\lnie
\endln
\inst{scv27}{jsr}{gtnum}{convert to numeric}
\inst{}{ppm}{exfal}{fail if unconvertible}
\inst{scv31}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
convert to buffer\endln
\lnie
\endln
\inst{scv28}{mov}{xr,-(xs)}{stack first arg for procedure}
\inst{}{jsr}{gtstb}{get string or buffer}
\inst{}{ppm}{exfal}{fail if conversion not possible}
\inst{}{bnz}{wb,scv30}{jump if already a buffer}
\inst{}{mov}{xr,xl}{save string pointer}
\inst{}{jsr}{alobf}{allocate buffer of same size}
\inst{}{jsr}{apndb}{copy in the string}
\inst{}{ppm}{}{already string - cant fail to cnv}
\inst{}{ppm}{}{must be enough room}
\inst{}{brn}{exsid}{exit setting idval field}
\lnie
\endln
\lnie
here if argument is already a buffer\endln
\lnie
\endln
\inst{scv30}{mov}{wb,xr}{return buffer without conversion}
\inst{}{brn}{scv31}{merge to return result}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
second argument not string or null\endln
\lnie
\endln
\inst{scv29}{erb}{074,convert second}{argument is not a string}
\lnie
\endln
\lnie
copy\endln
\lnie
\endln
\inst{s$cop}{ent}{}{entry point}
\inst{}{jsr}{copyb}{copy the block}
\inst{}{ppm}{exits}{return if no idval field}
\inst{}{brn}{exsid}{exit setting id value}
\vfill\break

\ifmac{.cmth}
\lnie
\endln
\lnie
cos\endln
\lnie
\endln
\inst{s$cos}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{303,cos argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{cos}{}{take cosine}
\inst{}{rno}{exrea}{if no overflow, return result in ra}
\inst{}{erb}{322,cos argument}{is out of range}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
data\endln
\lnie
\endln
\inst{s$dat}{ent}{}{entry point}
\inst{}{jsr}{xscni}{prepare to scan argument}
\inst{}{err}{075,data argument}{is not a string}
\inst{}{err}{076,data argument}{is null}
\lnie
\endln
\lnie
scan out datatype name\endln
\lnie
\endln
\inst{}{mov}{=ch$pp,wc}{delimiter one = left paren}
\inst{}{mov}{wc,xl}{delimiter two = left paren}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan datatype name}
\inst{}{bnz}{wa,sdat1}{skip if left paren found}
\inst{}{erb}{077,data argument}{is missing a left paren}
\lnie
\endln
\lnie
here after scanning datatype name\endln
\lnie
\endln
\ifmac{.culc}
\inst{sdat1}{mov}{sclen(xr),wa}{get length}
\inst{}{bze}{wa,sdt1a}{avoid folding if null string}
\inst{}{jsr}{flstg}{fold lower case to upper case}
\inst{sdt1a}{mov}{xr,xl}{save name ptr}
\asmac{else}
\inst{sdat1}{mov}{xr,xl}{save name ptr}
\asmac{fi}
\inst{}{mov}{sclen(xr),wa}{get length}
\inst{}{ctb}{wa,scsi$}{compute space needed}
\inst{}{jsr}{alost}{request static store for name}
\inst{}{mov}{xr,-(xs)}{save datatype name}
\inst{}{mvw}{}{copy name to static}
\inst{}{mov}{(xs),xr}{get name ptr}
\inst{}{zer}{xl}{scrub dud register}
\inst{}{jsr}{gtnvr}{locate vrblk for datatype name}
\inst{}{err}{078,data argument}{has null datatype name}
\inst{}{mov}{xr,datdv}{save vrblk pointer for datatype}
\inst{}{mov}{xs,datxs}{store starting stack value}
\inst{}{zer}{wb}{zero count of field names}
\lnie
\endln
\lnie
loop to scan field names and stack vrblk pointers\endln
\lnie
\endln
\inst{sdat2}{mov}{=ch$rp,wc}{delimiter one = right paren}
\inst{}{mov}{=ch$cm,xl}{delimiter two = comma}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan next field name}
\inst{}{bnz}{wa,sdat3}{jump if delimiter found}
\inst{}{erb}{079,data argument}{is missing a right paren}
\lnie
\endln
\lnie
here after scanning out one field name\endln
\lnie
\endln
\inst{sdat3}{jsr}{gtnvr}{locate vrblk for field name}
\inst{}{err}{080,data argument}{has null field name}
\inst{}{mov}{xr,-(xs)}{stack vrblk pointer}
\inst{}{icv}{wb}{increment counter}
\inst{}{beq}{wa,=num02,sdat2}{loop back if stopped by comma}
\vfill\break

\lnie
\endln
\lnie
data (continued)\endln
\lnie
\endln
\lnie
now build the dfblk\endln
\lnie
\endln
\inst{}{mov}{=dfsi$,wa}{set size of dfblk standard fields}
\inst{}{add}{wb,wa}{add number of fields}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{mov}{wb,wc}{preserve no. of fields}
\inst{}{jsr}{alost}{allocate space for dfblk}
\inst{}{mov}{wc,wb}{get no of fields}
\inst{}{mov}{datxs,xt}{point to start of stack}
\inst{}{mov}{(xt),wc}{load datatype name}
\inst{}{mov}{xr,(xt)}{save dfblk pointer on stack}
\inst{}{mov}{=b$dfc,(xr)+}{store type word}
\inst{}{mov}{wb,(xr)+}{store number of fields (fargs)}
\inst{}{mov}{wa,(xr)+}{store length (dflen)}
\inst{}{sub}{*pddfs,wa}{compute pdblk length (for dfpdl)}
\inst{}{mov}{wa,(xr)+}{store pdblk length (dfpdl)}
\inst{}{mov}{wc,(xr)+}{store datatype name (dfnam)}
\inst{}{lct}{wc,wb}{copy number of fields}
\lnie
\endln
\lnie
loop to move field name vrblk pointers to dfblk\endln
\lnie
\endln
\inst{sdat4}{mov}{-(xt),(xr)+}{move one field name vrblk pointer}
\inst{}{bct}{wc,sdat4}{loop till all moved}
\lnie
\endln
\lnie
now define the datatype function\endln
\lnie
\endln
\inst{}{mov}{wa,wc}{copy length of pdblk for later loop}
\inst{}{mov}{datdv,xr}{point to vrblk}
\inst{}{mov}{datxs,xt}{point back on stack}
\inst{}{mov}{(xt),xl}{load dfblk pointer}
\inst{}{jsr}{dffnc}{define function}
\vfill\break

\lnie
\endln
\lnie
data (continued)\endln
\lnie
\endln
\lnie
loop to build ffblks\endln
\lnie
\endln
\lnie
\endln
\lnie
notice that the ffblks are constructed in reverse order\endln
\lnie
so that the required offsets can be obtained from\endln
\lnie
successive decrementation of the pdblk length (in wc).\endln
\lnie
\endln
\inst{sdat5}{mov}{*ffsi$,wa}{set length of ffblk}
\inst{}{jsr}{alloc}{allocate space for ffblk}
\inst{}{mov}{=b$ffc,(xr)}{set type word}
\inst{}{mov}{=num01,fargs(xr)}{store fargs (always one)}
\inst{}{mov}{datxs,xt}{point back on stack}
\inst{}{mov}{(xt),ffdfp(xr)}{copy dfblk ptr to ffblk}
\inst{}{dca}{wc}{decrement old dfpdl to get next ofs}
\inst{}{mov}{wc,ffofs(xr)}{set offset to this field}
\inst{}{zer}{ffnxt(xr)}{tentatively set zero forward ptr}
\inst{}{mov}{xr,xl}{copy ffblk pointer for dffnc}
\inst{}{mov}{(xs),xr}{load vrblk pointer for field}
\inst{}{mov}{vrfnc(xr),xr}{load current function pointer}
\inst{}{bne}{(xr),=b$ffc,sdat6}{skip if not currently a field func}
\lnie
\endln
\lnie
here we must chain an old ffblk ptr to preserve it in the\endln
\lnie
case of multiple field functions with the same name\endln
\lnie
\endln
\inst{}{mov}{xr,ffnxt(xl)}{link new ffblk to previous chain}
\lnie
\endln
\lnie
merge here to define field function\endln
\lnie
\endln
\inst{sdat6}{mov}{(xs)+,xr}{load vrblk pointer}
\inst{}{jsr}{dffnc}{define field function}
\inst{}{bne}{xs,datxs,sdat5}{loop back till all done}
\inst{}{ica}{xs}{pop dfblk pointer}
\inst{}{brn}{exnul}{return with null result}
\vfill\break

\lnie
\endln
\lnie
datatype\endln
\lnie
\endln
\inst{s$dtp}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{jsr}{dtype}{get datatype}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
date\endln
\lnie
\endln
\inst{s$dte}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{jsr}{gtint}{convert to an integer}
\inst{}{err}{330,date argument}{is not integer}
\inst{}{jsr}{sysdt}{call system date routine}
\inst{}{mov}{num01(xl),wa}{load length for sbstr}
\inst{}{bze}{wa,exnul}{return null if length is zero}
\inst{}{zer}{wb}{set zero offset}
\inst{}{jsr}{sbstr}{use sbstr to build scblk}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
define\endln
\lnie
\endln
\inst{s$def}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load second argument}
\inst{}{zer}{deflb}{zero label pointer in case null}
\inst{}{beq}{xr,=nulls,sdf01}{jump if null second argument}
\inst{}{jsr}{gtnvr}{else find vrblk for label}
\inst{}{ppm}{sdf12}{jump if not a variable name}
\inst{}{mov}{xr,deflb}{else set specified entry}
\lnie
\endln
\lnie
scan function name\endln
\lnie
\endln
\inst{sdf01}{jsr}{xscni}{prepare to scan first argument}
\inst{}{err}{081,define first}{argument is not a string}
\inst{}{err}{082,define first}{argument is null}
\inst{}{mov}{=ch$pp,wc}{delimiter one = left paren}
\inst{}{mov}{wc,xl}{delimiter two = left paren}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan out function name}
\inst{}{bnz}{wa,sdf02}{jump if left paren found}
\inst{}{erb}{083,define first}{argument is missing a left paren}
\lnie
\endln
\lnie
here after scanning out function name\endln
\lnie
\endln
\inst{sdf02}{jsr}{gtnvr}{get variable name}
\inst{}{err}{084,define first}{argument has null function name}
\inst{}{mov}{xr,defvr}{save vrblk pointer for function nam}
\inst{}{zer}{wb}{zero count of arguments}
\inst{}{mov}{xs,defxs}{save initial stack pointer}
\inst{}{bnz}{deflb,sdf03}{jump if second argument given}
\inst{}{mov}{xr,deflb}{else default is function name}
\lnie
\endln
\lnie
loop to scan argument names and stack vrblk pointers\endln
\lnie
\endln
\inst{sdf03}{mov}{=ch$rp,wc}{delimiter one = right paren}
\inst{}{mov}{=ch$cm,xl}{delimiter two = comma}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan out next argument name}
\inst{}{bnz}{wa,sdf04}{skip if delimiter found}
\inst{}{erb}{085,null arg name}{or missing ) in define first arg.}
\vfill\break

\lnie
\endln
\lnie
define (continued)\endln
\lnie
\endln
\lnie
here after scanning an argument name\endln
\lnie
\endln
\inst{sdf04}{bne}{xr,=nulls,sdf05}{skip if non-null}
\inst{}{bze}{wb,sdf06}{ignore null if case of no arguments}
\lnie
\endln
\lnie
here after dealing with the case of no arguments\endln
\lnie
\endln
\inst{sdf05}{jsr}{gtnvr}{get vrblk pointer}
\inst{}{ppm}{sdf03}{loop back to ignore null name}
\inst{}{mov}{xr,-(xs)}{stack argument vrblk pointer}
\inst{}{icv}{wb}{increment counter}
\inst{}{beq}{wa,=num02,sdf03}{loop back if stopped by a comma}
\lnie
\endln
\lnie
here after scanning out function argument names\endln
\lnie
\endln
\inst{sdf06}{mov}{wb,defna}{save number of arguments}
\inst{}{zer}{wb}{zero count of locals}
\lnie
\endln
\lnie
loop to scan local names and stack vrblk pointers\endln
\lnie
\endln
\inst{sdf07}{mov}{=ch$cm,wc}{set delimiter one = comma}
\inst{}{mov}{wc,xl}{set delimiter two = comma}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan out next local name}
\inst{}{bne}{xr,=nulls,sdf08}{skip if non-null}
\inst{}{bze}{wa,sdf09}{exit scan if end of string}
\lnie
\endln
\lnie
here after scanning out a local name\endln
\lnie
\endln
\inst{sdf08}{jsr}{gtnvr}{get vrblk pointer}
\inst{}{ppm}{sdf07}{loop back to ignore null name}
\inst{}{icv}{wb}{if ok, increment count}
\inst{}{mov}{xr,-(xs)}{stack vrblk pointer}
\inst{}{bnz}{wa,sdf07}{loop back if stopped by a comma}
\vfill\break

\lnie
\endln
\lnie
define (continued)\endln
\lnie
\endln
\lnie
here after scanning locals, build pfblk\endln
\lnie
\endln
\inst{sdf09}{mov}{wb,wa}{copy count of locals}
\inst{}{add}{defna,wa}{add number of arguments}
\inst{}{mov}{wa,wc}{set sum args+locals as loop count}
\inst{}{add}{=pfsi$,wa}{add space for standard fields}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{jsr}{alloc}{allocate space for pfblk}
\inst{}{mov}{xr,xl}{save pointer to pfblk}
\inst{}{mov}{=b$pfc,(xr)+}{store first word}
\inst{}{mov}{defna,(xr)+}{store number of arguments}
\inst{}{mov}{wa,(xr)+}{store length (pflen)}
\inst{}{mov}{defvr,(xr)+}{store vrblk ptr for function name}
\inst{}{mov}{wb,(xr)+}{store number of locals}
\inst{}{zer}{(xr)+}{deal with label later}
\inst{}{zer}{(xr)+}{zero pfctr}
\inst{}{zer}{(xr)+}{zero pfrtr}
\inst{}{bze}{wc,sdf11}{skip if no args or locals}
\inst{}{mov}{xl,wa}{keep pfblk pointer}
\inst{}{mov}{defxs,xt}{point before arguments}
\inst{}{lct}{wc,wc}{get count of args+locals for loop}
\lnie
\endln
\lnie
loop to move locals and args to pfblk\endln
\lnie
\endln
\inst{sdf10}{mov}{-(xt),(xr)+}{store one entry and bump pointers}
\inst{}{bct}{wc,sdf10}{loop till all stored}
\inst{}{mov}{wa,xl}{recover pfblk pointer}
\vfill\break

\lnie
\endln
\lnie
define (continued)\endln
\lnie
\endln
\lnie
now deal with label\endln
\lnie
\endln
\inst{sdf11}{mov}{defxs,xs}{pop stack}
\inst{}{mov}{deflb,pfcod(xl)}{store label vrblk in pfblk}
\inst{}{mov}{defvr,xr}{point back to vrblk for function}
\inst{}{jsr}{dffnc}{define function}
\inst{}{brn}{exnul}{and exit returning null}
\lnie
\endln
\lnie
here for erroneous label\endln
\lnie
\endln
\inst{sdf12}{erb}{086,define function}{entry point is not defined label}
\vfill\break

\lnie
\endln
\lnie
detach\endln
\lnie
\endln
\inst{s$det}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{jsr}{gtvar}{locate variable}
\inst{}{err}{087,detach argument}{is not appropriate name}
\inst{}{jsr}{dtach}{detach i/o association from name}
\inst{}{brn}{exnul}{return null result}
\vfill\break

\lnie
\endln
\lnie
differ\endln
\lnie
\endln
\inst{s$dif}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load second argument}
\inst{}{mov}{(xs)+,xl}{load first argument}
\inst{}{jsr}{ident}{call ident comparison routine}
\inst{}{ppm}{exfal}{fail if ident}
\inst{}{brn}{exnul}{return null if differ}
\vfill\break

\lnie
\endln
\lnie
dump\endln
\lnie
\endln
\inst{s$dmp}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{load dump arg as small integer}
\inst{}{err}{088,dump argument}{is not integer}
\inst{}{err}{089,dump argument}{is negative or too large}
\inst{}{jsr}{dumpr}{else call dump routine}
\inst{}{brn}{exnul}{and return null as result}
\vfill\break

\lnie
\endln
\lnie
dupl\endln
\lnie
\endln
\inst{s$dup}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{get second argument as small integr}
\inst{}{err}{090,dupl second argument}{is not integer}
\inst{}{ppm}{sdup7}{jump if negative or too big}
\inst{}{mov}{xr,wb}{save duplication factor}
\inst{}{jsr}{gtstg}{get first arg as string}
\inst{}{ppm}{sdup4}{jump if not a string}
\lnie
\endln
\lnie
here for case of duplication of a string\endln
\lnie
\endln
\inst{}{mti}{wa}{acquire length as integer}
\inst{}{sti}{dupsi}{save for the moment}
\inst{}{mti}{wb}{get duplication factor as integer}
\inst{}{mli}{dupsi}{form product}
\inst{}{iov}{sdup3}{jump if overflow}
\inst{}{ieq}{exnul}{return null if result length = 0}
\inst{}{mfi}{wa,sdup3}{get as addr integer, check ovflo}
\lnie
\endln
\lnie
merge here with result length in wa\endln
\lnie
\endln
\inst{sdup1}{mov}{xr,xl}{save string pointer}
\inst{}{jsr}{alocs}{allocate space for string}
\inst{}{mov}{xr,-(xs)}{save as result pointer}
\inst{}{mov}{xl,wc}{save pointer to argument string}
\inst{}{psc}{xr}{prepare to store chars of result}
\inst{}{lct}{wb,wb}{set counter to control loop}
\lnie
\endln
\lnie
loop through duplications\endln
\lnie
\endln
\inst{sdup2}{mov}{wc,xl}{point back to argument string}
\inst{}{mov}{sclen(xl),wa}{get number of characters}
\inst{}{plc}{xl}{point to chars in argument string}
\inst{}{mvc}{}{move characters to result string}
\inst{}{bct}{wb,sdup2}{loop till all duplications done}
\inst{}{zer}{xl}{clear garbage value}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
dupl (continued)\endln
\lnie
\endln
\lnie
here if too large, set max length and let alocs catch it\endln
\lnie
\endln
\inst{sdup3}{mov}{dname,wa}{set impossible length for alocs}
\inst{}{brn}{sdup1}{merge back}
\lnie
\endln
\lnie
here if not a string\endln
\lnie
\endln
\inst{sdup4}{jsr}{gtpat}{convert argument to pattern}
\inst{}{err}{091,dupl first argument}{is not a string or pattern}
\lnie
\endln
\lnie
here to duplicate a pattern argument\endln
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{store pattern on stack}
\inst{}{mov}{=ndnth,xr}{start off with null pattern}
\inst{}{bze}{wb,sdup6}{null pattern is result if dupfac=0}
\inst{}{mov}{wb,-(xs)}{preserve loop count}
\lnie
\endln
\lnie
loop to duplicate by successive concatenation\endln
\lnie
\endln
\inst{sdup5}{mov}{xr,xl}{copy current value as right argumnt}
\inst{}{mov}{num01(xs),xr}{get a new copy of left}
\inst{}{jsr}{pconc}{concatenate}
\inst{}{dcv}{(xs)}{count down}
\inst{}{bnz}{(xs),sdup5}{loop}
\inst{}{ica}{xs}{pop loop count}
\lnie
\endln
\lnie
here to exit after constructing pattern\endln
\lnie
\endln
\inst{sdup6}{mov}{xr,(xs)}{store result on stack}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\lnie
\endln
\lnie
fail if second arg is out of range\endln
\lnie
\endln
\inst{sdup7}{ica}{xs}{pop first argument}
\inst{}{brn}{exfal}{fail}
\vfill\break

\lnie
\endln
\lnie
eject\endln
\lnie
\endln
\inst{s$ejc}{ent}{}{entry point}
\inst{}{jsr}{iofcb}{call fcblk routine}
\inst{}{err}{092,eject argument}{is not a suitable name}
\inst{}{ppm}{sejc1}{null argument}
\inst{}{err}{093,eject file does}{not exist}
\inst{}{jsr}{sysef}{call eject file function}
\inst{}{err}{093,eject file does}{not exist}
\inst{}{err}{094,eject file does}{not permit page eject}
\inst{}{err}{095,eject caused}{non-recoverable output error}
\inst{}{brn}{exnul}{return null as result}
\lnie
\endln
\lnie
here to eject standard output file\endln
\lnie
\endln
\inst{sejc1}{jsr}{sysep}{call routine to eject printer}
\inst{}{brn}{exnul}{exit with null result}
\vfill\break

\lnie
\endln
\lnie
endfile\endln
\lnie
\endln
\inst{s$enf}{ent}{}{entry point}
\inst{}{jsr}{iofcb}{call fcblk routine}
\inst{}{err}{096,endfile argument}{is not a suitable name}
\inst{}{err}{097,endfile argument}{is null}
\inst{}{err}{098,endfile file}{does not exist}
\inst{}{jsr}{sysen}{call endfile routine}
\inst{}{err}{098,endfile file}{does not exist}
\inst{}{err}{099,endfile file}{does not permit endfile}
\inst{}{err}{100,endfile caused}{non-recoverable output error}
\inst{}{mov}{xl,wb}{remember vrblk ptr from iofcb call}
\inst{}{mov}{xl,xr}{copy pointer}
\lnie
\endln
\lnie
loop to find trtrf block\endln
\lnie
\endln
\inst{senf1}{mov}{xr,xl}{remember previous entry}
\inst{}{mov}{trval(xr),xr}{chain along}
\inst{}{bne}{(xr),=b$trt,exnul}{skip out if chain end}
\inst{}{bne}{trtyp(xr),=trtfc,senf1}{loop if not found}
\inst{}{mov}{trval(xr),trval(xl)}{remove trtrf}
\inst{}{mov}{trtrf(xr),enfch}{point to head of iochn}
\inst{}{mov}{trfpt(xr),wc}{point to fcblk}
\inst{}{mov}{wb,xr}{filearg1 vrblk from iofcb}
\inst{}{jsr}{setvr}{reset it}
\inst{}{mov}{=r$fcb,xl}{ptr to head of fcblk chain}
\inst{}{sub}{*num02,xl}{adjust ready to enter loop}
\lnie
\endln
\lnie
find fcblk\endln
\lnie
\endln
\inst{senf2}{mov}{xl,xr}{copy ptr}
\inst{}{mov}{num02(xl),xl}{get next link}
\inst{}{bze}{xl,senf4}{stop if chain end}
\inst{}{beq}{num03(xl),wc,senf3}{jump if fcblk found}
\inst{}{brn}{senf2}{loop}
\lnie
\endln
\lnie
remove fcblk\endln
\lnie
\endln
\inst{senf3}{mov}{num02(xl),num02(xr)}{delete fcblk from chain}
\lnie
\endln
\lnie
loop which detaches all vbls on iochn chain\endln
\lnie
\endln
\inst{senf4}{mov}{enfch,xl}{get chain head}
\inst{}{bze}{xl,exnul}{finished if chain end}
\inst{}{mov}{trtrf(xl),enfch}{chain along}
\inst{}{mov}{ionmo(xl),wa}{name offset}
\inst{}{mov}{ionmb(xl),xl}{name base}
\inst{}{jsr}{dtach}{detach name}
\inst{}{brn}{senf4}{loop till done}
\vfill\break

\lnie
\endln
\lnie
eq\endln
\lnie
\endln
\inst{s$eqf}{ent}{}{entry point}
\inst{}{jsr}{acomp}{call arithmetic comparison routine}
\inst{}{err}{101,eq first argument}{is not numeric}
\inst{}{err}{102,eq second argument}{is not numeric}
\inst{}{ppm}{exfal}{fail if lt}
\inst{}{ppm}{exnul}{return null if eq}
\inst{}{ppm}{exfal}{fail if gt}
\vfill\break

\lnie
\endln
\lnie
eval\endln
\lnie
\endln
\inst{s$evl}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\ifmac{.cevb}
\asmac{else}
\inst{}{jsr}{gtexp}{convert to expression}
\inst{}{err}{103,eval argument}{is not expression}
\asmac{fi}
\inst{}{lcw}{wc}{load next code word}
\inst{}{bne}{wc,=ofne$,sevl1}{jump if called by value}
\inst{}{scp}{xl}{copy code pointer}
\inst{}{mov}{(xl),wa}{get next code word}
\inst{}{bne}{wa,=ornm$,sevl2}{by name unless expression}
\inst{}{bnz}{num01(xs),sevl2}{jump if by name}
\lnie
\endln
\lnie
here if called by value\endln
\lnie
\endln
\inst{sevl1}{zer}{wb}{set flag for by value}
\ifmac{.cevb}
\inst{}{mov}{wc,-(xs)}{save code word}
\inst{}{jsr}{gtexp}{convert to expression}
\inst{}{err}{103,eval argument}{is not expression}
\inst{}{zer}{r$ccb}{forget interim code block}
\inst{}{zer}{wb}{set flag for by value}
\asmac{else}
\inst{}{mov}{wc,-(xs)}{save code word}
\asmac{fi}
\inst{}{jsr}{evalx}{evaluate expression by value}
\inst{}{ppm}{exfal}{fail if evaluation fails}
\inst{}{mov}{xr,xl}{copy result}
\inst{}{mov}{(xs),xr}{reload next code word}
\inst{}{mov}{xl,(xs)}{stack result}
\inst{}{bri}{(xr)}{jump to execute next code word}
\lnie
\endln
\lnie
here if called by name\endln
\lnie
\endln
\inst{sevl2}{mov}{=num01,wb}{set flag for by name}
\ifmac{.cevb}
\inst{}{jsr}{gtexp}{convert to expression}
\inst{}{err}{103,eval argument}{is not expression}
\inst{}{zer}{r$ccb}{forget interim code block}
\inst{}{mov}{=num01,wb}{set flag for by name}
\asmac{fi}
\inst{}{jsr}{evalx}{evaluate expression by name}
\inst{}{ppm}{exfal}{fail if evaluation fails}
\inst{}{brn}{exnam}{exit with name}
\ifmac{.cnex}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
exit\endln
\lnie
\endln
\inst{s$ext}{ent}{}{entry point}
\inst{}{zer}{wb}{clear amount of static shift}
\inst{}{zer}{r$ccb}{forget interim code block}
\ifmac{.csed}
\inst{}{zer}{dnams}{collect sediment too}
\inst{}{jsr}{gbcol}{compact memory by collecting}
\inst{}{mov}{xr,dnams}{record new sediment size}
\asmac{else}
\inst{}{jsr}{gbcol}{compact memory by collecting}
\asmac{fi}
\inst{}{jsr}{gbcol}{compact memory by collecting}
\inst{}{err}{288,exit second argument}{is not a string}
\inst{}{mov}{xr,xl}{copy second arg string pointer}
\inst{}{jsr}{gtstg}{convert arg to string}
\inst{}{err}{104,exit first argument}{is not suitable integer or string}
\inst{}{mov}{xl,-(xs)}{save second argument}
\inst{}{mov}{xr,xl}{copy first arg string ptr}
\inst{}{jsr}{gtint}{check it is integer}
\inst{}{ppm}{sext1}{skip if unconvertible}
\inst{}{zer}{xl}{note it is integer}
\inst{}{ldi}{icval(xr)}{get integer arg}
\lnie
\endln
\lnie
merge to call osint exit routine\endln
\lnie
\endln
\inst{sext1}{mov}{r$fcb,wb}{get fcblk chain header}
\inst{}{mov}{=headv,xr}{point to v.v string}
\inst{}{mov}{(xs)+,wa}{provide second argument scblk}
\inst{}{jsr}{sysxi}{call external routine}
\inst{}{err}{105,exit action not}{available in this implementation}
\inst{}{err}{106,exit action caused}{irrecoverable error}
\inst{}{ieq}{exnul}{return if argument 0}
\inst{}{igt}{sext2}{skip if positive}
\inst{}{ngi}{}{make positive}
\lnie
\endln
\lnie
check for option respecification\endln
\lnie
\endln
\lnie
sysxi returns 0 in wa when a file has been resumed,\endln
\lnie
1 when this is a continuation of an exit(4) or exit(-4)\endln
\lnie
action.\endln
\lnie
\endln
\inst{sext2}{mfi}{wc}{get value in work reg}
\inst{}{add}{wc,wa}{prepare to test for continue}
\inst{}{beq}{wa,=num05,sext5}{continued execution if 4 plus 1}
\inst{}{zer}{gbcnt}{resuming execution so reset}
\inst{}{bge}{wc,=num03,sext3}{skip if was 3 or 4}
\inst{}{mov}{wc,-(xs)}{save value}
\inst{}{zer}{wc}{set to read options}
\inst{}{jsr}{prpar}{read syspp options}
\inst{}{mov}{(xs)+,wc}{restore value}
\lnie
\endln
\lnie
deal with header option (fiddled by prpar)\endln
\lnie
\endln
\inst{sext3}{mnz}{headp}{assume no headers}
\inst{}{bne}{wc,=num01,sext4}{skip if not 1}
\inst{}{zer}{headp}{request header printing}
\lnie
\endln
\lnie
almost ready to resume running\endln
\lnie
\endln
\inst{sext4}{jsr}{systm}{get execution time start (sgd11)}
\inst{}{sti}{timsx}{save as initial time}
\inst{}{ldi}{kvstc}{reset to ensure ...}
\inst{}{sti}{kvstl}{... correct execution stats}
\inst{}{jsr}{stgcc}{recompute countdown counters}
\inst{}{brn}{exnul}{resume execution}
\lnie
\endln
\lnie
here after exit(4) or exit(-4) -- create save file\endln
\lnie
or load module and continue execution.\endln
\lnie
\endln
\lnie
return integer 1 to signal the continuation of the\endln
\lnie
original execution.\endln
\lnie
\endln
\inst{sext5}{mov}{=inton,xr}{integer one}
\inst{}{brn}{exixr}{return as result}
\asmac{fi}
\vfill\break

\ifmac{.cmth}
\lnie
\endln
\lnie
exp\endln
\lnie
\endln
\inst{s$exp}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{304,exp argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{etx}{}{take exponential}
\inst{}{rno}{exrea}{if no overflow, return result in ra}
\inst{}{erb}{305,exp produced}{real overflow}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
field\endln
\lnie
\endln
\inst{s$fld}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{get second argument (field number)}
\inst{}{err}{107,field second}{argument is not integer}
\inst{}{ppm}{exfal}{fail if out of range}
\inst{}{mov}{xr,wb}{else save integer value}
\inst{}{mov}{(xs)+,xr}{load first argument}
\inst{}{jsr}{gtnvr}{point to vrblk}
\inst{}{ppm}{sfld1}{jump (error) if not variable name}
\inst{}{mov}{vrfnc(xr),xr}{else point to function block}
\inst{}{bne}{(xr),=b$dfc,sfld1}{error if not datatype function}
\lnie
\endln
\lnie
here if first argument is a datatype function name\endln
\lnie
\endln
\inst{}{bze}{wb,exfal}{fail if argument number is zero}
\inst{}{bgt}{wb,fargs(xr),exfal}{fail if too large}
\inst{}{wtb}{wb}{else convert to byte offset}
\inst{}{add}{wb,xr}{point to field name}
\inst{}{mov}{dfflb(xr),xr}{load vrblk pointer}
\inst{}{brn}{exvnm}{exit to build nmblk}
\lnie
\endln
\lnie
here for bad first argument\endln
\lnie
\endln
\inst{sfld1}{erb}{108,field first argument}{is not datatype name}
\vfill\break

\lnie
\endln
\lnie
fence\endln
\lnie
\endln
\inst{s$fnc}{ent}{}{entry point}
\inst{}{mov}{=p$fnc,wb}{set pcode for p$fnc}
\inst{}{zer}{xr}{p0blk}
\inst{}{jsr}{pbild}{build p$fnc node}
\inst{}{mov}{xr,xl}{save pointer to it}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtpat}{convert to pattern}
\inst{}{err}{259,fence argument}{is not pattern}
\inst{}{jsr}{pconc}{concatenate to p$fnc node}
\inst{}{mov}{xr,xl}{save ptr to concatenated pattern}
\inst{}{mov}{=p$fna,wb}{set for p$fna pcode}
\inst{}{zer}{xr}{p0blk}
\inst{}{jsr}{pbild}{construct p$fna node}
\inst{}{mov}{xl,pthen(xr)}{set pattern as pthen}
\inst{}{mov}{xr,-(xs)}{set as result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute next code word}
\vfill\break

\lnie
\endln
\lnie
ge\endln
\lnie
\endln
\inst{s$gef}{ent}{}{entry point}
\inst{}{jsr}{acomp}{call arithmetic comparison routine}
\inst{}{err}{109,ge first argument}{is not numeric}
\inst{}{err}{110,ge second argument}{is not numeric}
\inst{}{ppm}{exfal}{fail if lt}
\inst{}{ppm}{exnul}{return null if eq}
\inst{}{ppm}{exnul}{return null if gt}
\vfill\break

\lnie
\endln
\lnie
gt\endln
\lnie
\endln
\inst{s$gtf}{ent}{}{entry point}
\inst{}{jsr}{acomp}{call arithmetic comparison routine}
\inst{}{err}{111,gt first argument}{is not numeric}
\inst{}{err}{112,gt second argument}{is not numeric}
\inst{}{ppm}{exfal}{fail if lt}
\inst{}{ppm}{exfal}{fail if eq}
\inst{}{ppm}{exnul}{return null if gt}
\vfill\break

\lnie
\endln
\lnie
host\endln
\lnie
\endln
\inst{s$hst}{ent}{}{entry point}
\inst{}{mov}{(xs)+,wc}{get fifth arg}
\inst{}{mov}{(xs)+,wb}{get fourth arg}
\inst{}{mov}{(xs)+,xr}{get third arg}
\inst{}{mov}{(xs)+,xl}{get second arg}
\inst{}{mov}{(xs)+,wa}{get first arg}
\inst{}{jsr}{syshs}{enter syshs routine}
\inst{}{err}{254,erroneous argument}{for host}
\inst{}{err}{255,error during}{execution of host}
\inst{}{ppm}{shst1}{store host string}
\inst{}{ppm}{exnul}{return null result}
\inst{}{ppm}{exixr}{return xr}
\inst{}{ppm}{exfal}{fail return}
\inst{}{ppm}{shst3}{store actual string}
\inst{}{ppm}{shst4}{return copy of xr}
\lnie
\endln
\lnie
return host string\endln
\lnie
\endln
\inst{shst1}{bze}{xl,exnul}{null string if syshs uncooperative}
\inst{}{mov}{sclen(xl),wa}{length}
\inst{}{zer}{wb}{zero offset}
\lnie
\endln
\lnie
copy string and return\endln
\lnie
\endln
\inst{shst2}{jsr}{sbstr}{build copy of string}
\inst{}{mov}{xr,-(xs)}{stack the result}
\inst{}{lcw}{xr}{load next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
return actual string pointed to by xl\endln
\lnie
\endln
\inst{shst3}{zer}{wb}{treat xl like an scblk ptr}
\inst{}{sub}{=cfp$f,wb}{by creating a negative offset}
\inst{}{brn}{shst2}{join to copy string}
\lnie
\endln
\lnie
return copy of block pointed to by xr\endln
\lnie
\endln
\inst{shst4}{mov}{xr,-(xs)}{stack results}
\inst{}{jsr}{copyb}{make copy of block}
\inst{}{ppm}{exits}{if not an aggregate structure}
\inst{}{brn}{exsid}{set current id value otherwise}
\vfill\break

\lnie
\endln
\lnie
ident\endln
\lnie
\endln
\inst{s$idn}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load second argument}
\inst{}{mov}{(xs)+,xl}{load first argument}
\inst{}{jsr}{ident}{call ident comparison routine}
\inst{}{ppm}{exnul}{return null if ident}
\inst{}{brn}{exfal}{fail if differ}
\vfill\break

\lnie
\endln
\lnie
input\endln
\lnie
\endln
\inst{s$inp}{ent}{}{entry point}
\inst{}{zer}{wb}{input flag}
\inst{}{jsr}{ioput}{call input/output assoc. routine}
\inst{}{err}{113,input third argument}{is not a string}
\inst{}{err}{114,inappropriate}{second argument for input}
\inst{}{err}{115,inappropriate}{first argument for input}
\inst{}{err}{116,inappropriate}{file specification for input}
\inst{}{ppm}{exfal}{fail if file does not exist}
\inst{}{err}{117,input file cannot}{be read}
\inst{}{err}{289,input channel}{currently in use}
\inst{}{brn}{exnul}{return null string}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
insert\endln
\lnie
\endln
\inst{s$ins}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xl}{get string arg}
\inst{}{jsr}{gtsmi}{get replace length}
\inst{}{err}{277,insert third}{argument not integer}
\inst{}{ppm}{exfal}{fail if out of range}
\inst{}{mov}{wc,wb}{copy to proper reg}
\inst{}{jsr}{gtsmi}{get replace position}
\inst{}{err}{278,insert second}{argument not integer}
\inst{}{ppm}{exfal}{fail if out of range}
\inst{}{bze}{wc,exfal}{fail if zero}
\inst{}{dcv}{wc}{decrement to get offset}
\inst{}{mov}{wc,wa}{put in proper register}
\inst{}{mov}{(xs)+,xr}{get buffer}
\inst{}{beq}{(xr),=b$bct,sins1}{press on if type ok}
\inst{}{erb}{279,insert first}{argument is not a buffer}
\lnie
\endln
\lnie
here when everything loaded up\endln
\lnie
\endln
\inst{sins1}{jsr}{insbf}{call to insert}
\inst{}{err}{280,insert fourth}{argument is not a string}
\inst{}{ppm}{exfal}{fail if out of range}
\inst{}{brn}{exnul}{else ok - exit with null}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
integer\endln
\lnie
\endln
\inst{s$int}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{jsr}{gtnum}{convert to numeric}
\inst{}{ppm}{exfal}{fail if non-numeric}
\inst{}{beq}{wa,=b$icl,exnul}{return null if integer}
\inst{}{brn}{exfal}{fail if real}
\vfill\break

\lnie
\endln
\lnie
item\endln
\lnie
\endln
\lnie
item does not permit the direct (fast) call so that\endln
\lnie
wa contains the actual number of arguments passed.\endln
\lnie
\endln
\inst{s$itm}{ent}{}{entry point}
\lnie
\endln
\lnie
deal with case of no args\endln
\lnie
\endln
\inst{}{bnz}{wa,sitm1}{jump if at least one arg}
\inst{}{mov}{=nulls,-(xs)}{else supply garbage null arg}
\inst{}{mov}{=num01,wa}{and fix argument count}
\lnie
\endln
\lnie
check for name/value cases\endln
\lnie
\endln
\inst{sitm1}{scp}{xr}{get current code pointer}
\inst{}{mov}{(xr),xl}{load next code word}
\inst{}{dcv}{wa}{get number of subscripts}
\inst{}{mov}{wa,xr}{copy for arref}
\inst{}{beq}{xl,=ofne$,sitm2}{jump if called by name}
\lnie
\endln
\lnie
here if called by value\endln
\lnie
\endln
\inst{}{zer}{wb}{set code for call by value}
\inst{}{brn}{arref}{off to array reference routine}
\lnie
\endln
\lnie
here for call by name\endln
\lnie
\endln
\inst{sitm2}{mnz}{wb}{set code for call by name}
\inst{}{lcw}{wa}{load and ignore ofne$ call}
\inst{}{brn}{arref}{off to array reference routine}
\vfill\break

\lnie
\endln
\lnie
le\endln
\lnie
\endln
\inst{s$lef}{ent}{}{entry point}
\inst{}{jsr}{acomp}{call arithmetic comparison routine}
\inst{}{err}{118,le first argument}{is not numeric}
\inst{}{err}{119,le second argument}{is not numeric}
\inst{}{ppm}{exnul}{return null if lt}
\inst{}{ppm}{exnul}{return null if eq}
\inst{}{ppm}{exfal}{fail if gt}
\vfill\break

\lnie
\endln
\lnie
len\endln
\lnie
\endln
\inst{s$len}{ent}{}{entry point}
\inst{}{mov}{=p$len,wb}{set pcode for integer arg case}
\inst{}{mov}{=p$lnd,wa}{set pcode for expr arg case}
\inst{}{jsr}{patin}{call common routine to build node}
\inst{}{err}{120,len argument}{is not integer or expression}
\inst{}{err}{121,len argument}{is negative or too large}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
leq\endln
\lnie
\endln
\inst{s$leq}{ent}{}{entry point}
\inst{}{jsr}{lcomp}{call string comparison routine}
\inst{}{err}{122,leq first argument}{is not a string}
\inst{}{err}{123,leq second argument}{is not a string}
\inst{}{ppm}{exfal}{fail if llt}
\inst{}{ppm}{exnul}{return null if leq}
\inst{}{ppm}{exfal}{fail if lgt}
\vfill\break

\lnie
\endln
\lnie
lge\endln
\lnie
\endln
\inst{s$lge}{ent}{}{entry point}
\inst{}{jsr}{lcomp}{call string comparison routine}
\inst{}{err}{124,lge first argument}{is not a string}
\inst{}{err}{125,lge second argument}{is not a string}
\inst{}{ppm}{exfal}{fail if llt}
\inst{}{ppm}{exnul}{return null if leq}
\inst{}{ppm}{exnul}{return null if lgt}
\vfill\break

\lnie
\endln
\lnie
lgt\endln
\lnie
\endln
\inst{s$lgt}{ent}{}{entry point}
\inst{}{jsr}{lcomp}{call string comparison routine}
\inst{}{err}{126,lgt first argument}{is not a string}
\inst{}{err}{127,lgt second argument}{is not a string}
\inst{}{ppm}{exfal}{fail if llt}
\inst{}{ppm}{exfal}{fail if leq}
\inst{}{ppm}{exnul}{return null if lgt}
\vfill\break

\lnie
\endln
\lnie
lle\endln
\lnie
\endln
\inst{s$lle}{ent}{}{entry point}
\inst{}{jsr}{lcomp}{call string comparison routine}
\inst{}{err}{128,lle first argument}{is not a string}
\inst{}{err}{129,lle second argument}{is not a string}
\inst{}{ppm}{exnul}{return null if llt}
\inst{}{ppm}{exnul}{return null if leq}
\inst{}{ppm}{exfal}{fail if lgt}
\vfill\break

\lnie
\endln
\lnie
llt\endln
\lnie
\endln
\inst{s$llt}{ent}{}{entry point}
\inst{}{jsr}{lcomp}{call string comparison routine}
\inst{}{err}{130,llt first argument}{is not a string}
\inst{}{err}{131,llt second argument}{is not a string}
\inst{}{ppm}{exnul}{return null if llt}
\inst{}{ppm}{exfal}{fail if leq}
\inst{}{ppm}{exfal}{fail if lgt}
\vfill\break

\lnie
\endln
\lnie
lne\endln
\lnie
\endln
\inst{s$lne}{ent}{}{entry point}
\inst{}{jsr}{lcomp}{call string comparison routine}
\inst{}{err}{132,lne first argument}{is not a string}
\inst{}{err}{133,lne second argument}{is not a string}
\inst{}{ppm}{exnul}{return null if llt}
\inst{}{ppm}{exfal}{fail if leq}
\inst{}{ppm}{exnul}{return null if lgt}
\vfill\break

\ifmac{.cmth}
\lnie
\endln
\lnie
ln\endln
\lnie
\endln
\inst{s$lnf}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{306,ln argument not}{numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{req}{slnf1}{overflow if argument is 0}
\inst{}{rlt}{slnf2}{error if argument less than 0}
\inst{}{lnf}{}{take natural logarithm}
\inst{}{rno}{exrea}{if no overflow, return result in ra}
\inst{slnf1}{erb}{307,ln produced real}{overflow}
\lnie
\endln
\lnie
here for bad argument\endln
\lnie
\endln
\inst{slnf2}{erb}{307,ln produced realreal}{}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
local\endln
\lnie
\endln
\inst{s$loc}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{get second argument (local number)}
\inst{}{err}{134,local second}{argument is not integer}
\inst{}{ppm}{exfal}{fail if out of range}
\inst{}{mov}{xr,wb}{save local number}
\inst{}{mov}{(xs)+,xr}{load first argument}
\inst{}{jsr}{gtnvr}{point to vrblk}
\inst{}{ppm}{sloc1}{jump if not variable name}
\inst{}{mov}{vrfnc(xr),xr}{else load function pointer}
\inst{}{bne}{(xr),=b$pfc,sloc1}{jump if not program defined}
\lnie
\endln
\lnie
here if we have a program defined function name\endln
\lnie
\endln
\inst{}{bze}{wb,exfal}{fail if second arg is zero}
\inst{}{bgt}{wb,pfnlo(xr),exfal}{or too large}
\inst{}{add}{fargs(xr),wb}{else adjust offset to include args}
\inst{}{wtb}{wb}{convert to bytes}
\inst{}{add}{wb,xr}{point to local pointer}
\inst{}{mov}{pfagb(xr),xr}{load vrblk pointer}
\inst{}{brn}{exvnm}{exit building nmblk}
\lnie
\endln
\lnie
here if first argument is no good\endln
\lnie
\endln
\inst{sloc1}{erb}{135,local first arg}{is not a program function name}
\ifmac{.cnld}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
load\endln
\lnie
\endln
\inst{s$lod}{ent}{}{entry point}
\inst{}{jsr}{gtstg}{load library name}
\inst{}{err}{136,load second argument}{is not a string}
\inst{}{mov}{xr,xl}{save library name}
\inst{}{jsr}{xscni}{prepare to scan first argument}
\inst{}{err}{137,load first argument}{is not a string}
\inst{}{err}{138,load first argument}{is null}
\inst{}{mov}{xl,-(xs)}{stack library name}
\inst{}{mov}{=ch$pp,wc}{set delimiter one = left paren}
\inst{}{mov}{wc,xl}{set delimiter two = left paren}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan function name}
\inst{}{mov}{xr,-(xs)}{save ptr to function name}
\inst{}{bnz}{wa,slod1}{jump if left paren found}
\inst{}{erb}{139,load first argument}{is missing a left paren}
\lnie
\endln
\lnie
here after successfully scanning function name\endln
\lnie
\endln
\inst{slod1}{jsr}{gtnvr}{locate vrblk}
\inst{}{err}{140,load first argument}{has null function name}
\inst{}{mov}{xr,lodfn}{save vrblk pointer}
\inst{}{zer}{lodna}{zero count of arguments}
\lnie
\endln
\lnie
loop to scan argument datatype names\endln
\lnie
\endln
\inst{slod2}{mov}{=ch$rp,wc}{delimiter one is right paren}
\inst{}{mov}{=ch$cm,xl}{delimiter two is comma}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan next argument name}
\inst{}{icv}{lodna}{bump argument count}
\inst{}{bnz}{wa,slod3}{jump if ok delimiter was found}
\inst{}{erb}{141,load first argument}{is missing a right paren}
\vfill\break

\lnie
\endln
\lnie
load (continued)\endln
\lnie
\endln
\lnie
come here to analyze the datatype pointer in (xr). this\endln
\lnie
code is used both for arguments (wa=1,2) and for the\endln
\lnie
result datatype (with wa set to zero).\endln
\lnie
\endln
\ifmac{.culc}
\inst{slod3}{mov}{wa,wb}{save scan mode}
\inst{}{mov}{sclen(xr),wa}{datatype length}
\inst{}{bze}{wa,sld3a}{bypass if null string}
\inst{}{jsr}{flstg}{fold to upper case}
\inst{sld3a}{mov}{wb,wa}{restore scan mode}
\inst{}{mov}{xr,-(xs)}{stack datatype name pointer}
\asmac{else}
\inst{slod3}{mov}{xr,-(xs)}{stack datatype name pointer}
\asmac{fi}
\inst{}{mov}{=num01,wb}{set string code in case}
\inst{}{mov}{=scstr,xl}{point to /string/}
\inst{}{jsr}{ident}{check for match}
\inst{}{ppm}{slod4}{jump if match}
\inst{}{mov}{(xs),xr}{else reload name}
\inst{}{add}{wb,wb}{set code for integer (2)}
\inst{}{mov}{=scint,xl}{point to /integer/}
\inst{}{jsr}{ident}{check for match}
\inst{}{ppm}{slod4}{jump if match}
\ifmac{.cnra}
\asmac{else}
\inst{}{mov}{(xs),xr}{else reload string pointer}
\inst{}{icv}{wb}{set code for real (3)}
\inst{}{mov}{=screa,xl}{point to /real/}
\inst{}{jsr}{ident}{check for match}
\inst{}{ppm}{slod4}{jump if match}
\asmac{fi}
\ifmac{.cnlf}
\inst{}{mov}{(xs),xr}{reload string pointer}
\inst{}{icv}{wb}{code for file (4, or 3 if no reals)}
\inst{}{mov}{=scfil,xl}{point to /file/}
\inst{}{jsr}{ident}{check for match}
\inst{}{ppm}{slod4}{jump if match}
\asmac{fi}
\inst{}{zer}{wb}{else get code for no convert}
\lnie
\endln
\lnie
merge here with proper datatype code in wb\endln
\lnie
\endln
\inst{slod4}{mov}{wb,(xs)}{store code on stack}
\inst{}{beq}{wa,=num02,slod2}{loop back if arg stopped by comma}
\inst{}{bze}{wa,slod5}{jump if that was the result type}
\lnie
\endln
\lnie
here we scan out the result type (arg stopped by ) )\endln
\lnie
\endln
\inst{}{mov}{mxlen,wc}{set dummy (impossible) delimiter 1}
\inst{}{mov}{wc,xl}{and delimiter two}
\inst{}{mnz}{wa}{skip/trim blanks in prototype}
\inst{}{jsr}{xscan}{scan result name}
\inst{}{zer}{wa}{set code for processing result}
\inst{}{brn}{slod3}{jump back to process result name}
\vfill\break

\lnie
\endln
\lnie
load (continued)\endln
\lnie
\endln
\lnie
here after processing all args and result\endln
\lnie
\endln
\inst{slod5}{mov}{lodna,wa}{get number of arguments}
\inst{}{mov}{wa,wc}{copy for later}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{add}{*efsi$,wa}{add space for standard fields}
\inst{}{jsr}{alloc}{allocate efblk}
\inst{}{mov}{=b$efc,(xr)}{set type word}
\inst{}{mov}{wc,fargs(xr)}{set number of arguments}
\inst{}{zer}{efuse(xr)}{set use count (dffnc will set to 1)}
\inst{}{zer}{efcod(xr)}{zero code pointer for now}
\inst{}{mov}{(xs)+,efrsl(xr)}{store result type code}
\inst{}{mov}{lodfn,efvar(xr)}{store function vrblk pointer}
\inst{}{mov}{wa,eflen(xr)}{store efblk length}
\inst{}{mov}{xr,wb}{save efblk pointer}
\inst{}{add}{wa,xr}{point past end of efblk}
\inst{}{lct}{wc,wc}{set number of arguments for loop}
\lnie
\endln
\lnie
loop to set argument type codes from stack\endln
\lnie
\endln
\inst{slod6}{mov}{(xs)+,-(xr)}{store one type code from stack}
\inst{}{bct}{wc,slod6}{loop till all stored}
\lnie
\endln
\lnie
now load the external function and perform definition\endln
\lnie
\endln
\inst{}{mov}{(xs)+,xr}{load function string name}
\ifmac{.culc}
\inst{}{mov}{sclen(xr),wa}{function name length}
\inst{}{jsr}{flstg}{fold to upper case}
\asmac{fi}
\inst{}{mov}{(xs),xl}{load library name}
\inst{}{mov}{wb,(xs)}{store efblk pointer}
\inst{}{jsr}{sysld}{call function to load external func}
\inst{}{err}{142,load function}{does not exist}
\inst{}{err}{143,load function}{caused input error during load}
\inst{}{err}{328,load function}{- insufficient memory}
\inst{}{mov}{(xs)+,xl}{recall efblk pointer}
\inst{}{mov}{xr,efcod(xl)}{store code pointer}
\inst{}{mov}{lodfn,xr}{point to vrblk for function}
\inst{}{jsr}{dffnc}{perform function definition}
\inst{}{brn}{exnul}{return null result}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
lpad\endln
\lnie
\endln
\inst{s$lpd}{ent}{}{entry point}
\inst{}{jsr}{gtstg}{get pad character}
\inst{}{err}{144,lpad third argument}{is not a string}
\inst{}{plc}{xr}{point to character (null is blank)}
\inst{}{lch}{wb,(xr)}{load pad character}
\inst{}{jsr}{gtsmi}{get pad length}
\inst{}{err}{145,lpad second argument}{is not integer}
\inst{}{ppm}{slpd4}{skip if negative or large}
\lnie
\endln
\lnie
merge to check first arg\endln
\lnie
\endln
\inst{slpd1}{jsr}{gtstg}{get first argument (string to pad)}
\inst{}{err}{146,lpad first argument}{is not a string}
\inst{}{bge}{wa,wc,exixr}{return 1st arg if too long to pad}
\inst{}{mov}{xr,xl}{else move ptr to string to pad}
\lnie
\endln
\lnie
now we are ready for the pad\endln
\lnie
\endln
\lnie
(xl)                  pointer to string to pad\endln
\lnie
(wb)                  pad character\endln
\lnie
(wc)                  length to pad string to\endln
\lnie
\endln
\inst{}{mov}{wc,wa}{copy length}
\inst{}{jsr}{alocs}{allocate scblk for new string}
\inst{}{mov}{xr,-(xs)}{save as result}
\inst{}{mov}{sclen(xl),wa}{load length of argument}
\inst{}{sub}{wa,wc}{calculate number of pad characters}
\inst{}{psc}{xr}{point to chars in result string}
\inst{}{lct}{wc,wc}{set counter for pad loop}
\lnie
\endln
\lnie
loop to perform pad\endln
\lnie
\endln
\inst{slpd2}{sch}{wb,(xr)+}{store pad character, bump ptr}
\inst{}{bct}{wc,slpd2}{loop till all pad chars stored}
\inst{}{csc}{xr}{complete store characters}
\lnie
\endln
\lnie
now copy string\endln
\lnie
\endln
\inst{}{bze}{wa,slpd3}{exit if null string}
\inst{}{plc}{xl}{else point to chars in argument}
\inst{}{mvc}{}{move characters to result string}
\inst{}{zer}{xl}{clear garbage xl}
\lnie
\endln
\lnie
here to exit with result on stack\endln
\lnie
\endln
\inst{slpd3}{lcw}{xr}{load next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
here if 2nd arg is negative or large\endln
\lnie
\endln
\inst{slpd4}{zer}{wc}{zero pad count}
\inst{}{brn}{slpd1}{merge}
\vfill\break

\lnie
\endln
\lnie
lt\endln
\lnie
\endln
\inst{s$ltf}{ent}{}{entry point}
\inst{}{jsr}{acomp}{call arithmetic comparison routine}
\inst{}{err}{147,lt first argument}{is not numeric}
\inst{}{err}{148,lt second argument}{is not numeric}
\inst{}{ppm}{exnul}{return null if lt}
\inst{}{ppm}{exfal}{fail if eq}
\inst{}{ppm}{exfal}{fail if gt}
\vfill\break

\lnie
\endln
\lnie
ne\endln
\lnie
\endln
\inst{s$nef}{ent}{}{entry point}
\inst{}{jsr}{acomp}{call arithmetic comparison routine}
\inst{}{err}{149,ne first argument}{is not numeric}
\inst{}{err}{150,ne second argument}{is not numeric}
\inst{}{ppm}{exnul}{return null if lt}
\inst{}{ppm}{exfal}{fail if eq}
\inst{}{ppm}{exnul}{return null if gt}
\vfill\break

\lnie
\endln
\lnie
notany\endln
\lnie
\endln
\inst{s$nay}{ent}{}{entry point}
\inst{}{mov}{=p$nas,wb}{set pcode for single char arg}
\inst{}{mov}{=p$nay,xl}{pcode for multi-char arg}
\inst{}{mov}{=p$nad,wc}{set pcode for expr arg}
\inst{}{jsr}{patst}{call common routine to build node}
\inst{}{err}{151,notany argument}{is not a string or expression}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
opsyn\endln
\lnie
\endln
\inst{s$ops}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{load third argument}
\inst{}{err}{152,opsyn third argument}{is not integer}
\inst{}{err}{153,opsyn third argument}{is negative or too large}
\inst{}{mov}{wc,wb}{if ok, save third argumnet}
\inst{}{mov}{(xs)+,xr}{load second argument}
\inst{}{jsr}{gtnvr}{locate variable block}
\inst{}{err}{154,opsyn second}{arg is not natural variable name}
\inst{}{mov}{vrfnc(xr),xl}{if ok, load function block pointer}
\inst{}{bnz}{wb,sops2}{jump if operator opsyn case}
\lnie
\endln
\lnie
here for function opsyn (third arg zero)\endln
\lnie
\endln
\inst{}{mov}{(xs)+,xr}{load first argument}
\inst{}{jsr}{gtnvr}{get vrblk pointer}
\inst{}{err}{155,opsyn first arg}{is not natural variable name}
\lnie
\endln
\lnie
merge here to perform function definition\endln
\lnie
\endln
\inst{sops1}{jsr}{dffnc}{call function definer}
\inst{}{brn}{exnul}{exit with null result}
\lnie
\endln
\lnie
here for operator opsyn (third arg non-zero)\endln
\lnie
\endln
\inst{sops2}{jsr}{gtstg}{get operator name}
\inst{}{ppm}{sops5}{jump if not string}
\inst{}{bne}{wa,=num01,sops5}{error if not one char long}
\inst{}{plc}{xr}{else point to character}
\inst{}{lch}{wc,(xr)}{load character name}
\vfill\break

\lnie
\endln
\lnie
opsyn (continued)\endln
\lnie
\endln
\lnie
now set to search for matching unary or binary operator\endln
\lnie
name as appropriate. note that there are =opbun undefined\endln
\lnie
binary operators and =opuun undefined unary operators.\endln
\lnie
\endln
\inst{}{mov}{=r$uub,wa}{point to unop pointers in case}
\inst{}{mov}{=opnsu,xr}{point to names of unary operators}
\inst{}{add}{=opbun,wb}{add no. of undefined binary ops}
\inst{}{beq}{wb,=opuun,sops3}{jump if unop (third arg was 1)}
\inst{}{mov}{=r$uba,wa}{else point to binary operator ptrs}
\inst{}{mov}{=opsnb,xr}{point to names of binary operators}
\inst{}{mov}{=opbun,wb}{set number of undefined binops}
\lnie
\endln
\lnie
merge here to check list (wb = number to check)\endln
\lnie
\endln
\inst{sops3}{lct}{wb,wb}{set counter to control loop}
\lnie
\endln
\lnie
loop to search for name match\endln
\lnie
\endln
\inst{sops4}{beq}{wc,(xr),sops6}{jump if names match}
\inst{}{ica}{wa}{else push pointer to function ptr}
\inst{}{ica}{xr}{bump pointer}
\inst{}{bct}{wb,sops4}{loop back till all checked}
\lnie
\endln
\lnie
here if bad operator name\endln
\lnie
\endln
\inst{sops5}{erb}{156,opsyn first arg}{is not correct operator name}
\lnie
\endln
\lnie
come here on finding a match in the operator name table\endln
\lnie
\endln
\inst{sops6}{mov}{wa,xr}{copy pointer to function block ptr}
\inst{}{sub}{*vrfnc,xr}{make it look like dummy vrblk}
\inst{}{brn}{sops1}{merge back to define operator}
\vfill\break

\ifmac{.c370}
\lnie
\endln
\lnie
or\endln
\lnie
\endln
\inst{s$orf}{ent}{}{entry point}
\inst{}{mnz}{wb}{signal two arguments}
\inst{}{jsr}{sbool}{call string boolean routine}
\inst{}{err}{xxx,or first argument}{is not a string}
\inst{}{err}{xxx,or second argument}{is not a string}
\inst{}{err}{xxx,or arguments}{not same length}
\inst{}{ppm}{exits}{null string arguments}
\lnie
\endln
\lnie
here to process (wc) words.  result is stacked.\endln
\lnie
\endln
\inst{sorf1}{mov}{(xl)+,wa}{get next cfp$c chars from arg 1}
\inst{}{orb}{(xr),wa}{or with characters from arg 2}
\inst{}{mov}{wa,(xr)+}{put back in memory}
\inst{}{bct}{wc,sorf1}{loop over all words in string block}
\inst{}{brn}{exits}{fetch next code word}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
output\endln
\lnie
\endln
\inst{s$oup}{ent}{}{entry point}
\inst{}{mov}{=num03,wb}{output flag}
\inst{}{jsr}{ioput}{call input/output assoc. routine}
\inst{}{err}{157,output third}{argument is not a string}
\inst{}{err}{158,inappropriate}{second argument for output}
\inst{}{err}{159,inappropriate}{first argument for output}
\inst{}{err}{160,inappropriate}{file specification for output}
\inst{}{ppm}{exfal}{fail if file does not exist}
\inst{}{err}{161,output file cannot}{be written to}
\inst{}{err}{290,output channel}{currently in use}
\inst{}{brn}{exnul}{return null string}
\vfill\break

\lnie
\endln
\lnie
pos\endln
\lnie
\endln
\inst{s$pos}{ent}{}{entry point}
\inst{}{mov}{=p$pos,wb}{set pcode for integer arg case}
\inst{}{mov}{=p$psd,wa}{set pcode for expression arg case}
\inst{}{jsr}{patin}{call common routine to build node}
\inst{}{err}{162,pos argument}{is not integer or expression}
\inst{}{err}{163,pos argument}{is negative or too large}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
prototype\endln
\lnie
\endln
\inst{s$pro}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{mov}{tblen(xr),wb}{length if table, vector (=vclen)}
\inst{}{btw}{wb}{convert to words}
\inst{}{mov}{(xr),wa}{load type word of argument block}
\inst{}{beq}{wa,=b$art,spro4}{jump if array}
\inst{}{beq}{wa,=b$tbt,spro1}{jump if table}
\inst{}{beq}{wa,=b$vct,spro3}{jump if vector}
\ifmac{.cnbf}
\asmac{else}
\inst{}{beq}{wa,=b$bct,spr05}{jump if buffer}
\asmac{fi}
\inst{}{erb}{164,prototype argument}{is not valid object}
\lnie
\endln
\lnie
here for table\endln
\lnie
\endln
\inst{spro1}{sub}{=tbsi$,wb}{subtract standard fields}
\lnie
\endln
\lnie
merge for vector\endln
\lnie
\endln
\inst{spro2}{mti}{wb}{convert to integer}
\inst{}{brn}{exint}{exit with integer result}
\lnie
\endln
\lnie
here for vector\endln
\lnie
\endln
\inst{spro3}{sub}{=vcsi$,wb}{subtract standard fields}
\inst{}{brn}{spro2}{merge}
\lnie
\endln
\lnie
here for array\endln
\lnie
\endln
\inst{spro4}{add}{arofs(xr),xr}{point to prototype field}
\inst{}{mov}{(xr),xr}{load prototype}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
here for buffer\endln
\lnie
\endln
\inst{spr05}{mov}{bcbuf(xr),xr}{point to bfblk}
\inst{}{mti}{bfalc(xr)}{load allocated length}
\inst{}{brn}{exint}{exit with integer allocation}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
remdr\endln
\lnie
\endln
\inst{s$rmd}{ent}{}{entry point}
\ifmac{.cmth}
\inst{}{jsr}{arith}{get two integers or two reals}
\inst{}{err}{166,remdr first argument}{is not numeric}
\inst{}{err}{165,remdr second}{argument is not numeric}
\inst{}{ppm}{srm06}{if real}
\asmac{else}
\inst{}{mov}{(xs),xr}{load second argument}
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{err}{165,remdr second}{argument is not integer}
\inst{}{mov}{xr,(xs)}{place converted arg in stack}
\inst{}{jsr}{arith}{convert args}
\inst{}{ppm}{srm04}{first arg not integer}
\inst{}{ppm}{}{second arg checked above}
\ifmac{.cnra}
\asmac{else}
\inst{}{ppm}{srm01}{first arg real}
\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
both arguments integer\endln
\lnie
\endln
\inst{}{zer}{wb}{set positive flag}
\inst{}{ldi}{icval(xr)}{load left argument value}
\inst{}{ige}{srm01}{jump if positive}
\inst{}{mnz}{wb}{set negative flag}
\inst{srm01}{rmi}{icval(xl)}{get remainder}
\inst{}{iov}{srm05}{error if overflow}
\lnie
\endln
\lnie
make sign of result match sign of first argument\endln
\lnie
\endln
\inst{}{bze}{wb,srm03}{if result should be positive}
\inst{}{ile}{exint}{if should be negative, and is}
\inst{srm02}{ngi}{}{adjust sign of result}
\inst{}{brn}{exint}{return result}
\inst{srm03}{ilt}{srm02}{should be pos, and result negative}
\inst{}{brn}{exint}{should be positive, and is}
\lnie
\endln
\lnie
fail first argument\endln
\lnie
\endln
\inst{srm04}{erb}{166,remdr first argument}{is not numeric}
\lnie
\endln
\lnie
fail if overflow\endln
\lnie
\endln
\inst{srm05}{erb}{167,remdr caused}{integer overflow}
\ifmac{.cmth}
\lnie
\endln
\lnie
here with 1st argument in (xr), 2nd in (xl), both real\endln
\lnie
\endln
\lnie
result = n1 - chop(n1/n2)*n2\endln
\lnie
\endln
\inst{srm06}{zer}{wb}{set positive flag}
\inst{}{ldr}{rcval(xr)}{load left argument value}
\inst{}{rge}{srm07}{jump if positive}
\inst{}{mnz}{wb}{set negative flag}
\inst{srm07}{dvr}{rcval(xl)}{compute n1/n2}
\inst{}{rov}{srm10}{jump if overflow}
\inst{}{chp}{}{chop result}
\inst{}{mlr}{rcval(xl)}{times n2}
\inst{}{sbr}{rcval(xr)}{compute difference}
\lnie
\endln
\lnie
make sign of result match sign of first argument\endln
\lnie
-result is in ra at this point\endln
\lnie
\endln
\inst{}{bze}{wb,srm09}{if result should be positive}
\inst{}{rle}{exrea}{if should be negative, and is}
\inst{srm08}{ngr}{}{adjust sign of result}
\inst{}{brn}{exrea}{return result}
\inst{srm09}{rlt}{srm08}{should be pos, and result negative}
\inst{}{brn}{exrea}{should be positive, and is}
\lnie
\endln
\lnie
fail if overflow\endln
\lnie
\endln
\inst{srm10}{erb}{312,remdr caused}{real overflow}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
replace\endln
\lnie
\endln
\lnie
the actual replace operation uses an scblk whose cfp$a\endln
\lnie
chars contain the translated versions of all the chars.\endln
\lnie
the table pointer is remembered from call to call and\endln
\lnie
the table is only built when the arguments change.\endln
\lnie
\endln
\lnie
we also perform an optimization gleaned from spitbol 370.\endln
\lnie
if the second argument is &alphabet, there is no need to\endln
\lnie
to build a replace table.  the third argument can be\endln
\lnie
used directly as the replace table.\endln
\lnie
\endln
\inst{s$rpl}{ent}{}{entry point}
\inst{}{jsr}{gtstg}{load third argument as string}
\inst{}{err}{168,replace third}{argument is not a string}
\inst{}{mov}{xr,xl}{save third arg ptr}
\inst{}{jsr}{gtstg}{get second argument}
\inst{}{err}{169,replace second}{argument is not a string}
\lnie
\endln
\lnie
check to see if this is the same table as last time\endln
\lnie
\endln
\inst{}{bne}{xr,r$ra2,srpl1}{jump if 2nd argument different}
\inst{}{beq}{xl,r$ra3,srpl4}{jump if args same as last time}
\lnie
\endln
\lnie
here we build a new replace table (note wa = 2nd arg len)\endln
\lnie
\endln
\inst{srpl1}{mov}{sclen(xl),wb}{load 3rd argument length}
\inst{}{bne}{wa,wb,srpl6}{jump if arguments not same length}
\inst{}{beq}{xr,kvalp,srpl5}{jump if 2nd arg is alphabet string}
\inst{}{bze}{wb,srpl6}{jump if null 2nd argument}
\inst{}{mov}{xl,r$ra3}{save third arg for next time in}
\inst{}{mov}{xr,r$ra2}{save second arg for next time in}
\inst{}{mov}{kvalp,xl}{point to alphabet string}
\inst{}{mov}{sclen(xl),wa}{load alphabet scblk length}
\inst{}{mov}{r$rpt,xr}{point to current table (if any)}
\inst{}{bnz}{xr,srpl2}{jump if we already have a table}
\lnie
\endln
\lnie
here we allocate a new table\endln
\lnie
\endln
\inst{}{jsr}{alocs}{allocate new table}
\inst{}{mov}{wc,wa}{keep scblk length}
\inst{}{mov}{xr,r$rpt}{save table pointer for next time}
\lnie
\endln
\lnie
merge here with pointer to new table block in (xr)\endln
\lnie
\endln
\inst{srpl2}{ctb}{wa,scsi$}{compute length of scblk}
\inst{}{mvw}{}{copy to get initial table values}
\vfill\break

\lnie
\endln
\lnie
replace (continued)\endln
\lnie
\endln
\lnie
now we must plug selected entries as required. note that\endln
\lnie
we are short of index registers for the following loop.\endln
\lnie
hence the need to repeatedly re-initialise char ptr xl\endln
\lnie
\endln
\inst{}{mov}{r$ra2,xl}{point to second argument}
\inst{}{lct}{wb,wb}{number of chars to plug}
\inst{}{zer}{wc}{zero char offset}
\inst{}{mov}{r$ra3,xr}{point to 3rd arg}
\inst{}{plc}{xr}{get char ptr for 3rd arg}
\lnie
\endln
\lnie
loop to plug chars\endln
\lnie
\endln
\inst{srpl3}{mov}{r$ra2,xl}{point to 2nd arg}
\inst{}{plc}{xl,wc}{point to next char}
\inst{}{icv}{wc}{increment offset}
\inst{}{lch}{wa,(xl)}{get next char}
\inst{}{mov}{r$rpt,xl}{point to translate table}
\inst{}{psc}{xl,wa}{convert char to offset into table}
\inst{}{lch}{wa,(xr)+}{get translated char}
\inst{}{sch}{wa,(xl)}{store in table}
\inst{}{csc}{xl}{complete store characters}
\inst{}{bct}{wb,srpl3}{loop till done}
\vfill\break

\lnie
\endln
\lnie
replace (continued)\endln
\lnie
\endln
\lnie
here to use r$rpt as replace table.\endln
\lnie
\endln
\inst{srpl4}{mov}{r$rpt,xl}{replace table to use}
\lnie
\endln
\lnie
here to perform translate using table in xl.\endln
\lnie
\endln
\ifmac{.cnbf}
\inst{srpl5}{jsr}{gtstg}{get first argument}
\inst{}{err}{170,replace first}{argument is not a string}
\asmac{else}
\lnie
\endln
\lnie
if first arg is a buffer, perform translate in place.\endln
\lnie
\endln
\inst{srpl5}{jsr}{gtstb}{get first argument}
\inst{}{err}{170,replace first}{argument is not a string or buffer}
\inst{}{bnz}{wb,srpl7}{branch if buffer}
\asmac{fi}
\inst{}{bze}{wa,exnul}{return null if null argument}
\inst{}{mov}{xl,-(xs)}{stack replace table to use}
\inst{}{mov}{xr,xl}{copy pointer}
\inst{}{mov}{wa,wc}{save length}
\inst{}{ctb}{wa,schar}{get scblk length}
\inst{}{jsr}{alloc}{allocate space for copy}
\inst{}{mov}{xr,wb}{save address of copy}
\inst{}{mvw}{}{move scblk contents to copy}
\inst{}{mov}{(xs)+,xr}{unstack replace table}
\inst{}{plc}{xr}{point to chars of table}
\inst{}{mov}{wb,xl}{point to string to translate}
\inst{}{plc}{xl}{point to chars of string}
\inst{}{mov}{wc,wa}{set number of chars to translate}
\inst{}{trc}{}{perform translation}
\inst{srpl8}{mov}{wb,-(xs)}{stack result}
\inst{}{lcw}{xr}{load next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
error point\endln
\lnie
\endln
\inst{srpl6}{erb}{171,null or unequally}{long 2nd, 3rd args to replace}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
here to perform replacement within buffer\endln
\lnie
\endln
\inst{srpl7}{bze}{wa,srpl8}{return buffer unchanged if empty}
\inst{}{mov}{xr,wc}{copy bfblk pointer to wc}
\inst{}{mov}{xl,xr}{translate table to xr}
\inst{}{plc}{xr}{point to chars of table}
\inst{}{mov}{wc,xl}{point to string to translate}
\inst{}{plc}{xl}{point to chars of string}
\inst{}{trc}{}{perform translation}
\inst{}{brn}{srpl8}{stack result and exit}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
rewind\endln
\lnie
\endln
\inst{s$rew}{ent}{}{entry point}
\inst{}{jsr}{iofcb}{call fcblk routine}
\inst{}{err}{172,rewind argument}{is not a suitable name}
\inst{}{err}{173,rewind argument}{is null}
\inst{}{err}{174,rewind file does}{not exist}
\inst{}{jsr}{sysrw}{call system rewind function}
\inst{}{err}{174,rewind file does}{not exist}
\inst{}{err}{175,rewind file does}{not permit rewind}
\inst{}{err}{176,rewind caused}{non-recoverable error}
\inst{}{brn}{exnul}{exit with null result if no error}
\vfill\break

\lnie
\endln
\lnie
reverse\endln
\lnie
\endln
\inst{s$rvs}{ent}{}{entry point}
\ifmac{.cnbf}
\inst{}{jsr}{gtstg}{load string argument}
\inst{}{err}{177,reverse argument}{is not a string}
\asmac{else}
\inst{}{jsr}{gtstb}{load string or buffer argument}
\inst{}{err}{177,reverse argument}{is not a string or buffer}
\inst{}{bnz}{wb,srvs3}{branch if buffer}
\asmac{fi}
\inst{}{bze}{wa,exixr}{return argument if null}
\inst{}{mov}{xr,xl}{else save pointer to string arg}
\inst{}{jsr}{alocs}{allocate space for new scblk}
\inst{}{mov}{xr,-(xs)}{store scblk ptr on stack as result}
\inst{}{psc}{xr}{prepare to store in new scblk}
\inst{}{plc}{xl,wc}{point past last char in argument}
\inst{}{lct}{wc,wc}{set loop counter}
\lnie
\endln
\lnie
loop to move chars in reverse order\endln
\lnie
\endln
\inst{srvs1}{lch}{wb,-(xl)}{load next char from argument}
\inst{}{sch}{wb,(xr)+}{store in result}
\inst{}{bct}{wc,srvs1}{loop till all moved}
\lnie
\endln
\lnie
here when complete to execute next code word\endln
\lnie
\endln
\inst{srvs4}{csc}{xr}{complete store characters}
\inst{}{zer}{xl}{clear garbage xl}
\inst{srvs2}{lcw}{xr}{load next code word}
\inst{}{bri}{(xr)}{execute it}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
here if argument is a buffer.  perform reverse in place.\endln
\lnie
\endln
\inst{srvs3}{mov}{wb,-(xs)}{stack buffer as result}
\inst{}{bze}{wa,srvs2}{return buffer unchanged if empty}
\inst{}{mov}{xr,xl}{copy bfblk pointer to xl}
\inst{}{psc}{xr}{prepare to store at first char}
\inst{}{plc}{xl,wa}{point past last char in argument}
\inst{}{rsh}{wa,1}{operate on half the string}
\inst{}{lct}{wc,wa}{set loop counter}
\lnie
\endln
\lnie
loop to swap chars from end to end.  note that in the\endln
\lnie
case of an odd count, the middle char is not touched.\endln
\lnie
\endln
\inst{srvs5}{lch}{wb,-(xl)}{load next char from end}
\inst{}{lch}{wa,(xr)}{load next char from front}
\inst{}{sch}{wb,(xr)+}{store end char in front}
\inst{}{sch}{wa,(xl)}{store front char at end}
\inst{}{bct}{wc,srvs5}{loop till all moved}
\inst{}{brn}{srvs4}{complete store}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
rpad\endln
\lnie
\endln
\inst{s$rpd}{ent}{}{entry point}
\inst{}{jsr}{gtstg}{get pad character}
\inst{}{err}{178,rpad third argument}{is not a string}
\inst{}{plc}{xr}{point to character (null is blank)}
\inst{}{lch}{wb,(xr)}{load pad character}
\inst{}{jsr}{gtsmi}{get pad length}
\inst{}{err}{179,rpad second argument}{is not integer}
\inst{}{ppm}{srpd3}{skip if negative or large}
\lnie
\endln
\lnie
merge to check first arg.\endln
\lnie
\endln
\inst{srpd1}{jsr}{gtstg}{get first argument (string to pad)}
\inst{}{err}{180,rpad first argument}{is not a string}
\inst{}{bge}{wa,wc,exixr}{return 1st arg if too long to pad}
\inst{}{mov}{xr,xl}{else move ptr to string to pad}
\lnie
\endln
\lnie
now we are ready for the pad\endln
\lnie
\endln
\lnie
(xl)                  pointer to string to pad\endln
\lnie
(wb)                  pad character\endln
\lnie
(wc)                  length to pad string to\endln
\lnie
\endln
\inst{}{mov}{wc,wa}{copy length}
\inst{}{jsr}{alocs}{allocate scblk for new string}
\inst{}{mov}{xr,-(xs)}{save as result}
\inst{}{mov}{sclen(xl),wa}{load length of argument}
\inst{}{sub}{wa,wc}{calculate number of pad characters}
\inst{}{psc}{xr}{point to chars in result string}
\inst{}{lct}{wc,wc}{set counter for pad loop}
\lnie
\endln
\lnie
copy argument string\endln
\lnie
\endln
\inst{}{bze}{wa,srpd2}{jump if argument is null}
\inst{}{plc}{xl}{else point to argument chars}
\inst{}{mvc}{}{move characters to result string}
\inst{}{zer}{xl}{clear garbage xl}
\lnie
\endln
\lnie
loop to supply pad characters\endln
\lnie
\endln
\inst{srpd2}{sch}{wb,(xr)+}{store pad character, bump ptr}
\inst{}{bct}{wc,srpd2}{loop till all pad chars stored}
\inst{}{csc}{xr}{complete character storing}
\inst{}{lcw}{xr}{load next code word}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
here if 2nd arg is negative or large\endln
\lnie
\endln
\inst{srpd3}{zer}{wc}{zero pad count}
\inst{}{brn}{srpd1}{merge}
\vfill\break

\lnie
\endln
\lnie
rtab\endln
\lnie
\endln
\inst{s$rtb}{ent}{}{entry point}
\inst{}{mov}{=p$rtb,wb}{set pcode for integer arg case}
\inst{}{mov}{=p$rtd,wa}{set pcode for expression arg case}
\inst{}{jsr}{patin}{call common routine to build node}
\inst{}{err}{181,rtab argument}{is not integer or expression}
\inst{}{err}{182,rtab argument}{is negative or too large}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\ifmac{.cust}
\lnie
\endln
\lnie
set\endln
\lnie
\endln
\inst{s$set}{ent}{}{entry point}
\inst{}{mov}{(xs)+,r$io2}{save third arg (whence)}
\ifmac{.cusr}
\inst{}{mov}{(xs)+,xr}{get second arg (offset)}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{324,set second argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\asmac{else}
\inst{}{mov}{(xs)+,r$io1}{save second arg (offset)}
\asmac{fi}
\inst{}{jsr}{iofcb}{call fcblk routine}
\inst{}{err}{291,set first argument}{is not a suitable name}
\inst{}{err}{292,set first argument}{is null}
\inst{}{err}{295,set file does}{not exist}
\ifmac{.cusr}
\asmac{else}
\inst{}{mov}{r$io1,wb}{load second arg}
\asmac{fi}
\inst{}{mov}{r$io2,wc}{load third arg}
\inst{}{jsr}{sysst}{call system set routine}
\inst{}{err}{293,inappropriate}{second argument to set}
\inst{}{err}{294,inappropriate}{third argument to set}
\inst{}{err}{295,set file does}{not exist}
\inst{}{err}{296,set file does}{not permit setting file pointer}
\inst{}{err}{297,set caused non-recoverable}{i/o error}
\ifmac{.cusr}
\inst{}{rti}{exrea}{return real position if not able}
\inst{}{brn}{exint}{to return integer position}
\asmac{else}
\inst{}{brn}{exint}{otherwise return position}
\asmac{fi}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
tab\endln
\lnie
\endln
\inst{s$tab}{ent}{}{entry point}
\inst{}{mov}{=p$tab,wb}{set pcode for integer arg case}
\inst{}{mov}{=p$tbd,wa}{set pcode for expression arg case}
\inst{}{jsr}{patin}{call common routine to build node}
\inst{}{err}{183,tab argument}{is not integer or expression}
\inst{}{err}{184,tab argument}{is negative or too large}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
rpos\endln
\lnie
\endln
\inst{s$rps}{ent}{}{entry point}
\inst{}{mov}{=p$rps,wb}{set pcode for integer arg case}
\inst{}{mov}{=p$rpd,wa}{set pcode for expression arg case}
\inst{}{jsr}{patin}{call common routine to build node}
\inst{}{err}{185,rpos argument}{is not integer or expression}
\inst{}{err}{186,rpos argument}{is negative or too large}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\ifmac{.cnsr}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
rsort\endln
\lnie
\endln
\inst{s$rsr}{ent}{}{entry point}
\inst{}{mnz}{wa}{mark as rsort}
\inst{}{jsr}{sorta}{call sort routine}
\inst{}{ppm}{exfal}{if conversion fails, so shall we}
\inst{}{brn}{exsid}{return, setting idval}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
setexit\endln
\lnie
\endln
\inst{s$stx}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{mov}{stxvr,wa}{load old vrblk pointer}
\inst{}{zer}{xl}{load zero in case null arg}
\inst{}{beq}{xr,=nulls,sstx1}{jump if null argument (reset call)}
\inst{}{jsr}{gtnvr}{else get specified vrblk}
\inst{}{ppm}{sstx2}{jump if not natural variable}
\inst{}{mov}{vrlbl(xr),xl}{else load label}
\inst{}{beq}{xl,=stndl,sstx2}{jump if label is not defined}
\inst{}{bne}{(xl),=b$trt,sstx1}{jump if not trapped}
\inst{}{mov}{trlbl(xl),xl}{else load ptr to real label code}
\lnie
\endln
\lnie
here to set/reset setexit trap\endln
\lnie
\endln
\inst{sstx1}{mov}{xr,stxvr}{store new vrblk pointer (or null)}
\inst{}{mov}{xl,r$sxc}{store new code ptr (or zero)}
\inst{}{beq}{wa,=nulls,exnul}{return null if null result}
\inst{}{mov}{wa,xr}{else copy vrblk pointer}
\inst{}{brn}{exvnm}{and return building nmblk}
\lnie
\endln
\lnie
here if bad argument\endln
\lnie
\endln
\inst{sstx2}{erb}{187,setexit argument}{is not label name or null}
\ifmac{.cmth}
\lnie
\endln
\lnie
sin\endln
\lnie
\endln
\inst{s$sin}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{308,sin argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{sin}{}{take sine}
\inst{}{rno}{exrea}{if no overflow, return result in ra}
\inst{}{erb}{323,sin argument}{is out of range}
\vfill\break

\asmac{fi}
\ifmac{.cmth}
\lnie
\endln
\lnie
sqrt\endln
\lnie
\endln
\inst{s$sqr}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{313,sqrt argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{rlt}{ssqr1}{negative number}
\inst{}{sqr}{}{take square root}
\inst{}{brn}{exrea}{no overflow possible, result in ra}
\lnie
\endln
\lnie
here if bad argument\endln
\lnie
\endln
\inst{ssqr1}{erb}{314,sqrt argument}{negative}
\vfill\break

\asmac{fi}
\ifmac{.cnsr}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
sort\endln
\lnie
\endln
\inst{s$srt}{ent}{}{entry point}
\inst{}{zer}{wa}{mark as sort}
\inst{}{jsr}{sorta}{call sort routine}
\inst{}{ppm}{exfal}{if conversion fails, so shall we}
\inst{}{brn}{exsid}{return, setting idval}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
span\endln
\lnie
\endln
\inst{s$spn}{ent}{}{entry point}
\inst{}{mov}{=p$sps,wb}{set pcode for single char arg}
\inst{}{mov}{=p$spn,xl}{set pcode for multi-char arg}
\inst{}{mov}{=p$spd,wc}{set pcode for expression arg}
\inst{}{jsr}{patst}{call common routine to build node}
\inst{}{err}{188,span argument}{is not a string or expression}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
size\endln
\lnie
\endln
\inst{s$si$}{ent}{}{entry point}
\ifmac{.cnbf}
\inst{}{jsr}{gtstg}{load string argument}
\inst{}{err}{189,size argument}{is not a string}
\asmac{else}
\inst{}{jsr}{gtstb}{load string argument}
\inst{}{err}{189,size argument}{is not a string or buffer}
\asmac{fi}
\lnie
\endln
\lnie
merge with bfblk or scblk ptr in xr.  wa has length.\endln
\lnie
\endln
\inst{}{mti}{wa}{load length as integer}
\inst{}{brn}{exint}{exit with integer result}
\vfill\break

\lnie
\endln
\lnie
stoptr\endln
\lnie
\endln
\inst{s$stt}{ent}{}{entry point}
\inst{}{zer}{xl}{indicate stoptr case}
\inst{}{jsr}{trace}{call trace procedure}
\inst{}{err}{190,stoptr first}{argument is not appropriate name}
\inst{}{err}{191,stoptr second}{argument is not trace type}
\inst{}{brn}{exnul}{return null}
\vfill\break

\lnie
\endln
\lnie
substr\endln
\lnie
\endln
\inst{s$sub}{ent}{}{entry point}
\inst{}{jsr}{gtsmi}{load third argument}
\inst{}{err}{192,substr third}{argument is not integer}
\inst{}{ppm}{exfal}{jump if negative or too large}
\inst{}{mov}{xr,sbssv}{save third argument}
\inst{}{jsr}{gtsmi}{load second argument}
\inst{}{err}{193,substr second}{argument is not integer}
\inst{}{ppm}{exfal}{jump if out of range}
\inst{}{mov}{xr,wc}{save second argument}
\inst{}{bze}{wc,exfal}{jump if second argument zero}
\inst{}{dcv}{wc}{else decrement for ones origin}
\ifmac{.cnbf}
\inst{}{jsr}{gtstg}{load first argument}
\inst{}{err}{194,substr first}{argument is not a string}
\asmac{else}
\inst{}{jsr}{gtstb}{load first argument}
\inst{}{err}{194,substr first}{argument is not a string or buffer}
\asmac{fi}
\lnie
\endln
\lnie
merge with bfblk or scblk ptr in xr.  wa has length\endln
\lnie
\endln
\inst{}{mov}{wc,wb}{copy second arg to wb}
\inst{}{mov}{sbssv,wc}{reload third argument}
\inst{}{bnz}{wc,ssub2}{skip if third arg given}
\inst{}{mov}{wa,wc}{else get string length}
\inst{}{bgt}{wb,wc,exfal}{fail if improper}
\inst{}{sub}{wb,wc}{reduce by offset to start}
\lnie
\endln
\lnie
merge\endln
\lnie
\endln
\inst{ssub2}{mov}{wa,xl}{save string length}
\inst{}{mov}{wc,wa}{set length of substring}
\inst{}{add}{wb,wc}{add 2nd arg to 3rd arg}
\inst{}{bgt}{wc,xl,exfal}{jump if improper substring}
\inst{}{mov}{xr,xl}{copy pointer to first arg}
\inst{}{jsr}{sbstr}{build substring}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
table\endln
\lnie
\endln
\inst{s$tbl}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xl}{get initial lookup value}
\inst{}{ica}{xs}{pop second argument}
\inst{}{jsr}{gtsmi}{load argument}
\inst{}{err}{195,table argument}{is not integer}
\inst{}{err}{196,table argument}{is out of range}
\inst{}{bnz}{wc,stbl1}{jump if non-zero}
\inst{}{mov}{=tbnbk,wc}{else supply default value}
\lnie
\endln
\lnie
merge here with number of headers in wc\endln
\lnie
\endln
\inst{stbl1}{jsr}{tmake}{make table}
\inst{}{brn}{exsid}{exit setting idval}
\vfill\break

\ifmac{.cmth}
\lnie
\endln
\lnie
tan\endln
\lnie
\endln
\inst{s$tan}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{get argument}
\inst{}{jsr}{gtrea}{convert to real}
\inst{}{err}{309,tan argument}{not numeric}
\inst{}{ldr}{rcval(xr)}{load accumulator with argument}
\inst{}{tan}{}{take tangent}
\inst{}{rno}{exrea}{if no overflow, return result in ra}
\inst{}{erb}{310,tan produced}{real overflow or argument is out of range}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
time\endln
\lnie
\endln
\inst{s$tim}{ent}{}{entry point}
\inst{}{jsr}{systm}{get timer value}
\inst{}{sbi}{timsx}{subtract starting time}
\inst{}{brn}{exint}{exit with integer value}
\vfill\break

\lnie
\endln
\lnie
trace\endln
\lnie
\endln
\inst{s$tra}{ent}{}{entry point}
\inst{}{beq}{num03(xs),=nulls,str02}{jump if first argument is null}
\inst{}{mov}{(xs)+,xr}{load fourth argument}
\inst{}{zer}{xl}{tentatively set zero pointer}
\inst{}{beq}{xr,=nulls,str01}{jump if 4th argument is null}
\inst{}{jsr}{gtnvr}{else point to vrblk}
\inst{}{ppm}{str03}{jump if not variable name}
\inst{}{mov}{xr,xl}{else save vrblk in trfnc}
\lnie
\endln
\lnie
here with vrblk or zero in xl\endln
\lnie
\endln
\inst{str01}{mov}{(xs)+,xr}{load third argument (tag)}
\inst{}{zer}{wb}{set zero as trtyp value for now}
\inst{}{jsr}{trbld}{build trblk for trace call}
\inst{}{mov}{xr,xl}{move trblk pointer for trace}
\inst{}{jsr}{trace}{call trace procedure}
\inst{}{err}{198,trace first argument}{is not appropriate name}
\inst{}{err}{199,trace second}{argument is not trace type}
\inst{}{brn}{exnul}{return null}
\lnie
\endln
\lnie
here to call system trace toggle routine\endln
\lnie
\endln
\inst{str02}{jsr}{systt}{call it}
\inst{}{add}{*num04,xs}{pop trace arguments}
\inst{}{brn}{exnul}{return}
\lnie
\endln
\lnie
here for bad fourth argument\endln
\lnie
\endln
\inst{str03}{erb}{197,trace fourth}{arg is not function name or null}
\vfill\break

\lnie
\endln
\lnie
trim\endln
\lnie
\endln
\inst{s$trm}{ent}{}{entry point}
\ifmac{.cnbf}
\inst{}{jsr}{gtstg}{load argument as string}
\inst{}{err}{200,trim argument}{is not a string}
\asmac{else}
\inst{}{jsr}{gtstb}{load argument as string}
\inst{}{err}{200,trim argument}{is not a string or buffer}
\inst{}{bnz}{wb,strm0}{branch if buffer}
\asmac{fi}
\inst{}{bze}{wa,exnul}{return null if argument is null}
\inst{}{mov}{xr,xl}{copy string pointer}
\inst{}{ctb}{wa,schar}{get block length}
\inst{}{jsr}{alloc}{allocate copy same size}
\inst{}{mov}{xr,wb}{save pointer to copy}
\inst{}{mvw}{}{copy old string block to new}
\inst{}{mov}{wb,xr}{restore ptr to new block}
\inst{}{jsr}{trimr}{trim blanks (wb is non-zero)}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
argument is a buffer, perform trim in place.\endln
\lnie
\endln
\inst{strm0}{mov}{wb,-(xs)}{stack buffer as result}
\inst{}{bze}{wa,strm6}{return buffer unchanged if empty}
\inst{}{mov}{xr,xl}{get bfblk ptr}
\inst{}{mov}{wb,xr}{copy bcblk ptr to xr}
\inst{}{plc}{xl,wa}{point past last character}
\inst{}{mov}{=ch$bl,wc}{load blank character}
\lnie
\endln
\lnie
loop through characters from right to left\endln
\lnie
\endln
\inst{strm1}{lch}{wb,-(xl)}{load next character}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,strm2}{jump if horizontal tab}
\asmac{fi}
\inst{}{bne}{wb,wc,strm3}{jump if non-blank found}
\inst{strm2}{dcv}{wa}{else decrement character count}
\inst{}{bnz}{wa,strm1}{loop back if more to check}
\lnie
\endln
\lnie
here when buffer trim complete\endln
\lnie
\endln
\inst{strm3}{mov}{wa,bclen(xr)}{set new length in bcblk}
\inst{}{mov}{bcbuf(xr),xr}{get bfblk ptr}
\inst{}{mov}{wa,wb}{copy length}
\inst{}{ctb}{wb,0}{words needed converted to bytes}
\inst{}{sub}{wa,wb}{number of zeros needed}
\inst{}{psc}{xr,wa}{ready for storing zeros}
\inst{}{zer}{wc}{set zero char}
\lnie
\endln
\lnie
loop to zero pad last word of characters\endln
\lnie
\endln
\inst{strm4}{bze}{wb,strm5}{loop while more to be done}
\inst{}{sch}{wc,(xr)+}{store zero character}
\inst{}{dcv}{wb}{decrement count}
\inst{}{brn}{strm4}{continue loop}
\inst{strm5}{csc}{xr}{complete store characters}
\inst{strm6}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
unload\endln
\lnie
\endln
\inst{s$unl}{ent}{}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{jsr}{gtnvr}{point to vrblk}
\inst{}{err}{201,unload argument}{is not natural variable name}
\inst{}{mov}{=stndf,xl}{get ptr to undefined function}
\inst{}{jsr}{dffnc}{undefine named function}
\inst{}{brn}{exnul}{return null as result}
\ifmac{.c370}
\vfill\break

\lnie
\endln
\lnie
xor\endln
\lnie
\endln
\inst{s$xor}{ent}{}{entry point}
\inst{}{mnz}{wb}{signal two arguments}
\inst{}{jsr}{sbool}{call string boolean routine}
\inst{}{err}{xxx,xor first argument}{is not a string}
\inst{}{err}{xxx,xor second argument}{is not a string}
\inst{}{err}{xxx,xor arguments}{not same length}
\inst{}{ppm}{exits}{null string arguments}
\lnie
\endln
\lnie
here to process (wc) words.  result is stacked.\endln
\lnie
\endln
\inst{sxor1}{mov}{(xl)+,wa}{get next cfp$c chars from arg 1}
\inst{}{xob}{(xr),wa}{xor with characters from arg 2}
\inst{}{mov}{wa,(xr)+}{put back in memory}
\inst{}{bct}{wc,sxor1}{loop over all words in string block}
\inst{}{brn}{exits}{fetch next code word}
\asmac{fi}
\vfill\break
{\bf spitbol--\rm utility routines}
\vskip1em
\lnie
\endln
\lnie
the following section contains utility routines used for\endln
\lnie
various purposes throughout the system. these differ\endln
\lnie
from the procedures in the utility procedures section in\endln
\lnie
they are not in procedure form and they do not return\endln
\lnie
to their callers. they are accessed with a branch type\endln
\lnie
instruction after setting the registers to appropriate\endln
\lnie
parameter values.\endln
\lnie
\endln
\lnie
the register values required for each routine are\endln
\lnie
documented at the start of each routine. registers not\endln
\lnie
mentioned may contain any values except that xr,xl\endln
\lnie
can only contain proper collectable pointers.\endln
\lnie
\endln
\lnie
some of these routines will tolerate garbage pointers\endln
\lnie
in xl,xr on entry. this is always documented and in\endln
\lnie
each case, the routine clears these garbage values before\endln
\lnie
exiting after completing its task.\endln
\lnie
\endln
\lnie
the routines have names consisting of five letters\endln
\lnie
and are assembled in alphabetical order.\endln
\vfill\break

\lnie
arref -- array reference\endln
\lnie
\endln
\lnie
(xl)                  may be non-collectable\endln
\lnie
(xr)                  number of subscripts\endln
\lnie
(wb)                  set zero/nonzero for value/name\endln
\lnie
                      the value in wb must be collectable\endln
\lnie
stack                 subscripts and array operand\endln
\lnie
brn  arref            jump to call function\endln
\lnie
\endln
\lnie
arref continues by executing the next code word with\endln
\lnie
the result name or value placed on top of the stack.\endln
\lnie
to deal with the problem of accessing subscripts in the\endln
\lnie
order of stacking, xl is used as a subscript pointer\endln
\lnie
working below the stack pointer.\endln
\lnie
\endln
\inst{arref}{rtn}{exits}{}
\inst{}{mov}{xr,wa}{copy number of subscripts}
\inst{}{mov}{xs,xt}{point to stack front}
\inst{}{wtb}{xr}{convert to byte offset}
\inst{}{add}{xr,xt}{point to array operand on stack}
\inst{}{ica}{xt}{final value for stack popping}
\inst{}{mov}{xt,arfxs}{keep for later}
\inst{}{mov}{-(xt),xr}{load array operand pointer}
\inst{}{mov}{xr,r$arf}{keep array pointer}
\inst{}{mov}{xt,xr}{save pointer to subscripts}
\inst{}{mov}{r$arf,xl}{point xl to possible vcblk or tbblk}
\inst{}{mov}{(xl),wc}{load first word}
\inst{}{beq}{wc,=b$art,arf01}{jump if arblk}
\inst{}{beq}{wc,=b$vct,arf07}{jump if vcblk}
\inst{}{beq}{wc,=b$tbt,arf10}{jump if tbblk}
\inst{}{erb}{235,subscripted operand}{is not table or array}
\lnie
\endln
\lnie
here for array (arblk)\endln
\lnie
\endln
\inst{arf01}{bne}{wa,arndm(xl),arf09}{jump if wrong number of dims}
\inst{}{ldi}{intv0}{get initial subscript of zero}
\inst{}{mov}{xr,xt}{point before subscripts}
\inst{}{zer}{wa}{initial offset to bounds}
\inst{}{brn}{arf03}{jump into loop}
\lnie
\endln
\lnie
loop to compute subscripts by multiplications\endln
\lnie
\endln
\inst{arf02}{mli}{ardm2(xr)}{multiply total by next dimension}
\lnie
\endln
\lnie
merge here first time\endln
\lnie
\endln
\inst{arf03}{mov}{-(xt),xr}{load next subscript}
\inst{}{sti}{arfsi}{save current subscript}
\inst{}{ldi}{icval(xr)}{load integer value in case}
\inst{}{beq}{(xr),=b$icl,arf04}{jump if it was an integer}
\vfill\break

\lnie
\endln
\lnie
arref (continued)\endln
\lnie
\endln
\lnie
\endln
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{ppm}{arf12}{jump if not integer}
\inst{}{ldi}{icval(xr)}{if ok, load integer value}
\lnie
\endln
\lnie
here with integer subscript in (ia)\endln
\lnie
\endln
\inst{arf04}{mov}{r$arf,xr}{point to array}
\inst{}{add}{wa,xr}{offset to next bounds}
\inst{}{sbi}{arlbd(xr)}{subtract low bound to compare}
\inst{}{iov}{arf13}{out of range fail if overflow}
\inst{}{ilt}{arf13}{out of range fail if too small}
\inst{}{sbi}{ardim(xr)}{subtract dimension}
\inst{}{ige}{arf13}{out of range fail if too large}
\inst{}{adi}{ardim(xr)}{else restore subscript offset}
\inst{}{adi}{arfsi}{add to current total}
\inst{}{add}{*ardms,wa}{point to next bounds}
\inst{}{bne}{xt,xs,arf02}{loop back if more to go}
\lnie
\endln
\lnie
here with integer subscript computed\endln
\lnie
\endln
\inst{}{mfi}{wa}{get as one word integer}
\inst{}{wtb}{wa}{convert to offset}
\inst{}{mov}{r$arf,xl}{point to arblk}
\inst{}{add}{arofs(xl),wa}{add offset past bounds}
\inst{}{ica}{wa}{adjust for arpro field}
\inst{}{bnz}{wb,arf08}{exit with name if name call}
\lnie
\endln
\lnie
merge here to get value for value call\endln
\lnie
\endln
\inst{arf05}{jsr}{acess}{get value}
\inst{}{ppm}{arf13}{fail if acess fails}
\lnie
\endln
\lnie
return value\endln
\lnie
\endln
\inst{arf06}{mov}{arfxs,xs}{pop stack entries}
\inst{}{zer}{r$arf}{finished with array pointer}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{lcw}{xr}{get next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
arref (continued)\endln
\lnie
\endln
\lnie
here for vector\endln
\lnie
\endln
\inst{arf07}{bne}{wa,=num01,arf09}{error if more than 1 subscript}
\inst{}{mov}{(xs),xr}{else load subscript}
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{ppm}{arf12}{error if not integer}
\inst{}{ldi}{icval(xr)}{else load integer value}
\inst{}{sbi}{intv1}{subtract for ones offset}
\inst{}{mfi}{wa,arf13}{get subscript as one word}
\inst{}{add}{=vcvls,wa}{add offset for standard fields}
\inst{}{wtb}{wa}{convert offset to bytes}
\inst{}{bge}{wa,vclen(xl),arf13}{fail if out of range subscript}
\inst{}{bze}{wb,arf05}{back to get value if value call}
\lnie
\endln
\lnie
return name\endln
\lnie
\endln
\inst{arf08}{mov}{arfxs,xs}{pop stack entries}
\inst{}{zer}{r$arf}{finished with array pointer}
\inst{}{brn}{exnam}{else exit with name}
\lnie
\endln
\lnie
here if subscript count is wrong\endln
\lnie
\endln
\inst{arf09}{erb}{236,array referenced}{with wrong number of subscripts}
\lnie
\endln
\lnie
table\endln
\lnie
\endln
\inst{arf10}{bne}{wa,=num01,arf11}{error if more than 1 subscript}
\inst{}{mov}{(xs),xr}{else load subscript}
\inst{}{jsr}{tfind}{call table search routine}
\inst{}{ppm}{arf13}{fail if failed}
\inst{}{bnz}{wb,arf08}{exit with name if name call}
\inst{}{brn}{arf06}{else exit with value}
\lnie
\endln
\lnie
here for bad table reference\endln
\lnie
\endln
\inst{arf11}{erb}{237,table referenced}{with more than one subscript}
\lnie
\endln
\lnie
here for bad subscript\endln
\lnie
\endln
\inst{arf12}{erb}{238,array subscript}{is not integer}
\lnie
\endln
\lnie
here to signal failure\endln
\lnie
\endln
\inst{arf13}{zer}{r$arf}{finished with array pointer}
\inst{}{brn}{exfal}{fail}
\vfill\break

\lnie
\endln
\lnie
cfunc -- call a function\endln
\lnie
\endln
\lnie
cfunc is used to call a snobol level function. it is\endln
\lnie
used by the apply function (s$app), the function\endln
\lnie
trace routine (trxeq) and the main function call entry\endln
\lnie
(o$fnc, o$fns). in the latter cases, cfunc is used only\endln
\lnie
if the number of arguments is incorrect.\endln
\lnie
\endln
\lnie
(xl)                  pointer to function block\endln
\lnie
(wa)                  actual number of arguments\endln
\lnie
(xs)                  points to stacked arguments\endln
\lnie
brn  cfunc            jump to call function\endln
\lnie
\endln
\lnie
cfunc continues by executing the function\endln
\lnie
\endln
\inst{cfunc}{rtn}{exfal}{}
\inst{}{blt}{wa,fargs(xl),cfnc1}{jump if too few arguments}
\inst{}{beq}{wa,fargs(xl),cfnc3}{jump if correct number of args}
\lnie
\endln
\lnie
here if too many arguments supplied, pop them off\endln
\lnie
\endln
\inst{}{mov}{wa,wb}{copy actual number}
\inst{}{sub}{fargs(xl),wb}{get number of extra args}
\inst{}{wtb}{wb}{convert to bytes}
\inst{}{add}{wb,xs}{pop off unwanted arguments}
\inst{}{brn}{cfnc3}{jump to go off to function}
\lnie
\endln
\lnie
here if too few arguments\endln
\lnie
\endln
\inst{cfnc1}{mov}{fargs(xl),wb}{load required number of arguments}
\inst{}{beq}{wb,=nini9,cfnc3}{jump if case of var num of args}
\inst{}{sub}{wa,wb}{calculate number missing}
\inst{}{lct}{wb,wb}{set counter to control loop}
\lnie
\endln
\lnie
loop to supply extra null arguments\endln
\lnie
\endln
\inst{cfnc2}{mov}{=nulls,-(xs)}{stack a null argument}
\inst{}{bct}{wb,cfnc2}{loop till proper number stacked}
\lnie
\endln
\lnie
merge here to jump to function\endln
\lnie
\endln
\inst{cfnc3}{bri}{(xl)}{jump through fcode field}
\vfill\break

\lnie
\endln
\lnie
exfal -- exit signalling snobol failure\endln
\lnie
\endln
\lnie
(xl,xr)               may be non-collectable\endln
\lnie
brn  exfal            jump to fail\endln
\lnie
\endln
\lnie
exfal continues by executing the appropriate fail goto\endln
\lnie
\endln
\inst{exfal}{rtn}{(xl)}{}
\inst{}{mov}{flptr,xs}{pop stack}
\inst{}{mov}{(xs),xr}{load failure offset}
\inst{}{add}{r$cod,xr}{point to failure code location}
\inst{}{lcp}{xr}{set code pointer}
\inst{}{lcw}{xr}{load next code word}
\inst{}{mov}{(xr),xl}{load entry address}
\inst{}{bri}{xl}{jump to execute next code word}
\vfill\break

\lnie
\endln
\lnie
exint -- exit with integer result\endln
\lnie
\endln
\lnie
(xl,xr)               may be non-collectable\endln
\lnie
(ia)                  integer value\endln
\lnie
brn  exint            jump to exit with integer\endln
\lnie
\endln
\lnie
exint continues by executing the next code word\endln
\lnie
which it does by falling through to exixr\endln
\lnie
\endln
\inst{exint}{rtn}{xl}{}
\inst{}{zer}{xl}{clear dud value}
\inst{}{jsr}{icbld}{build icblk}
\vfill\break

\lnie
exixr -- exit with result in (xr)\endln
\lnie
\endln
\lnie
(xr)                  result\endln
\lnie
(xl)                  may be non-collectable\endln
\lnie
brn  exixr            jump to exit with result in (xr)\endln
\lnie
\endln
\lnie
exixr continues by executing the next code word\endln
\lnie
which it does by falling through to exits.\endln
\inst{exixr}{rtn}{icbld}{which it does by falling through to exits.}
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{stack result}
\lnie
\endln
\lnie
\endln
\lnie
exits -- exit with result if any stacked\endln
\lnie
\endln
\lnie
(xr,xl)               may be non-collectable\endln
\lnie
\endln
\lnie
brn  exits            enter exits routine\endln
\lnie
\endln
\inst{exits}{rtn}{xr,-(xs)}{}
\inst{}{lcw}{xr}{load next code word}
\inst{}{mov}{(xr),xl}{load entry address}
\inst{}{bri}{xl}{jump to execute next code word}
\vfill\break

\lnie
\endln
\lnie
exnam -- exit with name in (xl,wa)\endln
\lnie
\endln
\lnie
(xl)                  name base\endln
\lnie
(wa)                  name offset\endln
\lnie
(xr)                  may be non-collectable\endln
\lnie
brn  exnam            jump to exit with name in (xl,wa)\endln
\lnie
\endln
\lnie
exnam continues by executing the next code word\endln
\lnie
\endln
\inst{exnam}{rtn}{xl}{}
\inst{}{mov}{xl,-(xs)}{stack name base}
\inst{}{mov}{wa,-(xs)}{stack name offset}
\inst{}{lcw}{xr}{load next code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
exnul -- exit with null result\endln
\lnie
\endln
\lnie
(xl,xr)               may be non-collectable\endln
\lnie
brn  exnul            jump to exit with null value\endln
\lnie
\endln
\lnie
exnul continues by executing the next code word\endln
\lnie
\endln
\inst{exnul}{rtn}{(xr)}{}
\inst{}{mov}{=nulls,-(xs)}{stack null value}
\inst{}{lcw}{xr}{load next code word}
\inst{}{mov}{(xr),xl}{load entry address}
\inst{}{bri}{xl}{jump to execute next code word}
\vfill\break

\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
exrea -- exit with real result\endln
\lnie
\endln
\lnie
(xl,xr)               may be non-collectable\endln
\lnie
(ra)                  real value\endln
\lnie
brn  exrea            jump to exit with real value\endln
\lnie
\endln
\lnie
exrea continues by executing the next code word\endln
\lnie
\endln
\inst{exrea}{rtn}{xl}{}
\inst{}{zer}{xl}{clear dud value}
\inst{}{jsr}{rcbld}{build rcblk}
\inst{}{brn}{exixr}{jump to exit with result in xr}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
exsid -- exit setting id field\endln
\lnie
\endln
\lnie
exsid is used to exit after building any of the following\endln
\lnie
blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.\endln
\lnie
\endln
\lnie
(xr)                  ptr to block with idval field\endln
\lnie
(xl)                  may be non-collectable\endln
\lnie
brn  exsid            jump to exit after setting id field\endln
\lnie
\endln
\lnie
exsid continues by executing the next code word\endln
\lnie
\endln
\inst{exsid}{rtn}{exixr}{}
\inst{}{mov}{curid,wa}{load current id value}
\inst{}{bne}{wa,=cfp$m,exsi1}{jump if no overflow}
\inst{}{zer}{wa}{else reset for wraparound}
\lnie
\endln
\lnie
here with old idval in wa\endln
\lnie
\endln
\inst{exsi1}{icv}{wa}{bump id value}
\inst{}{mov}{wa,curid}{store for next time}
\inst{}{mov}{wa,idval(xr)}{store id value}
\inst{}{brn}{exixr}{exit with result in (xr)}
\vfill\break

\lnie
\endln
\lnie
exvnm -- exit with name of variable\endln
\lnie
\endln
\lnie
exvnm exits after stacking a value which is a nmblk\endln
\lnie
referencing the name of a given natural variable.\endln
\lnie
\endln
\lnie
(xr)                  vrblk pointer\endln
\lnie
(xl)                  may be non-collectable\endln
\lnie
brn  exvnm            exit with vrblk pointer in xr\endln
\lnie
\endln
\inst{exvnm}{rtn}{exixr}{}
\inst{}{mov}{xr,xl}{copy name base pointer}
\inst{}{mov}{*nmsi$,wa}{set size of nmblk}
\inst{}{jsr}{alloc}{allocate nmblk}
\inst{}{mov}{=b$nml,(xr)}{store type word}
\inst{}{mov}{xl,nmbas(xr)}{store name base}
\inst{}{mov}{*vrval,nmofs(xr)}{store name offset}
\inst{}{brn}{exixr}{exit with result in xr}
\vfill\break

\lnie
\endln
\lnie
flpop -- fail and pop in pattern matching\endln
\lnie
\endln
\lnie
flpop pops the node and cursor on the stack and then\endln
\lnie
drops through into failp to cause pattern failure\endln
\lnie
\endln
\lnie
(xl,xr)               may be non-collectable\endln
\lnie
brn  flpop            jump to fail and pop stack\endln
\lnie
\endln
\inst{flpop}{rtn}{exixr}{}
\inst{}{add}{*num02,xs}{pop two entries off stack}
\vfill\break

\lnie
\endln
\lnie
failp -- failure in matching pattern node\endln
\lnie
\endln
\lnie
failp is used after failing to match a pattern node.\endln
\lnie
see pattern match routines for details of use.\endln
\lnie
\endln
\lnie
(xl,xr)               may be non-collectable\endln
\lnie
brn  failp            signal failure to match\endln
\lnie
\endln
\lnie
failp continues by matching an alternative from the stack\endln
\lnie
\endln
\inst{failp}{rtn}{*num02,xs}{}
\inst{}{mov}{(xs)+,xr}{load alternative node pointer}
\inst{}{mov}{(xs)+,wb}{restore old cursor}
\inst{}{mov}{(xr),xl}{load pcode entry pointer}
\inst{}{bri}{xl}{jump to execute code for node}
\vfill\break

\lnie
\endln
\lnie
indir -- compute indirect reference\endln
\lnie
\endln
\lnie
(wb)                  nonzero/zero for by name/value\endln
\lnie
brn  indir            jump to get indirect ref on stack\endln
\lnie
\endln
\lnie
indir continues by executing the next code word\endln
\lnie
\endln
\inst{indir}{rtn}{xl}{}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{beq}{(xr),=b$nml,indr2}{jump if a name}
\inst{}{jsr}{gtnvr}{else convert to variable}
\inst{}{err}{239,indirection operand}{is not name}
\inst{}{bze}{wb,indr1}{skip if by value}
\inst{}{mov}{xr,-(xs)}{else stack vrblk ptr}
\inst{}{mov}{*vrval,-(xs)}{stack name offset}
\inst{}{lcw}{xr}{load next code word}
\inst{}{mov}{(xr),xl}{load entry address}
\inst{}{bri}{xl}{jump to execute next code word}
\lnie
\endln
\lnie
here to get value of natural variable\endln
\lnie
\endln
\inst{indr1}{bri}{(xr)}{jump through vrget field of vrblk}
\lnie
\endln
\lnie
here if operand is a name\endln
\lnie
\endln
\inst{indr2}{mov}{nmbas(xr),xl}{load name base}
\inst{}{mov}{nmofs(xr),wa}{load name offset}
\inst{}{bnz}{wb,exnam}{exit if called by name}
\inst{}{jsr}{acess}{else get value first}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{brn}{exixr}{else return with value in xr}
\vfill\break

\lnie
\endln
\lnie
match -- initiate pattern match\endln
\lnie
\endln
\lnie
(wb)                  match type code\endln
\lnie
brn  match            jump to initiate pattern match\endln
\lnie
\endln
\lnie
match continues by executing the pattern match. see\endln
\lnie
pattern match routines (p$xxx) for full details.\endln
\lnie
\endln
\inst{match}{rtn}{exixr}{}
\inst{}{mov}{(xs)+,xr}{load pattern operand}
\inst{}{jsr}{gtpat}{convert to pattern}
\inst{}{err}{240,pattern match}{right operand is not pattern}
\inst{}{mov}{xr,xl}{if ok, save pattern pointer}
\inst{}{bnz}{wb,mtch1}{jump if not match by name}
\inst{}{mov}{(xs),wa}{else load name offset}
\inst{}{mov}{xl,-(xs)}{save pattern pointer}
\inst{}{mov}{num02(xs),xl}{load name base}
\inst{}{jsr}{acess}{access subject value}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{mov}{(xs),xl}{restore pattern pointer}
\inst{}{mov}{xr,(xs)}{stack subject string val for merge}
\inst{}{zer}{wb}{restore type code}
\lnie
\endln
\lnie
merge here with subject value on stack\endln
\lnie
\endln
\ifmac{.cnbf}
\inst{mtch1}{jsr}{gtstg}{convert subject to string}
\inst{}{err}{241,pattern match}{left operand is not a string}
\inst{}{mov}{wb,-(xs)}{stack match type code}
\asmac{else}
\inst{mtch1}{mov}{wb,wc}{save match type in wc}
\inst{}{jsr}{gtstb}{convert subject to string}
\inst{}{err}{241,pattern match}{left operand is not a string or buffer}
\inst{}{mov}{wb,r$pmb}{set to zero/bcblk if string/buffer}
\inst{}{mov}{wc,-(xs)}{stack match type code}
\asmac{fi}
\inst{}{mov}{xr,r$pms}{if ok, store subject string pointer}
\inst{}{mov}{wa,pmssl}{and length}
\inst{}{zer}{-(xs)}{stack initial cursor (zero)}
\inst{}{zer}{wb}{set initial cursor}
\inst{}{mov}{xs,pmhbs}{set history stack base ptr}
\inst{}{zer}{pmdfl}{reset pattern assignment flag}
\inst{}{mov}{xl,xr}{set initial node pointer}
\inst{}{bnz}{kvanc,mtch2}{jump if anchored}
\lnie
\endln
\lnie
here for unanchored\endln
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{stack initial node pointer}
\inst{}{mov}{=nduna,-(xs)}{stack pointer to anchor move node}
\inst{}{bri}{(xr)}{start match of first node}
\lnie
\endln
\lnie
here in anchored mode\endln
\lnie
\endln
\inst{mtch2}{zer}{-(xs)}{dummy cursor value}
\inst{}{mov}{=ndabo,-(xs)}{stack pointer to abort node}
\inst{}{bri}{(xr)}{start match of first node}
\vfill\break

\lnie
\endln
\lnie
retrn -- return from function\endln
\lnie
\endln
\lnie
(wa)                  string pointer for return type\endln
\lnie
brn  retrn            jump to return from (snobol) func\endln
\lnie
\endln
\lnie
retrn continues by executing the code at the return point\endln
\lnie
the stack is cleaned of any garbage left by other\endln
\lnie
routines which may have altered flptr since function\endln
\lnie
entry by using flprt, reserved for use only by\endln
\lnie
function call and return.\endln
\lnie
\endln
\inst{retrn}{rtn}{(xr)}{}
\inst{}{bnz}{kvfnc,rtn01}{jump if not level zero}
\inst{}{erb}{242,function return}{from level zero}
\lnie
\endln
\lnie
here if not level zero return\endln
\lnie
\endln
\inst{rtn01}{mov}{flprt,xs}{pop stack}
\inst{}{ica}{xs}{remove failure offset}
\inst{}{mov}{(xs)+,xr}{pop pfblk pointer}
\inst{}{mov}{(xs)+,flptr}{pop failure pointer}
\inst{}{mov}{(xs)+,flprt}{pop old flprt}
\inst{}{mov}{(xs)+,wb}{pop code pointer offset}
\inst{}{mov}{(xs)+,wc}{pop old code block pointer}
\inst{}{add}{wc,wb}{make old code pointer absolute}
\inst{}{lcp}{wb}{restore old code pointer}
\inst{}{mov}{wc,r$cod}{restore old code block pointer}
\inst{}{dcv}{kvfnc}{decrement function level}
\inst{}{mov}{kvtra,wb}{load trace}
\inst{}{add}{kvftr,wb}{add ftrace}
\inst{}{bze}{wb,rtn06}{jump if no tracing possible}
\lnie
\endln
\lnie
here if there may be a trace\endln
\lnie
\endln
\inst{}{mov}{wa,-(xs)}{save function return type}
\inst{}{mov}{xr,-(xs)}{save pfblk pointer}
\inst{}{mov}{wa,kvrtn}{set rtntype for trace function}
\inst{}{mov}{r$fnc,xl}{load fnclevel trblk ptr (if any)}
\inst{}{jsr}{ktrex}{execute possible fnclevel trace}
\inst{}{mov}{pfvbl(xr),xl}{load vrblk ptr (sgd13)}
\inst{}{bze}{kvtra,rtn02}{jump if trace is off}
\inst{}{mov}{pfrtr(xr),xr}{else load return trace trblk ptr}
\inst{}{bze}{xr,rtn02}{jump if not return traced}
\inst{}{dcv}{kvtra}{else decrement trace count}
\inst{}{bze}{trfnc(xr),rtn03}{jump if print trace}
\inst{}{mov}{*vrval,wa}{else set name offset}
\inst{}{mov}{num01(xs),kvrtn}{make sure rtntype is set right}
\inst{}{jsr}{trxeq}{execute full trace}
\vfill\break

\lnie
\endln
\lnie
retrn (continued)\endln
\lnie
\endln
\lnie
here to test for ftrace\endln
\lnie
\endln
\inst{rtn02}{bze}{kvftr,rtn05}{jump if ftrace is off}
\inst{}{dcv}{kvftr}{else decrement ftrace}
\lnie
\endln
\lnie
here for print trace of function return\endln
\lnie
\endln
\inst{rtn03}{jsr}{prtsn}{print statement number}
\inst{}{mov}{num01(xs),xr}{load return type}
\inst{}{jsr}{prtst}{print it}
\inst{}{mov}{=ch$bl,wa}{load blank}
\inst{}{jsr}{prtch}{print it}
\inst{}{mov}{0(xs),xl}{load pfblk ptr}
\inst{}{mov}{pfvbl(xl),xl}{load function vrblk ptr}
\inst{}{mov}{*vrval,wa}{set vrblk name offset}
\inst{}{bne}{xr,=scfrt,rtn04}{jump if not freturn case}
\lnie
\endln
\lnie
for freturn, just print function name\endln
\lnie
\endln
\inst{}{jsr}{prtnm}{print name}
\inst{}{jsr}{prtnl}{terminate print line}
\inst{}{brn}{rtn05}{merge}
\lnie
\endln
\lnie
here for return or nreturn, print function name = value\endln
\lnie
\endln
\inst{rtn04}{jsr}{prtnv}{print name = value}
\lnie
\endln
\lnie
here after completing trace\endln
\lnie
\endln
\inst{rtn05}{mov}{(xs)+,xr}{pop pfblk pointer}
\inst{}{mov}{(xs)+,wa}{pop return type string}
\lnie
\endln
\lnie
merge here if no trace required\endln
\lnie
\endln
\inst{rtn06}{mov}{wa,kvrtn}{set rtntype keyword}
\inst{}{mov}{pfvbl(xr),xl}{load pointer to fn vrblk}
\vfill\break

\lnie
retrn (continued)\endln
\lnie
\endln
\lnie
get value of function\endln
\lnie
\endln
\inst{rtn07}{mov}{xl,rtnbp}{save block pointer}
\inst{}{mov}{vrval(xl),xl}{load value}
\inst{}{beq}{(xl),=b$trt,rtn07}{loop back if trapped}
\inst{}{mov}{xl,rtnfv}{else save function result value}
\inst{}{mov}{(xs)+,rtnsv}{save original function value}
\ifmac{.cnpf}
\inst{}{mov}{fargs(xr),wb}{get number of arguments}
\asmac{else}
\inst{}{mov}{(xs)+,xl}{pop saved pointer}
\inst{}{bze}{xl,rtn7c}{no action if none}
\inst{}{bze}{kvpfl,rtn7c}{jump if no profiling}
\inst{}{jsr}{prflu}{else profile last func stmt}
\inst{}{beq}{kvpfl,=num02,rtn7a}{branch on value of profile keywd}
\lnie
\endln
\lnie
here if &profile = 1. start time must be frigged to\endln
\lnie
appear earlier than it actually is, by amount used before\endln
\lnie
the call.\endln
\lnie
\endln
\inst{}{ldi}{pfstm}{load current time}
\inst{}{sbi}{icval(xl)}{frig by subtracting saved amount}
\inst{}{brn}{rtn7b}{and merge}
\lnie
\endln
\lnie
here if &profile = 2\endln
\lnie
\endln
\inst{rtn7a}{ldi}{icval(xl)}{load saved time}
\lnie
\endln
\lnie
both profile types merge here\endln
\lnie
\endln
\inst{rtn7b}{sti}{pfstm}{store back correct start time}
\lnie
\endln
\lnie
merge here if no profiling\endln
\lnie
\endln
\inst{rtn7c}{mov}{fargs(xr),wb}{get number of args}
\asmac{fi}
\inst{}{add}{pfnlo(xr),wb}{add number of locals}
\inst{}{bze}{wb,rtn10}{jump if no args/locals}
\inst{}{lct}{wb,wb}{else set loop counter}
\inst{}{add}{pflen(xr),xr}{and point to end of pfblk}
\lnie
\endln
\lnie
loop to restore functions and locals\endln
\lnie
\endln
\inst{rtn08}{mov}{-(xr),xl}{load next vrblk pointer}
\lnie
\endln
\lnie
loop to find value block\endln
\lnie
\endln
\inst{rtn09}{mov}{xl,wa}{save block pointer}
\inst{}{mov}{vrval(xl),xl}{load pointer to next value}
\inst{}{beq}{(xl),=b$trt,rtn09}{loop back if trapped}
\inst{}{mov}{wa,xl}{else restore last block pointer}
\inst{}{mov}{(xs)+,vrval(xl)}{restore old variable value}
\inst{}{bct}{wb,rtn08}{loop till all processed}
\lnie
\endln
\lnie
now restore function value and exit\endln
\lnie
\endln
\inst{rtn10}{mov}{rtnbp,xl}{restore ptr to last function block}
\inst{}{mov}{rtnsv,vrval(xl)}{restore old function value}
\inst{}{mov}{rtnfv,xr}{reload function result}
\inst{}{mov}{r$cod,xl}{point to new code block}
\inst{}{mov}{kvstn,kvlst}{set lastno from stno}
\inst{}{mov}{cdstm(xl),kvstn}{reset proper stno value}
\ifmac{.csln}
\inst{}{mov}{kvlin,kvlln}{set lastline from line}
\inst{}{mov}{cdsln(xl),kvlin}{reset proper line value}
\asmac{fi}
\inst{}{mov}{kvrtn,wa}{load return type}
\inst{}{beq}{wa,=scrtn,exixr}{exit with result in xr if return}
\inst{}{beq}{wa,=scfrt,exfal}{fail if freturn}
\vfill\break

\lnie
\endln
\lnie
retrn (continued)\endln
\lnie
\endln
\lnie
here for nreturn\endln
\lnie
\endln
\inst{}{beq}{(xr),=b$nml,rtn11}{jump if is a name}
\inst{}{jsr}{gtnvr}{else try convert to variable name}
\inst{}{err}{243,function result}{in nreturn is not name}
\inst{}{mov}{xr,xl}{if ok, copy vrblk (name base) ptr}
\inst{}{mov}{*vrval,wa}{set name offset}
\inst{}{brn}{rtn12}{and merge}
\lnie
\endln
\lnie
here if returned result is a name\endln
\lnie
\endln
\inst{rtn11}{mov}{nmbas(xr),xl}{load name base}
\inst{}{mov}{nmofs(xr),wa}{load name offset}
\lnie
\endln
\lnie
merge here with returned name in (xl,wa)\endln
\lnie
\endln
\inst{rtn12}{mov}{xl,xr}{preserve xl}
\inst{}{lcw}{wb}{load next word}
\inst{}{mov}{xr,xl}{restore xl}
\inst{}{beq}{wb,=ofne$,exnam}{exit if called by name}
\inst{}{mov}{wb,-(xs)}{else save code word}
\inst{}{jsr}{acess}{get value}
\inst{}{ppm}{exfal}{fail if access fails}
\inst{}{mov}{xr,xl}{if ok, copy result}
\inst{}{mov}{(xs),xr}{reload next code word}
\inst{}{mov}{xl,(xs)}{store result on stack}
\inst{}{mov}{(xr),xl}{load routine address}
\inst{}{bri}{xl}{jump to execute next code word}
\vfill\break

\lnie
\endln
\lnie
stcov -- signal statement counter overflow\endln
\lnie
\endln
\lnie
brn  stcov            jump to signal statement count oflo\endln
\lnie
\endln
\lnie
permit up to 10 more statements to be obeyed so that\endln
\lnie
setexit trap can regain control.\endln
\lnie
stcov continues by issuing the error message\endln
\lnie
\endln
\inst{stcov}{rtn}{xl}{}
\inst{}{icv}{errft}{fatal error}
\inst{}{ldi}{intvt}{get 10}
\inst{}{adi}{kvstl}{add to former limit}
\inst{}{sti}{kvstl}{store as new stlimit}
\inst{}{ldi}{intvt}{get 10}
\inst{}{sti}{kvstc}{set as new count}
\inst{}{jsr}{stgcc}{recompute countdown counters}
\inst{}{erb}{244,statement count}{exceeds value of stlimit keyword}
\vfill\break

\lnie
\endln
\lnie
stmgo -- start execution of new statement\endln
\lnie
\endln
\lnie
(xr)                  pointer to cdblk for new statement\endln
\lnie
brn  stmgo            jump to execute new statement\endln
\lnie
\endln
\lnie
stmgo continues by executing the next statement\endln
\lnie
\endln
\inst{stmgo}{rtn}{244,statement countunt}{}
\inst{}{mov}{xr,r$cod}{set new code block pointer}
\inst{}{dcv}{stmct}{see if time to check something}
\inst{}{bze}{stmct,stgo2}{jump if so}
\inst{}{mov}{kvstn,kvlst}{set lastno}
\inst{}{mov}{cdstm(xr),kvstn}{set stno}
\ifmac{.csln}
\inst{}{mov}{kvlin,kvlln}{set lastline}
\inst{}{mov}{cdsln(xr),kvlin}{set line}
\asmac{fi}
\inst{}{add}{*cdcod,xr}{point to first code word}
\inst{}{lcp}{xr}{set code pointer}
\lnie
\endln
\lnie
here to execute first code word of statement\endln
\lnie
\endln
\inst{stgo1}{lcw}{xr}{load next code word}
\inst{}{zer}{xl}{clear garbage xl}
\inst{}{bri}{(xr)}{execute it}
\lnie
\endln
\lnie
check profiling, polling, stlimit, statement tracing\endln
\lnie
\endln
\inst{stgo2}{bze}{kvpfl,stgo3}{skip if no profiling}
\inst{}{jsr}{prflu}{else profile the statement in kvstn}
\lnie
\endln
\lnie
here when finished with profiling\endln
\lnie
\endln
\inst{stgo3}{mov}{kvstn,kvlst}{set lastno}
\inst{}{mov}{cdstm(xr),kvstn}{set stno}
\ifmac{.csln}
\inst{}{mov}{kvlin,kvlln}{set lastline}
\inst{}{mov}{cdsln(xr),kvlin}{set line}
\asmac{fi}
\inst{}{add}{*cdcod,xr}{point to first code word}
\inst{}{lcp}{xr}{set code pointer}
\ifmac{.cpol}
\lnie
\endln
\lnie
here to check for polling\endln
\lnie
\endln
\inst{}{mov}{stmcs,-(xs)}{save present count start on stack}
\inst{}{dcv}{polct}{poll interval within stmct}
\inst{}{bnz}{polct,stgo4}{jump if not poll time yet}
\inst{}{zer}{wa}{=0 for poll}
\inst{}{mov}{kvstn,wb}{statement number}
\inst{}{mov}{xr,xl}{make collectable}
\inst{}{jsr}{syspl}{allow interactive access}
\inst{}{err}{syspl}{allow interactive access}
\inst{}{ppm}{}{single step}
\inst{}{ppm}{}{expression evaluation}
\inst{}{mov}{xl,xr}{restore code block pointer}
\inst{}{mov}{wa,polcs}{poll interval start value}
\inst{}{jsr}{stgcc}{recompute counter values}
\asmac{fi}
\lnie
\endln
\lnie
check statement limit\endln
\lnie
\endln
\inst{stgo4}{ldi}{kvstc}{get stmt count}
\inst{}{ilt}{stgo5}{omit counting if negative}
\inst{}{mti}{(xs)+}{reload start value of counter}
\inst{}{ngi}{}{negate}
\inst{}{adi}{kvstc}{stmt count minus counter}
\inst{}{sti}{kvstc}{replace it}
\inst{}{ile}{stcov}{fail if stlimit reached}
\inst{}{bze}{r$stc,stgo5}{jump if no statement trace}
\inst{}{zer}{xr}{clear garbage value in xr}
\inst{}{mov}{r$stc,xl}{load pointer to stcount trblk}
\inst{}{jsr}{ktrex}{execute keyword trace}
\lnie
\endln
\lnie
reset stmgo counter\endln
\lnie
\endln
\inst{stgo5}{mov}{stmcs,stmct}{reset counter}
\inst{}{brn}{stgo1}{fetch next code word}
\vfill\break

\lnie
\endln
\lnie
stopr -- terminate run\endln
\lnie
\endln
\lnie
(xr)                  points to ending message\endln
\lnie
brn stopr             jump to terminate run\endln
\lnie
\endln
\lnie
terminate run and print statistics.  on entry xr points\endln
\lnie
to ending message or is zero if message  printed already.\endln
\lnie
\endln
\inst{stopr}{rtn}{stgo1}{}
\ifmac{.csax}
\inst{}{bze}{xr,stpra}{skip if sysax already called}
\inst{}{jsr}{sysax}{call after execution proc}
\inst{stpra}{add}{rsmem,dname}{use the reserve memory}
\asmac{else}
\inst{}{add}{rsmem,dname}{use the reserve memory}
\asmac{fi}
\inst{}{bne}{xr,=endms,stpr0}{skip if not normal end message}
\inst{}{bnz}{exsts,stpr3}{skip if exec stats suppressed}
\inst{}{zer}{erich}{clear errors to int.ch. flag}
\lnie
\endln
\lnie
look to see if an ending message is supplied\endln
\lnie
\endln
\inst{stpr0}{jsr}{prtpg}{eject printer}
\inst{}{bze}{xr,stpr1}{skip if no message}
\inst{}{jsr}{prtst}{print message}
\lnie
\endln
\lnie
merge here if no message to print\endln
\lnie
\endln
\inst{stpr1}{jsr}{prtis}{print blank line}
\ifmac{.csfn}
\inst{}{bnz}{gbcfl,stpr5}{if in garbage collection, skip}
\inst{}{mov}{=stpm7,xr}{point to message /in file xxx/}
\inst{}{jsr}{prtst}{print it}
\inst{}{mov}{=prtmf,profs}{set column offset}
\inst{}{mov}{kvstn,wc}{get statement number}
\inst{}{jsr}{filnm}{get file name}
\inst{}{mov}{xl,xr}{prepare to print}
\inst{}{jsr}{prtst}{print file name}
\inst{}{jsr}{prtis}{print to interactive channel}
\asmac{fi}
\ifmac{.csln}
\ifmac{.csfn}
\asmac{else}
\inst{}{bnz}{gbcfl,stpr5}{if in garbage collection, skip}
\asmac{fi}
\inst{}{mov}{r$cod,xr}{get code pointer}
\inst{}{mti}{cdsln(xr)}{get source line number}
\inst{}{mov}{=stpm6,xr}{point to message /in line xxx/}
\inst{}{jsr}{prtmx}{print it}
\asmac{fi}
\inst{stpr5}{mti}{kvstn}{get statement number}
\inst{}{mov}{=stpm1,xr}{point to message /in statement xxx/}
\inst{}{jsr}{prtmx}{print it}
\inst{}{jsr}{systm}{get current time}
\inst{}{sbi}{timsx}{minus start time = elapsed exec tim}
\inst{}{sti}{stpti}{save for later}
\inst{}{mov}{=stpm3,xr}{point to msg /execution time msec /}
\inst{}{jsr}{prtmx}{print it}
\inst{}{ldi}{kvstl}{get statement limit}
\inst{}{ilt}{stpr2}{skip if negative}
\inst{}{sbi}{kvstc}{minus counter = course count}
\inst{}{sti}{stpsi}{save}
\inst{}{mov}{stmcs,wa}{refine with counter start value}
\inst{}{sub}{stmct,wa}{minus current counter}
\inst{}{mti}{wa}{convert to integer}
\inst{}{adi}{stpsi}{add in course count}
\inst{}{sti}{stpsi}{save}
\inst{}{mov}{=stpm2,xr}{point to message /stmts executed/}
\inst{}{jsr}{prtmx}{print it}
\ifmac{.ctmd}
\asmac{else}
\inst{}{ldi}{stpti}{reload elapsed time}
\inst{}{mli}{intth}{*1000 (microsecs)}
\inst{}{iov}{stpr2}{jump if we cannot compute}
\inst{}{dvi}{stpsi}{divide by statement count}
\inst{}{iov}{stpr2}{jump if overflow}
\inst{}{mov}{=stpm4,xr}{point to msg (mcsec per statement /}
\inst{}{jsr}{prtmx}{print it}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
stopr (continued)\endln
\lnie
\endln
\lnie
merge to skip message (overflow or negative stlimit)\endln
\lnie
\endln
\inst{stpr2}{mti}{gbcnt}{load count of collections}
\inst{}{mov}{=stpm5,xr}{point to message /regenerations /}
\inst{}{jsr}{prtmx}{print it}
\inst{}{jsr}{prtmm}{print memory usage}
\inst{}{jsr}{prtis}{one more blank for luck}
\lnie
\endln
\lnie
check if dump requested\endln
\lnie
\endln
\ifmac{.cnpf}
\inst{stpr3}{mov}{kvdmp,xr}{load dump keyword}
\asmac{else}
\inst{stpr3}{jsr}{prflr}{print profile if wanted}
\lnie
\endln
\inst{}{mov}{kvdmp,xr}{load dump keyword}
\asmac{fi}
\inst{}{jsr}{dumpr}{execute dump if requested}
\inst{}{mov}{r$fcb,xl}{get fcblk chain head}
\inst{}{mov}{kvabe,wa}{load abend value}
\inst{}{mov}{kvcod,wb}{load code value}
\inst{}{jsr}{sysej}{exit to system}
\ifmac{.cera}
\lnie
\endln
\lnie
here after sysea call and suppressing error msg print\endln
\lnie
\endln
\inst{stpr4}{rtn}{sysej}{}
\inst{}{add}{rsmem,dname}{use the reserve memory}
\inst{}{bze}{exsts,stpr1}{if execution stats requested}
\inst{}{brn}{stpr3}{check if dump or profile needed}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
succp -- signal successful match of a pattern node\endln
\lnie
\endln
\lnie
see pattern match routines for details\endln
\lnie
\endln
\lnie
(xr)                  current node\endln
\lnie
(wb)                  current cursor\endln
\lnie
(xl)                  may be non-collectable\endln
\lnie
brn  succp            signal successful pattern match\endln
\lnie
\endln
\lnie
succp continues by matching the successor node\endln
\lnie
\endln
\inst{succp}{rtn}{stpr3}{}
\inst{}{mov}{pthen(xr),xr}{load successor node}
\inst{}{mov}{(xr),xl}{load node code entry address}
\inst{}{bri}{xl}{jump to match successor node}
\vfill\break

\lnie
\endln
\lnie
sysab -- print /abnormal end/ and terminate\endln
\lnie
\endln
\inst{sysab}{rtn}{xl}{}
\inst{}{mov}{=endab,xr}{point to message}
\inst{}{mov}{=num01,kvabe}{set abend flag}
\inst{}{jsr}{prtnl}{skip to new line}
\inst{}{brn}{stopr}{jump to pack up}
\vfill\break

\lnie
\endln
\lnie
systu -- print /time up/ and terminate\endln
\lnie
\endln
\inst{systu}{rtn}{stopr}{}
\inst{}{mov}{=endtu,xr}{point to message}
\inst{}{mov}{strtu,wa}{get chars /tu/}
\inst{}{mov}{wa,kvcod}{put in kvcod}
\inst{}{mov}{timup,wa}{check state of timeup switch}
\inst{}{mnz}{timup}{set switch}
\inst{}{bnz}{wa,stopr}{stop run if already set}
\inst{}{erb}{245,translation/execution}{time expired}
\vfill\break
{\bf spitbol--\rm utility procedures}
\vskip1em
\lnie
\endln
\lnie
the following section contains procedures which are\endln
\lnie
used for various purposes throughout the system.\endln
\lnie
\endln
\lnie
each procedure is preceded by a description of the\endln
\lnie
calling sequence. usually the arguments are in registers\endln
\lnie
but arguments can also occur on the stack and as\endln
\lnie
parameters assembled after the jsr instruction.\endln
\lnie
\endln
\lnie
the following considerations apply to these descriptions.\endln
\lnie
\endln
\lnie
1)   the stack pointer (xs) is not changed unless the\endln
\lnie
     change is explicitly documented in the call.\endln
\lnie
\endln
\lnie
2)   registers whose entry values are not mentioned\endln
\lnie
     may contain any value except that xl,xr may only\endln
\lnie
     contain proper (collectable) pointer values.\endln
\lnie
     this condition on means that the called routine\endln
\lnie
     may if it chooses preserve xl,xr by stacking.\endln
\lnie
\endln
\lnie
3)   registers not mentioned on exit contain the same\endln
\lnie
     values as they did on entry except that values in\endln
\lnie
     xr,xl may have been relocated by the collector.\endln
\lnie
\endln
\lnie
4)   registers which are destroyed on exit may contain\endln
\lnie
     any value except that values in xl,xr are proper\endln
\lnie
     (collectable) pointers.\endln
\lnie
\endln
\lnie
5)   the code pointer register points to the current\endln
\lnie
     code location on entry and is unchanged on exit.\endln
\lnie
\endln
\lnie
in the above description, a collectable pointer is one\endln
\lnie
which either points outside the dynamic region or\endln
\lnie
points to the start of a block in the dynamic region.\endln
\lnie
\endln
\lnie
in those cases where the calling sequence contains\endln
\lnie
parameters which are used as alternate return points,\endln
\lnie
these parameters may be replaced by error codes\endln
\lnie
assembled with the err instruction. this will result\endln
\lnie
in the posting of the error if the return is taken.\endln
\lnie
\endln
\lnie
the procedures all have names consisting of five letters\endln
\lnie
and are in alphabetical order by their names.\endln
\vfill\break

\lnie
\endln
\lnie
acess - access variable value with trace/input checks\endln
\lnie
\endln
\lnie
acess loads the value of a variable. trace and input\endln
\lnie
associations are tested for and executed as required.\endln
\lnie
acess also handles the special cases of pseudo-variables.\endln
\lnie
\endln
\lnie
(xl)                  variable name base\endln
\lnie
(wa)                  variable name offset\endln
\lnie
jsr  acess            call to access value\endln
\lnie
ppm  loc              transfer loc if access failure\endln
\lnie
(xr)                  variable value\endln
\lnie
(wa,wb,wc)            destroyed\endln
\lnie
(xl,ra)               destroyed\endln
\lnie
\endln
\lnie
failure can occur if an input association causes an end\endln
\lnie
of file condition or if the evaluation of an expression\endln
\lnie
associated with an expression variable fails.\endln
\lnie
\endln
\inst{acess}{prc}{r,1}{entry point (recursive)}
\inst{}{mov}{xl,xr}{copy name base}
\inst{}{add}{wa,xr}{point to variable location}
\inst{}{mov}{(xr),xr}{load variable value}
\lnie
\endln
\lnie
loop here to check for successive trblks\endln
\lnie
\endln
\inst{acs02}{bne}{(xr),=b$trt,acs18}{jump if not trapped}
\lnie
\endln
\lnie
here if trapped\endln
\lnie
\endln
\inst{}{beq}{xr,=trbkv,acs12}{jump if keyword variable}
\inst{}{bne}{xr,=trbev,acs05}{jump if not expression variable}
\lnie
\endln
\lnie
here for expression variable, evaluate variable\endln
\lnie
\endln
\inst{}{mov}{evexp(xl),xr}{load expression pointer}
\inst{}{zer}{wb}{evaluate by value}
\inst{}{jsr}{evalx}{evaluate expression}
\inst{}{ppm}{acs04}{jump if evaluation failure}
\inst{}{brn}{acs02}{check value for more trblks}
\vfill\break

\lnie
\endln
\lnie
acess (continued)\endln
\lnie
\endln
\lnie
here on reading end of file\endln
\lnie
\endln
\inst{acs03}{add}{*num03,xs}{pop trblk ptr, name base and offset}
\inst{}{mov}{xr,dnamp}{pop unused scblk}
\lnie
\endln
\lnie
merge here when evaluation of expression fails\endln
\lnie
\endln
\inst{acs04}{exi}{1}{take alternate (failure) return}
\lnie
\endln
\lnie
here if not keyword or expression variable\endln
\lnie
\endln
\inst{acs05}{mov}{trtyp(xr),wb}{load trap type code}
\inst{}{bnz}{wb,acs10}{jump if not input association}
\inst{}{bze}{kvinp,acs09}{ignore input assoc if input is off}
\lnie
\endln
\lnie
here for input association\endln
\lnie
\endln
\inst{}{mov}{xl,-(xs)}{stack name base}
\inst{}{mov}{wa,-(xs)}{stack name offset}
\inst{}{mov}{xr,-(xs)}{stack trblk pointer}
\inst{}{mov}{kvtrm,actrm}{temp to hold trim keyword}
\inst{}{mov}{trfpt(xr),xl}{get file ctrl blk ptr or zero}
\inst{}{bnz}{xl,acs06}{jump if not standard input file}
\inst{}{beq}{trter(xr),=v$ter,acs21}{jump if terminal}
\lnie
\endln
\lnie
here to read from standard input file\endln
\lnie
\endln
\inst{}{mov}{cswin,wa}{length for read buffer}
\inst{}{jsr}{alocs}{build string of appropriate length}
\inst{}{jsr}{sysrd}{read next standard input image}
\inst{}{ppm}{acs03}{jump to fail exit if end of file}
\inst{}{brn}{acs07}{else merge with other file case}
\lnie
\endln
\lnie
here for input from other than standard input file\endln
\lnie
\endln
\inst{acs06}{mov}{xl,wa}{fcblk ptr}
\inst{}{jsr}{sysil}{get input record max length (to wa)}
\inst{}{bnz}{wc,acs6a}{jump if not binary file}
\inst{}{mov}{wc,actrm}{disable trim for binary file}
\inst{acs6a}{jsr}{alocs}{allocate string of correct size}
\inst{}{mov}{xl,wa}{fcblk ptr}
\inst{}{jsr}{sysin}{call system input routine}
\inst{}{ppm}{acs03}{jump to fail exit if end of file}
\inst{}{ppm}{acs22}{error}
\inst{}{ppm}{acs23}{error}
\vfill\break

\lnie
\endln
\lnie
acess (continued)\endln
\lnie
\endln
\lnie
merge here after obtaining input record\endln
\lnie
\endln
\inst{acs07}{mov}{actrm,wb}{load trim indicator}
\inst{}{jsr}{trimr}{trim record as required}
\inst{}{mov}{xr,wb}{copy result pointer}
\inst{}{mov}{(xs),xr}{reload pointer to trblk}
\lnie
\endln
\lnie
loop to chase to end of trblk chain and store value\endln
\lnie
\endln
\inst{acs08}{mov}{xr,xl}{save pointer to this trblk}
\inst{}{mov}{trnxt(xr),xr}{load forward pointer}
\inst{}{beq}{(xr),=b$trt,acs08}{loop if this is another trblk}
\inst{}{mov}{wb,trnxt(xl)}{else store result at end of chain}
\inst{}{mov}{(xs)+,xr}{restore initial trblk pointer}
\inst{}{mov}{(xs)+,wa}{restore name offset}
\inst{}{mov}{(xs)+,xl}{restore name base pointer}
\lnie
\endln
\lnie
come here to move to next trblk\endln
\lnie
\endln
\inst{acs09}{mov}{trnxt(xr),xr}{load forward ptr to next value}
\inst{}{brn}{acs02}{back to check if trapped}
\lnie
\endln
\lnie
here to check for access trace trblk\endln
\lnie
\endln
\inst{acs10}{bne}{wb,=trtac,acs09}{loop back if not access trace}
\inst{}{bze}{kvtra,acs09}{ignore access trace if trace off}
\inst{}{dcv}{kvtra}{else decrement trace count}
\inst{}{bze}{trfnc(xr),acs11}{jump if print trace}
\vfill\break

\lnie
\endln
\lnie
acess (continued)\endln
\lnie
\endln
\lnie
here for full function trace\endln
\lnie
\endln
\inst{}{jsr}{trxeq}{call routine to execute trace}
\inst{}{brn}{acs09}{jump for next trblk}
\lnie
\endln
\lnie
here for case of print trace\endln
\lnie
\endln
\inst{acs11}{jsr}{prtsn}{print statement number}
\inst{}{jsr}{prtnv}{print name = value}
\inst{}{brn}{acs09}{jump back for next trblk}
\lnie
\endln
\lnie
here for keyword variable\endln
\lnie
\endln
\inst{acs12}{mov}{kvnum(xl),xr}{load keyword number}
\inst{}{bge}{xr,=k$v$$,acs14}{jump if not one word value}
\inst{}{mti}{kvabe(xr)}{else load value as integer}
\lnie
\endln
\lnie
common exit with keyword value as integer in (ia)\endln
\lnie
\endln
\inst{acs13}{jsr}{icbld}{build icblk}
\inst{}{brn}{acs18}{jump to exit}
\lnie
\endln
\lnie
here if not one word keyword value\endln
\lnie
\endln
\inst{acs14}{bge}{xr,=k$s$$,acs15}{jump if special case}
\inst{}{sub}{=k$v$$,xr}{else get offset}
\inst{}{wtb}{xr}{convert to byte offset}
\inst{}{add}{=ndabo,xr}{point to pattern value}
\inst{}{brn}{acs18}{jump to exit}
\lnie
\endln
\lnie
here if special keyword case\endln
\lnie
\endln
\inst{acs15}{mov}{kvrtn,xl}{load rtntype in case}
\inst{}{ldi}{kvstl}{load stlimit in case}
\inst{}{sub}{=k$s$$,xr}{get case number}
\inst{}{bsw}{xr,k$$n$}{switch on keyword number}
\ifmac{.csfn}
\inst{}{iff}{k$$fl,acs26}{file}
\inst{}{iff}{k$$lf,acs27}{lastfile}
\asmac{fi}
\ifmac{.culk}
\inst{}{iff}{k$$lc,acs24}{lcase}
\inst{}{iff}{k$$uc,acs25}{ucase}
\asmac{fi}
\inst{}{iff}{k$$al,acs16}{jump if alphabet}
\inst{}{iff}{k$$rt,acs17}{rtntype}
\inst{}{iff}{k$$sc,acs19}{stcount}
\inst{}{iff}{k$$sl,acs13}{stlimit}
\inst{}{iff}{k$$et,acs20}{errtext}
\inst{}{esw}{}{end switch on keyword number}
\vfill\break

\lnie
\endln
\lnie
acess (continued)\endln
\lnie
\endln
\ifmac{.culk}
\lnie
lcase\endln
\lnie
\endln
\inst{acs24}{mov}{=lcase,xr}{load pointer to lcase string}
\inst{}{brn}{acs18}{common return}
\lnie
\endln
\lnie
ucase\endln
\lnie
\endln
\inst{acs25}{mov}{=ucase,xr}{load pointer to ucase string}
\inst{}{brn}{acs18}{common return}
\lnie
\endln
\asmac{fi}
\ifmac{.csfn}
\lnie
file\endln
\lnie
\endln
\inst{acs26}{mov}{kvstn,wc}{load current stmt number}
\inst{}{brn}{acs28}{merge to obtain file name}
\lnie
\endln
\lnie
lastfile\endln
\lnie
\endln
\inst{acs27}{mov}{kvlst,wc}{load last stmt number}
\lnie
\endln
\lnie
merge here to map statement number in wc to file name\endln
\lnie
\endln
\inst{acs28}{jsr}{filnm}{obtain file name for this stmt}
\inst{}{brn}{acs17}{merge to return string in xl}
\asmac{fi}
\lnie
alphabet\endln
\lnie
\endln
\inst{acs16}{mov}{kvalp,xl}{load pointer to alphabet string}
\lnie
\endln
\lnie
rtntype merges here\endln
\lnie
\endln
\inst{acs17}{mov}{xl,xr}{copy string ptr to proper reg}
\lnie
\endln
\lnie
common return point\endln
\lnie
\endln
\inst{acs18}{exi}{}{return to acess caller}
\lnie
\endln
\lnie
here for stcount (ia has stlimit)\endln
\lnie
\endln
\inst{acs19}{ilt}{acs29}{if counting suppressed}
\inst{}{mov}{stmcs,wa}{refine with counter start value}
\inst{}{sub}{stmct,wa}{minus current counter}
\inst{}{mti}{wa}{convert to integer}
\inst{}{adi}{kvstl}{add stlimit}
\inst{acs29}{sbi}{kvstc}{stcount = limit - left}
\inst{}{brn}{acs13}{merge back with integer result}
\lnie
\endln
\lnie
errtext\endln
\lnie
\endln
\inst{acs20}{mov}{r$etx,xr}{get errtext string}
\inst{}{brn}{acs18}{merge with result}
\lnie
\endln
\lnie
here to read a record from terminal\endln
\lnie
\endln
\inst{acs21}{mov}{=rilen,wa}{buffer length}
\inst{}{jsr}{alocs}{allocate buffer}
\inst{}{jsr}{sysri}{read record}
\inst{}{ppm}{acs03}{endfile}
\inst{}{brn}{acs07}{merge with record read}
\lnie
\endln
\lnie
error returns\endln
\lnie
\endln
\inst{acs22}{mov}{xr,dnamp}{pop unused scblk}
\inst{}{erb}{202,input from file}{caused non-recoverable error}
\lnie
\endln
\inst{acs23}{mov}{xr,dnamp}{pop unused scblk}
\inst{}{erb}{203,input file record}{has incorrect format}
\inst{}{enp}{}{end procedure acess}
\vfill\break

\lnie
\endln
\lnie
acomp -- compare two arithmetic values\endln
\lnie
\endln
\lnie
1(xs)                 first argument\endln
\lnie
0(xs)                 second argument\endln
\lnie
jsr  acomp            call to compare values\endln
\lnie
ppm  loc              transfer loc if arg1 is non-numeric\endln
\lnie
ppm  loc              transfer loc if arg2 is non-numeric\endln
\lnie
ppm  loc              transfer loc for arg1 lt arg2\endln
\lnie
ppm  loc              transfer loc for arg1 eq arg2\endln
\lnie
ppm  loc              transfer loc for arg1 gt arg2\endln
\lnie
(normal return is never given)\endln
\lnie
(wa,wb,wc,ia,ra)      destroyed\endln
\lnie
(xl,xr)               destroyed\endln
\lnie
\endln
\inst{acomp}{prc}{n,5}{entry point}
\inst{}{jsr}{arith}{load arithmetic operands}
\inst{}{ppm}{acmp7}{jump if first arg non-numeric}
\inst{}{ppm}{acmp8}{jump if second arg non-numeric}
\ifmac{.cnra}
\asmac{else}
\inst{}{ppm}{acmp4}{jump if real arguments}
\asmac{fi}
\lnie
\endln
\lnie
here for integer arguments\endln
\lnie
\endln
\inst{}{sbi}{icval(xl)}{subtract to compare}
\inst{}{iov}{acmp3}{jump if overflow}
\inst{}{ilt}{acmp5}{else jump if arg1 lt arg2}
\inst{}{ieq}{acmp2}{jump if arg1 eq arg2}
\lnie
\endln
\lnie
here if arg1 gt arg2\endln
\lnie
\endln
\inst{acmp1}{exi}{5}{take gt exit}
\lnie
\endln
\lnie
here if arg1 eq arg2\endln
\lnie
\endln
\inst{acmp2}{exi}{4}{take eq exit}
\vfill\break

\lnie
\endln
\lnie
acomp (continued)\endln
\lnie
\endln
\lnie
here for integer overflow on subtract\endln
\lnie
\endln
\inst{acmp3}{ldi}{icval(xl)}{load second argument}
\inst{}{ilt}{acmp1}{gt if negative}
\inst{}{brn}{acmp5}{else lt}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here for real operands\endln
\lnie
\endln
\inst{acmp4}{sbr}{rcval(xl)}{subtract to compare}
\inst{}{rov}{acmp6}{jump if overflow}
\inst{}{rgt}{acmp1}{else jump if arg1 gt}
\inst{}{req}{acmp2}{jump if arg1 eq arg2}
\asmac{fi}
\lnie
\endln
\lnie
here if arg1 lt arg2\endln
\lnie
\endln
\inst{acmp5}{exi}{3}{take lt exit}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here if overflow on real subtraction\endln
\lnie
\endln
\inst{acmp6}{ldr}{rcval(xl)}{reload arg2}
\inst{}{rlt}{acmp1}{gt if negative}
\inst{}{brn}{acmp5}{else lt}
\asmac{fi}
\lnie
\endln
\lnie
here if arg1 non-numeric\endln
\lnie
\endln
\inst{acmp7}{exi}{1}{take error exit}
\lnie
\endln
\lnie
here if arg2 non-numeric\endln
\lnie
\endln
\inst{acmp8}{exi}{2}{take error exit}
\inst{}{enp}{}{end procedure acomp}
\vfill\break

\lnie
\endln
\lnie
alloc                 allocate block of dynamic storage\endln
\lnie
\endln
\lnie
(wa)                  length required in bytes\endln
\lnie
jsr  alloc            call to allocate block\endln
\lnie
(xr)                  pointer to allocated block\endln
\lnie
\endln
\lnie
a possible alternative to aov ... and following stmt is -\endln
\lnie
mov  dname,xr .  sub  wa,xr .  blo xr,dnamp,aloc2 .\endln
\lnie
mov  dnamp,xr .  add  wa,xr\endln
\lnie
\endln
\inst{alloc}{prc}{e,0}{entry point}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{aloc1}{mov}{dnamp,xr}{point to next available loc}
\inst{}{aov}{wa,xr,aloc2}{point past allocated block}
\inst{}{bgt}{xr,dname,aloc2}{jump if not enough room}
\inst{}{mov}{xr,dnamp}{store new pointer}
\inst{}{sub}{wa,xr}{point back to start of allocated bk}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
here if insufficient room, try a garbage collection\endln
\lnie
\endln
\inst{aloc2}{mov}{wb,allsv}{save wb}
\inst{alc2a}{zer}{wb}{set no upward move for gbcol}
\inst{}{jsr}{gbcol}{garbage collect}
\ifmac{.csed}
\inst{}{mov}{xr,wb}{remember new sediment size}
\asmac{fi}
\lnie
\endln
\lnie
see if room after gbcol or sysmm call\endln
\lnie
\endln
\inst{aloc3}{mov}{dnamp,xr}{point to first available loc}
\inst{}{aov}{wa,xr,alc3a}{point past new block}
\inst{}{blo}{xr,dname,aloc4}{jump if there is room now}
\lnie
\endln
\lnie
failed again, see if we can get more core\endln
\lnie
\endln
\inst{alc3a}{jsr}{sysmm}{try to get more memory}
\inst{}{wtb}{xr}{convert to baus (sgd05)}
\inst{}{add}{xr,dname}{bump ptr by amount obtained}
\inst{}{bnz}{xr,aloc3}{jump if got more core}
\ifmac{.csed}
\inst{}{bze}{dnams,alc3b}{jump if there was no sediment}
\inst{}{zer}{dnams}{try collecting the sediment}
\inst{}{brn}{dnams}{try collecting the sediment}
\lnie
\endln
\lnie
sysmm failed and there was no sediment to collect\endln
\lnie
\endln
\inst{alc3b}{add}{rsmem,dname}{get the reserve memory}
\asmac{else}
\inst{}{add}{rsmem,dname}{get the reserve memory}
\asmac{fi}
\inst{}{zer}{rsmem}{only permissible once}
\inst{}{icv}{errft}{fatal error}
\inst{}{erb}{errft}{fatal error}
\vfill\break

\lnie
\endln
\lnie
here after successful garbage collection\endln
\lnie
\endln
\inst{aloc4}{sti}{allia}{save ia}
\ifmac{.csed}
\inst{}{mov}{wb,dnams}{record new sediment size}
\asmac{fi}
\inst{}{mov}{dname,wb}{get dynamic end adrs}
\inst{}{sub}{dnamp,wb}{compute free store}
\inst{}{btw}{wb}{convert bytes to words}
\inst{}{mti}{wb}{put free store in ia}
\inst{}{mli}{alfsf}{multiply by free store factor}
\inst{}{iov}{aloc5}{jump if overflowed}
\inst{}{mov}{dname,wb}{dynamic end adrs}
\inst{}{sub}{dnamb,wb}{compute total amount of dynamic}
\inst{}{btw}{wb}{convert to words}
\inst{}{mov}{wb,aldyn}{store it}
\inst{}{sbi}{aldyn}{subtract from scaled up free store}
\inst{}{igt}{aloc5}{jump if sufficient free store}
\inst{}{jsr}{sysmm}{try to get more store}
\inst{}{wtb}{xr}{convert to baus (sgd05)}
\inst{}{add}{xr,dname}{adjust dynamic end adrs}
\lnie
\endln
\lnie
merge to restore ia and wb\endln
\lnie
\endln
\inst{aloc5}{ldi}{allia}{recover ia}
\inst{}{mov}{allsv,wb}{restore wb}
\inst{}{brn}{aloc1}{jump back to exit}
\inst{}{enp}{}{end procedure alloc}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
alobf -- allocate buffer\endln
\lnie
\endln
\lnie
this routines allocates a new buffer.  as the bfblk\endln
\lnie
and bcblk come in pairs, both are allocated here,\endln
\lnie
and xr points to the bcblk on return.  the bfblk\endln
\lnie
and bcblk are set to the null buffer, and the idval\endln
\lnie
is zero on return.\endln
\lnie
\endln
\lnie
(wa)                  buffer size in characters\endln
\lnie
jsr  alobf            call to create buffer\endln
\lnie
(xr)                  bcblk ptr\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\inst{alobf}{prc}{e,0}{entry point}
\inst{}{bgt}{wa,kvmxl,alb01}{check for maxlngth exceeded}
\inst{}{mov}{wa,wb}{hang onto allocation size}
\inst{}{ctb}{wa,bfsi$}{get total block size}
\inst{}{add}{*bcsi$,wa}{add in allocation for bcblk}
\inst{}{jsr}{alloc}{allocate frame}
\inst{}{mov}{=b$bct,(xr)}{set type}
\inst{}{zer}{idval(xr)}{no id yet}
\inst{}{zer}{bclen(xr)}{no defined length}
\inst{}{mov}{xl,wa}{save xl}
\inst{}{mov}{xr,xl}{copy bcblk ptr}
\inst{}{add}{*bcsi$,xl}{bias past partially built bcblk}
\inst{}{mov}{=b$bft,(xl)}{set bfblk type word}
\inst{}{mov}{wb,bfalc(xl)}{set allocated size}
\inst{}{mov}{xl,bcbuf(xr)}{set pointer in bcblk}
\inst{}{zer}{bfchr(xl)}{clear first word (null pad)}
\inst{}{mov}{wa,xl}{restore entry xl}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
here for mxlen exceeded\endln
\lnie
\endln
\inst{alb01}{erb}{273,buffer size exceeds}{value of maxlngth keyword}
\inst{}{enp}{}{end procedure alobf}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
alocs -- allocate string block\endln
\lnie
\endln
\lnie
alocs is used to build a frame for a string block into\endln
\lnie
which the actual characters are placed by the caller.\endln
\lnie
all strings are created with a call to alocs (the\endln
\lnie
exceptions occur in trimr and s$rpl procedures).\endln
\lnie
\endln
\lnie
(wa)                  length of string to be allocated\endln
\lnie
jsr  alocs            call to allocate scblk\endln
\lnie
(xr)                  pointer to resulting scblk\endln
\lnie
(wa)                  destroyed\endln
\lnie
(wc)                  character count (entry value of wa)\endln
\lnie
\endln
\lnie
the resulting scblk has the type word and the length\endln
\lnie
filled in and the last word is cleared to zero characters\endln
\lnie
to ensure correct right padding of the final word.\endln
\lnie
\endln
\inst{alocs}{prc}{e,0}{entry point}
\inst{}{bgt}{wa,kvmxl,alcs2}{jump if length exceeds maxlength}
\inst{}{mov}{wa,wc}{else copy length}
\inst{}{ctb}{wa,scsi$}{compute length of scblk in bytes}
\inst{}{mov}{dnamp,xr}{point to next available location}
\inst{}{aov}{wa,xr,alcs0}{point past block}
\inst{}{blo}{xr,dname,alcs1}{jump if there is room}
\lnie
\endln
\lnie
insufficient memory\endln
\lnie
\endln
\inst{alcs0}{zer}{xr}{else clear garbage xr value}
\inst{}{jsr}{alloc}{and use standard allocator}
\inst{}{add}{wa,xr}{point past end of block to merge}
\lnie
\endln
\lnie
merge here with xr pointing beyond new block\endln
\lnie
\endln
\inst{alcs1}{mov}{xr,dnamp}{set updated storage pointer}
\inst{}{zer}{-(xr)}{store zero chars in last word}
\inst{}{dca}{wa}{decrement length}
\inst{}{sub}{wa,xr}{point back to start of block}
\inst{}{mov}{=b$scl,(xr)}{set type word}
\inst{}{mov}{wc,sclen(xr)}{store length in chars}
\inst{}{exi}{}{return to alocs caller}
\lnie
\endln
\lnie
come here if string is too long\endln
\lnie
\endln
\inst{alcs2}{erb}{205,string length}{exceeds value of maxlngth keyword}
\inst{}{enp}{}{end procedure alocs}
\vfill\break

\lnie
\endln
\lnie
alost -- allocate space in static region\endln
\lnie
\endln
\lnie
(wa)                  length required in bytes\endln
\lnie
jsr  alost            call to allocate space\endln
\lnie
(xr)                  pointer to allocated block\endln
\lnie
(wb)                  destroyed\endln
\lnie
\endln
\lnie
note that the coding ensures that the resulting value\endln
\lnie
of state is always less than dnamb. this fact is used\endln
\lnie
in testing a variable name for being in the static region\endln
\lnie
\endln
\inst{alost}{prc}{e,0}{entry point}
\lnie
\endln
\lnie
merge back here after allocating new chunk\endln
\lnie
\endln
\inst{alst1}{mov}{state,xr}{point to current end of area}
\inst{}{aov}{wa,xr,alst2}{point beyond proposed block}
\inst{}{bge}{xr,dnamb,alst2}{jump if overlap with dynamic area}
\inst{}{mov}{xr,state}{else store new pointer}
\inst{}{sub}{wa,xr}{point back to start of block}
\inst{}{exi}{}{return to alost caller}
\lnie
\endln
\lnie
here if no room, prepare to move dynamic storage up\endln
\lnie
\endln
\inst{alst2}{mov}{wa,alsta}{save wa}
\inst{}{bge}{wa,*e$sts,alst3}{skip if requested chunk is large}
\inst{}{mov}{*e$sts,wa}{else set to get large enough chunk}
\lnie
\endln
\lnie
here with amount to move up in wa\endln
\lnie
\endln
\inst{alst3}{jsr}{alloc}{allocate block to ensure room}
\inst{}{mov}{xr,dnamp}{and delete it}
\inst{}{mov}{wa,wb}{copy move up amount}
\inst{}{jsr}{gbcol}{call gbcol to move dynamic area up}
\ifmac{.csed}
\inst{}{mov}{xr,dnams}{remember new sediment size}
\asmac{fi}
\inst{}{mov}{alsta,wa}{restore wa}
\inst{}{brn}{alst1}{loop back to try again}
\inst{}{enp}{}{end procedure alost}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
apndb -- append string to buffer\endln
\lnie
\endln
\lnie
this routine is used by buffer handling routines to\endln
\lnie
append data to an existing bfblk.\endln
\lnie
\endln
\lnie
(xr)                  existing bcblk to be appended\endln
\lnie
(xl)                  convertable to string\endln
\lnie
jsr  apndb            call to append to buffer\endln
\lnie
ppm  loc              thread if (xl) cant be converted\endln
\lnie
ppm  loc              if not enough room\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\lnie
if more characters are specified than can be inserted,\endln
\lnie
then no action is taken and the second return is taken.\endln
\lnie
\endln
\inst{apndb}{prc}{e,2}{entry point}
\inst{}{mov}{bclen(xr),wa}{load offset to insert}
\inst{}{zer}{wb}{replace section is null}
\inst{}{jsr}{insbf}{call to insert at end}
\inst{}{ppm}{apn01}{convert error}
\inst{}{ppm}{apn02}{no room}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
here to take convert failure exit\endln
\lnie
\endln
\inst{apn01}{exi}{1}{return to caller alternate}
\lnie
\endln
\lnie
here for no fit exit\endln
\lnie
\endln
\inst{apn02}{exi}{2}{alternate exit to caller}
\inst{}{enp}{}{end procedure apndb}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
arith -- fetch arithmetic operands\endln
\lnie
\endln
\lnie
arith is used by functions and operators which expect\endln
\lnie
two numeric arguments (operands) which must both be\endln
\lnie
integer or both be real. arith fetches two arguments from\endln
\lnie
the stack and performs any necessary conversions.\endln
\lnie
\endln
\lnie
1(xs)                 first argument (left operand)\endln
\lnie
0(xs)                 second argument (right operand)\endln
\lnie
jsr  arith            call to fetch numeric arguments\endln
\lnie
ppm  loc              transfer loc for opnd 1 non-numeric\endln
\lnie
ppm  loc              transfer loc for opnd 2 non-numeric\endln
\ifmac{.cnra}
\asmac{else}
\lnie
ppm  loc              transfer loc for real operands\endln
\asmac{fi}
\lnie
\endln
\lnie
for integer args, control returns past the parameters\endln
\lnie
\endln
\lnie
(ia)                  left operand value\endln
\lnie
(xr)                  ptr to icblk for left operand\endln
\lnie
(xl)                  ptr to icblk for right operand\endln
\lnie
(xs)                  popped twice\endln
\lnie
(wa,wb,ra)            destroyed\endln
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
for real arguments, control returns to the location\endln
\lnie
specified by the third parameter.\endln
\lnie
\endln
\lnie
(ra)                  left operand value\endln
\lnie
(xr)                  ptr to rcblk for left operand\endln
\lnie
(xl)                  ptr to rcblk for right operand\endln
\lnie
(wa,wb,wc)            destroyed\endln
\lnie
(xs)                  popped twice\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
arith (continued)\endln
\lnie
\endln
\lnie
entry point\endln
\lnie
\endln
\ifmac{.cnra}
\inst{arith}{prc}{n,2}{entry point}
\asmac{else}
\inst{arith}{prc}{n,3}{entry point}
\asmac{fi}
\inst{}{mov}{(xs)+,xl}{load right operand}
\inst{}{mov}{(xs)+,xr}{load left operand}
\inst{}{mov}{(xl),wa}{get right operand type word}
\inst{}{beq}{wa,=b$icl,arth1}{jump if integer}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$rcl,arth4}{jump if real}
\asmac{fi}
\inst{}{mov}{xr,-(xs)}{else replace left arg on stack}
\inst{}{mov}{xl,xr}{copy left arg pointer}
\inst{}{jsr}{gtnum}{convert to numeric}
\inst{}{ppm}{arth6}{jump if unconvertible}
\inst{}{mov}{xr,xl}{else copy converted result}
\inst{}{mov}{(xl),wa}{get right operand type word}
\inst{}{mov}{(xs)+,xr}{reload left argument}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$rcl,arth4}{jump if right arg is real}
\asmac{fi}
\lnie
\endln
\lnie
here if right arg is an integer\endln
\lnie
\endln
\inst{arth1}{bne}{(xr),=b$icl,arth3}{jump if left arg not integer}
\lnie
\endln
\lnie
exit for integer case\endln
\lnie
\endln
\inst{arth2}{ldi}{icval(xr)}{load left operand value}
\inst{}{exi}{}{return to arith caller}
\lnie
\endln
\lnie
here for right operand integer, left operand not\endln
\lnie
\endln
\inst{arth3}{jsr}{gtnum}{convert left arg to numeric}
\inst{}{ppm}{arth7}{jump if not convertible}
\inst{}{beq}{wa,=b$icl,arth2}{jump back if integer-integer}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here we must convert real-integer to real-real\endln
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{put left arg back on stack}
\inst{}{ldi}{icval(xl)}{load right argument value}
\inst{}{itr}{}{convert to real}
\inst{}{jsr}{rcbld}{get real block for right arg, merge}
\inst{}{mov}{xr,xl}{copy right arg ptr}
\inst{}{mov}{(xs)+,xr}{load left argument}
\inst{}{brn}{arth5}{merge for real-real case}
\vfill\break

\lnie
\endln
\lnie
arith (continued)\endln
\lnie
\endln
\lnie
here if right argument is real\endln
\lnie
\endln
\inst{arth4}{beq}{(xr),=b$rcl,arth5}{jump if left arg real}
\inst{}{jsr}{gtrea}{else convert to real}
\inst{}{ppm}{arth7}{error if unconvertible}
\lnie
\endln
\lnie
here for real-real\endln
\lnie
\endln
\inst{arth5}{ldr}{rcval(xr)}{load left operand value}
\inst{}{exi}{3}{take real-real exit}
\asmac{fi}
\lnie
\endln
\lnie
here for error converting right argument\endln
\lnie
\endln
\inst{arth6}{ica}{xs}{pop unwanted left arg}
\inst{}{exi}{2}{take appropriate error exit}
\lnie
\endln
\lnie
here for error converting left operand\endln
\lnie
\endln
\inst{arth7}{exi}{1}{take appropriate error return}
\inst{}{enp}{}{end procedure arith}
\vfill\break

\lnie
\endln
\lnie
asign -- perform assignment\endln
\lnie
\endln
\lnie
asign performs the assignment of a value to a variable\endln
\lnie
with appropriate checks for output associations and\endln
\lnie
value trace associations which are executed as required.\endln
\lnie
asign also handles the special cases of assignment to\endln
\lnie
pattern and expression variables.\endln
\lnie
\endln
\lnie
(wb)                  value to be assigned\endln
\lnie
(xl)                  base pointer for variable\endln
\lnie
(wa)                  offset for variable\endln
\lnie
jsr  asign            call to assign value to variable\endln
\lnie
ppm  loc              transfer loc for failure\endln
\lnie
(xr,xl,wa,wb,wc)      destroyed\endln
\lnie
(ra)                  destroyed\endln
\lnie
\endln
\lnie
failure occurs if the evaluation of an expression\endln
\lnie
associated with an expression variable fails.\endln
\lnie
\endln
\inst{asign}{prc}{r,1}{entry point (recursive)}
\lnie
\endln
\lnie
merge back here to assign result to expression variable.\endln
\lnie
\endln
\inst{asg01}{add}{wa,xl}{point to variable value}
\inst{}{mov}{(xl),xr}{load variable value}
\inst{}{beq}{(xr),=b$trt,asg02}{jump if trapped}
\inst{}{mov}{wb,(xl)}{else perform assignment}
\inst{}{zer}{xl}{clear garbage value in xl}
\inst{}{exi}{}{and return to asign caller}
\lnie
\endln
\lnie
here if value is trapped\endln
\lnie
\endln
\inst{asg02}{sub}{wa,xl}{restore name base}
\inst{}{beq}{xr,=trbkv,asg14}{jump if keyword variable}
\inst{}{bne}{xr,=trbev,asg04}{jump if not expression variable}
\lnie
\endln
\lnie
here for assignment to expression variable\endln
\lnie
\endln
\inst{}{mov}{evexp(xl),xr}{point to expression}
\inst{}{mov}{wb,-(xs)}{store value to assign on stack}
\inst{}{mov}{=num01,wb}{set for evaluation by name}
\inst{}{jsr}{evalx}{evaluate expression by name}
\inst{}{ppm}{asg03}{jump if evaluation fails}
\inst{}{mov}{(xs)+,wb}{else reload value to assign}
\inst{}{brn}{asg01}{loop back to perform assignment}
\vfill\break

\lnie
\endln
\lnie
asign (continued)\endln
\lnie
\endln
\lnie
here for failure during expression evaluation\endln
\lnie
\endln
\inst{asg03}{ica}{xs}{remove stacked value entry}
\inst{}{exi}{1}{take failure exit}
\lnie
\endln
\lnie
here if not keyword or expression variable\endln
\lnie
\endln
\inst{asg04}{mov}{xr,-(xs)}{save ptr to first trblk}
\lnie
\endln
\lnie
loop to chase down trblk chain and assign value at end\endln
\lnie
\endln
\inst{asg05}{mov}{xr,wc}{save ptr to this trblk}
\inst{}{mov}{trnxt(xr),xr}{point to next trblk}
\inst{}{beq}{(xr),=b$trt,asg05}{loop back if another trblk}
\inst{}{mov}{wc,xr}{else point back to last trblk}
\inst{}{mov}{wb,trval(xr)}{store value at end of chain}
\inst{}{mov}{(xs)+,xr}{restore ptr to first trblk}
\lnie
\endln
\lnie
loop to process trblk entries on chain\endln
\lnie
\endln
\inst{asg06}{mov}{trtyp(xr),wb}{load type code of trblk}
\inst{}{beq}{wb,=trtvl,asg08}{jump if value trace}
\inst{}{beq}{wb,=trtou,asg10}{jump if output association}
\lnie
\endln
\lnie
here to move to next trblk on chain\endln
\lnie
\endln
\inst{asg07}{mov}{trnxt(xr),xr}{point to next trblk on chain}
\inst{}{beq}{(xr),=b$trt,asg06}{loop back if another trblk}
\inst{}{exi}{}{else end of chain, return to caller}
\lnie
\endln
\lnie
here to process value trace\endln
\lnie
\endln
\inst{asg08}{bze}{kvtra,asg07}{ignore value trace if trace off}
\inst{}{dcv}{kvtra}{else decrement trace count}
\inst{}{bze}{trfnc(xr),asg09}{jump if print trace}
\inst{}{jsr}{trxeq}{else execute function trace}
\inst{}{brn}{asg07}{and loop back}
\vfill\break

\lnie
\endln
\lnie
asign (continued)\endln
\lnie
\endln
\lnie
here for print trace\endln
\lnie
\endln
\inst{asg09}{jsr}{prtsn}{print statement number}
\inst{}{jsr}{prtnv}{print name = value}
\inst{}{brn}{asg07}{loop back for next trblk}
\lnie
\endln
\lnie
here for output association\endln
\lnie
\endln
\inst{asg10}{bze}{kvoup,asg07}{ignore output assoc if output off}
\inst{asg1b}{mov}{xr,xl}{copy trblk pointer}
\inst{}{mov}{trnxt(xr),xr}{point to next trblk}
\inst{}{beq}{(xr),=b$trt,asg1b}{loop back if another trblk}
\inst{}{mov}{xl,xr}{else point back to last trblk}
\ifmac{.cnbf}
\inst{}{mov}{trval(xr),-(xs)}{stack value to output}
\asmac{else}
\inst{}{mov}{trval(xr),xr}{get value to output}
\inst{}{beq}{(xr),=b$bct,asg11}{branch if buffer}
\inst{}{mov}{xr,-(xs)}{stack value to output}
\asmac{fi}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{asg12}{get datatype name if unconvertible}
\lnie
\endln
\lnie
merge with string or buffer to output in xr\endln
\lnie
\endln
\inst{asg11}{mov}{trfpt(xl),wa}{fcblk ptr}
\inst{}{bze}{wa,asg13}{jump if standard output file}
\lnie
\endln
\lnie
here for output to file\endln
\lnie
\endln
\inst{asg1a}{jsr}{sysou}{call system output routine}
\inst{}{err}{206,output caused}{file overflow}
\inst{}{err}{207,output caused}{non-recoverable error}
\inst{}{exi}{}{else all done, return to caller}
\lnie
\endln
\lnie
if not printable, get datatype name instead\endln
\lnie
\endln
\inst{asg12}{jsr}{dtype}{call datatype routine}
\inst{}{brn}{asg11}{merge}
\lnie
\endln
\lnie
here to print a string to standard output or terminal\endln
\lnie
\endln
\ifmac{.csou}
\inst{asg13}{beq}{trter(xl),=v$ter,asg1a}{jump if terminal output}
\inst{}{icv}{wa}{signal standard output}
\inst{}{brn}{asg1a}{use sysou to perform output}
\asmac{else}
\ifmac{.cnbf}
\inst{asg13}{jsr}{prtst}{print string value}
\asmac{else}
\inst{asg13}{bne}{(xr),=b$bct,asg1c}{branch if not buffer}
\inst{}{mov}{xr,-(xs)}{stack buffer}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{}{always succeeds}
\inst{asg1c}{jsr}{prtst}{print string value}
\asmac{fi}
\inst{}{beq}{trter(xl),=v$ter,asg20}{jump if terminal output}
\inst{}{jsr}{prtnl}{end of line}
\inst{}{exi}{}{return to caller}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
asign (continued)\endln
\lnie
\endln
\lnie
here for keyword assignment\endln
\lnie
\endln
\inst{asg14}{mov}{kvnum(xl),xl}{load keyword number}
\inst{}{beq}{xl,=k$etx,asg19}{jump if errtext}
\inst{}{mov}{wb,xr}{copy value to be assigned}
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{err}{208,keyword value}{assigned is not integer}
\inst{}{ldi}{icval(xr)}{else load value}
\inst{}{beq}{xl,=k$stl,asg16}{jump if special case of stlimit}
\inst{}{mfi}{wa,asg18}{else get addr integer, test ovflow}
\inst{}{bgt}{wa,mxlen,asg18}{fail if too large}
\inst{}{beq}{xl,=k$ert,asg17}{jump if special case of errtype}
\ifmac{.cnpf}
\asmac{else}
\inst{}{beq}{xl,=k$pfl,asg21}{jump if special case of profile}
\asmac{fi}
\inst{}{beq}{xl,=k$mxl,asg24}{jump if special case of maxlngth}
\inst{}{beq}{xl,=k$fls,asg26}{jump if special case of fullscan}
\inst{}{blt}{xl,=k$p$$,asg15}{jump unless protected}
\inst{}{erb}{209,keyword in assignment}{is protected}
\lnie
\endln
\lnie
here to do assignment if not protected\endln
\lnie
\endln
\inst{asg15}{mov}{wa,kvabe(xl)}{store new value}
\inst{}{exi}{}{return to asign caller}
\lnie
\endln
\lnie
here for special case of stlimit\endln
\lnie
\endln
\lnie
since stcount is maintained as (stlimit-stcount)\endln
\lnie
it is also necessary to modify stcount appropriately.\endln
\lnie
\endln
\inst{asg16}{sbi}{kvstl}{subtract old limit}
\inst{}{adi}{kvstc}{add old counter}
\inst{}{sti}{kvstc}{store course counter value}
\inst{}{ldi}{kvstl}{check if counting suppressed}
\inst{}{ilt}{asg25}{do not refine if so}
\inst{}{mov}{stmcs,wa}{refine with counter breakout}
\inst{}{sub}{stmct,wa}{values}
\inst{}{mti}{wa}{convert to integer}
\inst{}{ngi}{}{current-start value}
\inst{}{adi}{kvstc}{add in course counter value}
\inst{}{sti}{kvstc}{save refined value}
\inst{asg25}{ldi}{icval(xr)}{reload new limit value}
\inst{}{sti}{kvstl}{store new limit value}
\inst{}{jsr}{stgcc}{recompute countdown counters}
\inst{}{exi}{}{return to asign caller}
\lnie
\endln
\lnie
here for special case of errtype\endln
\lnie
\endln
\inst{asg17}{ble}{wa,=nini9,error}{ok to signal if in range}
\lnie
\endln
\lnie
here if value assigned is out of range\endln
\lnie
\endln
\inst{asg18}{erb}{210,keyword value}{assigned is negative or too large}
\lnie
\endln
\lnie
here for special case of errtext\endln
\lnie
\endln
\inst{asg19}{mov}{wb,-(xs)}{stack value}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{err}{211,value assigned}{to keyword errtext not a string}
\inst{}{mov}{xr,r$etx}{make assignment}
\inst{}{exi}{}{return to caller}
\ifmac{.csou}
\asmac{else}
\lnie
\endln
\lnie
print string to terminal\endln
\lnie
\endln
\inst{asg20}{jsr}{prttr}{print}
\inst{}{exi}{}{return}
\asmac{fi}
\lnie
\endln
\ifmac{.cnpf}
\asmac{else}
\lnie
here for keyword profile\endln
\lnie
\endln
\inst{asg21}{bgt}{wa,=num02,asg18}{moan if not 0,1, or 2}
\inst{}{bze}{wa,asg15}{just assign if zero}
\inst{}{bze}{pfdmp,asg22}{branch if first assignment}
\inst{}{beq}{wa,pfdmp,asg23}{also if same value as before}
\inst{}{erb}{268,inconsistent}{value assigned to keyword profile}
\lnie
\endln
\inst{asg22}{mov}{wa,pfdmp}{note value on first assignment}
\inst{asg23}{mov}{wa,kvpfl}{store new value}
\inst{}{jsr}{stgcc}{recompute countdown counts}
\inst{}{jsr}{systm}{get the time}
\inst{}{sti}{pfstm}{fudge some kind of start time}
\inst{}{exi}{}{return to asign caller}
\asmac{fi}
\lnie
\endln
\lnie
here for keyword maxlngth\endln
\lnie
\endln
\inst{asg24}{bge}{wa,=mnlen,asg15}{if acceptable value}
\inst{}{erb}{287,value assigned}{to keyword maxlngth is too small}
\lnie
\endln
\lnie
here for keyword fullscan\endln
\lnie
\endln
\inst{asg26}{bnz}{wa,asg15}{if acceptable value}
\inst{}{erb}{274,value assigned}{to keyword fullscan is zero}
\lnie
\endln
\inst{}{enp}{}{end procedure asign}
\vfill\break

\lnie
\endln
\lnie
asinp -- assign during pattern match\endln
\lnie
\endln
\lnie
asinp is like asign and has a similar calling sequence\endln
\lnie
and effect. the difference is that the global pattern\endln
\lnie
variables are saved and restored if required.\endln
\lnie
\endln
\lnie
(xl)                  base pointer for variable\endln
\lnie
(wa)                  offset for variable\endln
\lnie
(wb)                  value to be assigned\endln
\lnie
jsr  asinp            call to assign value to variable\endln
\lnie
ppm  loc              transfer loc if failure\endln
\lnie
(xr,xl)               destroyed\endln
\lnie
(wa,wb,wc,ra)         destroyed\endln
\lnie
\endln
\inst{asinp}{prc}{r,1}{entry point, recursive}
\inst{}{add}{wa,xl}{point to variable}
\inst{}{mov}{(xl),xr}{load current contents}
\inst{}{beq}{(xr),=b$trt,asnp1}{jump if trapped}
\inst{}{mov}{wb,(xl)}{else perform assignment}
\inst{}{zer}{xl}{clear garbage value in xl}
\inst{}{exi}{}{return to asinp caller}
\lnie
\endln
\lnie
here if variable is trapped\endln
\lnie
\endln
\inst{asnp1}{sub}{wa,xl}{restore base pointer}
\inst{}{mov}{pmssl,-(xs)}{stack subject string length}
\inst{}{mov}{pmhbs,-(xs)}{stack history stack base ptr}
\inst{}{mov}{r$pms,-(xs)}{stack subject string pointer}
\inst{}{mov}{pmdfl,-(xs)}{stack dot flag}
\inst{}{jsr}{asign}{call full-blown assignment routine}
\inst{}{ppm}{asnp2}{jump if failure}
\inst{}{mov}{(xs)+,pmdfl}{restore dot flag}
\inst{}{mov}{(xs)+,r$pms}{restore subject string pointer}
\inst{}{mov}{(xs)+,pmhbs}{restore history stack base pointer}
\inst{}{mov}{(xs)+,pmssl}{restore subject string length}
\inst{}{exi}{}{return to asinp caller}
\lnie
\endln
\lnie
here if failure in asign call\endln
\lnie
\endln
\inst{asnp2}{mov}{(xs)+,pmdfl}{restore dot flag}
\inst{}{mov}{(xs)+,r$pms}{restore subject string pointer}
\inst{}{mov}{(xs)+,pmhbs}{restore history stack base pointer}
\inst{}{mov}{(xs)+,pmssl}{restore subject string length}
\inst{}{exi}{1}{take failure exit}
\inst{}{enp}{}{end procedure asinp}
\vfill\break

\lnie
\endln
\lnie
blkln -- determine length of block\endln
\lnie
\endln
\lnie
blkln determines the length of a block in dynamic store.\endln
\lnie
\endln
\lnie
(wa)                  first word of block\endln
\lnie
(xr)                  pointer to block\endln
\lnie
jsr  blkln            call to get block length\endln
\lnie
(wa)                  length of block in bytes\endln
\lnie
(xl)                  destroyed\endln
\lnie
\endln
\lnie
blkln is used by the garbage collector and is not\endln
\lnie
permitted to call gbcol directly or indirectly.\endln
\lnie
\endln
\lnie
the first word stored in the block (i.e. at xr) may\endln
\lnie
be anything, but the contents of wa must be correct.\endln
\lnie
\endln
\inst{blkln}{prc}{e,0}{entry point}
\inst{}{mov}{wa,xl}{copy first word}
\inst{}{lei}{xl}{get entry id (bl$xx)}
\inst{}{bsw}{xl,bl$$$,bln00}{switch on block type}
\inst{}{iff}{bl$ar,bln01}{arblk}
\ifmac{.cnbf}
\asmac{else}
\inst{}{iff}{bl$bc,bln04}{bcblk}
\inst{}{iff}{bl$bf,bln11}{bfblk}
\asmac{fi}
\ifmac{.csln}
\inst{}{iff}{bl$cd,bln12}{cdblk}
\asmac{else}
\inst{}{iff}{bl$cd,bln01}{cdblk}
\asmac{fi}
\inst{}{iff}{bl$df,bln01}{dfblk}
\inst{}{iff}{bl$ef,bln01}{efblk}
\ifmac{.csln}
\inst{}{iff}{bl$ex,bln12}{exblk}
\asmac{else}
\inst{}{iff}{bl$ex,bln01}{exblk}
\asmac{fi}
\inst{}{iff}{bl$pf,bln01}{pfblk}
\inst{}{iff}{bl$tb,bln01}{tbblk}
\inst{}{iff}{bl$vc,bln01}{vcblk}
\inst{}{iff}{bl$ev,bln03}{evblk}
\inst{}{iff}{bl$kv,bln03}{kvblk}
\inst{}{iff}{bl$p0,bln02}{p0blk}
\inst{}{iff}{bl$se,bln02}{seblk}
\inst{}{iff}{bl$nm,bln03}{nmblk}
\inst{}{iff}{bl$p1,bln03}{p1blk}
\inst{}{iff}{bl$p2,bln04}{p2blk}
\inst{}{iff}{bl$te,bln04}{teblk}
\inst{}{iff}{bl$ff,bln05}{ffblk}
\inst{}{iff}{bl$tr,bln05}{trblk}
\inst{}{iff}{bl$ct,bln06}{ctblk}
\inst{}{iff}{bl$ic,bln07}{icblk}
\inst{}{iff}{bl$pd,bln08}{pdblk}
\ifmac{.cnra}
\asmac{else}
\inst{}{iff}{bl$rc,bln09}{rcblk}
\asmac{fi}
\inst{}{iff}{bl$sc,bln10}{scblk}
\inst{}{esw}{}{end of jump table on block type}
\vfill\break

\lnie
\endln
\lnie
blkln (continued)\endln
\lnie
\endln
\lnie
here for blocks with length in second word\endln
\lnie
\endln
\inst{bln00}{mov}{num01(xr),wa}{load length}
\inst{}{exi}{}{return to blkln caller}
\lnie
\endln
\lnie
here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)\endln
\lnie
\endln
\inst{bln01}{mov}{num02(xr),wa}{load length from third word}
\inst{}{exi}{}{return to blkln caller}
\lnie
\endln
\lnie
here for two word blocks (p0,se)\endln
\lnie
\endln
\inst{bln02}{mov}{*num02,wa}{load length (two words)}
\inst{}{exi}{}{return to blkln caller}
\lnie
\endln
\lnie
here for three word blocks (nm,p1,ev,kv)\endln
\lnie
\endln
\inst{bln03}{mov}{*num03,wa}{load length (three words)}
\inst{}{exi}{}{return to blkln caller}
\lnie
\endln
\lnie
here for four word blocks (p2,te,bc)\endln
\lnie
\endln
\inst{bln04}{mov}{*num04,wa}{load length (four words)}
\inst{}{exi}{}{return to blkln caller}
\lnie
\endln
\lnie
here for five word blocks (ff,tr)\endln
\lnie
\endln
\inst{bln05}{mov}{*num05,wa}{load length}
\inst{}{exi}{}{return to blkln caller}
\vfill\break

\lnie
\endln
\lnie
blkln (continued)\endln
\lnie
\endln
\lnie
here for ctblk\endln
\lnie
\endln
\inst{bln06}{mov}{*ctsi$,wa}{set size of ctblk}
\inst{}{exi}{}{return to blkln caller}
\lnie
\endln
\lnie
here for icblk\endln
\lnie
\endln
\inst{bln07}{mov}{*icsi$,wa}{set size of icblk}
\inst{}{exi}{}{return to blkln caller}
\lnie
\endln
\lnie
here for pdblk\endln
\lnie
\endln
\inst{bln08}{mov}{pddfp(xr),xl}{point to dfblk}
\inst{}{mov}{dfpdl(xl),wa}{load pdblk length from dfblk}
\inst{}{exi}{}{return to blkln caller}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here for rcblk\endln
\lnie
\endln
\inst{bln09}{mov}{*rcsi$,wa}{set size of rcblk}
\inst{}{exi}{}{return to blkln caller}
\asmac{fi}
\lnie
\endln
\lnie
here for scblk\endln
\lnie
\endln
\inst{bln10}{mov}{sclen(xr),wa}{load length in characters}
\inst{}{ctb}{wa,scsi$}{calculate length in bytes}
\inst{}{exi}{}{return to blkln caller}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
here for bfblk\endln
\lnie
\endln
\inst{bln11}{mov}{bfalc(xr),wa}{get allocation in bytes}
\inst{}{ctb}{wa,bfsi$}{calculate length in bytes}
\inst{}{exi}{}{return to blkln caller}
\asmac{fi}
\ifmac{.csln}
\lnie
\endln
\lnie
here for length in fourth word (cd,ex)\endln
\lnie
\endln
\inst{bln12}{mov}{num03(xr),wa}{load length from cdlen/exlen}
\inst{}{exi}{}{return to blkln caller}
\asmac{fi}
\inst{}{enp}{}{end procedure blkln}
\vfill\break

\lnie
\endln
\lnie
copyb -- copy a block\endln
\lnie
\endln
\lnie
(xs)                  block to be copied\endln
\lnie
jsr  copyb            call to copy block\endln
\lnie
ppm  loc              return if block has no idval field\endln
\lnie
                      normal return if idval field\endln
\lnie
(xr)                  copy of block\endln
\lnie
(xs)                  popped\endln
\lnie
(xl,wa,wb,wc)         destroyed\endln
\lnie
\endln
\inst{copyb}{prc}{n,1}{entry point}
\inst{}{mov}{(xs),xr}{load argument}
\inst{}{beq}{xr,=nulls,cop10}{return argument if it is null}
\inst{}{mov}{(xr),wa}{else load type word}
\inst{}{mov}{wa,wb}{copy type word}
\inst{}{jsr}{blkln}{get length of argument block}
\inst{}{mov}{xr,xl}{copy pointer}
\inst{}{jsr}{alloc}{allocate block of same size}
\inst{}{mov}{xr,(xs)}{store pointer to copy}
\inst{}{mvw}{}{copy contents of old block to new}
\inst{}{zer}{xl}{clear garbage xl}
\inst{}{mov}{(xs),xr}{reload pointer to start of copy}
\inst{}{beq}{wb,=b$tbt,cop05}{jump if table}
\inst{}{beq}{wb,=b$vct,cop01}{jump if vector}
\inst{}{beq}{wb,=b$pdt,cop01}{jump if program defined}
\ifmac{.cnbf}
\asmac{else}
\inst{}{beq}{wb,=b$bct,cop11}{jump if buffer}
\asmac{fi}
\inst{}{bne}{wb,=b$art,cop10}{return copy if not array}
\lnie
\endln
\lnie
here for array (arblk)\endln
\lnie
\endln
\inst{}{add}{arofs(xr),xr}{point to prototype field}
\inst{}{brn}{cop02}{jump to merge}
\lnie
\endln
\lnie
here for vector, program defined\endln
\lnie
\endln
\inst{cop01}{add}{*pdfld,xr}{point to pdfld = vcvls}
\lnie
\endln
\lnie
merge here for arblk, vcblk, pdblk to delete trap\endln
\lnie
blocks from all value fields (the copy is untrapped)\endln
\lnie
\endln
\inst{cop02}{mov}{(xr),xl}{load next pointer}
\lnie
\endln
\lnie
loop to get value at end of trblk chain\endln
\lnie
\endln
\inst{cop03}{bne}{(xl),=b$trt,cop04}{jump if not trapped}
\inst{}{mov}{trval(xl),xl}{else point to next value}
\inst{}{brn}{cop03}{and loop back}
\vfill\break

\lnie
\endln
\lnie
copyb (continued)\endln
\lnie
\endln
\lnie
here with untrapped value in xl\endln
\lnie
\endln
\inst{cop04}{mov}{xl,(xr)+}{store real value, bump pointer}
\inst{}{bne}{xr,dnamp,cop02}{loop back if more to go}
\inst{}{brn}{cop09}{else jump to exit}
\lnie
\endln
\lnie
here to copy a table\endln
\lnie
\endln
\inst{cop05}{zer}{idval(xr)}{zero id to stop dump blowing up}
\inst{}{mov}{*tesi$,wa}{set size of teblk}
\inst{}{mov}{*tbbuk,wc}{set initial offset}
\lnie
\endln
\lnie
loop through buckets in table\endln
\lnie
\endln
\inst{cop06}{mov}{(xs),xr}{load table pointer}
\inst{}{beq}{wc,tblen(xr),cop09}{jump to exit if all done}
\inst{}{mov}{wc,wb}{else copy offset}
\inst{}{sub}{*tenxt,wb}{subtract link offset to merge}
\inst{}{add}{wb,xr}{next bucket header less link offset}
\inst{}{ica}{wc}{bump offset}
\lnie
\endln
\lnie
loop through teblks on one chain\endln
\lnie
\endln
\inst{cop07}{mov}{tenxt(xr),xl}{load pointer to next teblk}
\inst{}{mov}{(xs),tenxt(xr)}{set end of chain pointer in case}
\inst{}{beq}{(xl),=b$tbt,cop06}{back for next bucket if chain end}
\inst{}{sub}{wb,xr}{point to head of previous block}
\inst{}{mov}{xr,-(xs)}{stack ptr to previous block}
\inst{}{mov}{*tesi$,wa}{set size of teblk}
\inst{}{jsr}{alloc}{allocate new teblk}
\inst{}{mov}{xr,-(xs)}{stack ptr to new teblk}
\inst{}{mvw}{}{copy old teblk to new teblk}
\inst{}{mov}{(xs)+,xr}{restore pointer to new teblk}
\inst{}{mov}{(xs)+,xl}{restore pointer to previous block}
\inst{}{add}{wb,xl}{add offset back in}
\inst{}{mov}{xr,tenxt(xl)}{link new block to previous}
\inst{}{mov}{xr,xl}{copy pointer to new block}
\lnie
\endln
\lnie
loop to set real value after removing trap chain\endln
\lnie
\endln
\inst{cop08}{mov}{teval(xl),xl}{load value}
\inst{}{beq}{(xl),=b$trt,cop08}{loop back if trapped}
\inst{}{mov}{xl,teval(xr)}{store untrapped value in teblk}
\inst{}{zer}{wb}{zero offset within teblk}
\inst{}{brn}{cop07}{back for next teblk}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{cop09}{mov}{(xs)+,xr}{load pointer to block}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
alternative return\endln
\lnie
\endln
\inst{cop10}{exi}{1}{return}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
here to copy buffer\endln
\lnie
\endln
\inst{cop11}{mov}{bcbuf(xr),xl}{get bfblk ptr}
\inst{}{mov}{bfalc(xl),wa}{get allocation}
\inst{}{ctb}{wa,bfsi$}{set total size}
\inst{}{mov}{xr,xl}{save bcblk ptr}
\inst{}{jsr}{alloc}{allocate bfblk}
\inst{}{mov}{bcbuf(xl),wb}{get old bfblk}
\inst{}{mov}{xr,bcbuf(xl)}{set pointer to new bfblk}
\inst{}{mov}{wb,xl}{point to old bfblk}
\inst{}{mvw}{}{copy bfblk too}
\inst{}{zer}{xl}{clear rubbish ptr}
\inst{}{brn}{cop09}{branch to exit}
\asmac{fi}
\inst{}{enp}{}{end procedure copyb}
\lnie
\endln
\lnie
cdgcg -- generate code for complex goto\endln
\lnie
\endln
\lnie
used by cmpil to process complex goto tree\endln
\lnie
\endln
\lnie
(wb)                  must be collectable\endln
\lnie
(xr)                  expression pointer\endln
\lnie
jsr  cdgcg            call to generate complex goto\endln
\lnie
(xl,xr,wa)            destroyed\endln
\lnie
\endln
\inst{cdgcg}{prc}{e,0}{entry point}
\inst{}{mov}{cmopn(xr),xl}{get unary goto operator}
\inst{}{mov}{cmrop(xr),xr}{point to goto operand}
\inst{}{beq}{xl,=opdvd,cdgc2}{jump if direct goto}
\inst{}{jsr}{cdgnm}{generate opnd by name if not direct}
\lnie
\endln
\lnie
return point\endln
\lnie
\endln
\inst{cdgc1}{mov}{xl,wa}{goto operator}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
direct goto\endln
\lnie
\endln
\inst{cdgc2}{jsr}{cdgvl}{generate operand by value}
\inst{}{brn}{cdgc1}{merge to return}
\inst{}{enp}{}{end procedure cdgcg}
\vfill\break

\lnie
\endln
\lnie
cdgex -- build expression block\endln
\lnie
\endln
\lnie
cdgex is passed a pointer to an expression tree (see\endln
\lnie
expan) and returns an expression (seblk or exblk).\endln
\lnie
\endln
\ifmac{.cevb}
\lnie
(wa)                  0 if by value, 1 if by name\endln
\asmac{fi}
\lnie
(wc)                  some collectable value\endln
\lnie
(wb)                  integer in range 0 le x le mxlen\endln
\lnie
(xl)                  ptr to expression tree\endln
\lnie
jsr  cdgex            call to build expression\endln
\lnie
(xr)                  ptr to seblk or exblk\endln
\lnie
(xl,wa,wb)            destroyed\endln
\lnie
\endln
\inst{cdgex}{prc}{r,0}{entry point, recursive}
\inst{}{blo}{(xl),=b$vr$,cdgx1}{jump if not variable}
\lnie
\endln
\lnie
here for natural variable, build seblk\endln
\lnie
\endln
\inst{}{mov}{*sesi$,wa}{set size of seblk}
\inst{}{jsr}{alloc}{allocate space for seblk}
\inst{}{mov}{=b$sel,(xr)}{set type word}
\inst{}{mov}{xl,sevar(xr)}{store vrblk pointer}
\inst{}{exi}{}{return to cdgex caller}
\lnie
\endln
\lnie
here if not variable, build exblk\endln
\lnie
\endln
\inst{cdgx1}{mov}{xl,xr}{copy tree pointer}
\inst{}{mov}{wc,-(xs)}{save wc}
\inst{}{mov}{cwcof,xl}{save current offset}
\ifmac{.cevb}
\inst{}{bze}{wa,cdgx2}{jump if by value}
\asmac{fi}
\inst{}{mov}{(xr),wa}{get type word}
\inst{}{bne}{wa,=b$cmt,cdgx2}{call by value if not cmblk}
\inst{}{bge}{cmtyp(xr),=c$$nm,cdgx2}{jump if cmblk only by value}
\vfill\break

\lnie
\endln
\lnie
cdgex (continued)\endln
\lnie
\endln
\lnie
here if expression can be evaluated by name\endln
\lnie
\endln
\inst{}{jsr}{cdgnm}{generate code by name}
\inst{}{mov}{=ornm$,wa}{load return by name word}
\inst{}{brn}{cdgx3}{merge with value case}
\lnie
\endln
\lnie
here if expression can only be evaluated by value\endln
\lnie
\endln
\inst{cdgx2}{jsr}{cdgvl}{generate code by value}
\inst{}{mov}{=orvl$,wa}{load return by value word}
\lnie
\endln
\lnie
merge here to construct exblk\endln
\lnie
\endln
\inst{cdgx3}{jsr}{cdwrd}{generate return word}
\inst{}{jsr}{exbld}{build exblk}
\inst{}{mov}{(xs)+,wc}{restore wc}
\inst{}{exi}{}{return to cdgex caller}
\inst{}{enp}{}{end procedure cdgex}
\vfill\break

\lnie
\endln
\lnie
cdgnm -- generate code by name\endln
\lnie
\endln
\lnie
cdgnm is called during the compilation process to\endln
\lnie
generate code by name for an expression. see cdblk\endln
\lnie
description for details of code generated. the input\endln
\lnie
to cdgnm is an expression tree as generated by expan.\endln
\lnie
\endln
\lnie
cdgnm is a recursive procedure which proceeds by making\endln
\lnie
recursive calls to generate code for operands.\endln
\lnie
\endln
\lnie
(wb)                  integer in range 0 le n le dnamb\endln
\lnie
(xr)                  ptr to tree generated by expan\endln
\lnie
(wc)                  constant flag (see below)\endln
\lnie
jsr  cdgnm            call to generate code by name\endln
\lnie
(xr,wa)               destroyed\endln
\lnie
(wc)                  set non-zero if non-constant\endln
\lnie
\endln
\lnie
wc is set to a non-zero (collectable) value if the\endln
\lnie
expression for which code is generated cannot be\endln
\lnie
evaluated at compile time, otherwise wc is unchanged.\endln
\lnie
\endln
\lnie
the code is generated in the current ccblk (see cdwrd).\endln
\lnie
\endln
\inst{cdgnm}{prc}{r,0}{entry point, recursive}
\inst{}{mov}{xl,-(xs)}{save entry xl}
\inst{}{mov}{wb,-(xs)}{save entry wb}
\inst{}{chk}{}{check for stack overflow}
\inst{}{mov}{(xr),wa}{load type word}
\inst{}{beq}{wa,=b$cmt,cgn04}{jump if cmblk}
\inst{}{bhi}{wa,=b$vr$,cgn02}{jump if simple variable}
\lnie
\endln
\lnie
merge here for operand yielding value (e.g. constant)\endln
\lnie
\endln
\inst{cgn01}{erb}{212,syntax error:}{value used where name is required}
\lnie
\endln
\lnie
here for natural variable reference\endln
\lnie
\endln
\inst{cgn02}{mov}{=olvn$,wa}{load variable load call}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{xr,wa}{copy vrblk pointer}
\inst{}{jsr}{cdwrd}{generate vrblk pointer}
\vfill\break

\lnie
\endln
\lnie
cdgnm (continued)\endln
\lnie
\endln
\lnie
here to exit with wc set correctly\endln
\lnie
\endln
\inst{cgn03}{mov}{(xs)+,wb}{restore entry wb}
\inst{}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{exi}{}{return to cdgnm caller}
\lnie
\endln
\lnie
here for cmblk\endln
\lnie
\endln
\inst{cgn04}{mov}{xr,xl}{copy cmblk pointer}
\inst{}{mov}{cmtyp(xr),xr}{load cmblk type}
\inst{}{bge}{xr,=c$$nm,cgn01}{error if not name operand}
\inst{}{bsw}{xr,c$$nm}{else switch on type}
\inst{}{iff}{c$arr,cgn05}{array reference}
\inst{}{iff}{c$fnc,cgn08}{function call}
\inst{}{iff}{c$def,cgn09}{deferred expression}
\inst{}{iff}{c$ind,cgn10}{indirect reference}
\inst{}{iff}{c$key,cgn11}{keyword reference}
\inst{}{iff}{c$ubo,cgn08}{undefined binary op}
\inst{}{iff}{c$uuo,cgn08}{undefined unary op}
\inst{}{esw}{}{end switch on cmblk type}
\lnie
\endln
\lnie
here to generate code for array reference\endln
\lnie
\endln
\inst{cgn05}{mov}{*cmopn,wb}{point to array operand}
\lnie
\endln
\lnie
loop to generate code for array operand and subscripts\endln
\lnie
\endln
\inst{cgn06}{jsr}{cmgen}{generate code for next operand}
\inst{}{mov}{cmlen(xl),wc}{load length of cmblk}
\inst{}{blt}{wb,wc,cgn06}{loop till all generated}
\lnie
\endln
\lnie
generate appropriate array call\endln
\lnie
\endln
\inst{}{mov}{=oaon$,wa}{load one-subscript case call}
\inst{}{beq}{wc,*cmar1,cgn07}{jump to exit if one subscript case}
\inst{}{mov}{=oamn$,wa}{else load multi-subscript case call}
\inst{}{jsr}{cdwrd}{generate call}
\inst{}{mov}{wc,wa}{copy cmblk length}
\inst{}{btw}{wa}{convert to words}
\inst{}{sub}{=cmvls,wa}{calculate number of subscripts}
\vfill\break

\lnie
\endln
\lnie
cdgnm (continued)\endln
\lnie
\endln
\lnie
here to exit generating word (non-constant)\endln
\lnie
\endln
\inst{cgn07}{mnz}{wc}{set result non-constant}
\inst{}{jsr}{cdwrd}{generate word}
\inst{}{brn}{cgn03}{back to exit}
\lnie
\endln
\lnie
here to generate code for functions and undefined oprs\endln
\lnie
\endln
\inst{cgn08}{mov}{xl,xr}{copy cmblk pointer}
\inst{}{jsr}{cdgvl}{gen code by value for call}
\inst{}{mov}{=ofne$,wa}{get extra call for by name}
\inst{}{brn}{cgn07}{back to generate and exit}
\lnie
\endln
\lnie
here to generate code for defered expression\endln
\lnie
\endln
\inst{cgn09}{mov}{cmrop(xl),xr}{check if variable}
\inst{}{bhi}{(xr),=b$vr$,cgn02}{treat *variable as simple var}
\inst{}{mov}{xr,xl}{copy ptr to expression tree}
\ifmac{.cevb}
\inst{}{mov}{=num01,wa}{return name}
\asmac{fi}
\inst{}{jsr}{cdgex}{else build exblk}
\inst{}{mov}{=olex$,wa}{set call to load expr by name}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{xr,wa}{copy exblk pointer}
\inst{}{jsr}{cdwrd}{generate exblk pointer}
\inst{}{brn}{cgn03}{back to exit}
\lnie
\endln
\lnie
here to generate code for indirect reference\endln
\lnie
\endln
\inst{cgn10}{mov}{cmrop(xl),xr}{get operand}
\inst{}{jsr}{cdgvl}{generate code by value for it}
\inst{}{mov}{=oinn$,wa}{load call for indirect by name}
\inst{}{brn}{cgn12}{merge}
\lnie
\endln
\lnie
here to generate code for keyword reference\endln
\lnie
\endln
\inst{cgn11}{mov}{cmrop(xl),xr}{get operand}
\inst{}{jsr}{cdgnm}{generate code by name for it}
\inst{}{mov}{=okwn$,wa}{load call for keyword by name}
\lnie
\endln
\lnie
keyword, indirect merge here\endln
\lnie
\endln
\inst{cgn12}{jsr}{cdwrd}{generate code for operator}
\inst{}{brn}{cgn03}{exit}
\inst{}{enp}{}{end procedure cdgnm}
\vfill\break

\lnie
\endln
\lnie
cdgvl -- generate code by value\endln
\lnie
\endln
\lnie
cdgvl is called during the compilation process to\endln
\lnie
generate code by value for an expression. see cdblk\endln
\lnie
description for details of the code generated. the input\endln
\lnie
to cdgvl is an expression tree as generated by expan.\endln
\lnie
\endln
\lnie
cdgvl is a recursive procedure which proceeds by making\endln
\lnie
recursive calls to generate code for operands.\endln
\lnie
\endln
\lnie
(wb)                  integer in range 0 le n le dnamb\endln
\lnie
(xr)                  ptr to tree generated by expan\endln
\lnie
(wc)                  constant flag (see below)\endln
\lnie
jsr  cdgvl            call to generate code by value\endln
\lnie
(xr,wa)               destroyed\endln
\lnie
(wc)                  set non-zero if non-constant\endln
\lnie
\endln
\lnie
wc is set to a non-zero (collectable) value if the\endln
\lnie
expression for which code is generated cannot be\endln
\lnie
evaluated at compile time, otherwise wc is unchanged.\endln
\lnie
\endln
\lnie
if wc is non-zero on entry, then preevaluation is not\endln
\lnie
allowed regardless of the nature of the operand.\endln
\lnie
\endln
\lnie
the code is generated in the current ccblk (see cdwrd).\endln
\lnie
\endln
\inst{cdgvl}{prc}{r,0}{entry point, recursive}
\inst{}{mov}{(xr),wa}{load type word}
\inst{}{beq}{wa,=b$cmt,cgv01}{jump if cmblk}
\inst{}{blt}{wa,=b$vra,cgv00}{jump if icblk, rcblk, scblk}
\inst{}{bnz}{vrlen(xr),cgvl0}{jump if not system variable}
\inst{}{mov}{xr,-(xs)}{stack xr}
\inst{}{mov}{vrsvp(xr),xr}{point to svblk}
\inst{}{mov}{svbit(xr),wa}{get svblk property bits}
\inst{}{mov}{(xs)+,xr}{recover xr}
\inst{}{anb}{btkwv,wa}{check if constant keyword value}
\inst{}{beq}{wa,btkwv,cgv00}{jump if constant keyword value}
\lnie
\endln
\lnie
here for variable value reference\endln
\lnie
\endln
\inst{cgvl0}{mnz}{wc}{indicate non-constant value}
\lnie
\endln
\lnie
merge here for simple constant (icblk,rcblk,scblk)\endln
\lnie
and for variables corresponding to constant keywords.\endln
\lnie
\endln
\inst{cgv00}{mov}{xr,wa}{copy ptr to var or constant}
\inst{}{jsr}{cdwrd}{generate as code word}
\inst{}{exi}{}{return to caller}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
here for tree node (cmblk)\endln
\lnie
\endln
\inst{cgv01}{mov}{wb,-(xs)}{save entry wb}
\inst{}{mov}{xl,-(xs)}{save entry xl}
\inst{}{mov}{wc,-(xs)}{save entry constant flag}
\inst{}{mov}{cwcof,-(xs)}{save initial code offset}
\inst{}{chk}{}{check for stack overflow}
\lnie
\endln
\lnie
prepare to generate code for cmblk. wc is set to the\endln
\lnie
value of cswno (zero if -optimise, 1 if -noopt) to\endln
\lnie
start with and is reset non-zero for any non-constant\endln
\lnie
code generated. if it is still zero after generating all\endln
\lnie
the cmblk code, then its value is computed as the result.\endln
\lnie
\endln
\inst{}{mov}{xr,xl}{copy cmblk pointer}
\inst{}{mov}{cmtyp(xr),xr}{load cmblk type}
\inst{}{mov}{cswno,wc}{reset constant flag}
\inst{}{ble}{xr,=c$pr$,cgv02}{jump if not predicate value}
\inst{}{mnz}{wc}{else force non-constant case}
\lnie
\endln
\lnie
here with wc set appropriately\endln
\lnie
\endln
\inst{cgv02}{bsw}{xr,c$$nv}{switch to appropriate generator}
\inst{}{iff}{c$arr,cgv03}{array reference}
\inst{}{iff}{c$fnc,cgv05}{function call}
\inst{}{iff}{c$def,cgv14}{deferred expression}
\inst{}{iff}{c$sel,cgv15}{selection}
\inst{}{iff}{c$ind,cgv31}{indirect reference}
\inst{}{iff}{c$key,cgv27}{keyword reference}
\inst{}{iff}{c$ubo,cgv29}{undefined binop}
\inst{}{iff}{c$uuo,cgv30}{undefined unop}
\inst{}{iff}{c$bvl,cgv18}{binops with val opds}
\inst{}{iff}{c$alt,cgv18}{alternation}
\inst{}{iff}{c$uvl,cgv19}{unops with valu opnd}
\inst{}{iff}{c$ass,cgv21}{assignment}
\inst{}{iff}{c$cnc,cgv24}{concatenation}
\inst{}{iff}{c$cnp,cgv24}{concatenation (not pattern match)}
\inst{}{iff}{c$unm,cgv27}{unops with name opnd}
\inst{}{iff}{c$bvn,cgv26}{binary $ and .}
\inst{}{iff}{c$int,cgv31}{interrogation}
\inst{}{iff}{c$neg,cgv28}{negation}
\inst{}{iff}{c$pmt,cgv18}{pattern match}
\inst{}{esw}{}{end switch on cmblk type}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
here to generate code for array reference\endln
\lnie
\endln
\inst{cgv03}{mov}{*cmopn,wb}{set offset to array operand}
\lnie
\endln
\lnie
loop to generate code for array operand and subscripts\endln
\lnie
\endln
\inst{cgv04}{jsr}{cmgen}{gen value code for next operand}
\inst{}{mov}{cmlen(xl),wc}{load cmblk length}
\inst{}{blt}{wb,wc,cgv04}{loop back if more to go}
\lnie
\endln
\lnie
generate call to appropriate array reference routine\endln
\lnie
\endln
\inst{}{mov}{=oaov$,wa}{set one subscript call in case}
\inst{}{beq}{wc,*cmar1,cgv32}{jump to exit if 1-sub case}
\inst{}{mov}{=oamv$,wa}{else set call for multi-subscripts}
\inst{}{jsr}{cdwrd}{generate call}
\inst{}{mov}{wc,wa}{copy length of cmblk}
\inst{}{sub}{*cmvls,wa}{subtract standard length}
\inst{}{btw}{wa}{get number of words}
\inst{}{brn}{cgv32}{jump to generate subscript count}
\lnie
\endln
\lnie
here to generate code for function call\endln
\lnie
\endln
\inst{cgv05}{mov}{*cmvls,wb}{set offset to first argument}
\lnie
\endln
\lnie
loop to generate code for arguments\endln
\lnie
\endln
\inst{cgv06}{beq}{wb,cmlen(xl),cgv07}{jump if all generated}
\inst{}{jsr}{cmgen}{else gen value code for next arg}
\inst{}{brn}{cgv06}{back to generate next argument}
\lnie
\endln
\lnie
here to generate actual function call\endln
\lnie
\endln
\inst{cgv07}{sub}{*cmvls,wb}{get number of arg ptrs (bytes)}
\inst{}{btw}{wb}{convert bytes to words}
\inst{}{mov}{cmopn(xl),xr}{load function vrblk pointer}
\inst{}{bnz}{vrlen(xr),cgv12}{jump if not system function}
\inst{}{mov}{vrsvp(xr),xl}{load svblk ptr if system var}
\inst{}{mov}{svbit(xl),wa}{load bit mask}
\inst{}{anb}{btffc,wa}{test for fast function call allowed}
\inst{}{zrb}{wa,cgv12}{jump if not}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
here if fast function call is allowed\endln
\lnie
\endln
\inst{}{mov}{svbit(xl),wa}{reload bit indicators}
\inst{}{anb}{btpre,wa}{test for preevaluation ok}
\inst{}{nzb}{wa,cgv08}{jump if preevaluation permitted}
\inst{}{mnz}{wc}{else set result non-constant}
\lnie
\endln
\lnie
test for correct number of args for fast call\endln
\lnie
\endln
\inst{cgv08}{mov}{vrfnc(xr),xl}{load ptr to svfnc field}
\inst{}{mov}{fargs(xl),wa}{load svnar field value}
\inst{}{beq}{wa,wb,cgv11}{jump if argument count is correct}
\inst{}{bhi}{wa,wb,cgv09}{jump if too few arguments given}
\lnie
\endln
\lnie
here if too many arguments, prepare to generate o$pops\endln
\lnie
\endln
\inst{}{sub}{wa,wb}{get number of extra args}
\inst{}{lct}{wb,wb}{set as count to control loop}
\inst{}{mov}{=opop$,wa}{set pop call}
\inst{}{brn}{cgv10}{jump to common loop}
\lnie
\endln
\lnie
here if too few arguments, prepare to generate nulls\endln
\lnie
\endln
\inst{cgv09}{sub}{wb,wa}{get number of missing arguments}
\inst{}{lct}{wb,wa}{load as count to control loop}
\inst{}{mov}{=nulls,wa}{load ptr to null constant}
\lnie
\endln
\lnie
loop to generate calls to fix argument count\endln
\lnie
\endln
\inst{cgv10}{jsr}{cdwrd}{generate one call}
\inst{}{bct}{wb,cgv10}{loop till all generated}
\lnie
\endln
\lnie
here after adjusting arg count as required\endln
\lnie
\endln
\inst{cgv11}{mov}{xl,wa}{copy pointer to svfnc field}
\inst{}{brn}{cgv36}{jump to generate call}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
come here if fast call is not permitted\endln
\lnie
\endln
\inst{cgv12}{mov}{=ofns$,wa}{set one arg call in case}
\inst{}{beq}{wb,=num01,cgv13}{jump if one arg case}
\inst{}{mov}{=ofnc$,wa}{else load call for more than 1 arg}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{wb,wa}{copy argument count}
\lnie
\endln
\lnie
one arg case merges here\endln
\lnie
\endln
\inst{cgv13}{jsr}{cdwrd}{generate =o$fns or arg count}
\inst{}{mov}{xr,wa}{copy vrblk pointer}
\inst{}{brn}{cgv32}{jump to generate vrblk ptr}
\lnie
\endln
\lnie
here for deferred expression\endln
\lnie
\endln
\inst{cgv14}{mov}{cmrop(xl),xl}{point to expression tree}
\ifmac{.cevb}
\inst{}{zer}{wa}{return value}
\asmac{fi}
\inst{}{jsr}{cdgex}{build exblk or seblk}
\inst{}{mov}{xr,wa}{copy block ptr}
\inst{}{jsr}{cdwrd}{generate ptr to exblk or seblk}
\inst{}{brn}{cgv34}{jump to exit, constant test}
\lnie
\endln
\lnie
here to generate code for selection\endln
\lnie
\endln
\inst{cgv15}{zer}{-(xs)}{zero ptr to chain of forward jumps}
\inst{}{zer}{-(xs)}{zero ptr to prev o$slc forward ptr}
\inst{}{mov}{*cmvls,wb}{point to first alternative}
\inst{}{mov}{=osla$,wa}{set initial code word}
\lnie
\endln
\lnie
0(xs)                 is the offset to the previous word\endln
\lnie
                      which requires filling in with an\endln
\lnie
                      offset to the following o$slc,o$sld\endln
\lnie
\endln
\lnie
1(xs)                 is the head of a chain of offset\endln
\lnie
                      pointers indicating those locations\endln
\lnie
                      to be filled with offsets past\endln
\lnie
                      the end of all the alternatives\endln
\lnie
\endln
\inst{cgv16}{jsr}{cdwrd}{generate o$slc (o$sla first time)}
\inst{}{mov}{cwcof,(xs)}{set current loc as ptr to fill in}
\inst{}{jsr}{cdwrd}{generate garbage word there for now}
\inst{}{jsr}{cmgen}{gen value code for alternative}
\inst{}{mov}{=oslb$,wa}{load o$slb pointer}
\inst{}{jsr}{cdwrd}{generate o$slb call}
\inst{}{mov}{num01(xs),wa}{load old chain ptr}
\inst{}{mov}{cwcof,num01(xs)}{set current loc as new chain head}
\inst{}{jsr}{cdwrd}{generate forward chain link}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
now to fill in the skip offset to o$slc,o$sld\endln
\lnie
\endln
\inst{}{mov}{(xs),xr}{load offset to word to plug}
\inst{}{add}{r$ccb,xr}{point to actual location to plug}
\inst{}{mov}{cwcof,(xr)}{plug proper offset in}
\inst{}{mov}{=oslc$,wa}{load o$slc ptr for next alternative}
\inst{}{mov}{wb,xr}{copy offset (destroy garbage xr)}
\inst{}{ica}{xr}{bump extra time for test}
\inst{}{blt}{xr,cmlen(xl),cgv16}{loop back if not last alternative}
\lnie
\endln
\lnie
here to generate code for last alternative\endln
\lnie
\endln
\inst{}{mov}{=osld$,wa}{get header call}
\inst{}{jsr}{cdwrd}{generate o$sld call}
\inst{}{jsr}{cmgen}{generate code for last alternative}
\inst{}{ica}{xs}{pop offset ptr}
\inst{}{mov}{(xs)+,xr}{load chain ptr}
\lnie
\endln
\lnie
loop to plug offsets past structure\endln
\lnie
\endln
\inst{cgv17}{add}{r$ccb,xr}{make next ptr absolute}
\inst{}{mov}{(xr),wa}{load forward ptr}
\inst{}{mov}{cwcof,(xr)}{plug required offset}
\inst{}{mov}{wa,xr}{copy forward ptr}
\inst{}{bnz}{wa,cgv17}{loop back if more to go}
\inst{}{brn}{cgv33}{else jump to exit (not constant)}
\lnie
\endln
\lnie
here for binary ops with value operands\endln
\lnie
\endln
\inst{cgv18}{mov}{cmlop(xl),xr}{load left operand pointer}
\inst{}{jsr}{cdgvl}{gen value code for left operand}
\lnie
\endln
\lnie
here for unary ops with value operand (binops merge)\endln
\lnie
\endln
\inst{cgv19}{mov}{cmrop(xl),xr}{load right (only) operand ptr}
\inst{}{jsr}{cdgvl}{gen code by value}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
merge here to generate operator call from cmopn field\endln
\lnie
\endln
\inst{cgv20}{mov}{cmopn(xl),wa}{load operator call pointer}
\inst{}{brn}{cgv36}{jump to generate it with cons test}
\lnie
\endln
\lnie
here for assignment\endln
\lnie
\endln
\inst{cgv21}{mov}{cmlop(xl),xr}{load left operand pointer}
\inst{}{blo}{(xr),=b$vr$,cgv22}{jump if not variable}
\lnie
\endln
\lnie
here for assignment to simple variable\endln
\lnie
\endln
\inst{}{mov}{cmrop(xl),xr}{load right operand ptr}
\inst{}{jsr}{cdgvl}{generate code by value}
\inst{}{mov}{cmlop(xl),wa}{reload left operand vrblk ptr}
\inst{}{add}{*vrsto,wa}{point to vrsto field}
\inst{}{brn}{cgv32}{jump to generate store ptr}
\lnie
\endln
\lnie
here if not simple variable assignment\endln
\lnie
\endln
\inst{cgv22}{jsr}{expap}{test for pattern match on left side}
\inst{}{ppm}{cgv23}{jump if not pattern match}
\lnie
\endln
\lnie
here for pattern replacement\endln
\lnie
\endln
\inst{}{mov}{cmrop(xr),cmlop(xl)}{save pattern ptr in safe place}
\inst{}{mov}{cmlop(xr),xr}{load subject ptr}
\inst{}{jsr}{cdgnm}{gen code by name for subject}
\inst{}{mov}{cmlop(xl),xr}{load pattern ptr}
\inst{}{jsr}{cdgvl}{gen code by value for pattern}
\inst{}{mov}{=opmn$,wa}{load match by name call}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{cmrop(xl),xr}{load replacement value ptr}
\inst{}{jsr}{cdgvl}{gen code by value}
\inst{}{mov}{=orpl$,wa}{load replace call}
\inst{}{brn}{cgv32}{jump to gen and exit (not constant)}
\lnie
\endln
\lnie
here for assignment to complex variable\endln
\lnie
\endln
\inst{cgv23}{mnz}{wc}{inhibit pre-evaluation}
\inst{}{jsr}{cdgnm}{gen code by name for left side}
\inst{}{brn}{cgv31}{merge with unop circuit}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
here for concatenation\endln
\lnie
\endln
\inst{cgv24}{mov}{cmlop(xl),xr}{load left operand ptr}
\inst{}{bne}{(xr),=b$cmt,cgv18}{ordinary binop if not cmblk}
\inst{}{mov}{cmtyp(xr),wb}{load cmblk type code}
\inst{}{beq}{wb,=c$int,cgv25}{special case if interrogation}
\inst{}{beq}{wb,=c$neg,cgv25}{or negation}
\inst{}{bne}{wb,=c$fnc,cgv18}{else ordinary binop if not function}
\inst{}{mov}{cmopn(xr),xr}{else load function vrblk ptr}
\inst{}{bnz}{vrlen(xr),cgv18}{ordinary binop if not system var}
\inst{}{mov}{vrsvp(xr),xr}{else point to svblk}
\inst{}{mov}{svbit(xr),wa}{load bit indicators}
\inst{}{anb}{btprd,wa}{test for predicate function}
\inst{}{zrb}{wa,cgv18}{ordinary binop if not}
\lnie
\endln
\lnie
here if left arg of concatenation is predicate function\endln
\lnie
\endln
\inst{cgv25}{mov}{cmlop(xl),xr}{reload left arg}
\inst{}{jsr}{cdgvl}{gen code by value}
\inst{}{mov}{=opop$,wa}{load pop call}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{cmrop(xl),xr}{load right operand}
\inst{}{jsr}{cdgvl}{gen code by value as result code}
\inst{}{brn}{cgv33}{exit (not constant)}
\lnie
\endln
\lnie
here to generate code for pattern, immediate assignment\endln
\lnie
\endln
\inst{cgv26}{mov}{cmlop(xl),xr}{load left operand}
\inst{}{jsr}{cdgvl}{gen code by value, merge}
\lnie
\endln
\lnie
here for unops with arg by name (binary $ . merge)\endln
\lnie
\endln
\inst{cgv27}{mov}{cmrop(xl),xr}{load right operand ptr}
\inst{}{jsr}{cdgnm}{gen code by name for right arg}
\inst{}{mov}{cmopn(xl),xr}{get operator code word}
\inst{}{bne}{(xr),=o$kwv,cgv20}{gen call unless keyword value}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
here for keyword by value. this is constant only if\endln
\lnie
the operand is one of the special system variables with\endln
\lnie
the svckw bit set to indicate a constant keyword value.\endln
\lnie
note that the only constant operand by name is a variable\endln
\lnie
\endln
\inst{}{bnz}{wc,cgv20}{gen call if non-constant (not var)}
\inst{}{mnz}{wc}{else set non-constant in case}
\inst{}{mov}{cmrop(xl),xr}{load ptr to operand vrblk}
\inst{}{bnz}{vrlen(xr),cgv20}{gen (non-constant) if not sys var}
\inst{}{mov}{vrsvp(xr),xr}{else load ptr to svblk}
\inst{}{mov}{svbit(xr),wa}{load bit mask}
\inst{}{anb}{btckw,wa}{test for constant keyword}
\inst{}{zrb}{wa,cgv20}{go gen if not constant}
\inst{}{zer}{wc}{else set result constant}
\inst{}{brn}{cgv20}{and jump back to generate call}
\lnie
\endln
\lnie
here to generate code for negation\endln
\lnie
\endln
\inst{cgv28}{mov}{=onta$,wa}{get initial word}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{cwcof,wb}{save next offset}
\inst{}{jsr}{cdwrd}{generate gunk word for now}
\inst{}{mov}{cmrop(xl),xr}{load right operand ptr}
\inst{}{jsr}{cdgvl}{gen code by value}
\inst{}{mov}{=ontb$,wa}{load end of evaluation call}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{wb,xr}{copy offset to word to plug}
\inst{}{add}{r$ccb,xr}{point to actual word to plug}
\inst{}{mov}{cwcof,(xr)}{plug word with current offset}
\inst{}{mov}{=ontc$,wa}{load final call}
\inst{}{brn}{cgv32}{jump to generate it (not constant)}
\lnie
\endln
\lnie
here to generate code for undefined binary operator\endln
\lnie
\endln
\inst{cgv29}{mov}{cmlop(xl),xr}{load left operand ptr}
\inst{}{jsr}{cdgvl}{generate code by value}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
here to generate code for undefined unary operator\endln
\lnie
\endln
\inst{cgv30}{mov}{=c$uo$,wb}{set unop code + 1}
\inst{}{sub}{cmtyp(xl),wb}{set number of args (1 or 2)}
\lnie
\endln
\lnie
merge here for undefined operators\endln
\lnie
\endln
\inst{}{mov}{cmrop(xl),xr}{load right (only) operand pointer}
\inst{}{jsr}{cdgvl}{gen value code for right operand}
\inst{}{mov}{cmopn(xl),xr}{load pointer to operator dv}
\inst{}{mov}{dvopn(xr),xr}{load pointer offset}
\inst{}{wtb}{xr}{convert word offset to bytes}
\inst{}{add}{=r$uba,xr}{point to proper function ptr}
\inst{}{sub}{*vrfnc,xr}{set standard function offset}
\inst{}{brn}{cgv12}{merge with function call circuit}
\lnie
\endln
\lnie
here to generate code for interrogation, indirection\endln
\lnie
\endln
\inst{cgv31}{mnz}{wc}{set non constant}
\inst{}{brn}{cgv19}{merge}
\lnie
\endln
\lnie
here to exit generating a word, result not constant\endln
\lnie
\endln
\inst{cgv32}{jsr}{cdwrd}{generate word, merge}
\lnie
\endln
\lnie
here to exit with no word generated, not constant\endln
\lnie
\endln
\inst{cgv33}{mnz}{wc}{indicate result is not constant}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{cgv34}{ica}{xs}{pop initial code offset}
\inst{}{mov}{(xs)+,wa}{restore old constant flag}
\inst{}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{mov}{(xs)+,wb}{restore entry wb}
\inst{}{bnz}{wc,cgv35}{jump if not constant}
\inst{}{mov}{wa,wc}{else restore entry constant flag}
\lnie
\endln
\lnie
here to return after dealing with wc setting\endln
\lnie
\endln
\inst{cgv35}{exi}{}{return to cdgvl caller}
\lnie
\endln
\lnie
exit here to generate word and test for constant\endln
\lnie
\endln
\inst{cgv36}{jsr}{cdwrd}{generate word}
\inst{}{bnz}{wc,cgv34}{jump to exit if not constant}
\vfill\break

\lnie
\endln
\lnie
cdgvl (continued)\endln
\lnie
\endln
\lnie
here to preevaluate constant sub-expression\endln
\lnie
\endln
\inst{}{mov}{=orvl$,wa}{load call to return value}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{(xs),xl}{load initial code offset}
\inst{}{jsr}{exbld}{build exblk for expression}
\inst{}{zer}{wb}{set to evaluate by value}
\inst{}{jsr}{evalx}{evaluate expression}
\inst{}{ppm}{}{should not fail}
\inst{}{mov}{(xr),wa}{load type word of result}
\inst{}{blo}{wa,=p$aaa,cgv37}{jump if not pattern}
\inst{}{mov}{=olpt$,wa}{else load special pattern load call}
\inst{}{jsr}{cdwrd}{generate it}
\lnie
\endln
\lnie
merge here to generate pointer to resulting constant\endln
\lnie
\endln
\inst{cgv37}{mov}{xr,wa}{copy constant pointer}
\inst{}{jsr}{cdwrd}{generate ptr}
\inst{}{zer}{wc}{set result constant}
\inst{}{brn}{cgv34}{jump back to exit}
\inst{}{enp}{}{end procedure cdgvl}
\vfill\break

\lnie
\endln
\lnie
cdwrd -- generate one word of code\endln
\lnie
\endln
\lnie
cdwrd writes one word into the current code block under\endln
\lnie
construction. a new, larger, block is allocated if there\endln
\lnie
is insufficient room in the current block. cdwrd ensures\endln
\ifmac{.csln}
\lnie
that there are at least four words left in the block\endln
\asmac{else}
\lnie
that there are at least three words left in the block\endln
\asmac{fi}
\lnie
after entering the new word. this guarantees that any\endln
\lnie
extra space at the end can be split off as a ccblk.\endln
\lnie
\endln
\lnie
(wa)                  word to be generated\endln
\lnie
jsr  cdwrd            call to generate word\endln
\lnie
\endln
\inst{cdwrd}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save entry xr}
\inst{}{mov}{wa,-(xs)}{save code word to be generated}
\lnie
\endln
\lnie
merge back here after allocating larger block\endln
\lnie
\endln
\inst{cdwd1}{mov}{r$ccb,xr}{load ptr to ccblk being built}
\inst{}{bnz}{xr,cdwd2}{jump if block allocated}
\lnie
\endln
\lnie
here we allocate an entirely fresh block\endln
\lnie
\endln
\inst{}{mov}{*e$cbs,wa}{load initial length}
\inst{}{jsr}{alloc}{allocate ccblk}
\inst{}{mov}{=b$cct,(xr)}{store type word}
\inst{}{mov}{*cccod,cwcof}{set initial offset}
\inst{}{mov}{wa,cclen(xr)}{store block length}
\ifmac{.csln}
\inst{}{zer}{ccsln(xr)}{zero line number}
\asmac{fi}
\inst{}{mov}{xr,r$ccb}{store ptr to new block}
\lnie
\endln
\lnie
here we have a block we can use\endln
\lnie
\endln
\inst{cdwd2}{mov}{cwcof,wa}{load current offset}
\ifmac{.csln}
\inst{}{add}{*num05,wa}{adjust for test (five words)}
\asmac{else}
\inst{}{add}{*num04,wa}{adjust for test (four words)}
\asmac{fi}
\inst{}{blo}{wa,cclen(xr),cdwd4}{jump if room in this block}
\lnie
\endln
\lnie
here if no room in current block\endln
\lnie
\endln
\inst{}{bge}{wa,mxlen,cdwd5}{jump if already at max size}
\inst{}{add}{*e$cbs,wa}{else get new size}
\inst{}{mov}{xl,-(xs)}{save entry xl}
\inst{}{mov}{xr,xl}{copy pointer}
\inst{}{blt}{wa,mxlen,cdwd3}{jump if not too large}
\inst{}{mov}{mxlen,wa}{else reset to max allowed size}
\vfill\break

\lnie
\endln
\lnie
cdwrd (continued)\endln
\lnie
\endln
\lnie
here with new block size in wa\endln
\lnie
\endln
\inst{cdwd3}{jsr}{alloc}{allocate new block}
\inst{}{mov}{xr,r$ccb}{store pointer to new block}
\inst{}{mov}{=b$cct,(xr)+}{store type word in new block}
\inst{}{mov}{wa,(xr)+}{store block length}
\ifmac{.csln}
\inst{}{mov}{ccsln(xl),(xr)+}{copy source line number word}
\asmac{fi}
\inst{}{add}{*ccuse,xl}{point to ccuse,cccod fields in old}
\inst{}{mov}{(xl),wa}{load ccuse value}
\inst{}{mvw}{}{copy useful words from old block}
\inst{}{mov}{(xs)+,xl}{restore xl}
\inst{}{brn}{cdwd1}{merge back to try again}
\lnie
\endln
\lnie
here with room in current block\endln
\lnie
\endln
\inst{cdwd4}{mov}{cwcof,wa}{load current offset}
\inst{}{ica}{wa}{get new offset}
\inst{}{mov}{wa,cwcof}{store new offset}
\inst{}{mov}{wa,ccuse(xr)}{store in ccblk for gbcol}
\inst{}{dca}{wa}{restore ptr to this word}
\inst{}{add}{wa,xr}{point to current entry}
\inst{}{mov}{(xs)+,wa}{reload word to generate}
\inst{}{mov}{wa,(xr)}{store word in block}
\inst{}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
here if compiled code is too long for cdblk\endln
\lnie
\endln
\inst{cdwd5}{erb}{213,syntax error:}{statement is too complicated.}
\inst{}{enp}{}{end procedure cdwrd}
\vfill\break

\lnie
\endln
\lnie
cmgen -- generate code for cmblk ptr\endln
\lnie
\endln
\lnie
cmgen is a subsidiary procedure used to generate value\endln
\lnie
code for a cmblk ptr from the main code generators.\endln
\lnie
\endln
\lnie
(xl)                  cmblk pointer\endln
\lnie
(wb)                  offset to pointer in cmblk\endln
\lnie
jsr  cmgen            call to generate code\endln
\lnie
(xr,wa)               destroyed\endln
\lnie
(wb)                  bumped by one word\endln
\lnie
\endln
\inst{cmgen}{prc}{r,0}{entry point, recursive}
\inst{}{mov}{xl,xr}{copy cmblk pointer}
\inst{}{add}{wb,xr}{point to cmblk pointer}
\inst{}{mov}{(xr),xr}{load cmblk pointer}
\inst{}{jsr}{cdgvl}{generate code by value}
\inst{}{ica}{wb}{bump offset}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure cmgen}
\vfill\break

\lnie
\endln
\lnie
cmpil (compile source code)\endln
\lnie
\endln
\lnie
cmpil is used to convert snobol4 source code to internal\endln
\lnie
form (see cdblk format). it is used both for the initial\endln
\lnie
compile and at run time by the code and convert functions\endln
\lnie
this procedure has control for the entire duration of\endln
\lnie
initial compilation. an error in any procedure called\endln
\lnie
during compilation will lead first to the error section\endln
\lnie
and ultimately back here for resumed compilation. the\endln
\lnie
re-entry points after an error are specially labelled -\endln
\lnie
\endln
\lnie
cmpce                 resume after control card error\endln
\lnie
cmple                 resume after label error\endln
\lnie
cmpse                 resume after statement error\endln
\lnie
\endln
\lnie
jsr  cmpil            call to compile code\endln
\lnie
(xr)                  ptr to cdblk for entry statement\endln
\lnie
(xl,wa,wb,wc,ra)      destroyed\endln
\lnie
\endln
\lnie
the following global variables are referenced\endln
\lnie
\endln
\lnie
cmpln                 line number of first line of\endln
\lnie
                      statement to be compiled\endln
\lnie
\endln
\lnie
cmpsn                 number of next statement\endln
\lnie
                      to be compiled.\endln
\lnie
\endln
\lnie
cswxx                 control card switch values are\endln
\lnie
                      changed when relevant control\endln
\lnie
                      cards are met.\endln
\lnie
\endln
\lnie
cwcof                 offset to next word in code block\endln
\lnie
                      being built (see cdwrd).\endln
\lnie
\endln
\lnie
lstsn                 number of statement most recently\endln
\lnie
                      compiled (initially set to zero).\endln
\lnie
\endln
\lnie
r$cim                 current (initial) compiler image\endln
\lnie
                      (zero for initial compile call)\endln
\lnie
\endln
\lnie
r$cni                 used to point to following image.\endln
\lnie
                      (see readr procedure).\endln
\lnie
\endln
\lnie
scngo                 goto switch for scane procedure\endln
\lnie
\endln
\lnie
scnil                 length of current image excluding\endln
\lnie
                      characters removed by -input.\endln
\lnie
\endln
\lnie
scnpt                 current scan offset, see scane.\endln
\lnie
\endln
\lnie
scnrs                 rescan switch for scane procedure.\endln
\lnie
\endln
\lnie
scnse                 offset (in r$cim) of most recently\endln
\lnie
                      scanned element. set zero if not\endln
\lnie
                      currently scanning items\endln
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
stage               stgic  initial compile in progress\endln
\lnie
                    stgxc  code/convert compile\endln
\lnie
                    stgev  building exblk for eval\endln
\lnie
                    stgxt  execute time (outside compile)\endln
\lnie
                    stgce  initial compile after end line\endln
\lnie
                    stgxe  execute compile after end line\endln
\lnie
\endln
\lnie
cmpil also uses a fixed number of locations on the\endln
\lnie
main stack as follows. (the definitions of the actual\endln
\lnie
offsets are in the definitions section).\endln
\lnie
\endln
\lnie
cmstm(xs)             pointer to expan tree for body of\endln
\lnie
                      statement (see expan procedure).\endln
\lnie
\endln
\lnie
cmsgo(xs)             pointer to tree representation of\endln
\lnie
                      success goto (see procedure scngo)\endln
\lnie
                      zero if no success goto is given\endln
\lnie
\endln
\lnie
cmfgo(xs)             like cmsgo for failure goto.\endln
\lnie
\endln
\lnie
cmcgo(xs)             set non-zero only if there is a\endln
\lnie
                      conditional goto. used for -fail,\endln
\lnie
                      -nofail code generation.\endln
\lnie
\endln
\lnie
cmpcd(xs)             pointer to cdblk for previous\endln
\lnie
                      statement. zero for 1st statement.\endln
\lnie
\endln
\lnie
cmffp(xs)             set non-zero if cdfal in previous\endln
\lnie
                      cdblk needs filling with forward\endln
\lnie
                      pointer, else set to zero.\endln
\lnie
\endln
\lnie
cmffc(xs)             same as cmffp for current cdblk\endln
\lnie
\endln
\lnie
cmsop(xs)             offset to word in previous cdblk\endln
\lnie
                      to be filled in with forward ptr\endln
\lnie
                      to next cdblk for success goto.\endln
\lnie
                      zero if no fill in is required.\endln
\lnie
\endln
\lnie
cmsoc(xs)             same as cmsop for current cdblk.\endln
\lnie
\endln
\lnie
cmlbl(xs)             pointer to vrblk for label of\endln
\lnie
                      current statement. zero if no label\endln
\lnie
\endln
\lnie
cmtra(xs)             pointer to cdblk for entry stmnt.\endln
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
entry point\endln
\lnie
\endln
\inst{cmpil}{prc}{e,0}{entry point}
\inst{}{lct}{wb,=cmnen}{set number of stack work locations}
\lnie
\endln
\lnie
loop to initialize stack working locations\endln
\lnie
\endln
\inst{cmp00}{zer}{-(xs)}{store a zero, make one entry}
\inst{}{bct}{wb,cmp00}{loop back until all set}
\inst{}{mov}{xs,cmpxs}{save stack pointer for error sec}
\inst{}{sss}{cmpss}{save s-r stack pointer if any}
\lnie
\endln
\lnie
loop through statements\endln
\lnie
\endln
\inst{cmp01}{mov}{scnpt,wb}{set scan pointer offset}
\inst{}{mov}{wb,scnse}{set start of element location}
\inst{}{mov}{=ocer$,wa}{point to compile error call}
\inst{}{jsr}{cdwrd}{generate as temporary cdfal}
\inst{}{blt}{wb,scnil,cmp04}{jump if chars left on this image}
\lnie
\endln
\lnie
loop here after comment or control card\endln
\lnie
also special entry after control card error\endln
\lnie
\endln
\inst{cmpce}{zer}{xr}{clear possible garbage xr value}
\ifmac{.cinc}
\inst{}{bnz}{cnind,cmpc2}{if within include file}
\asmac{fi}
\inst{}{bne}{stage,=stgic,cmp02}{skip unless initial compile}
\inst{cmpc2}{jsr}{readr}{read next input image}
\inst{}{bze}{xr,cmp09}{jump if no input available}
\inst{}{jsr}{nexts}{acquire next source image}
\inst{}{mov}{cmpsn,lstsn}{store stmt no for use by listr}
\inst{}{mov}{rdcln,cmpln}{store line number at start of stmt}
\inst{}{zer}{scnpt}{reset scan pointer}
\inst{}{brn}{cmp04}{go process image}
\lnie
\endln
\lnie
for execute time compile, permit embedded control cards\endln
\lnie
and comments (by skipping to next semi-colon)\endln
\lnie
\endln
\inst{cmp02}{mov}{r$cim,xr}{get current image}
\inst{}{mov}{scnpt,wb}{get current offset}
\inst{}{plc}{xr,wb}{prepare to get chars}
\lnie
\endln
\lnie
skip to semi-colon\endln
\lnie
\endln
\inst{cmp03}{bge}{scnpt,scnil,cmp09}{end loop if end of image}
\inst{}{lch}{wc,(xr)+}{get char}
\inst{}{icv}{scnpt}{advance offset}
\inst{}{bne}{wc,=ch$sm,cmp03}{loop if not semi-colon}
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
here with image available to scan. note that if the input\endln
\lnie
string is null, then everything is ok since null is\endln
\lnie
actually assembled as a word of blanks.\endln
\lnie
\endln
\inst{cmp04}{mov}{r$cim,xr}{point to current image}
\inst{}{mov}{scnpt,wb}{load current offset}
\inst{}{mov}{wb,wa}{copy for label scan}
\inst{}{plc}{xr,wb}{point to first character}
\inst{}{lch}{wc,(xr)+}{load first character}
\inst{}{beq}{wc,=ch$sm,cmp12}{no label if semicolon}
\inst{}{beq}{wc,=ch$as,cmpce}{loop back if comment card}
\inst{}{beq}{wc,=ch$mn,cmp32}{jump if control card}
\inst{}{mov}{r$cim,r$cmp}{about to destroy r$cim}
\inst{}{mov}{=cmlab,xl}{point to label work string}
\inst{}{mov}{xl,r$cim}{scane is to scan work string}
\inst{}{psc}{xl}{point to first character position}
\inst{}{sch}{wc,(xl)+}{store char just loaded}
\inst{}{mov}{=ch$sm,wc}{get a semicolon}
\inst{}{sch}{wc,(xl)}{store after first char}
\inst{}{csc}{xl}{finished character storing}
\inst{}{zer}{xl}{clear pointer}
\inst{}{zer}{scnpt}{start at first character}
\inst{}{mov}{scnil,-(xs)}{preserve image length}
\inst{}{mov}{=num02,scnil}{read 2 chars at most}
\inst{}{jsr}{scane}{scan first char for type}
\inst{}{mov}{(xs)+,scnil}{restore image length}
\inst{}{mov}{xl,wc}{note return code}
\inst{}{mov}{r$cmp,xl}{get old r$cim}
\inst{}{mov}{xl,r$cim}{put it back}
\inst{}{mov}{wb,scnpt}{reinstate offset}
\inst{}{bnz}{scnbl,cmp12}{blank seen - cant be label}
\inst{}{mov}{xl,xr}{point to current image}
\inst{}{plc}{xr,wb}{point to first char again}
\inst{}{beq}{wc,=t$var,cmp06}{ok if letter}
\inst{}{beq}{wc,=t$con,cmp06}{ok if digit}
\lnie
\endln
\lnie
drop in or jump from error section if scane failed\endln
\lnie
\endln
\inst{cmple}{mov}{r$cmp,r$cim}{point to bad line}
\inst{}{erb}{214,bad label or}{misplaced continuation line}
\lnie
\endln
\lnie
loop to scan label\endln
\lnie
\endln
\inst{cmp05}{beq}{wc,=ch$sm,cmp07}{skip if semicolon}
\inst{}{icv}{wa}{bump offset}
\inst{}{beq}{wa,scnil,cmp07}{jump if end of image (label end)}
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
enter loop at this point\endln
\lnie
\endln
\inst{cmp06}{lch}{wc,(xr)+}{else load next character}
\ifmac{.caht}
\inst{}{beq}{wc,=ch$ht,cmp07}{jump if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wc,=ch$vt,cmp07}{jump if vertical tab}
\asmac{fi}
\inst{}{bne}{wc,=ch$bl,cmp05}{loop back if non-blank}
\lnie
\endln
\lnie
here after scanning out label\endln
\lnie
\endln
\inst{cmp07}{mov}{wa,scnpt}{save updated scan offset}
\inst{}{sub}{wb,wa}{get length of label}
\inst{}{bze}{wa,cmp12}{skip if label length zero}
\inst{}{zer}{xr}{clear garbage xr value}
\inst{}{jsr}{sbstr}{build scblk for label name}
\inst{}{jsr}{gtnvr}{locate/contruct vrblk}
\inst{}{ppm}{}{dummy (impossible) error return}
\inst{}{mov}{xr,cmlbl(xs)}{store label pointer}
\inst{}{bnz}{vrlen(xr),cmp11}{jump if not system label}
\inst{}{bne}{vrsvp(xr),=v$end,cmp11}{jump if not end label}
\lnie
\endln
\lnie
here for end label scanned out\endln
\lnie
\endln
\inst{}{add}{=stgnd,stage}{adjust stage appropriately}
\inst{}{jsr}{scane}{scan out next element}
\inst{}{beq}{xl,=t$smc,cmp10}{jump if end of image}
\inst{}{bne}{xl,=t$var,cmp08}{else error if not variable}
\lnie
\endln
\lnie
here check for valid initial transfer\endln
\lnie
\endln
\inst{}{beq}{vrlbl(xr),=stndl,cmp08}{jump if not defined (error)}
\inst{}{mov}{vrlbl(xr),cmtra(xs)}{else set initial entry pointer}
\inst{}{jsr}{scane}{scan next element}
\inst{}{beq}{xl,=t$smc,cmp10}{jump if ok (end of image)}
\lnie
\endln
\lnie
here for bad transfer label\endln
\lnie
\endln
\inst{cmp08}{erb}{215,syntax error:}{undefined or erroneous entry label}
\lnie
\endln
\lnie
here for end of input (no end label detected)\endln
\lnie
\endln
\inst{cmp09}{zer}{xr}{clear garbage xr value}
\inst{}{add}{=stgnd,stage}{adjust stage appropriately}
\inst{}{beq}{stage,=stgxe,cmp10}{jump if code call (ok)}
\inst{}{erb}{216,syntax error:}{missing end line}
\lnie
\endln
\lnie
here after processing end line (merge here on end error)\endln
\lnie
\endln
\inst{cmp10}{mov}{=ostp$,wa}{set stop call pointer}
\inst{}{jsr}{cdwrd}{generate as statement call}
\inst{}{brn}{cmpse}{jump to generate as failure}
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
here after processing label other than end\endln
\lnie
\endln
\inst{cmp11}{bne}{stage,=stgic,cmp12}{jump if code call - redef. ok}
\inst{}{beq}{vrlbl(xr),=stndl,cmp12}{else check for redefinition}
\inst{}{zer}{cmlbl(xs)}{leave first label decln undisturbed}
\inst{}{erb}{217,syntax error:}{duplicate label}
\lnie
\endln
\lnie
here after dealing with label\endln
\lnie
null statements and statements just containing a\endln
\lnie
constant subject are optimized out by resetting the\endln
\lnie
current ccblk to empty.\endln
\lnie
\endln
\inst{cmp12}{zer}{wb}{set flag for statement body}
\inst{}{jsr}{expan}{get tree for statement body}
\inst{}{mov}{xr,cmstm(xs)}{store for later use}
\inst{}{zer}{cmsgo(xs)}{clear success goto pointer}
\inst{}{zer}{cmfgo(xs)}{clear failure goto pointer}
\inst{}{zer}{cmcgo(xs)}{clear conditional goto flag}
\inst{}{jsr}{scane}{scan next element}
\inst{}{beq}{xl,=t$col,cmp13}{jump if colon (goto)}
\inst{}{bnz}{cswno,cmp18}{jump if not optimizing}
\inst{}{bnz}{cmlbl(xs),cmp18}{jump if label present}
\inst{}{mov}{cmstm(xs),xr}{load tree ptr for statement body}
\inst{}{mov}{(xr),wa}{load type word}
\inst{}{beq}{wa,=b$cmt,cmp18}{jump if cmblk}
\inst{}{bge}{wa,=b$vra,cmp18}{jump if not icblk, scblk, or rcblk}
\inst{}{mov}{r$ccb,xl}{load ptr to ccblk}
\inst{}{mov}{*cccod,ccuse(xl)}{reset use offset in ccblk}
\inst{}{mov}{*cccod,cwcof}{and in global}
\inst{}{icv}{cmpsn}{bump statement number}
\inst{}{brn}{cmp01}{generate no code for statement}
\lnie
\endln
\lnie
loop to process goto fields\endln
\lnie
\endln
\inst{cmp13}{mnz}{scngo}{set goto flag}
\inst{}{jsr}{scane}{scan next element}
\inst{}{beq}{xl,=t$smc,cmp31}{jump if no fields left}
\inst{}{beq}{xl,=t$sgo,cmp14}{jump if s for success goto}
\inst{}{beq}{xl,=t$fgo,cmp16}{jump if f for failure goto}
\lnie
\endln
\lnie
here for unconditional goto (i.e. not f or s)\endln
\lnie
\endln
\inst{}{mnz}{scnrs}{set to rescan element not f,s}
\inst{}{jsr}{scngf}{scan out goto field}
\inst{}{bnz}{cmfgo(xs),cmp17}{error if fgoto already}
\inst{}{mov}{xr,cmfgo(xs)}{else set as fgoto}
\inst{}{brn}{cmp15}{merge with sgoto circuit}
\lnie
\endln
\lnie
here for success goto\endln
\lnie
\endln
\inst{cmp14}{jsr}{scngf}{scan success goto field}
\inst{}{mov}{=num01,cmcgo(xs)}{set conditional goto flag}
\lnie
\endln
\lnie
uncontional goto merges here\endln
\lnie
\endln
\inst{cmp15}{bnz}{cmsgo(xs),cmp17}{error if sgoto already given}
\inst{}{mov}{xr,cmsgo(xs)}{else set sgoto}
\inst{}{brn}{cmp13}{loop back for next goto field}
\lnie
\endln
\lnie
here for failure goto\endln
\lnie
\endln
\inst{cmp16}{jsr}{scngf}{scan goto field}
\inst{}{mov}{=num01,cmcgo(xs)}{set conditonal goto flag}
\inst{}{bnz}{cmfgo(xs),cmp17}{error if fgoto already given}
\inst{}{mov}{xr,cmfgo(xs)}{else store fgoto pointer}
\inst{}{brn}{cmp13}{loop back for next field}
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
here for duplicated goto field\endln
\lnie
\endln
\inst{cmp17}{erb}{218,syntax error:}{duplicated goto field}
\lnie
\endln
\lnie
here to generate code\endln
\lnie
\endln
\inst{cmp18}{zer}{scnse}{stop positional error flags}
\inst{}{mov}{cmstm(xs),xr}{load tree ptr for statement body}
\inst{}{zer}{wb}{collectable value for wb for cdgvl}
\inst{}{zer}{wc}{reset constant flag for cdgvl}
\inst{}{jsr}{expap}{test for pattern match}
\inst{}{ppm}{cmp19}{jump if not pattern match}
\inst{}{mov}{=opms$,cmopn(xr)}{else set pattern match pointer}
\inst{}{mov}{=opms$,cmopn(xr)}{else set pattern match pointer}
\lnie
\endln
\lnie
here after dealing with special pattern match case\endln
\lnie
\endln
\inst{cmp19}{jsr}{cdgvl}{generate code for body of statement}
\inst{}{mov}{cmsgo(xs),xr}{load sgoto pointer}
\inst{}{mov}{xr,wa}{copy it}
\inst{}{bze}{xr,cmp21}{jump if no success goto}
\inst{}{zer}{cmsoc(xs)}{clear success offset fillin ptr}
\inst{}{bhi}{xr,state,cmp20}{jump if complex goto}
\lnie
\endln
\lnie
here for simple success goto (label)\endln
\lnie
\endln
\inst{}{add}{*vrtra,wa}{point to vrtra field as required}
\inst{}{jsr}{cdwrd}{generate success goto}
\inst{}{brn}{cmp22}{jump to deal with fgoto}
\lnie
\endln
\lnie
here for complex success goto\endln
\lnie
\endln
\inst{cmp20}{beq}{xr,cmfgo(xs),cmp22}{no code if same as fgoto}
\inst{}{zer}{wb}{else set ok value for cdgvl in wb}
\inst{}{jsr}{cdgcg}{generate code for success goto}
\inst{}{brn}{cmp22}{jump to deal with fgoto}
\lnie
\endln
\lnie
here for no success goto\endln
\lnie
\endln
\inst{cmp21}{mov}{cwcof,cmsoc(xs)}{set success fill in offset}
\inst{}{mov}{=ocer$,wa}{point to compile error call}
\inst{}{jsr}{cdwrd}{generate as temporary value}
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
here to deal with failure goto\endln
\lnie
\endln
\inst{cmp22}{mov}{cmfgo(xs),xr}{load failure goto pointer}
\inst{}{mov}{xr,wa}{copy it}
\inst{}{zer}{cmffc(xs)}{set no fill in required yet}
\inst{}{bze}{xr,cmp23}{jump if no failure goto given}
\inst{}{add}{*vrtra,wa}{point to vrtra field in case}
\inst{}{blo}{xr,state,cmpse}{jump to gen if simple fgoto}
\lnie
\endln
\lnie
here for complex failure goto\endln
\lnie
\endln
\inst{}{mov}{cwcof,wb}{save offset to o$gof call}
\inst{}{mov}{=ogof$,wa}{point to failure goto call}
\inst{}{jsr}{cdwrd}{generate}
\inst{}{mov}{=ofif$,wa}{point to fail in fail word}
\inst{}{jsr}{cdwrd}{generate}
\inst{}{jsr}{cdgcg}{generate code for failure goto}
\inst{}{mov}{wb,wa}{copy offset to o$gof for cdfal}
\inst{}{mov}{=b$cdc,wb}{set complex case cdtyp}
\inst{}{brn}{cmp25}{jump to build cdblk}
\lnie
\endln
\lnie
here if no failure goto given\endln
\lnie
\endln
\inst{cmp23}{mov}{=ounf$,wa}{load unexpected failure call in cas}
\inst{}{mov}{cswfl,wc}{get -nofail flag}
\inst{}{orb}{cmcgo(xs),wc}{check if conditional goto}
\inst{}{zrb}{wc,cmpse}{jump if -nofail and no cond. goto}
\inst{}{mnz}{cmffc(xs)}{else set fill in flag}
\inst{}{mov}{=ocer$,wa}{and set compile error for temporary}
\lnie
\endln
\lnie
merge here with cdfal value in wa, simple cdblk\endln
\lnie
also special entry after statement error\endln
\lnie
\endln
\inst{cmpse}{mov}{=b$cds,wb}{set cdtyp for simple case}
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
merge here to build cdblk\endln
\lnie
\endln
\lnie
(wa)                  cdfal value to be generated\endln
\lnie
(wb)                  cdtyp value to be generated\endln
\lnie
\endln
\lnie
at this stage, we chop off an appropriate chunk of the\endln
\lnie
current ccblk and convert it into a cdblk. the remainder\endln
\lnie
of the ccblk is reformatted to be the new ccblk.\endln
\lnie
\endln
\inst{cmp25}{mov}{r$ccb,xr}{point to ccblk}
\inst{}{mov}{cmlbl(xs),xl}{get possible label pointer}
\inst{}{bze}{xl,cmp26}{skip if no label}
\inst{}{zer}{cmlbl(xs)}{clear flag for next statement}
\inst{}{mov}{xr,vrlbl(xl)}{put cdblk ptr in vrblk label field}
\lnie
\endln
\lnie
merge after doing label\endln
\lnie
\endln
\inst{cmp26}{mov}{wb,(xr)}{set type word for new cdblk}
\inst{}{mov}{wa,cdfal(xr)}{set failure word}
\inst{}{mov}{xr,xl}{copy pointer to ccblk}
\inst{}{mov}{ccuse(xr),wb}{load length gen (= new cdlen)}
\inst{}{mov}{cclen(xr),wc}{load total ccblk length}
\inst{}{add}{wb,xl}{point past cdblk}
\inst{}{sub}{wb,wc}{get length left for chop off}
\inst{}{mov}{=b$cct,(xl)}{set type code for new ccblk at end}
\inst{}{mov}{*cccod,ccuse(xl)}{set initial code offset}
\inst{}{mov}{*cccod,cwcof}{reinitialise cwcof}
\inst{}{mov}{wc,cclen(xl)}{set new length}
\inst{}{mov}{xl,r$ccb}{set new ccblk pointer}
\ifmac{.csln}
\inst{}{zer}{ccsln(xl)}{initialize new line number}
\inst{}{mov}{cmpln,cdsln(xr)}{set line number in old block}
\asmac{fi}
\inst{}{mov}{cmpsn,cdstm(xr)}{set statement number}
\inst{}{icv}{cmpsn}{bump statement number}
\lnie
\endln
\lnie
set pointers in previous code block as required\endln
\lnie
\endln
\inst{}{mov}{cmpcd(xs),xl}{load ptr to previous cdblk}
\inst{}{bze}{cmffp(xs),cmp27}{jump if no failure fill in required}
\inst{}{mov}{xr,cdfal(xl)}{else set failure ptr in previous}
\lnie
\endln
\lnie
here to deal with success forward pointer\endln
\lnie
\endln
\inst{cmp27}{mov}{cmsop(xs),wa}{load success offset}
\inst{}{bze}{wa,cmp28}{jump if no fill in required}
\inst{}{add}{wa,xl}{else point to fill in location}
\inst{}{mov}{xr,(xl)}{store forward pointer}
\inst{}{zer}{xl}{clear garbage xl value}
\vfill\break

\lnie
\endln
\lnie
cmpil (continued)\endln
\lnie
\endln
\lnie
now set fill in pointers for this statement\endln
\lnie
\endln
\inst{cmp28}{mov}{cmffc(xs),cmffp(xs)}{copy failure fill in flag}
\inst{}{mov}{cmsoc(xs),cmsop(xs)}{copy success fill in offset}
\inst{}{mov}{xr,cmpcd(xs)}{save ptr to this cdblk}
\inst{}{bnz}{cmtra(xs),cmp29}{jump if initial entry already set}
\inst{}{mov}{xr,cmtra(xs)}{else set ptr here as default}
\lnie
\endln
\lnie
here after compiling one statement\endln
\lnie
\endln
\inst{cmp29}{blt}{stage,=stgce,cmp01}{jump if not end line just done}
\inst{}{bze}{cswls,cmp30}{skip if -nolist}
\inst{}{jsr}{listr}{list last line}
\lnie
\endln
\lnie
return\endln
\lnie
\endln
\inst{cmp30}{mov}{cmtra(xs),xr}{load initial entry cdblk pointer}
\inst{}{add}{*cmnen,xs}{pop work locations off stack}
\inst{}{exi}{}{and return to cmpil caller}
\lnie
\endln
\lnie
here at end of goto field\endln
\lnie
\endln
\inst{cmp31}{mov}{cmfgo(xs),wb}{get fail goto}
\inst{}{orb}{cmsgo(xs),wb}{or in success goto}
\inst{}{bnz}{wb,cmp18}{ok if non-null field}
\inst{}{erb}{219,syntax error:}{empty goto field}
\lnie
\endln
\lnie
control card found\endln
\lnie
\endln
\inst{cmp32}{icv}{wb}{point past ch$mn}
\inst{}{jsr}{cncrd}{process control card}
\inst{}{zer}{scnse}{clear start of element loc.}
\inst{}{brn}{cmpce}{loop for next statement}
\inst{}{enp}{}{end procedure cmpil}
\vfill\break

\lnie
\endln
\lnie
cncrd -- control card processor\endln
\lnie
\endln
\lnie
called to deal with control cards\endln
\lnie
\endln
\lnie
r$cim                 points to current image\endln
\lnie
(wb)                  offset to 1st char of control card\endln
\lnie
jsr  cncrd            call to process control cards\endln
\lnie
(xl,xr,wa,wb,wc,ia)   destroyed\endln
\lnie
\endln
\inst{cncrd}{prc}{e,0}{entry point}
\inst{}{mov}{wb,scnpt}{offset for control card scan}
\inst{}{mov}{=ccnoc,wa}{number of chars for comparison}
\inst{}{ctw}{wa,0}{convert to word count}
\inst{}{mov}{wa,cnswc}{save word count}
\lnie
\endln
\lnie
loop here if more than one control card\endln
\lnie
\endln
\inst{cnc01}{bge}{scnpt,scnil,cnc09}{return if end of image}
\inst{}{mov}{r$cim,xr}{point to image}
\inst{}{plc}{xr,scnpt}{char ptr for first char}
\inst{}{lch}{wa,(xr)+}{get first char}
\ifmac{.culc}
\inst{}{flc}{wa}{fold to upper case}
\asmac{fi}
\inst{}{beq}{wa,=ch$li,cnc07}{special case of -inxxx}
\inst{cnc0a}{mnz}{scncc}{set flag for scane}
\inst{}{jsr}{scane}{scan card name}
\inst{}{zer}{scncc}{clear scane flag}
\inst{}{bnz}{xl,cnc06}{fail unless control card name}
\inst{}{mov}{=ccnoc,wa}{no. of chars to be compared}
\ifmac{.cicc}
\inst{}{blt}{sclen(xr),wa,cnc08}{ fail if too few chars}
\asmac{else}
\inst{}{blt}{sclen(xr),wa,cnc06}{ fail if too few chars}
\asmac{fi}
\inst{}{mov}{xr,xl}{point to control card name}
\inst{}{zer}{wb}{zero offset for substring}
\inst{}{jsr}{sbstr}{extract substring for comparison}
\ifmac{.culc}
\inst{}{mov}{sclen(xr),wa}{reload length}
\inst{}{jsr}{flstg}{fold to upper case}
\asmac{fi}
\inst{}{mov}{xr,cnscc}{keep control card substring ptr}
\inst{}{mov}{=ccnms,xr}{point to list of standard names}
\inst{}{zer}{wb}{initialise name offset}
\inst{}{lct}{wc,=cc$nc}{number of standard names}
\lnie
\endln
\lnie
try to match name\endln
\lnie
\endln
\inst{cnc02}{mov}{cnscc,xl}{point to name}
\inst{}{lct}{wa,cnswc}{counter for inner loop}
\inst{}{brn}{cnc04}{jump into loop}
\lnie
\endln
\lnie
inner loop to match card name chars\endln
\lnie
\endln
\inst{cnc03}{ica}{xr}{bump standard names ptr}
\inst{}{ica}{xl}{bump name pointer}
\lnie
\endln
\lnie
here to initiate the loop\endln
\lnie
\endln
\inst{cnc04}{cne}{schar(xl),(xr),cnc05}{comp. up to cfp$c chars at once}
\inst{}{bct}{wa,cnc03}{loop if more words to compare}
\vfill\break

\lnie
\endln
\lnie
cncrd (continued)\endln
\lnie
\endln
\lnie
matched - branch on card offset\endln
\lnie
\endln
\inst{}{mov}{wb,xl}{get name offset}
\ifmac{.cicc}
\inst{}{bsw}{xl,cc$nc,cnc08}{switch}
\asmac{else}
\inst{}{bsw}{xl,cc$nc,cnc06}{switch}
\asmac{fi}
\ifmac{.culc}
\inst{}{iff}{cc$ca,cnc37}{-case}
\asmac{fi}
\ifmac{.ccmc}
\inst{}{iff}{cc$co,cnc39}{-compare}
\asmac{fi}
\inst{}{iff}{cc$do,cnc10}{-double}
\inst{}{iff}{cc$du,cnc11}{-dump}
\ifmac{.cinc}
\inst{}{iff}{cc$cp,cnc41}{-copy}
\asmac{fi}
\inst{}{iff}{cc$ej,cnc12}{-eject}
\inst{}{iff}{cc$er,cnc13}{-errors}
\inst{}{iff}{cc$ex,cnc14}{-execute}
\inst{}{iff}{cc$fa,cnc15}{-fail}
\ifmac{.cinc}
\inst{}{iff}{cc$in,cnc41}{-include}
\asmac{fi}
\ifmac{.csln}
\inst{}{iff}{cc$ln,cnc44}{-line}
\asmac{fi}
\inst{}{iff}{cc$li,cnc16}{-list}
\inst{}{iff}{cc$nr,cnc17}{-noerrors}
\inst{}{iff}{cc$nx,cnc18}{-noexecute}
\inst{}{iff}{cc$nf,cnc19}{-nofail}
\inst{}{iff}{cc$nl,cnc20}{-nolist}
\inst{}{iff}{cc$no,cnc21}{-noopt}
\inst{}{iff}{cc$np,cnc22}{-noprint}
\inst{}{iff}{cc$op,cnc24}{-optimise}
\inst{}{iff}{cc$pr,cnc25}{-print}
\inst{}{iff}{cc$si,cnc27}{-single}
\inst{}{iff}{cc$sp,cnc28}{-space}
\inst{}{iff}{cc$st,cnc31}{-stitle}
\inst{}{iff}{cc$ti,cnc32}{-title}
\inst{}{iff}{cc$tr,cnc36}{-trace}
\inst{}{esw}{}{end switch}
\lnie
\endln
\lnie
not matched yet. align std names ptr and try again\endln
\lnie
\endln
\inst{cnc05}{ica}{xr}{bump standard names ptr}
\inst{}{bct}{wa,cnc05}{loop}
\inst{}{icv}{wb}{bump names offset}
\inst{}{bct}{wc,cnc02}{continue if more names}
\ifmac{.cicc}
\inst{}{brn}{cnc08}{ignore unrecognized control card}
\asmac{fi}
\lnie
\endln
\lnie
invalid control card name\endln
\lnie
\endln
\inst{cnc06}{erb}{247,invalid control}{statement}
\lnie
\endln
\lnie
special processing for -inxxx\endln
\lnie
\endln
\inst{cnc07}{lch}{wa,(xr)+}{get next char}
\ifmac{.culc}
\inst{}{flc}{wa}{fold to upper case}
\asmac{fi}
\inst{}{bne}{wa,=ch$ln,cnc0a}{if not letter n}
\inst{}{lch}{wa,(xr)}{get third char}
\inst{}{blt}{wa,=ch$d0,cnc0a}{if not digit}
\inst{}{bgt}{wa,=ch$d9,cnc0a}{if not digit}
\inst{}{add}{=num02,scnpt}{bump offset past -in}
\inst{}{jsr}{scane}{scan integer after -in}
\inst{}{mov}{xr,-(xs)}{stack scanned item}
\inst{}{jsr}{gtsmi}{check if integer}
\inst{}{ppm}{cnc06}{fail if not integer}
\inst{}{ppm}{cnc06}{fail if negative or large}
\inst{}{mov}{xr,cswin}{keep integer}
\vfill\break

\lnie
\endln
\lnie
cncrd (continued)\endln
\lnie
\endln
\lnie
check for more control cards before returning\endln
\lnie
\endln
\inst{cnc08}{mov}{scnpt,wa}{preserve in case xeq time compile}
\inst{}{jsr}{scane}{look for comma}
\inst{}{beq}{xl,=t$cma,cnc01}{loop if comma found}
\inst{}{mov}{wa,scnpt}{restore scnpt in case xeq time}
\lnie
\endln
\lnie
return point\endln
\lnie
\endln
\inst{cnc09}{exi}{}{return}
\lnie
\endln
\lnie
-double\endln
\lnie
\endln
\inst{cnc10}{mnz}{cswdb}{set switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-dump\endln
\lnie
this is used for system debugging . it has the effect of\endln
\lnie
producing a core dump at compilation time\endln
\lnie
\endln
\inst{cnc11}{jsr}{sysdm}{call dumper}
\inst{}{brn}{cnc09}{finished}
\lnie
\endln
\lnie
-eject\endln
\lnie
\endln
\inst{cnc12}{bze}{cswls,cnc09}{return if -nolist}
\inst{}{jsr}{prtps}{eject}
\inst{}{jsr}{listt}{list title}
\inst{}{brn}{cnc09}{finished}
\lnie
\endln
\lnie
-errors\endln
\lnie
\endln
\inst{cnc13}{zer}{cswer}{clear switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-execute\endln
\lnie
\endln
\inst{cnc14}{zer}{cswex}{clear switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-fail\endln
\lnie
\endln
\inst{cnc15}{mnz}{cswfl}{set switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-list\endln
\lnie
\endln
\inst{cnc16}{mnz}{cswls}{set switch}
\inst{}{beq}{stage,=stgic,cnc08}{done if compile time}
\lnie
\endln
\lnie
list code line if execute time compile\endln
\lnie
\endln
\inst{}{zer}{lstpf}{permit listing}
\inst{}{jsr}{listr}{list line}
\inst{}{brn}{cnc08}{merge}
\vfill\break

\lnie
\endln
\lnie
cncrd (continued)\endln
\lnie
\endln
\lnie
-noerrors\endln
\lnie
\endln
\inst{cnc17}{mnz}{cswer}{set switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-noexecute\endln
\lnie
\endln
\inst{cnc18}{mnz}{cswex}{set switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-nofail\endln
\lnie
\endln
\inst{cnc19}{zer}{cswfl}{clear switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-nolist\endln
\lnie
\endln
\inst{cnc20}{zer}{cswls}{clear switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-nooptimise\endln
\lnie
\endln
\inst{cnc21}{mnz}{cswno}{set switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-noprint\endln
\lnie
\endln
\inst{cnc22}{zer}{cswpr}{clear switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-optimise\endln
\lnie
\endln
\inst{cnc24}{zer}{cswno}{clear switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-print\endln
\lnie
\endln
\inst{cnc25}{mnz}{cswpr}{set switch}
\inst{}{brn}{cnc08}{merge}
\vfill\break

\lnie
\endln
\lnie
cncrd (continued)\endln
\lnie
\endln
\lnie
-single\endln
\lnie
\endln
\inst{cnc27}{zer}{cswdb}{clear switch}
\inst{}{brn}{cnc08}{merge}
\lnie
\endln
\lnie
-space\endln
\lnie
\endln
\inst{cnc28}{bze}{cswls,cnc09}{return if -nolist}
\inst{}{jsr}{scane}{scan integer after -space}
\inst{}{mov}{=num01,wc}{1 space in case}
\inst{}{beq}{xr,=t$smc,cnc29}{jump if no integer}
\inst{}{mov}{xr,-(xs)}{stack it}
\inst{}{jsr}{gtsmi}{check integer}
\inst{}{ppm}{cnc06}{fail if not integer}
\inst{}{ppm}{cnc06}{fail if negative or large}
\inst{}{bnz}{wc,cnc29}{jump if non zero}
\inst{}{mov}{=num01,wc}{else 1 space}
\lnie
\endln
\lnie
merge with count of lines to skip\endln
\lnie
\endln
\inst{cnc29}{add}{wc,lstlc}{bump line count}
\inst{}{lct}{wc,wc}{convert to loop counter}
\inst{}{blt}{lstlc,lstnp,cnc30}{jump if fits on page}
\inst{}{jsr}{prtps}{eject}
\inst{}{jsr}{listt}{list title}
\inst{}{brn}{cnc09}{merge}
\lnie
\endln
\lnie
skip lines\endln
\lnie
\endln
\inst{cnc30}{jsr}{prtnl}{print a blank}
\inst{}{bct}{wc,cnc30}{loop}
\inst{}{brn}{cnc09}{merge}
\vfill\break

\lnie
\endln
\lnie
cncrd (continued)\endln
\lnie
\endln
\lnie
-stitl\endln
\lnie
\endln
\inst{cnc31}{mov}{=r$stl,cnr$t}{ptr to r$stl}
\inst{}{brn}{cnc33}{merge}
\lnie
\endln
\lnie
-title\endln
\lnie
\endln
\inst{cnc32}{mov}{=nulls,r$stl}{clear subtitle}
\inst{}{mov}{=r$ttl,cnr$t}{ptr to r$ttl}
\lnie
\endln
\lnie
common processing for -title, -stitl\endln
\lnie
\endln
\inst{cnc33}{mov}{=nulls,xr}{null in case needed}
\inst{}{mnz}{cnttl}{set flag for next listr call}
\inst{}{mov}{=ccofs,wb}{offset to title/subtitle}
\inst{}{mov}{scnil,wa}{input image length}
\inst{}{blo}{wa,wb,cnc34}{jump if no chars left}
\inst{}{sub}{wb,wa}{no of chars to extract}
\inst{}{mov}{r$cim,xl}{point to image}
\inst{}{jsr}{sbstr}{get title/subtitle}
\lnie
\endln
\lnie
store title/subtitle\endln
\lnie
\endln
\inst{cnc34}{mov}{cnr$t,xl}{point to storage location}
\inst{}{mov}{xr,(xl)}{store title/subtitle}
\inst{}{beq}{xl,=r$stl,cnc09}{return if stitl}
\inst{}{bnz}{precl,cnc09}{return if extended listing}
\inst{}{bze}{prich,cnc09}{return if regular printer}
\inst{}{mov}{sclen(xr),xl}{get length of title}
\inst{}{mov}{xl,wa}{copy it}
\inst{}{bze}{xl,cnc35}{jump if null}
\inst{}{add}{=num10,xl}{increment}
\inst{}{bhi}{xl,prlen,cnc09}{use default lstp0 val if too long}
\inst{}{add}{=num04,wa}{point just past title}
\lnie
\endln
\lnie
store offset to page nn message for short title\endln
\lnie
\endln
\inst{cnc35}{mov}{wa,lstpo}{store offset}
\inst{}{brn}{cnc09}{return}
\lnie
\endln
\lnie
-trace\endln
\lnie
provided for system debugging.  toggles the system label\endln
\lnie
trace switch at compile time\endln
\lnie
\endln
\inst{cnc36}{jsr}{systt}{toggle switch}
\inst{}{brn}{cnc08}{merge}
\ifmac{.culc}
\lnie
\endln
\lnie
-case\endln
\lnie
sets value of kvcas so that names are folded or not\endln
\lnie
during compilation.\endln
\lnie
\endln
\inst{cnc37}{jsr}{scane}{scan integer after -case}
\inst{}{zer}{wc}{get 0 in case none there}
\inst{}{beq}{xl,=t$smc,cnc38}{skip if no integer}
\inst{}{mov}{xr,-(xs)}{stack it}
\inst{}{jsr}{gtsmi}{check integer}
\inst{}{ppm}{cnc06}{fail if not integer}
\inst{}{ppm}{cnc06}{fail if negative or too large}
\inst{cnc38}{mov}{wc,kvcas}{store new case value}
\inst{}{brn}{cnc09}{merge}
\asmac{fi}
\ifmac{.ccmc}
\lnie
\endln
\lnie
-compare\endln
\lnie
\endln
\lnie
sets value of kvcom so that string comparisons may\endln
\lnie
follow collation sequence determined by the interface.\endln
\lnie
\endln
\inst{cnc39}{jsr}{scane}{scan integer after -compare}
\inst{}{zer}{wc}{get 0 in case none there}
\inst{}{beq}{xl,=t$smc,cnc40}{skip if no integer}
\inst{}{mov}{xr,-(xs)}{stack it}
\inst{}{jsr}{gtsmi}{check integer}
\inst{}{ppm}{cnc06}{fail if not integer}
\inst{}{ppm}{cnc06}{fail if negative or too large}
\inst{cnc40}{mov}{wc,kvcom}{store new compare value}
\inst{}{brn}{cnc09}{merge}
\asmac{fi}
\ifmac{.cinc}
\lnie
\endln
\lnie
-include\endln
\lnie
\endln
\inst{cnc41}{mnz}{scncc}{set flag for scane}
\inst{}{jsr}{scane}{scan quoted file name}
\inst{}{zer}{scncc}{clear scane flag}
\inst{}{bne}{xl,=t$con,cnc06}{if not constant}
\inst{}{bne}{(xr),=b$scl,cnc06}{ if not string constant}
\inst{}{mov}{xr,r$ifn}{save file name}
\inst{}{mov}{r$inc,xl}{examine include file name table}
\inst{}{zer}{wb}{lookup by value}
\inst{}{jsr}{tfind}{do lookup}
\inst{}{ppm}{}{never fails}
\inst{}{beq}{xr,=inton,cnc09}{ignore if already in table}
\inst{}{mnz}{wb}{set for trim}
\inst{}{mov}{r$ifn,xr}{file name}
\inst{}{jsr}{trimr}{remove trailing blanks}
\inst{}{mov}{r$inc,xl}{include file name table}
\inst{}{mnz}{wb}{lookup by name this time}
\inst{}{jsr}{tfind}{do lookup}
\inst{}{ppm}{}{never fails}
\inst{}{mov}{=inton,teval(xl)}{make table value integer 1}
\inst{}{icv}{cnind}{increase nesting level}
\inst{}{mov}{cnind,wa}{load new nest level}
\inst{}{bgt}{wa,=ccinm,cnc42}{fail if excessive nesting}
\ifmac{.csfn}
\lnie
\endln
\lnie
record the name and line number of the current input file\endln
\lnie
\endln
\inst{}{mov}{r$ifa,xl}{array of nested file names}
\inst{}{add}{=vcvlb,wa}{compute offset in words}
\inst{}{wtb}{wa}{convert to bytes}
\inst{}{add}{wa,xl}{point to element}
\inst{}{mov}{r$sfc,(xl)}{record current file name}
\inst{}{mov}{wa,xl}{preserve nesting byte offset}
\inst{}{mti}{rdnln}{fetch source line number as integer}
\inst{}{jsr}{icbld}{convert to icblk}
\inst{}{add}{r$ifl,xl}{entry in nested line number array}
\inst{}{mov}{xr,(xl)}{record in array}
\asmac{fi}
\lnie
\endln
\lnie
here to switch to include file named in r$ifn\endln
\lnie
\endln
\inst{}{mov}{cswin,wa}{max read length}
\inst{}{mov}{r$ifn,xl}{include file name}
\inst{}{jsr}{alocs}{get buffer for complete file name}
\inst{}{jsr}{sysif}{open include file}
\inst{}{ppm}{cnc43}{could not open}
\ifmac{.csfn}
\lnie
\endln
\lnie
make note of the complete file name for error messages\endln
\lnie
\endln
\inst{}{zer}{wb}{do not trim trailing blanks}
\inst{}{jsr}{trimr}{adjust scblk for actual length}
\inst{}{mov}{xr,r$sfc}{save ptr to file name}
\inst{}{mti}{cmpsn}{current statement as integer}
\inst{}{jsr}{icbld}{build icblk for stmt number}
\inst{}{mov}{r$sfn,xl}{file name table}
\inst{}{mnz}{wb}{lookup statement number by name}
\inst{}{jsr}{tfind}{allocate new teblk}
\inst{}{ppm}{}{always possible to allocate block}
\inst{}{mov}{r$sfc,teval(xl)}{record file name as entry value}
\asmac{else}
\inst{}{mov}{xr,dnamp}{release allocated scblk}
\asmac{fi}
\inst{}{zer}{rdnln}{restart line counter for new file}
\inst{}{beq}{stage,=stgic,cnc09}{if initial compile}
\inst{}{bne}{cnind,=num01,cnc09}{if not first execute-time nesting}
\lnie
\endln
\lnie
here for -include during execute-time compile\endln
\lnie
\endln
\inst{}{mov}{r$cim,r$ici}{remember code argument string}
\inst{}{mov}{scnpt,cnspt}{save position in string}
\inst{}{mov}{scnil,cnsil}{and length of string}
\inst{}{brn}{cnc09}{all done, merge}
\lnie
\endln
\lnie
here for excessive include file nesting\endln
\lnie
\endln
\inst{cnc42}{erb}{284,excessively nested}{include files}
\lnie
\endln
\lnie
here if include file could not be opened\endln
\lnie
\endln
\inst{cnc43}{mov}{xr,dnamp}{release allocated scblk}
\inst{}{erb}{285,include file}{cannot be opened}
\lnie
\endln
\asmac{fi}
\ifmac{.csln}
\lnie
\endln
\lnie
-line n filename\endln
\lnie
\endln
\inst{cnc44}{jsr}{scane}{scan integer after -line}
\inst{}{bne}{xl,=t$con,cnc06}{jump if no line number}
\inst{}{bne}{(xr),=b$icl,cnc06}{jump if not integer}
\inst{}{ldi}{icval(xr)}{fetch integer line number}
\inst{}{ile}{cnc06}{error if negative or zero}
\inst{}{beq}{stage,=stgic,cnc45}{skip if initial compile}
\inst{}{mfi}{cmpln}{set directly for other compiles}
\inst{}{brn}{cnc46}{no need to set rdnln}
\inst{cnc45}{sbi}{intv1}{adjust number by one}
\inst{}{mfi}{rdnln}{save line number}
\ifmac{.csfn}
\inst{cnc46}{mnz}{scncc}{set flag for scane}
\inst{}{jsr}{scane}{scan quoted file name}
\inst{}{zer}{scncc}{clear scane flag}
\inst{}{beq}{xl,=t$smc,cnc47}{done if no file name}
\inst{}{bne}{xl,=t$con,cnc06}{error if not constant}
\inst{}{bne}{(xr),=b$scl,cnc06}{if not string constant}
\inst{}{jsr}{newfn}{record new file name}
\inst{}{brn}{cnc09}{merge}
\lnie
\endln
\lnie
here if file name not present\endln
\lnie
\endln
\inst{cnc47}{dcv}{scnpt}{set to rescan the terminator}
\inst{}{brn}{cnc09}{merge}
\asmac{else}
\inst{cnc46}{brn}{cnc09}{merge}
\asmac{fi}
\asmac{fi}
\inst{}{enp}{}{end procedure cncrd}
\vfill\break

\ifmac{.ceng}
\lnie
\endln
\lnie
enevs -- evaluate string expression for engine\endln
\lnie
\endln
\lnie
enevs is used by the external interface to evaluate a\endln
\lnie
string expression, typically for an engine wishing to\endln
\lnie
obtain the value of a variable or expression.\endln
\lnie
\endln
\ifmac{.cevb}
\lnie
(wb)                  0 if by value, 1 if by name\endln
\asmac{fi}
\lnie
(xr)                  scblk for string to evaluate\endln
\lnie
jsr  enevs            call to convert and evaluate\endln
\lnie
(xr)                  pointer to result\endln
\lnie
                      = 0 if expression evaluation failed\endln
\lnie
                      = 1 if conversion to expression failed\endln
\lnie
\endln
\inst{enevs}{prc}{r,0}{entry point (recursive)}
\ifmac{.cevb}
\inst{}{mov}{wb,-(xs)}{save value/name flag}
\asmac{fi}
\inst{}{jsr}{gtexp}{convert to expression}
\inst{}{ppm}{enev2}{conversion fails}
\ifmac{.cevb}
\inst{}{mov}{(xs)+,wb}{recover value/name flag}
\asmac{fi}
\inst{}{jsr}{evalx}{evaluate expression by value}
\inst{}{ppm}{enev1}{evaluation fails}
\inst{}{exi}{enev1}{evaluation fails}
\lnie
\endln
\lnie
here if expression evaluation failed\endln
\lnie
\endln
\inst{enev1}{zer}{xr}{return zero result}
\inst{}{exi}{xr}{return zero result}
\lnie
\endln
\lnie
here if conversion to expression failed\endln
\lnie
\endln
\ifmac{.cevb}
\inst{enev2}{ica}{xs}{discard value/name flag}
\inst{}{mov}{=num01,xr}{return integer one result}
\asmac{else}
\inst{enev2}{mov}{=num01,xr}{return integer one result}
\asmac{fi}
\inst{}{exi}{=num01,xr}{return integer one result}
\inst{}{enp}{=num01,xr}{return integer one result}
\vfill\break

\lnie
\endln
\lnie
engts -- get string for engine\endln
\lnie
\endln
\lnie
engts is passed an object and returns a string with\endln
\lnie
any necessary conversions performed.\endln
\lnie
\endln
\lnie
(xr)                  input argument\endln
\lnie
jsr  engts            call to convert to string\endln
\lnie
(xr)                  pointer to resulting string\endln
\lnie
                      =0 if conversion not possible\endln
\lnie
\endln
\inst{engts}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{stack argument to convert}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{engt1}{convert impossible}
\inst{}{exi}{engt1}{convert impossible}
\lnie
\endln
\lnie
here if unable to convert to string\endln
\lnie
\endln
\inst{engt1}{zer}{xr}{return zero}
\inst{}{exi}{xr}{return zero}
\inst{}{enp}{xr}{return zero}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
dffnc -- define function\endln
\lnie
\endln
\lnie
dffnc is called whenever a new function is assigned to\endln
\lnie
a variable. it deals with external function use counts.\endln
\lnie
\endln
\lnie
(xr)                  pointer to vrblk\endln
\lnie
(xl)                  pointer to new function block\endln
\lnie
jsr  dffnc            call to define function\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\inst{dffnc}{prc}{e,0}{entry point}
\ifmac{.cnld}
\asmac{else}
\inst{}{bne}{(xl),=b$efc,dffn1}{skip if new function not external}
\inst{}{icv}{efuse(xl)}{else increment its use count}
\lnie
\endln
\lnie
here after dealing with new function use count\endln
\lnie
\endln
\inst{dffn1}{mov}{xr,wa}{save vrblk pointer}
\inst{}{mov}{vrfnc(xr),xr}{load old function pointer}
\inst{}{bne}{(xr),=b$efc,dffn2}{jump if old function not external}
\inst{}{mov}{efuse(xr),wb}{else get use count}
\inst{}{dcv}{wb}{decrement}
\inst{}{mov}{wb,efuse(xr)}{store decremented value}
\inst{}{bnz}{wb,dffn2}{jump if use count still non-zero}
\inst{}{jsr}{sysul}{else call system unload function}
\lnie
\endln
\lnie
here after dealing with old function use count\endln
\lnie
\endln
\inst{dffn2}{mov}{wa,xr}{restore vrblk pointer}
\asmac{fi}
\inst{}{mov}{xl,wa}{copy function block ptr}
\inst{}{blt}{xr,=r$yyy,dffn3}{skip checks if opsyn op definition}
\inst{}{bnz}{vrlen(xr),dffn3}{jump if not system variable}
\lnie
\endln
\lnie
for system variable, check for illegal redefinition\endln
\lnie
\endln
\inst{}{mov}{vrsvp(xr),xl}{point to svblk}
\inst{}{mov}{svbit(xl),wb}{load bit indicators}
\inst{}{anb}{btfnc,wb}{is it a system function}
\inst{}{zrb}{wb,dffn3}{redef ok if not}
\inst{}{erb}{248,attempted redefinition}{of system function}
\lnie
\endln
\lnie
here if redefinition is permitted\endln
\lnie
\endln
\inst{dffn3}{mov}{wa,vrfnc(xr)}{store new function pointer}
\inst{}{mov}{wa,xl}{restore function block pointer}
\inst{}{exi}{}{return to dffnc caller}
\inst{}{enp}{}{end procedure dffnc}
\vfill\break

\lnie
\endln
\lnie
dtach -- detach i/o associated names\endln
\lnie
\endln
\lnie
detaches trblks from i/o associated variables, removes\endln
\lnie
entry from iochn chain attached to filearg1 vrblk and may\endln
\lnie
remove vrblk access and store traps.\endln
\lnie
input, output, terminal are handled specially.\endln
\lnie
\endln
\lnie
(xl)                  i/o assoc. vbl name base ptr\endln
\lnie
(wa)                  offset to name\endln
\lnie
jsr  dtach            call for detach operation\endln
\lnie
(xl,xr,wa,wb,wc)      destroyed\endln
\lnie
\endln
\inst{dtach}{prc}{e,0}{entry point}
\inst{}{mov}{xl,dtcnb}{store name base (gbcol not called)}
\inst{}{add}{wa,xl}{point to name location}
\inst{}{mov}{xl,dtcnm}{store it}
\lnie
\endln
\lnie
loop to search for i/o trblk\endln
\lnie
\endln
\inst{dtch1}{mov}{xl,xr}{copy name pointer}
\lnie
\endln
\lnie
continue after block deletion\endln
\lnie
\endln
\inst{dtch2}{mov}{(xl),xl}{point to next value}
\inst{}{bne}{(xl),=b$trt,dtch6}{jump at chain end}
\inst{}{mov}{trtyp(xl),wa}{get trap block type}
\inst{}{beq}{wa,=trtin,dtch3}{jump if input}
\inst{}{beq}{wa,=trtou,dtch3}{jump if output}
\inst{}{add}{*trnxt,xl}{point to next link}
\inst{}{brn}{dtch1}{loop}
\lnie
\endln
\lnie
delete an old association\endln
\lnie
\endln
\inst{dtch3}{mov}{trval(xl),(xr)}{delete trblk}
\inst{}{mov}{xl,wa}{dump xl ...}
\inst{}{mov}{xr,wb}{... and xr}
\inst{}{mov}{trtrf(xl),xl}{point to trtrf trap block}
\inst{}{bze}{xl,dtch5}{jump if no iochn}
\inst{}{bne}{(xl),=b$trt,dtch5}{jump if input, output, terminal}
\lnie
\endln
\lnie
loop to search iochn chain for name ptr\endln
\lnie
\endln
\inst{dtch4}{mov}{xl,xr}{remember link ptr}
\inst{}{mov}{trtrf(xl),xl}{point to next link}
\inst{}{bze}{xl,dtch5}{jump if end of chain}
\inst{}{mov}{ionmb(xl),wc}{get name base}
\inst{}{add}{ionmo(xl),wc}{add offset}
\inst{}{bne}{wc,dtcnm,dtch4}{loop if no match}
\inst{}{mov}{trtrf(xl),trtrf(xr)}{remove name from chain}
\vfill\break

\lnie
\endln
\lnie
dtach (continued)\endln
\lnie
\endln
\lnie
prepare to resume i/o trblk scan\endln
\lnie
\endln
\inst{dtch5}{mov}{wa,xl}{recover xl ...}
\inst{}{mov}{wb,xr}{... and xr}
\inst{}{add}{*trval,xl}{point to value field}
\inst{}{brn}{dtch2}{continue}
\lnie
\endln
\lnie
exit point\endln
\lnie
\endln
\inst{dtch6}{mov}{dtcnb,xr}{possible vrblk ptr}
\inst{}{jsr}{setvr}{reset vrblk if necessary}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure dtach}
\vfill\break

\lnie
\endln
\lnie
dtype -- get datatype name\endln
\lnie
\endln
\lnie
(xr)                  object whose datatype is required\endln
\lnie
jsr  dtype            call to get datatype\endln
\lnie
(xr)                  result datatype\endln
\lnie
\endln
\inst{dtype}{prc}{e,0}{entry point}
\inst{}{beq}{(xr),=b$pdt,dtyp1}{  jump if prog.defined}
\inst{}{mov}{(xr),xr}{load type word}
\inst{}{lei}{xr}{get entry point id (block code)}
\inst{}{wtb}{xr}{convert to byte offset}
\inst{}{mov}{scnmt(xr),xr}{load table entry}
\inst{}{exi}{}{exit to dtype caller}
\lnie
\endln
\lnie
here if program defined\endln
\lnie
\endln
\inst{dtyp1}{mov}{pddfp(xr),xr}{point to dfblk}
\inst{}{mov}{dfnam(xr),xr}{get datatype name from dfblk}
\inst{}{exi}{}{return to dtype caller}
\inst{}{enp}{}{end procedure dtype}
\vfill\break

\lnie
\endln
\lnie
dumpr -- print dump of storage\endln
\lnie
\endln
\lnie
(xr)                  dump argument (see below)\endln
\lnie
jsr  dumpr            call to print dump\endln
\lnie
(xr,xl)               destroyed\endln
\lnie
(wa,wb,wc,ra)         destroyed\endln
\lnie
\endln
\lnie
the dump argument has the following significance\endln
\lnie
\endln
\lnie
dmarg = 0             no dump printed\endln
\lnie
dmarg = 1             partial dump (nat vars, keywords)\endln
\lnie
dmarg = 2             full dump (arrays, tables, etc.)\endln
\lnie
dmarg = 3             full dump + null variables\endln
\lnie
dmarg ge 4            core dump\endln
\lnie
\endln
\lnie
since dumpr scrambles store, it is not permissible to\endln
\lnie
collect in mid-dump. hence a collect is done initially\endln
\lnie
and then if store runs out an error message is produced.\endln
\lnie
\endln
\inst{dumpr}{prc}{e,0}{entry point}
\inst{}{bze}{xr,dmp28}{skip dump if argument is zero}
\inst{}{bgt}{xr,=num03,dmp29}{jump if core dump required}
\inst{}{zer}{xl}{clear xl}
\inst{}{zer}{wb}{zero move offset}
\inst{}{mov}{xr,dmarg}{save dump argument}
\ifmac{.csed}
\inst{}{zer}{dnams}{collect sediment too}
\asmac{fi}
\inst{}{jsr}{gbcol}{collect garbage}
\inst{}{jsr}{prtpg}{eject printer}
\inst{}{mov}{=dmhdv,xr}{point to heading for variables}
\inst{}{jsr}{prtst}{print it}
\inst{}{jsr}{prtnl}{terminate print line}
\inst{}{jsr}{prtnl}{and print a blank line}
\lnie
\endln
\lnie
first all natural variable blocks (vrblk) whose values\endln
\lnie
are non-null are linked in lexical order using dmvch as\endln
\lnie
the chain head and chaining through the vrget fields.\endln
\lnie
note that this scrambles store if the process is\endln
\lnie
interrupted before completion e.g. by exceeding time  or\endln
\lnie
print limits. since the subsequent core dumps and\endln
\lnie
failures if execution is resumed are very confusing, the\endln
\lnie
execution time error routine checks for this event and\endln
\lnie
attempts an unscramble. similar precautions should be\endln
\lnie
observed if translate time dumping is implemented.\endln
\lnie
\endln
\inst{}{zer}{dmvch}{set null chain to start}
\inst{}{mov}{hshtb,wa}{point to hash table}
\lnie
\endln
\lnie
loop through headers in hash table\endln
\lnie
\endln
\inst{dmp00}{mov}{wa,xr}{copy hash bucket pointer}
\inst{}{ica}{wa}{bump pointer}
\inst{}{sub}{*vrnxt,xr}{set offset to merge}
\lnie
\endln
\lnie
loop through vrblks on one chain\endln
\lnie
\endln
\inst{dmp01}{mov}{vrnxt(xr),xr}{point to next vrblk on chain}
\inst{}{bze}{xr,dmp09}{jump if end of this hash chain}
\inst{}{mov}{xr,xl}{else copy vrblk pointer}
\vfill\break

\lnie
\endln
\lnie
dumpr (continued)\endln
\lnie
\endln
\lnie
loop to find value and skip if null\endln
\lnie
\endln
\inst{dmp02}{mov}{vrval(xl),xl}{load value}
\inst{}{beq}{dmarg,=num03,dmp2a}{skip null value check if dump(3)}
\inst{}{beq}{xl,=nulls,dmp01}{loop for next vrblk if null value}
\inst{dmp2a}{beq}{(xl),=b$trt,dmp02}{loop back if value is trapped}
\lnie
\endln
\lnie
non-null value, prepare to search chain\endln
\lnie
\endln
\inst{}{mov}{xr,wc}{save vrblk pointer}
\inst{}{add}{*vrsof,xr}{adjust ptr to be like scblk ptr}
\inst{}{bnz}{sclen(xr),dmp03}{jump if non-system variable}
\inst{}{mov}{vrsvo(xr),xr}{else load ptr to name in svblk}
\lnie
\endln
\lnie
here with name pointer for new block in xr\endln
\lnie
\endln
\inst{dmp03}{mov}{xr,wb}{save pointer to chars}
\inst{}{mov}{wa,dmpsv}{save hash bucket pointer}
\inst{}{mov}{=dmvch,wa}{point to chain head}
\lnie
\endln
\lnie
loop to search chain for correct insertion point\endln
\lnie
\endln
\inst{dmp04}{mov}{wa,dmpch}{save chain pointer}
\inst{}{mov}{wa,xl}{copy it}
\inst{}{mov}{(xl),xr}{load pointer to next entry}
\inst{}{bze}{xr,dmp08}{jump if end of chain to insert}
\inst{}{add}{*vrsof,xr}{else get name ptr for chained vrblk}
\inst{}{bnz}{sclen(xr),dmp05}{jump if not system variable}
\inst{}{mov}{vrsvo(xr),xr}{else point to name in svblk}
\lnie
\endln
\lnie
here prepare to compare the names\endln
\lnie
\endln
\lnie
(wa)                  scratch\endln
\lnie
(wb)                  pointer to string of entering vrblk\endln
\lnie
(wc)                  pointer to entering vrblk\endln
\lnie
(xr)                  pointer to string of current block\endln
\lnie
(xl)                  scratch\endln
\lnie
\endln
\inst{dmp05}{mov}{wb,xl}{point to entering vrblk string}
\inst{}{mov}{sclen(xl),wa}{load its length}
\inst{}{plc}{xl}{point to chars of entering string}
\ifmac{.ccmc}
\inst{}{mov}{wb,dmpsb}{save wb}
\inst{}{mov}{sclen(xr),wb}{length of old string}
\inst{}{plc}{xr}{point to chars of old string}
\inst{}{jsr}{syscm}{generalized lexical compare}
\inst{}{ppm}{dmp06}{string too long, treat like eq}
\inst{}{ppm}{dmp06}{entering string lt old string}
\inst{}{ppm}{dmp07}{entering string gt old string}
\lnie
\endln
\lnie
here when entering string le old string\endln
\lnie
\endln
\inst{dmp06}{mov}{dmpsb,wb}{restore wb}
\inst{}{brn}{dmp08}{found insertion point}
\vfill\break

\lnie
\endln
\lnie
dumpr (continued)\endln
\lnie
\endln
\lnie
here we move out on the chain\endln
\lnie
\endln
\inst{dmp07}{mov}{dmpsb,wb}{restore wb}
\inst{}{mov}{dmpch,xl}{copy chain pointer}
\asmac{else}
\inst{}{bhi}{wa,sclen(xr),dmp06}{jump if entering length high}
\inst{}{plc}{xr}{else point to chars of old string}
\inst{}{cmc}{dmp08,dmp07}{compare, insert if new is llt old}
\inst{}{brn}{dmp08}{or if leq (we had shorter length)}
\lnie
\endln
\lnie
here when new length is longer than old length\endln
\lnie
\endln
\inst{dmp06}{mov}{sclen(xr),wa}{load shorter length}
\inst{}{plc}{xr}{point to chars of old string}
\inst{}{cmc}{dmp08,dmp07}{compare, insert if new one low}
\vfill\break

\lnie
\endln
\lnie
dumpr (continued)\endln
\lnie
\endln
\lnie
here we move out on the chain\endln
\lnie
\endln
\inst{dmp07}{mov}{dmpch,xl}{copy chain pointer}
\asmac{fi}
\inst{}{mov}{(xl),wa}{move to next entry on chain}
\inst{}{brn}{dmp04}{loop back}
\lnie
\endln
\lnie
here after locating the proper insertion point\endln
\lnie
\endln
\inst{dmp08}{mov}{dmpch,xl}{copy chain pointer}
\inst{}{mov}{dmpsv,wa}{restore hash bucket pointer}
\inst{}{mov}{wc,xr}{restore vrblk pointer}
\inst{}{mov}{(xl),vrget(xr)}{link vrblk to rest of chain}
\inst{}{mov}{xr,(xl)}{link vrblk into current chain loc}
\inst{}{brn}{dmp01}{loop back for next vrblk}
\lnie
\endln
\lnie
here after processing all vrblks on one chain\endln
\lnie
\endln
\inst{dmp09}{bne}{wa,hshte,dmp00}{loop back if more buckets to go}
\lnie
\endln
\lnie
loop to generate dump of natural variable values\endln
\lnie
\endln
\inst{dmp10}{mov}{dmvch,xr}{load pointer to next entry on chain}
\inst{}{bze}{xr,dmp11}{jump if end of chain}
\inst{}{mov}{(xr),dmvch}{else update chain ptr to next entry}
\inst{}{jsr}{setvr}{restore vrget field}
\inst{}{mov}{xr,xl}{copy vrblk pointer (name base)}
\inst{}{mov}{*vrval,wa}{set offset for vrblk name}
\inst{}{jsr}{prtnv}{print name = value}
\inst{}{brn}{dmp10}{loop back till all printed}
\lnie
\endln
\lnie
prepare to print keywords\endln
\lnie
\endln
\inst{dmp11}{jsr}{prtnl}{print blank line}
\inst{}{jsr}{prtnl}{and another}
\inst{}{mov}{=dmhdk,xr}{point to keyword heading}
\inst{}{jsr}{prtst}{print heading}
\inst{}{jsr}{prtnl}{end line}
\inst{}{jsr}{prtnl}{print one blank line}
\inst{}{mov}{=vdmkw,xl}{point to list of keyword svblk ptrs}
\vfill\break

\lnie
\endln
\lnie
dumpr (continued)\endln
\lnie
\endln
\lnie
loop to dump keyword values\endln
\lnie
\endln
\inst{dmp12}{mov}{(xl)+,xr}{load next svblk ptr from table}
\inst{}{bze}{xr,dmp13}{jump if end of list}
\ifmac{.ccmk}
\inst{}{beq}{xr,=num01,dmp12}{&compare ignored if not implemented}
\asmac{fi}
\inst{}{mov}{=ch$am,wa}{load ampersand}
\inst{}{jsr}{prtch}{print ampersand}
\inst{}{jsr}{prtst}{print keyword name}
\inst{}{mov}{svlen(xr),wa}{load name length from svblk}
\inst{}{ctb}{wa,svchs}{get length of name}
\inst{}{add}{wa,xr}{point to svknm field}
\inst{}{mov}{(xr),dmpkn}{store in dummy kvblk}
\inst{}{mov}{=tmbeb,xr}{point to blank-equal-blank}
\inst{}{jsr}{prtst}{print it}
\inst{}{mov}{xl,dmpsv}{save table pointer}
\inst{}{mov}{=dmpkb,xl}{point to dummy kvblk}
\inst{}{mov}{=b$kvt,(xl)}{build type word}
\inst{}{mov}{=trbkv,kvvar(xl)}{build ptr to dummy trace block}
\inst{}{mov}{*kvvar,wa}{set zero offset}
\inst{}{jsr}{acess}{get keyword value}
\inst{}{ppm}{}{failure is impossible}
\inst{}{jsr}{prtvl}{print keyword value}
\inst{}{jsr}{prtnl}{terminate print line}
\inst{}{mov}{dmpsv,xl}{restore table pointer}
\inst{}{brn}{dmp12}{loop back till all printed}
\lnie
\endln
\lnie
here after completing partial dump\endln
\lnie
\endln
\inst{dmp13}{beq}{dmarg,=num01,dmp27}{exit if partial dump complete}
\inst{}{mov}{dnamb,xr}{else point to first dynamic block}
\lnie
\endln
\lnie
loop through blocks in dynamic storage\endln
\lnie
\endln
\inst{dmp14}{beq}{xr,dnamp,dmp27}{jump if end of used region}
\inst{}{mov}{(xr),wa}{else load first word of block}
\inst{}{beq}{wa,=b$vct,dmp16}{jump if vector}
\inst{}{beq}{wa,=b$art,dmp17}{jump if array}
\inst{}{beq}{wa,=b$pdt,dmp18}{jump if program defined}
\inst{}{beq}{wa,=b$tbt,dmp19}{jump if table}
\ifmac{.cnbf}
\asmac{else}
\inst{}{beq}{wa,=b$bct,dmp30}{jump if buffer}
\asmac{fi}
\lnie
\endln
\lnie
merge here to move to next block\endln
\lnie
\endln
\inst{dmp15}{jsr}{blkln}{get length of block}
\inst{}{add}{wa,xr}{point past this block}
\inst{}{brn}{dmp14}{loop back for next block}
\vfill\break

\lnie
\endln
\lnie
dumpr (continued)\endln
\lnie
\endln
\lnie
here for vector\endln
\lnie
\endln
\inst{dmp16}{mov}{*vcvls,wb}{set offset to first value}
\inst{}{brn}{dmp19}{jump to merge}
\lnie
\endln
\lnie
here for array\endln
\lnie
\endln
\inst{dmp17}{mov}{arofs(xr),wb}{set offset to arpro field}
\inst{}{ica}{wb}{bump to get offset to values}
\inst{}{brn}{dmp19}{jump to merge}
\lnie
\endln
\lnie
here for program defined\endln
\lnie
\endln
\inst{dmp18}{mov}{*pdfld,wb}{point to values, merge}
\lnie
\endln
\lnie
here for table (others merge)\endln
\lnie
\endln
\inst{dmp19}{bze}{idval(xr),dmp15}{ignore block if zero id value}
\inst{}{jsr}{blkln}{else get block length}
\inst{}{mov}{xr,xl}{copy block pointer}
\inst{}{mov}{wa,dmpsv}{save length}
\inst{}{mov}{wb,wa}{copy offset to first value}
\inst{}{jsr}{prtnl}{print blank line}
\inst{}{mov}{wa,dmpsa}{preserve offset}
\inst{}{jsr}{prtvl}{print block value (for title)}
\inst{}{mov}{dmpsa,wa}{recover offset}
\inst{}{jsr}{prtnl}{end print line}
\inst{}{beq}{(xr),=b$tbt,dmp22}{jump if table}
\inst{}{dca}{wa}{point before first word}
\lnie
\endln
\lnie
loop to print contents of array, vector, or program def\endln
\lnie
\endln
\inst{dmp20}{mov}{xl,xr}{copy block pointer}
\inst{}{ica}{wa}{bump offset}
\inst{}{add}{wa,xr}{point to next value}
\inst{}{beq}{wa,dmpsv,dmp14}{exit if end (xr past block)}
\inst{}{sub}{*vrval,xr}{subtract offset to merge into loop}
\lnie
\endln
\lnie
loop to find value and ignore nulls\endln
\lnie
\endln
\inst{dmp21}{mov}{vrval(xr),xr}{load next value}
\inst{}{beq}{dmarg,=num03,dmp2b}{skip null value check if dump(3)}
\inst{}{beq}{xr,=nulls,dmp20}{loop back if null value}
\inst{dmp2b}{beq}{(xr),=b$trt,dmp21}{loop back if trapped}
\inst{}{jsr}{prtnv}{else print name = value}
\inst{}{brn}{dmp20}{loop back for next field}
\vfill\break

\lnie
\endln
\lnie
dumpr (continued)\endln
\lnie
\endln
\lnie
here to dump a table\endln
\lnie
\endln
\inst{dmp22}{mov}{*tbbuk,wc}{set offset to first bucket}
\inst{}{mov}{*teval,wa}{set name offset for all teblks}
\lnie
\endln
\lnie
loop through table buckets\endln
\lnie
\endln
\inst{dmp23}{mov}{xl,-(xs)}{save tbblk pointer}
\inst{}{add}{wc,xl}{point to next bucket header}
\inst{}{ica}{wc}{bump bucket offset}
\inst{}{sub}{*tenxt,xl}{subtract offset to merge into loop}
\lnie
\endln
\lnie
loop to process teblks on one chain\endln
\lnie
\endln
\inst{dmp24}{mov}{tenxt(xl),xl}{point to next teblk}
\inst{}{beq}{xl,(xs),dmp26}{jump if end of chain}
\inst{}{mov}{xl,xr}{else copy teblk pointer}
\lnie
\endln
\lnie
loop to find value and ignore if null\endln
\lnie
\endln
\inst{dmp25}{mov}{teval(xr),xr}{load next value}
\inst{}{beq}{xr,=nulls,dmp24}{ignore if null value}
\inst{}{beq}{(xr),=b$trt,dmp25}{loop back if trapped}
\inst{}{mov}{wc,dmpsv}{else save offset pointer}
\inst{}{jsr}{prtnv}{print name = value}
\inst{}{mov}{dmpsv,wc}{reload offset}
\inst{}{brn}{dmp24}{loop back for next teblk}
\lnie
\endln
\lnie
here to move to next hash chain\endln
\lnie
\endln
\inst{dmp26}{mov}{(xs)+,xl}{restore tbblk pointer}
\inst{}{bne}{wc,tblen(xl),dmp23}{loop back if more buckets to go}
\inst{}{mov}{xl,xr}{else copy table pointer}
\inst{}{add}{wc,xr}{point to following block}
\inst{}{brn}{dmp14}{loop back to process next block}
\lnie
\endln
\lnie
here after completing dump\endln
\lnie
\endln
\inst{dmp27}{jsr}{prtpg}{eject printer}
\lnie
\endln
\lnie
merge here if no dump given (dmarg=0)\endln
\lnie
\endln
\inst{dmp28}{exi}{}{return to dump caller}
\lnie
\endln
\lnie
call system core dump routine\endln
\lnie
\endln
\inst{dmp29}{jsr}{sysdm}{call it}
\inst{}{brn}{dmp28}{return}
\ifmac{.cnbf}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
dumpr (continued)\endln
\lnie
\endln
\lnie
here to dump buffer block\endln
\lnie
\endln
\inst{dmp30}{jsr}{prtnl}{print blank line}
\inst{}{jsr}{prtvl}{print value id for title}
\inst{}{jsr}{prtnl}{force new line}
\inst{}{mov}{=ch$dq,wa}{load double quote}
\inst{}{jsr}{prtch}{print it}
\inst{}{mov}{bclen(xr),wc}{load defined length}
\inst{}{bze}{wc,dmp32}{skip characters if none}
\inst{}{lct}{wc,wc}{load count for loop}
\inst{}{mov}{xr,wb}{save bcblk ptr}
\inst{}{mov}{bcbuf(xr),xr}{point to bfblk}
\inst{}{plc}{xr}{get set to load characters}
\lnie
\endln
\lnie
loop here stuffing characters in output stream\endln
\lnie
\endln
\inst{dmp31}{lch}{wa,(xr)+}{get next character}
\inst{}{jsr}{prtch}{stuff it}
\inst{}{bct}{wc,dmp31}{branch for next one}
\inst{}{mov}{wb,xr}{restore bcblk pointer}
\lnie
\endln
\lnie
merge to stuff closing quote mark\endln
\lnie
\endln
\inst{dmp32}{mov}{=ch$dq,wa}{stuff quote}
\inst{}{jsr}{prtch}{print it}
\inst{}{jsr}{prtnl}{print new line}
\inst{}{mov}{(xr),wa}{get first wd for blkln}
\inst{}{brn}{dmp15}{merge to get next block}
\asmac{fi}
\inst{}{enp}{}{end procedure dumpr}
\vfill\break

\lnie
\endln
\lnie
ermsg -- print error code and error message\endln
\lnie
\endln
\lnie
kvert                 error code\endln
\lnie
jsr  ermsg            call to print message\endln
\lnie
(xr,xl,wa,wb,wc,ia)   destroyed\endln
\lnie
\endln
\inst{ermsg}{prc}{e,0}{entry point}
\inst{}{mov}{kvert,wa}{load error code}
\inst{}{mov}{=ermms,xr}{point to error message /error/}
\inst{}{jsr}{prtst}{print it}
\inst{}{jsr}{ertex}{get error message text}
\inst{}{add}{=thsnd,wa}{bump error code for print}
\inst{}{mti}{wa}{fail code in int acc}
\inst{}{mov}{profs,wb}{save current buffer position}
\inst{}{jsr}{prtin}{print code (now have error1xxx)}
\inst{}{mov}{prbuf,xl}{point to print buffer}
\inst{}{psc}{xl,wb}{point to the 1}
\inst{}{mov}{=ch$bl,wa}{load a blank}
\inst{}{sch}{wa,(xl)}{store blank over 1 (error xxx)}
\inst{}{csc}{xl}{complete store characters}
\inst{}{zer}{xl}{clear garbage pointer in xl}
\inst{}{mov}{xr,wa}{keep error text}
\inst{}{mov}{=ermns,xr}{point to / -- /}
\inst{}{jsr}{prtst}{print it}
\inst{}{mov}{wa,xr}{get error text again}
\inst{}{jsr}{prtst}{print error message text}
\inst{}{jsr}{prtis}{print line}
\inst{}{jsr}{prtis}{print blank line}
\inst{}{exi}{}{return to ermsg caller}
\inst{}{enp}{}{end procedure ermsg}
\vfill\break

\lnie
\endln
\lnie
ertex -- get error message text\endln
\lnie
\endln
\lnie
(wa)                  error code\endln
\lnie
jsr  ertex            call to get error text\endln
\lnie
(xr)                  ptr to error text in dynamic\endln
\lnie
(r$etx)               copy of ptr to error text\endln
\lnie
(xl,wc,ia)            destroyed\endln
\lnie
\endln
\inst{ertex}{prc}{e,0}{entry point}
\inst{}{mov}{wa,ertwa}{save wa}
\inst{}{mov}{wb,ertwb}{save wb}
\inst{}{jsr}{sysem}{get failure message text}
\inst{}{mov}{xr,xl}{copy pointer to it}
\inst{}{mov}{sclen(xr),wa}{get length of string}
\inst{}{bze}{wa,ert02}{jump if null}
\inst{}{zer}{wb}{offset of zero}
\inst{}{jsr}{sbstr}{copy into dynamic store}
\inst{}{mov}{xr,r$etx}{store for relocation}
\lnie
\endln
\lnie
return\endln
\lnie
\endln
\inst{ert01}{mov}{ertwb,wb}{restore wb}
\inst{}{mov}{ertwa,wa}{restore wa}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
return errtext contents instead of null\endln
\lnie
\endln
\inst{ert02}{mov}{r$etx,xr}{get errtext}
\inst{}{brn}{ert01}{return}
\inst{}{enp}{ert01}{return}
\vfill\break

\lnie
\endln
\lnie
evali -- evaluate integer argument\endln
\lnie
\endln
\lnie
evali is used by pattern primitives len,tab,rtab,pos,rpos\endln
\lnie
when their argument is an expression value.\endln
\lnie
\endln
\lnie
(xr)                  node pointer\endln
\lnie
(wb)                  cursor\endln
\lnie
jsr  evali            call to evaluate integer\endln
\lnie
ppm  loc              transfer loc for non-integer arg\endln
\lnie
ppm  loc              transfer loc for out of range arg\endln
\lnie
ppm  loc              transfer loc for evaluation failure\endln
\lnie
ppm  loc              transfer loc for successful eval\endln
\lnie
(the normal return is never taken)\endln
\lnie
(xr)                  ptr to node with integer argument\endln
\lnie
(wc,xl,ra)            destroyed\endln
\lnie
\endln
\lnie
on return, the node pointed to has the integer argument\endln
\lnie
in parm1 and the proper successor pointer in pthen.\endln
\lnie
this allows merging with the normal (integer arg) case.\endln
\lnie
\endln
\inst{evali}{prc}{r,4}{entry point (recursive)}
\inst{}{jsr}{evalp}{evaluate expression}
\inst{}{ppm}{evli1}{jump on failure}
\inst{}{mov}{xl,-(xs)}{stack result for gtsmi}
\inst{}{mov}{pthen(xr),xl}{load successor pointer}
\inst{}{mov}{xr,evlio}{save original node pointer}
\inst{}{mov}{wc,evlif}{zero if simple argument}
\inst{}{jsr}{gtsmi}{convert arg to small integer}
\inst{}{ppm}{evli2}{jump if not integer}
\inst{}{ppm}{evli3}{jump if out of range}
\inst{}{mov}{xr,evliv}{store result in special dummy node}
\inst{}{mov}{=evlin,xr}{point to dummy node with result}
\inst{}{mov}{=p$len,(xr)}{dummy pattern block pcode}
\inst{}{mov}{xl,pthen(xr)}{store successor pointer}
\inst{}{exi}{4}{take successful exit}
\lnie
\endln
\lnie
here if evaluation fails\endln
\lnie
\endln
\inst{evli1}{exi}{3}{take failure return}
\lnie
\endln
\lnie
here if argument is not integer\endln
\lnie
\endln
\inst{evli2}{exi}{1}{take non-integer error exit}
\lnie
\endln
\lnie
here if argument is out of range\endln
\lnie
\endln
\inst{evli3}{exi}{2}{take out-of-range error exit}
\inst{}{enp}{}{end procedure evali}
\vfill\break

\lnie
\endln
\lnie
evalp -- evaluate expression during pattern match\endln
\lnie
\endln
\lnie
evalp is used to evaluate an expression (by value) during\endln
\lnie
a pattern match. the effect is like evalx, but pattern\endln
\lnie
variables are stacked and restored if necessary.\endln
\lnie
\endln
\lnie
evalp also differs from evalx in that if the result is\endln
\lnie
an expression it is reevaluated. this occurs repeatedly.\endln
\lnie
\endln
\lnie
to support optimization of pos and rpos, evalp uses wc\endln
\lnie
to signal the caller for the case of a simple vrblk\endln
\lnie
that is not an expression and is not trapped.  because\endln
\lnie
this case cannot have any side effects, optimization is\endln
\lnie
possible.\endln
\lnie
\endln
\lnie
(xr)                  node pointer\endln
\lnie
(wb)                  pattern match cursor\endln
\lnie
jsr  evalp            call to evaluate expression\endln
\lnie
ppm  loc              transfer loc if evaluation fails\endln
\lnie
(xl)                  result\endln
\lnie
(wa)                  first word of result block\endln
\lnie
(wc)                  zero if simple vrblk, else non-zero\endln
\lnie
(xr,wb)               destroyed (failure case only)\endln
\lnie
(ra)                  destroyed\endln
\lnie
\endln
\lnie
the expression pointer is stored in parm1 of the node\endln
\lnie
\endln
\lnie
control returns to failp on failure of evaluation\endln
\lnie
\endln
\inst{evalp}{prc}{r,1}{entry point (recursive)}
\inst{}{mov}{parm1(xr),xl}{load expression pointer}
\inst{}{beq}{(xl),=b$exl,evlp1}{jump if exblk case}
\lnie
\endln
\lnie
here for case of seblk\endln
\lnie
\endln
\lnie
we can give a fast return if the value of the vrblk is\endln
\lnie
not an expression and is not trapped.\endln
\lnie
\endln
\inst{}{mov}{sevar(xl),xl}{load vrblk pointer}
\inst{}{mov}{vrval(xl),xl}{load value of vrblk}
\inst{}{mov}{(xl),wa}{load first word of value}
\inst{}{bhi}{wa,=b$t$$,evlp3}{jump if not seblk, trblk or exblk}
\lnie
\endln
\lnie
here for exblk or seblk with expr value or trapped value\endln
\lnie
\endln
\inst{evlp1}{chk}{}{check for stack space}
\inst{}{mov}{xr,-(xs)}{stack node pointer}
\inst{}{mov}{wb,-(xs)}{stack cursor}
\inst{}{mov}{r$pms,-(xs)}{stack subject string pointer}
\inst{}{mov}{pmssl,-(xs)}{stack subject string length}
\inst{}{mov}{pmdfl,-(xs)}{stack dot flag}
\inst{}{mov}{pmhbs,-(xs)}{stack history stack base pointer}
\inst{}{mov}{parm1(xr),xr}{load expression pointer}
\vfill\break

\lnie
\endln
\lnie
evalp (continued)\endln
\lnie
\endln
\lnie
loop back here to reevaluate expression result\endln
\lnie
\endln
\inst{evlp2}{zer}{wb}{set flag for by value}
\inst{}{jsr}{evalx}{evaluate expression}
\inst{}{ppm}{evlp4}{jump on failure}
\inst{}{mov}{(xr),wa}{else load first word of value}
\inst{}{blo}{wa,=b$e$$,evlp2}{loop back to reevaluate expression}
\lnie
\endln
\lnie
here to restore pattern values after successful eval\endln
\lnie
\endln
\inst{}{mov}{xr,xl}{copy result pointer}
\inst{}{mov}{(xs)+,pmhbs}{restore history stack base pointer}
\inst{}{mov}{(xs)+,pmdfl}{restore dot flag}
\inst{}{mov}{(xs)+,pmssl}{restore subject string length}
\inst{}{mov}{(xs)+,r$pms}{restore subject string pointer}
\inst{}{mov}{(xs)+,wb}{restore cursor}
\inst{}{mov}{(xs)+,xr}{restore node pointer}
\inst{}{mov}{xr,wc}{non-zero for simple vrblk}
\inst{}{exi}{}{return to evalp caller}
\lnie
\endln
\lnie
here to return after simple vrblk case\endln
\lnie
\endln
\inst{evlp3}{zer}{wc}{simple vrblk, no side effects}
\inst{}{exi}{}{return to evalp caller}
\lnie
\endln
\lnie
here for failure during evaluation\endln
\lnie
\endln
\inst{evlp4}{mov}{(xs)+,pmhbs}{restore history stack base pointer}
\inst{}{mov}{(xs)+,pmdfl}{restore dot flag}
\inst{}{mov}{(xs)+,pmssl}{restore subject string length}
\inst{}{mov}{(xs)+,r$pms}{restore subject string pointer}
\inst{}{add}{*num02,xs}{remove node ptr, cursor}
\inst{}{exi}{1}{take failure exit}
\inst{}{enp}{}{end procedure evalp}
\vfill\break

\lnie
\endln
\lnie
evals -- evaluate string argument\endln
\lnie
\endln
\lnie
evals is used by span, any, notany, break, breakx when\endln
\lnie
they are passed an expression argument.\endln
\lnie
\endln
\lnie
(xr)                  node pointer\endln
\lnie
(wb)                  cursor\endln
\lnie
jsr  evals            call to evaluate string\endln
\lnie
ppm  loc              transfer loc for non-string arg\endln
\lnie
ppm  loc              transfer loc for evaluation failure\endln
\lnie
ppm  loc              transfer loc for successful eval\endln
\lnie
(the normal return is never taken)\endln
\lnie
(xr)                  ptr to node with parms set\endln
\lnie
(xl,wc,ra)            destroyed\endln
\lnie
\endln
\lnie
on return, the node pointed to has a character table\endln
\lnie
pointer in parm1 and a bit mask in parm2. the proper\endln
\lnie
successor is stored in pthen of this node. thus it is\endln
\lnie
ok for merging with the normal (multi-char string) case.\endln
\lnie
\endln
\inst{evals}{prc}{r,3}{entry point (recursive)}
\inst{}{jsr}{evalp}{evaluate expression}
\inst{}{ppm}{evls1}{jump if evaluation fails}
\inst{}{mov}{pthen(xr),-(xs)}{save successor pointer}
\inst{}{mov}{wb,-(xs)}{save cursor}
\inst{}{mov}{xl,-(xs)}{stack result ptr for patst}
\inst{}{zer}{wb}{dummy pcode for one char string}
\inst{}{zer}{wc}{dummy pcode for expression arg}
\inst{}{mov}{=p$brk,xl}{appropriate pcode for our use}
\inst{}{jsr}{patst}{call routine to build node}
\inst{}{ppm}{evls2}{jump if not string}
\inst{}{mov}{(xs)+,wb}{restore cursor}
\inst{}{mov}{(xs)+,pthen(xr)}{store successor pointer}
\inst{}{exi}{3}{take success return}
\lnie
\endln
\lnie
here if evaluation fails\endln
\lnie
\endln
\inst{evls1}{exi}{2}{take failure return}
\lnie
\endln
\lnie
here if argument is not string\endln
\lnie
\endln
\inst{evls2}{add}{*num02,xs}{pop successor and cursor}
\inst{}{exi}{1}{take non-string error exit}
\inst{}{enp}{}{end procedure evals}
\vfill\break

\lnie
\endln
\lnie
evalx -- evaluate expression\endln
\lnie
\endln
\lnie
evalx is called to evaluate an expression\endln
\lnie
\endln
\lnie
(xr)                  pointer to exblk or seblk\endln
\lnie
(wb)                  0 if by value, 1 if by name\endln
\lnie
jsr  evalx            call to evaluate expression\endln
\lnie
ppm  loc              transfer loc if evaluation fails\endln
\lnie
(xr)                  result if called by value\endln
\lnie
(xl,wa)               result name base,offset if by name\endln
\lnie
(xr)                  destroyed (name case only)\endln
\lnie
(xl,wa)               destroyed (value case only)\endln
\lnie
(wb,wc,ra)            destroyed\endln
\lnie
\endln
\inst{evalx}{prc}{r,1}{entry point, recursive}
\inst{}{beq}{(xr),=b$exl,evlx2}{jump if exblk case}
\lnie
\endln
\lnie
here for seblk\endln
\lnie
\endln
\inst{}{mov}{sevar(xr),xl}{load vrblk pointer (name base)}
\inst{}{mov}{*vrval,wa}{set name offset}
\inst{}{bnz}{wb,evlx1}{jump if called by name}
\inst{}{jsr}{acess}{call routine to access value}
\inst{}{ppm}{evlx9}{jump if failure on access}
\lnie
\endln
\lnie
merge here to exit for seblk case\endln
\lnie
\endln
\inst{evlx1}{exi}{}{return to evalx caller}
\vfill\break

\lnie
\endln
\lnie
evalx (continued)\endln
\lnie
\endln
\lnie
here for full expression (exblk) case\endln
\lnie
\endln
\lnie
if an error occurs in the expression code at execution\endln
\lnie
time, control is passed via error section to exfal\endln
\lnie
without returning to this routine.\endln
\lnie
the following entries are made on the stack before\endln
\lnie
giving control to the expression code\endln
\lnie
\endln
\lnie
                      evalx return point\endln
\lnie
                      saved value of r$cod\endln
\lnie
                      code pointer (-r$cod)\endln
\lnie
                      saved value of flptr\endln
\lnie
                      0 if by value, 1 if by name\endln
\lnie
flptr --------------- *exflc, fail offset in exblk\endln
\lnie
\endln
\inst{evlx2}{scp}{wc}{get code pointer}
\inst{}{mov}{r$cod,wa}{load code block pointer}
\inst{}{sub}{wa,wc}{get code pointer as offset}
\inst{}{mov}{wa,-(xs)}{stack old code block pointer}
\inst{}{mov}{wc,-(xs)}{stack relative code offset}
\inst{}{mov}{flptr,-(xs)}{stack old failure pointer}
\inst{}{mov}{wb,-(xs)}{stack name/value indicator}
\inst{}{mov}{*exflc,-(xs)}{stack new fail offset}
\inst{}{mov}{flptr,gtcef}{keep in case of error}
\inst{}{mov}{r$cod,r$gtc}{keep code block pointer similarly}
\inst{}{mov}{xs,flptr}{set new failure pointer}
\inst{}{mov}{xr,r$cod}{set new code block pointer}
\inst{}{mov}{kvstn,exstm(xr)}{remember stmnt number}
\inst{}{add}{*excod,xr}{point to first code word}
\inst{}{lcp}{xr}{set code pointer}
\inst{}{bne}{stage,=stgxt,evlx0}{jump if not execution time}
\inst{}{mov}{=stgee,stage}{evaluating expression}
\lnie
\endln
\lnie
here to execute first code word of expression\endln
\lnie
\endln
\inst{evlx0}{zer}{xl}{clear garbage xl}
\inst{}{lcw}{xr}{load first code word}
\inst{}{bri}{(xr)}{execute it}
\vfill\break

\lnie
\endln
\lnie
evalx (continued)\endln
\lnie
\endln
\lnie
come here if successful return by value (see o$rvl)\endln
\lnie
\endln
\inst{evlx3}{mov}{(xs)+,xr}{load value}
\inst{}{bze}{num01(xs),evlx5}{jump if called by value}
\inst{}{erb}{249,expression evaluated}{by name returned value}
\lnie
\endln
\lnie
here for expression returning by name (see o$rnm)\endln
\lnie
\endln
\inst{evlx4}{mov}{(xs)+,wa}{load name offset}
\inst{}{mov}{(xs)+,xl}{load name base}
\inst{}{bnz}{num01(xs),evlx5}{jump if called by name}
\inst{}{jsr}{acess}{else access value first}
\inst{}{ppm}{evlx6}{jump if failure during access}
\lnie
\endln
\lnie
here after loading correct result into xr or xl,wa\endln
\lnie
\endln
\inst{evlx5}{zer}{wb}{note successful}
\inst{}{brn}{evlx7}{merge}
\lnie
\endln
\lnie
here for failure in expression evaluation (see o$fex)\endln
\lnie
\endln
\inst{evlx6}{mnz}{wb}{note unsuccessful}
\lnie
\endln
\lnie
restore environment\endln
\lnie
\endln
\inst{evlx7}{bne}{stage,=stgee,evlx8}{skip if was not previously xt}
\inst{}{mov}{=stgxt,stage}{execute time}
\lnie
\endln
\lnie
merge with stage set up\endln
\lnie
\endln
\inst{evlx8}{add}{*num02,xs}{pop name/value indicator, *exfal}
\inst{}{mov}{(xs)+,flptr}{restore old failure pointer}
\inst{}{mov}{(xs)+,wc}{load code offset}
\inst{}{add}{(xs),wc}{make code pointer absolute}
\inst{}{mov}{(xs)+,r$cod}{restore old code block pointer}
\inst{}{lcp}{wc}{restore old code pointer}
\inst{}{bze}{wb,evlx1}{jump for successful return}
\lnie
\endln
\lnie
merge here for failure in seblk case\endln
\lnie
\endln
\inst{evlx9}{exi}{1}{take failure exit}
\inst{}{enp}{}{end of procedure evalx}
\vfill\break

\lnie
\endln
\lnie
exbld -- build exblk\endln
\lnie
\endln
\lnie
exbld is used to build an expression block from the\endln
\lnie
code compiled most recently in the current ccblk.\endln
\lnie
\endln
\lnie
(xl)                  offset in ccblk to start of code\endln
\lnie
(wb)                  integer in range 0 le n le mxlen\endln
\lnie
jsr  exbld            call to build exblk\endln
\lnie
(xr)                  ptr to constructed exblk\endln
\lnie
(wa,wb,xl)            destroyed\endln
\lnie
\endln
\inst{exbld}{prc}{e,0}{entry point}
\inst{}{mov}{xl,wa}{copy offset to start of code}
\inst{}{sub}{*excod,wa}{calc reduction in offset in exblk}
\inst{}{mov}{wa,-(xs)}{stack for later}
\inst{}{mov}{cwcof,wa}{load final offset}
\inst{}{sub}{xl,wa}{compute length of code}
\inst{}{add}{*exsi$,wa}{add space for standard fields}
\inst{}{jsr}{alloc}{allocate space for exblk}
\inst{}{mov}{xr,-(xs)}{save pointer to exblk}
\inst{}{mov}{=b$exl,extyp(xr)}{store type word}
\inst{}{zer}{exstm(xr)}{zeroise stmnt number field}
\ifmac{.csln}
\inst{}{mov}{cmpln,exsln(xr)}{set line number field}
\asmac{fi}
\inst{}{mov}{wa,exlen(xr)}{store length}
\inst{}{mov}{=ofex$,exflc(xr)}{store failure word}
\inst{}{add}{*exsi$,xr}{set xr for mvw}
\inst{}{mov}{xl,cwcof}{reset offset to start of code}
\inst{}{add}{r$ccb,xl}{point to start of code}
\inst{}{sub}{*exsi$,wa}{length of code to move}
\inst{}{mov}{wa,-(xs)}{stack length of code}
\inst{}{mvw}{}{move code to exblk}
\inst{}{mov}{(xs)+,wa}{get length of code}
\inst{}{btw}{wa}{convert byte count to word count}
\inst{}{lct}{wa,wa}{prepare counter for loop}
\inst{}{mov}{(xs),xl}{copy exblk ptr, dont unstack}
\inst{}{add}{*excod,xl}{point to code itself}
\inst{}{mov}{num01(xs),wb}{get reduction in offset}
\lnie
\endln
\lnie
this loop searches for negation and selection code so\endln
\lnie
that the offsets computed whilst code was in code block\endln
\lnie
can be transformed to reduced values applicable in an\endln
\lnie
exblk.\endln
\lnie
\endln
\inst{exbl1}{mov}{(xl)+,xr}{get next code word}
\inst{}{beq}{xr,=osla$,exbl3}{jump if selection found}
\inst{}{beq}{xr,=onta$,exbl3}{jump if negation found}
\inst{}{bct}{wa,exbl1}{loop to end of code}
\lnie
\endln
\lnie
no selection found or merge to exit on termination\endln
\lnie
\endln
\inst{exbl2}{mov}{(xs)+,xr}{pop exblk ptr into xr}
\inst{}{mov}{(xs)+,xl}{pop reduction constant}
\inst{}{exi}{}{return to caller}
\vfill\break

\lnie
\endln
\lnie
exbld (continued)\endln
\lnie
\endln
\lnie
selection or negation found\endln
\lnie
reduce the offsets as needed. offsets occur in words\endln
\lnie
following code words -\endln
\lnie
     =onta$, =osla$, =oslb$, =oslc$\endln
\lnie
\endln
\inst{exbl3}{sub}{wb,(xl)+}{adjust offset}
\inst{}{bct}{wa,exbl4}{decrement count}
\lnie
\endln
\inst{exbl4}{bct}{wa,exbl5}{decrement count}
\lnie
\endln
\lnie
continue search for more offsets\endln
\lnie
\endln
\inst{exbl5}{mov}{(xl)+,xr}{get next code word}
\inst{}{beq}{xr,=osla$,exbl3}{jump if offset found}
\inst{}{beq}{xr,=oslb$,exbl3}{jump if offset found}
\inst{}{beq}{xr,=oslc$,exbl3}{jump if offset found}
\inst{}{beq}{xr,=onta$,exbl3}{jump if offset found}
\inst{}{bct}{wa,exbl5}{loop}
\inst{}{brn}{exbl2}{merge to return}
\inst{}{enp}{}{end procedure exbld}
\vfill\break

\lnie
\endln
\lnie
expan -- analyze expression\endln
\lnie
\endln
\lnie
the expression analyzer (expan) procedure is used to scan\endln
\lnie
an expression and convert it into a tree representation.\endln
\lnie
see the description of cmblk in the structures section\endln
\lnie
for detailed format of tree blocks.\endln
\lnie
\endln
\lnie
the analyzer uses a simple precedence scheme in which\endln
\lnie
operands and operators are placed on a single stack\endln
\lnie
and condensations are made when low precedence operators\endln
\lnie
are stacked after a higher precedence operator. a global\endln
\lnie
variable (in wb) keeps track of the level as follows.\endln
\lnie
\endln
\lnie
0    scanning outer level of statement or expression\endln
\lnie
1    scanning outer level of normal goto\endln
\lnie
2    scanning outer level of direct goto\endln
\lnie
3    scanning inside array brackets\endln
\lnie
4    scanning inside grouping parentheses\endln
\lnie
5    scanning inside function parentheses\endln
\lnie
\endln
\lnie
this variable is saved on the stack on encountering a\endln
\lnie
grouping and restored at the end of the grouping.\endln
\lnie
\endln
\lnie
another global variable (in wc) counts the number of\endln
\lnie
items at one grouping level and is incremented for each\endln
\lnie
comma encountered. it is stacked with the level indicator\endln
\lnie
\endln
\lnie
the scan is controlled by a three state finite machine.\endln
\lnie
a global variable stored in wa is the current state.\endln
\lnie
\endln
\lnie
wa=0                  nothing scanned at this level\endln
\lnie
wa=1                  operand expected\endln
\lnie
wa=2                  operator expected\endln
\lnie
\endln
\lnie
(wb)                  call type (see below)\endln
\lnie
jsr  expan            call to analyze expression\endln
\lnie
(xr)                  pointer to resulting tree\endln
\lnie
(xl,wa,wb,wc,ra)      destroyed\endln
\lnie
\endln
\lnie
the entry value of wb indicates the call type as follows.\endln
\lnie
\endln
\lnie
0    scanning either the main body of a statement or the\endln
\lnie
     text of an expression (from eval call). valid\endln
\lnie
     terminators are colon, semicolon. the rescan flag is\endln
\lnie
     set to return the terminator on the next scane call.\endln
\lnie
\endln
\lnie
1    scanning a normal goto. the only valid\endln
\lnie
     terminator is a right paren.\endln
\lnie
\endln
\lnie
2    scanning a direct goto. the only valid\endln
\lnie
     terminator is a right bracket.\endln
\vfill\break

\lnie
\endln
\lnie
expan (continued)\endln
\lnie
\endln
\lnie
entry point\endln
\lnie
\endln
\inst{expan}{prc}{e,0}{entry point}
\inst{}{zer}{-(xs)}{set top of stack indicator}
\inst{}{zer}{wa}{set initial state to zero}
\inst{}{zer}{wc}{zero counter value}
\lnie
\endln
\lnie
loop here for successive entries\endln
\lnie
\endln
\inst{exp01}{jsr}{scane}{scan next element}
\inst{}{add}{wa,xl}{add state to syntax code}
\inst{}{bsw}{xl,t$nes}{switch on element type/state}
\inst{}{iff}{t$va0,exp03}{variable, s=0}
\inst{}{iff}{t$va1,exp03}{variable, state one}
\inst{}{iff}{t$va2,exp04}{variable, s=2}
\inst{}{iff}{t$co0,exp03}{constant, s=0}
\inst{}{iff}{t$co1,exp03}{constant, s=1}
\inst{}{iff}{t$co2,exp04}{constant, s=2}
\inst{}{iff}{t$lp0,exp06}{left paren, s=0}
\inst{}{iff}{t$lp1,exp06}{left paren, s=1}
\inst{}{iff}{t$lp2,exp04}{left paren, s=2}
\inst{}{iff}{t$fn0,exp10}{function, s=0}
\inst{}{iff}{t$fn1,exp10}{function, s=1}
\inst{}{iff}{t$fn2,exp04}{function, s=2}
\inst{}{iff}{t$rp0,exp02}{right paren, s=0}
\inst{}{iff}{t$rp1,exp05}{right paren, s=1}
\inst{}{iff}{t$rp2,exp12}{right paren, s=2}
\inst{}{iff}{t$lb0,exp08}{left brkt, s=0}
\inst{}{iff}{t$lb1,exp08}{left brkt, s=1}
\inst{}{iff}{t$lb2,exp09}{left brkt, s=2}
\inst{}{iff}{t$rb0,exp02}{right brkt, s=0}
\inst{}{iff}{t$rb1,exp05}{right brkt, s=1}
\inst{}{iff}{t$rb2,exp18}{right brkt, s=2}
\inst{}{iff}{t$uo0,exp27}{unop, s=0}
\inst{}{iff}{t$uo1,exp27}{unop, s=1}
\inst{}{iff}{t$uo2,exp04}{unop, s=2}
\inst{}{iff}{t$bo0,exp05}{binop, s=0}
\inst{}{iff}{t$bo1,exp05}{binop, s=1}
\inst{}{iff}{t$bo2,exp26}{binop, s=2}
\inst{}{iff}{t$cm0,exp02}{comma, s=0}
\inst{}{iff}{t$cm1,exp05}{comma, s=1}
\inst{}{iff}{t$cm2,exp11}{comma, s=2}
\inst{}{iff}{t$cl0,exp02}{colon, s=0}
\inst{}{iff}{t$cl1,exp05}{colon, s=1}
\inst{}{iff}{t$cl2,exp19}{colon, s=2}
\inst{}{iff}{t$sm0,exp02}{semicolon, s=0}
\inst{}{iff}{t$sm1,exp05}{semicolon, s=1}
\inst{}{iff}{t$sm2,exp19}{semicolon, s=2}
\inst{}{esw}{}{end switch on element type/state}
\vfill\break

\lnie
\endln
\lnie
expan (continued)\endln
\lnie
\endln
\lnie
here for rbr,rpr,col,smc,cma in state 0\endln
\lnie
\endln
\lnie
set to rescan the terminator encountered and create\endln
\lnie
a null constant (case of omitted null)\endln
\lnie
\endln
\inst{exp02}{mnz}{scnrs}{set to rescan element}
\inst{}{mov}{=nulls,xr}{point to null, merge}
\lnie
\endln
\lnie
here for var or con in states 0,1\endln
\lnie
\endln
\lnie
stack the variable/constant and set state=2\endln
\lnie
\endln
\inst{exp03}{mov}{xr,-(xs)}{stack pointer to operand}
\inst{}{mov}{=num02,wa}{set state 2}
\inst{}{brn}{exp01}{jump for next element}
\lnie
\endln
\lnie
here for var,con,lpr,fnc,uop in state 2\endln
\lnie
\endln
\lnie
we rescan the element and create a concatenation operator\endln
\lnie
this is the case of the blank concatenation operator.\endln
\lnie
\endln
\inst{exp04}{mnz}{scnrs}{set to rescan element}
\inst{}{mov}{=opdvc,xr}{point to concat operator dv}
\inst{}{bze}{wb,exp4a}{ok if at top level}
\inst{}{mov}{=opdvp,xr}{else point to unmistakable concat.}
\lnie
\endln
\lnie
merge here when xr set up with proper concatenation dvblk\endln
\lnie
\endln
\inst{exp4a}{bnz}{scnbl,exp26}{merge bop if blanks, else error}
\lnie
dcv  scnse            adjust start of element location\endln
\inst{}{erb}{220,syntax error:}{missing operator}
\lnie
\endln
\lnie
here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)\endln
\lnie
\endln
\lnie
this is an erronous contruction\endln
\lnie
\endln
\lnie
dcv  scnse            adjust start of element location\endln
\inst{exp05}{erb}{221,syntax error:}{missing operand}
\lnie
\endln
\lnie
here for lpr (s=0,1)\endln
\lnie
\endln
\inst{exp06}{mov}{=num04,xl}{set new level indicator}
\inst{}{zer}{xr}{set zero value for cmopn}
\vfill\break

\lnie
\endln
\lnie
expan (continued)\endln
\lnie
\endln
\lnie
merge here to store old level on stack and start new one\endln
\lnie
\endln
\inst{exp07}{mov}{xr,-(xs)}{stack cmopn value}
\inst{}{mov}{wc,-(xs)}{stack old counter}
\inst{}{mov}{wb,-(xs)}{stack old level indicator}
\inst{}{chk}{}{check for stack overflow}
\inst{}{zer}{wa}{set new state to zero}
\inst{}{mov}{xl,wb}{set new level indicator}
\inst{}{mov}{=num01,wc}{initialize new counter}
\inst{}{brn}{exp01}{jump to scan next element}
\lnie
\endln
\lnie
here for lbr (s=0,1)\endln
\lnie
\endln
\lnie
this is an illegal use of left bracket\endln
\lnie
\endln
\inst{exp08}{erb}{222,syntax error:}{invalid use of left bracket}
\lnie
\endln
\lnie
here for lbr (s=2)\endln
\lnie
\endln
\lnie
set new level and start to scan subscripts\endln
\lnie
\endln
\inst{exp09}{mov}{(xs)+,xr}{load array ptr for cmopn}
\inst{}{mov}{=num03,xl}{set new level indicator}
\inst{}{brn}{exp07}{jump to stack old and start new}
\lnie
\endln
\lnie
here for fnc (s=0,1)\endln
\lnie
\endln
\lnie
stack old level and start to scan arguments\endln
\lnie
\endln
\inst{exp10}{mov}{=num05,xl}{set new lev indic (xr=vrblk=cmopn)}
\inst{}{brn}{exp07}{jump to stack old and start new}
\lnie
\endln
\lnie
here for cma (s=2)\endln
\lnie
\endln
\lnie
increment argument count and continue\endln
\lnie
\endln
\inst{exp11}{icv}{wc}{increment counter}
\inst{}{jsr}{expdm}{dump operators at this level}
\inst{}{zer}{-(xs)}{set new level for parameter}
\inst{}{zer}{wa}{set new state}
\inst{}{bgt}{wb,=num02,exp01}{loop back unless outer level}
\inst{}{erb}{223,syntax error:}{invalid use of comma}
\vfill\break

\lnie
\endln
\lnie
expan (continued)\endln
\lnie
\endln
\lnie
here for rpr (s=2)\endln
\lnie
\endln
\lnie
at outer level in a normal goto this is a terminator\endln
\lnie
otherwise it must terminate a function or grouping\endln
\lnie
\endln
\inst{exp12}{beq}{wb,=num01,exp20}{end of normal goto}
\inst{}{beq}{wb,=num05,exp13}{end of function arguments}
\inst{}{beq}{wb,=num04,exp14}{end of grouping / selection}
\inst{}{erb}{224,syntax error:}{unbalanced right parenthesis}
\lnie
\endln
\lnie
here at end of function arguments\endln
\lnie
\endln
\inst{exp13}{mov}{=c$fnc,xl}{set cmtyp value for function}
\inst{}{brn}{exp15}{jump to build cmblk}
\lnie
\endln
\lnie
here for end of grouping\endln
\lnie
\endln
\inst{exp14}{beq}{wc,=num01,exp17}{jump if end of grouping}
\inst{}{mov}{=c$sel,xl}{else set cmtyp for selection}
\lnie
\endln
\lnie
merge here to build cmblk for level just scanned and\endln
\lnie
to pop up to the previous scan level before continuing.\endln
\lnie
\endln
\inst{exp15}{jsr}{expdm}{dump operators at this level}
\inst{}{mov}{wc,wa}{copy count}
\inst{}{add}{=cmvls,wa}{add for standard fields at start}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{jsr}{alloc}{allocate space for cmblk}
\inst{}{mov}{=b$cmt,(xr)}{store type code for cmblk}
\inst{}{mov}{xl,cmtyp(xr)}{store cmblk node type indicator}
\inst{}{mov}{wa,cmlen(xr)}{store length}
\inst{}{add}{wa,xr}{point past end of block}
\inst{}{lct}{wc,wc}{set loop counter}
\lnie
\endln
\lnie
loop to move remaining words to cmblk\endln
\lnie
\endln
\inst{exp16}{mov}{(xs)+,-(xr)}{move one operand ptr from stack}
\inst{}{mov}{(xs)+,wb}{pop to old level indicator}
\inst{}{bct}{wc,exp16}{loop till all moved}
\vfill\break

\lnie
\endln
\lnie
expan (continued)\endln
\lnie
\endln
\lnie
complete cmblk and stack pointer to it on stack\endln
\lnie
\endln
\inst{}{sub}{*cmvls,xr}{point back to start of block}
\inst{}{mov}{(xs)+,wc}{restore old counter}
\inst{}{mov}{(xs),cmopn(xr)}{store operand ptr in cmblk}
\inst{}{mov}{xr,(xs)}{stack cmblk pointer}
\inst{}{mov}{=num02,wa}{set new state}
\inst{}{brn}{exp01}{back for next element}
\lnie
\endln
\lnie
here at end of a parenthesized expression\endln
\lnie
\endln
\inst{exp17}{jsr}{expdm}{dump operators at this level}
\inst{}{mov}{(xs)+,xr}{restore xr}
\inst{}{mov}{(xs)+,wb}{restore outer level}
\inst{}{mov}{(xs)+,wc}{restore outer count}
\inst{}{mov}{xr,(xs)}{store opnd over unused cmopn val}
\inst{}{mov}{=num02,wa}{set new state}
\inst{}{brn}{exp01}{back for next ele8ent}
\lnie
\endln
\lnie
here for rbr (s=2)\endln
\lnie
\endln
\lnie
at outer level in a direct goto, this is a terminator.\endln
\lnie
otherwise it must terminate a subscript list.\endln
\lnie
\endln
\inst{exp18}{mov}{=c$arr,xl}{set cmtyp for array reference}
\inst{}{beq}{wb,=num03,exp15}{jump to build cmblk if end arrayref}
\inst{}{beq}{wb,=num02,exp20}{jump if end of direct goto}
\inst{}{erb}{225,syntax error:}{unbalanced right bracket}
\vfill\break

\lnie
\endln
\lnie
expan (continued)\endln
\lnie
\endln
\lnie
here for col,smc (s=2)\endln
\lnie
\endln
\lnie
error unless terminating statement body at outer level\endln
\lnie
\endln
\inst{exp19}{mnz}{scnrs}{rescan terminator}
\inst{}{mov}{wb,xl}{copy level indicator}
\inst{}{bsw}{xl,6}{switch on level indicator}
\inst{}{iff}{0,exp20}{normal outer level}
\inst{}{iff}{1,exp22}{fail if normal goto}
\inst{}{iff}{2,exp23}{fail if direct goto}
\inst{}{iff}{3,exp24}{fail array brackets}
\inst{}{iff}{4,exp21}{fail if in grouping}
\inst{}{iff}{5,exp21}{fail function args}
\inst{}{esw}{}{end switch on level}
\lnie
\endln
\lnie
here at normal end of expression\endln
\lnie
\endln
\inst{exp20}{jsr}{expdm}{dump remaining operators}
\inst{}{mov}{(xs)+,xr}{load tree pointer}
\inst{}{ica}{xs}{pop off bottom of stack marker}
\inst{}{exi}{}{return to expan caller}
\lnie
\endln
\lnie
missing right paren\endln
\lnie
\endln
\inst{exp21}{erb}{226,syntax error:}{missing right paren}
\lnie
\endln
\lnie
missing right paren in goto field\endln
\lnie
\endln
\inst{exp22}{erb}{227,syntax error:}{right paren missing from goto}
\lnie
\endln
\lnie
missing bracket in goto\endln
\lnie
\endln
\inst{exp23}{erb}{228,syntax error:}{right bracket missing from goto}
\lnie
\endln
\lnie
missing array bracket\endln
\lnie
\endln
\inst{exp24}{erb}{229,syntax error:}{missing right array bracket}
\vfill\break

\lnie
\endln
\lnie
expan (continued)\endln
\lnie
\endln
\lnie
loop here when an operator causes an operator dump\endln
\lnie
\endln
\inst{exp25}{mov}{229,syntax error::}{}
\inst{}{jsr}{expop}{pop one operator}
\inst{}{mov}{expsv,xr}{restore op dv pointer and merge}
\lnie
\endln
\lnie
here for bop (s=2)\endln
\lnie
\endln
\lnie
remove operators (condense) from stack until no more\endln
\lnie
left at this level or top one has lower precedence.\endln
\lnie
loop here till this condition is met.\endln
\lnie
\endln
\inst{exp26}{mov}{num01(xs),xl}{load operator dvptr from stack}
\inst{}{ble}{xl,=num05,exp27}{jump if bottom of stack level}
\inst{}{blt}{dvrpr(xr),dvlpr(xl),exp25}{else pop if new prec is lo}
\lnie
\endln
\lnie
here for uop (s=0,1)\endln
\lnie
\endln
\lnie
binary operator merges after precedence check\endln
\lnie
\endln
\lnie
the operator dv is stored on the stack and the scan\endln
\lnie
continues after setting the scan state to one.\endln
\lnie
\endln
\inst{exp27}{mov}{xr,-(xs)}{stack operator dvptr on stack}
\inst{}{chk}{}{check for stack overflow}
\inst{}{mov}{=num01,wa}{set new state}
\inst{}{bne}{xr,=opdvs,exp01}{back for next element unless =}
\lnie
\endln
\lnie
here for special case of binary =. the syntax allows a\endln
\lnie
null right argument for this operator to be left\endln
\lnie
out. accordingly we reset to state zero to get proper\endln
\lnie
action on a terminator (supply a null constant).\endln
\lnie
\endln
\inst{}{zer}{wa}{set state zero}
\inst{}{brn}{exp01}{jump for next element}
\inst{}{enp}{}{end procedure expan}
\vfill\break

\lnie
\endln
\lnie
expap -- test for pattern match tree\endln
\lnie
\endln
\lnie
expap is passed an expression tree to determine if it\endln
\lnie
is a pattern match. the following are recogized as\endln
\lnie
matches in the context of this call.\endln
\lnie
\endln
\lnie
1)   an explicit use of binary question mark\endln
\lnie
2)   a concatenation\endln
\lnie
3)   an alternation whose left operand is a concatenation\endln
\lnie
\endln
\lnie
(xr)                  ptr to expan tree\endln
\lnie
jsr  expap            call to test for pattern match\endln
\lnie
ppm  loc              transfer loc if not a pattern match\endln
\lnie
(wa)                  destroyed\endln
\lnie
(xr)                  unchanged (if not match)\endln
\lnie
(xr)                  ptr to binary operator blk if match\endln
\lnie
\endln
\inst{expap}{prc}{e,1}{entry point}
\inst{}{mov}{xl,-(xs)}{save xl}
\inst{}{bne}{(xr),=b$cmt,expp2}{no match if not complex}
\inst{}{mov}{cmtyp(xr),wa}{else load type code}
\inst{}{beq}{wa,=c$cnc,expp1}{concatenation is a match}
\inst{}{beq}{wa,=c$pmt,expp1}{binary question mark is a match}
\inst{}{bne}{wa,=c$alt,expp2}{else not match unless alternation}
\lnie
\endln
\lnie
here for alternation. change (a b) / c to a qm (b / c)\endln
\lnie
\endln
\inst{}{mov}{cmlop(xr),xl}{load left operand pointer}
\inst{}{bne}{(xl),=b$cmt,expp2}{not match if left opnd not complex}
\inst{}{bne}{cmtyp(xl),=c$cnc,expp2}{not match if left op not conc}
\inst{}{mov}{cmrop(xl),cmlop(xr)}{xr points to (b / c)}
\inst{}{mov}{xr,cmrop(xl)}{set xl opnds to a, (b / c)}
\inst{}{mov}{xl,xr}{point to this altered node}
\lnie
\endln
\lnie
exit here for pattern match\endln
\lnie
\endln
\inst{expp1}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{exi}{}{give pattern match return}
\lnie
\endln
\lnie
exit here if not pattern match\endln
\lnie
\endln
\inst{expp2}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{exi}{1}{give non-match return}
\inst{}{enp}{}{end procedure expap}
\vfill\break

\lnie
\endln
\lnie
expdm -- dump operators at current level (for expan)\endln
\lnie
\endln
\lnie
expdm uses expop to condense all operators at this syntax\endln
\lnie
level. the stack bottom is recognized from the level\endln
\lnie
value which is saved on the top of the stack.\endln
\lnie
\endln
\lnie
jsr  expdm            call to dump operators\endln
\lnie
(xs)                  popped as required\endln
\lnie
(xr,wa)               destroyed\endln
\lnie
\endln
\inst{expdm}{prc}{n,0}{entry point}
\inst{}{mov}{xl,r$exs}{save xl value}
\lnie
\endln
\lnie
loop to dump operators\endln
\lnie
\endln
\inst{exdm1}{ble}{num01(xs),=num05,exdm2}{jump if stack bottom (saved level}
\inst{}{jsr}{expop}{else pop one operator}
\inst{}{brn}{exdm1}{and loop back}
\lnie
\endln
\lnie
here after popping all operators\endln
\lnie
\endln
\inst{exdm2}{mov}{r$exs,xl}{restore xl}
\inst{}{zer}{r$exs}{release save location}
\inst{}{exi}{}{return to expdm caller}
\inst{}{enp}{}{end procedure expdm}
\vfill\break

\lnie
\endln
\lnie
expop-- pop operator (for expan)\endln
\lnie
\endln
\lnie
expop is used by the expan routine to condense one\endln
\lnie
operator from the top of the syntax stack. an appropriate\endln
\lnie
cmblk is built for the operator (unary or binary) and a\endln
\lnie
pointer to this cmblk is stacked.\endln
\lnie
\endln
\lnie
expop is also used by scngf (goto field scan) procedure\endln
\lnie
\endln
\lnie
jsr  expop            call to pop operator\endln
\lnie
(xs)                  popped appropriately\endln
\lnie
(xr,xl,wa)            destroyed\endln
\lnie
\endln
\inst{expop}{prc}{n,0}{entry point}
\inst{}{mov}{num01(xs),xr}{load operator dv pointer}
\inst{}{beq}{dvlpr(xr),=lluno,expo2}{jump if unary}
\lnie
\endln
\lnie
here for binary operator\endln
\lnie
\endln
\inst{}{mov}{*cmbs$,wa}{set size of binary operator cmblk}
\inst{}{jsr}{alloc}{allocate space for cmblk}
\inst{}{mov}{(xs)+,cmrop(xr)}{pop and store right operand ptr}
\inst{}{mov}{(xs)+,xl}{pop and load operator dv ptr}
\inst{}{mov}{(xs),cmlop(xr)}{store left operand pointer}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{expo1}{mov}{=b$cmt,(xr)}{store type code for cmblk}
\inst{}{mov}{dvtyp(xl),cmtyp(xr)}{store cmblk node type code}
\inst{}{mov}{xl,cmopn(xr)}{store dvptr (=ptr to dac o$xxx)}
\inst{}{mov}{wa,cmlen(xr)}{store cmblk length}
\inst{}{mov}{xr,(xs)}{store resulting node ptr on stack}
\inst{}{exi}{}{return to expop caller}
\lnie
\endln
\lnie
here for unary operator\endln
\lnie
\endln
\inst{expo2}{mov}{*cmus$,wa}{set size of unary operator cmblk}
\inst{}{jsr}{alloc}{allocate space for cmblk}
\inst{}{mov}{(xs)+,cmrop(xr)}{pop and store operand pointer}
\inst{}{mov}{(xs),xl}{load operator dv pointer}
\inst{}{brn}{expo1}{merge back to exit}
\inst{}{enp}{}{end procedure expop}
\vfill\break

\ifmac{.csfn}
\lnie
\endln
\lnie
filnm -- obtain file name from statement number\endln
\lnie
\endln
\lnie
filnm takes a statement number and examines the file name\endln
\lnie
table pointed to by r$sfn to find the name of the file\endln
\lnie
containing the given statement.  table entries are\endln
\lnie
arranged in order of ascending statement number (there\endln
\lnie
is only one hash bucket in this table).  elements are\endln
\lnie
added to the table each time there is a change in\endln
\lnie
file name, recording the then current statement number.\endln
\lnie
\endln
\lnie
to find the file name, the linked list of teblks is\endln
\lnie
scanned for an element containing a subscript (statement\endln
\lnie
number) greater than the argument statement number, or\endln
\lnie
the end of chain.  when this condition is met, the\endln
\lnie
previous teblk contains the desired file name as its\endln
\lnie
value entry.\endln
\lnie
\endln
\lnie
(wc)                  statement number\endln
\lnie
jsr  filnm            call to obtain file name\endln
\lnie
(xl)                  file name (scblk)\endln
\lnie
(ia)                  destroyed\endln
\lnie
\endln
\inst{filnm}{prc}{e,0}{entry point}
\inst{}{mov}{wb,-(xs)}{preserve wb}
\inst{}{bze}{wc,filn3}{return nulls if stno is zero}
\inst{}{mov}{r$sfn,xl}{file name table}
\inst{}{bze}{xl,filn3}{if no table}
\inst{}{mov}{tbbuk(xl),wb}{get bucket entry}
\inst{}{beq}{wb,r$sfn,filn3}{jump if no teblks on chain}
\inst{}{mov}{xr,-(xs)}{preserve xr}
\inst{}{mov}{wb,xr}{previous block pointer}
\inst{}{mov}{wc,-(xs)}{preserve stmt number}
\lnie
\endln
\lnie
loop through teblks on hash chain\endln
\lnie
\endln
\inst{filn1}{mov}{xr,xl}{next element to examine}
\inst{}{mov}{tesub(xl),xr}{load subscript value (an icblk)}
\inst{}{ldi}{icval(xr)}{load the statement number}
\inst{}{mfi}{wc}{convert to address constant}
\inst{}{blt}{(xs),wc,filn2}{compare arg with teblk stmt number}
\lnie
\endln
\lnie
here if desired stmt number is ge teblk stmt number\endln
\lnie
\endln
\inst{}{mov}{xl,wb}{save previous entry pointer}
\inst{}{mov}{tenxt(xl),xr}{point to next teblk on chain}
\inst{}{bne}{xr,r$sfn,filn1}{jump if there is one}
\lnie
\endln
\lnie
here if chain exhausted or desired block found.\endln
\lnie
\endln
\inst{filn2}{mov}{wb,xl}{previous teblk}
\inst{}{mov}{teval(xl),xl}{get ptr to file name scblk}
\inst{}{mov}{(xs)+,wc}{restore stmt number}
\inst{}{mov}{(xs)+,xr}{restore xr}
\inst{}{mov}{(xs)+,wb}{restore wb}
\inst{}{exi}{(xs)+,wb}{restore wb}
\lnie
\endln
\lnie
no table or no table entries\endln
\lnie
\endln
\inst{filn3}{mov}{(xs)+,wb}{restore wb}
\inst{}{mov}{=nulls,xl}{return null string}
\inst{}{exi}{=nulls,xl}{return null string}
\inst{}{enp}{=nulls,xl}{return null string}
\vfill\break

\asmac{fi}
\lnie
\endln
\ifmac{.culc}
\lnie
\endln
\lnie
flstg -- fold string to upper case\endln
\lnie
\endln
\lnie
flstg folds a character string containing lower case\endln
\lnie
characcters to one containing upper case characters.\endln
\lnie
folding is only done if &case (kvcas) is not zero.\endln
\lnie
\endln
\lnie
(xr)                  string argument\endln
\lnie
(wa)                  length of string\endln
\lnie
jsr  flstg            call to fold string\endln
\lnie
(xr)                  result string (possibly original)\endln
\lnie
(wc)                  destroyed\endln
\lnie
\endln
\inst{flstg}{prc}{e,0}{entry point}
\inst{}{bze}{kvcas,fst99}{skip if &case is 0}
\inst{}{mov}{xl,-(xs)}{save xl across call}
\inst{}{mov}{xr,-(xs)}{save original scblk ptr}
\inst{}{jsr}{alocs}{allocate new string block}
\inst{}{mov}{(xs),xl}{point to original scblk}
\inst{}{mov}{xr,-(xs)}{save pointer to new scblk}
\inst{}{plc}{xl}{point to original chars}
\inst{}{psc}{xr}{point to new chars}
\inst{}{zer}{-(xs)}{init did fold flag}
\inst{}{lct}{wc,wc}{load loop counter}
\inst{fst01}{lch}{wa,(xl)+}{load character}
\inst{}{blt}{wa,=ch$$a,fst02}{skip if less than lc a}
\inst{}{bgt}{wa,=ch$$$,fst02}{skip if greater than lc z}
\inst{}{flc}{wa}{fold character to upper case}
\inst{}{mnz}{(xs)}{set did fold character flag}
\inst{fst02}{sch}{wa,(xr)+}{store (possibly folded) character}
\inst{}{bct}{wc,fst01}{loop thru entire string}
\inst{}{csc}{xr}{complete store characters}
\inst{}{mov}{(xs)+,xr}{see if any change}
\inst{}{bnz}{xr,fst10}{skip if folding done (no change)}
\inst{}{mov}{(xs)+,dnamp}{do not need new scblk}
\inst{}{mov}{(xs)+,xr}{return original scblk}
\inst{}{brn}{fst20}{merge below}
\inst{fst10}{mov}{(xs)+,xr}{return new scblk}
\inst{}{ica}{xs}{throw away original scblk pointer}
\inst{fst20}{mov}{sclen(xr),wa}{reload string length}
\inst{}{mov}{(xs)+,xl}{restore xl}
\inst{fst99}{exi}{}{return}
\inst{}{enp}{}{return}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
gbcol -- perform garbage collection\endln
\lnie
\endln
\lnie
gbcol performs a garbage collection on the dynamic region\endln
\lnie
all blocks which are no longer in use are eliminated\endln
\lnie
by moving blocks which are in use down and resetting\endln
\lnie
dnamp, the pointer to the next available location.\endln
\lnie
\endln
\lnie
(wb)                  move offset (see below)\endln
\lnie
jsr  gbcol            call to collect garbage\endln
\ifmac{.csed}
\lnie
(xr)                  sediment size after collection\endln
\asmac{else}
\lnie
(xr)                  destroyed\endln
\asmac{fi}
\lnie
\endln
\lnie
the following conditions must be met at the time when\endln
\lnie
gbcol is called.\endln
\lnie
\endln
\lnie
1)   all pointers to blocks in the dynamic area must be\endln
\lnie
     accessible to the garbage collector. this means\endln
\lnie
     that they must occur in one of the following.\endln
\lnie
\endln
\lnie
     a)               main stack, with current top\endln
\lnie
                      element being indicated by xs\endln
\lnie
\endln
\lnie
     b)               in relocatable fields of vrblks.\endln
\lnie
\endln
\lnie
     c)               in register xl at the time of call\endln
\lnie
\endln
\lnie
     e)               in the special region of working\endln
\lnie
                      storage where names begin with r$.\endln
\lnie
\endln
\lnie
2)   all pointers must point to the start of blocks with\endln
\lnie
     the sole exception of the contents of the code\endln
\lnie
     pointer register which points into the r$cod block.\endln
\lnie
\endln
\lnie
3)   no location which appears to contain a pointer\endln
\lnie
     into the dynamic region may occur unless it is in\endln
\lnie
     fact a pointer to the start of the block. however\endln
\lnie
     pointers outside this area may occur and will\endln
\lnie
     not be changed by the garbage collector.\endln
\lnie
     it is especially important to make sure that xl\endln
\lnie
     does not contain a garbage value from some process\endln
\lnie
     carried out before the call to the collector.\endln
\lnie
\endln
\lnie
gbcol has the capability of moving the final compacted\endln
\lnie
result up in memory (with addresses adjusted accordingly)\endln
\lnie
this is used to add space to the static region. the\endln
\lnie
entry value of wb is the number of bytes to move up.\endln
\lnie
the caller must guarantee that there is enough room.\endln
\lnie
furthermore the value in wb if it is non-zero, must be at\endln
\lnie
least 256 so that the mwb instruction conditions are met.\endln
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\lnie
the algorithm, which is a modification of the lisp-2\endln
\lnie
garbage collector devised by r.dewar and k.belcher\endln
\lnie
takes three passes as follows.\endln
\lnie
\endln
\lnie
1)   all pointers in memory are scanned and blocks in use\endln
\lnie
     determined from this scan. note that this procedure\endln
\lnie
     is recursive and uses the main stack for linkage.\endln
\lnie
     the marking process is thus similar to that used in\endln
\lnie
     a standard lisp collector. however the method of\endln
\lnie
     actually marking the blocks is different.\endln
\lnie
\endln
\lnie
     the first field of a block normally contains a\endln
\lnie
     code entry point pointer. such an entry pointer\endln
\lnie
     can be distinguished from the address of any pointer\endln
\lnie
     to be processed by the collector. during garbage\endln
\lnie
     collection, this word is used to build a back chain\endln
\lnie
     of pointers through fields which point to the block.\endln
\lnie
     the end of the chain is marked by the occurence\endln
\lnie
     of the word which used to be in the first word of\endln
\lnie
     the block. this backchain serves both as a mark\endln
\lnie
     indicating that the block is in use and as a list of\endln
\lnie
     references for the relocation phase.\endln
\lnie
\endln
\lnie
2)   storage is scanned sequentially to discover which\endln
\lnie
     blocks are currently in use as indicated by the\endln
\lnie
     presence of a backchain. two pointers are maintained\endln
\lnie
     one scans through looking at each block. the other\endln
\lnie
     is incremented only for blocks found to be in use.\endln
\lnie
     in this way, the eventual location of each block can\endln
\lnie
     be determined without actually moving any blocks.\endln
\lnie
     as each block which is in use is processed, the back\endln
\lnie
     chain is used to reset all pointers which point to\endln
\lnie
     this block to contain its new address, i.e. the\endln
\lnie
     address it will occupy after the blocks are moved.\endln
\lnie
     the first word of the block, taken from the end of\endln
\lnie
     the chain is restored at this point.\endln
\lnie
\endln
\lnie
     during pass 2, the collector builds blocks which\endln
\lnie
     describe the regions of storage which are to be\endln
\lnie
     moved in the third pass. there is one descriptor for\endln
\lnie
     each contiguous set of good blocks. the descriptor\endln
\lnie
     is built just behind the block to be moved and\endln
\lnie
     contains a pointer to the next block and the number\endln
\lnie
     of words to be moved.\endln
\lnie
\endln
\lnie
3)   in the third and final pass, the move descriptor\endln
\lnie
     blocks built in pass two are used to actually move\endln
\lnie
     the blocks down to the bottom of the dynamic region.\endln
\lnie
     the collection is then complete and the next\endln
\lnie
     available location pointer is reset.\endln
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\ifmac{.csed}
\lnie
the garbage collector also recognizes the concept of\endln
\lnie
sediment.  sediment is defined as long-lived objects\endln
\lnie
which percipitate to the bottom of dynamic storage.\endln
\lnie
moving these objects during repeated collections is\endln
\lnie
inefficient.  it also contributes to thrashing on\endln
\lnie
systems with virtual memory.  in a typical worst-case\endln
\lnie
situation, there may be several megabytes of live objects\endln
\lnie
in the sediment, and only a few dead objects in need of\endln
\lnie
collection.  without recognising sediment, the standard\endln
\lnie
collector would move those megabytes of objects downward\endln
\lnie
to squeeze out the dead objects.  this type of move\endln
\lnie
would result in excessive thrasing for very little memory\endln
\lnie
gain.\endln
\lnie
\endln
\lnie
scanning of blocks in the sediment cannot be avoided\endln
\lnie
entirely, because these blocks may contain pointers to\endln
\lnie
live objects above the sediment.  however, sediment\endln
\lnie
blocks need not be linked to a back chain as described\endln
\lnie
in pass one above.  since these blocks will not be moved,\endln
\lnie
pointers to them do not need to be adjusted.  eliminating\endln
\lnie
unnecessary back chain links increases locality of\endln
\lnie
reference, improving virtual memory performance.\endln
\lnie
\endln
\lnie
because back chains are used to mark blocks whose con-\endln
\lnie
tents have been processed, a different marking system\endln
\ifmac{.cepp}
\lnie
is needed for blocks in the sediment.  since block type\endln
\lnie
words point to odd-parity entry addresses, merely incre-\endln
\lnie
menting the type word serves to mark the block as pro-\endln
\lnie
cessed.  during pass three, the type words are decre-\endln
\lnie
mented to restore them to their original value.\endln
\asmac{else}
\lnie
is needed for blocks in the sediment.  all block type\endln
\lnie
words normally lie in the range b$aaa to p$yyy.  blocks\endln
\lnie
can be marked by adding an offset (created in gbcmk) to\endln
\lnie
move type words out of this range.  during pass three the\endln
\lnie
offset is subtracted to restore them to their original\endln
\lnie
value.\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\lnie
\endln
\lnie
the variable dnams contains the number of bytes of memory\endln
\lnie
currently in the sediment.  setting dnams to zero will\endln
\lnie
eliminate the sediment and force it to be included in a\endln
\lnie
full garbage collection.  gbcol returns a suggested new\endln
\lnie
value for dnams (usually dnamp-dnamb) in xr which the\endln
\lnie
caller can store in dnams if it wishes to maintain the\endln
\lnie
sediment.  that is, data remaining after a garbage\endln
\lnie
collection is considered to be sediment.  if one accepts\endln
\lnie
the common lore that most objects are either very short-\endln
\lnie
or very long-lived, then this naive setting of dnams\endln
\lnie
probably includes some short-lived objects toward the end\endln
\lnie
of the sediment.\endln
\lnie
\endln
\lnie
knowing when to reset dnams to zero to collect the sedi-\endln
\lnie
ment is not precisely known.  we force it to zero prior\endln
\lnie
to producing a dump, when gbcol is invoked by collect()\endln
\lnie
(so that the sediment is invisible to the user), when\endln
\lnie
sysmm is unable to obtain additional memory, and when\endln
\lnie
gbcol is called to relocate the dynamic area up in memory\endln
\lnie
(to make room for enlarging the static area).  if there\endln
\lnie
are no other reset situations, this leads to the inexo-\endln
\lnie
rable growth of the sediment, possible forcing a modest\endln
\lnie
program to begin to use virtual memory that it otherwise\endln
\lnie
would not.\endln
\lnie
\endln
\lnie
as we scan sediment blocks in pass three, we maintain\endln
\lnie
aggregate counts of the amount of dead and live storage,\endln
\lnie
which is used to decide when to reset dnams.  when the\endln
\lnie
ratio of free storage found in the sediment to total\endln
\lnie
sediment size exceeds a threshold, the sediment is marked\endln
\lnie
for collection on the next gbcol call.\endln
\lnie
\endln
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\inst{gbcol}{prc}{e,0}{entry point}
\inst{}{bnz}{dmvch,gbc14}{fail if in mid-dump}
\inst{}{mnz}{gbcfl}{note gbcol entered}
\inst{}{mov}{wa,gbsva}{save entry wa}
\inst{}{mov}{wb,gbsvb}{save entry wb}
\inst{}{mov}{wc,gbsvc}{save entry wc}
\inst{}{mov}{xl,-(xs)}{save entry xl}
\inst{}{scp}{wa}{get code pointer value}
\inst{}{sub}{r$cod,wa}{make relative}
\inst{}{lcp}{wa}{and restore}
\ifmac{.csed}
\inst{}{bze}{wb,gbc0a}{check there is no move offset}
\inst{}{zer}{dnams}{collect sediment if must move it}
\inst{gbc0a}{mov}{dnamb,wa}{start of dynamic area}
\inst{}{add}{dnams,wa}{size of sediment}
\inst{}{mov}{wa,gbcsd}{first location past sediment}
\ifmac{.cepp}
\asmac{else}
\inst{}{mov}{=p$yyy,wa}{last entry point}
\inst{}{icv}{wa}{address past last entry point}
\inst{}{sub}{=b$aaa,wa}{size of entry point area}
\inst{}{mov}{wa,gbcmk}{use to mark processed sed. blocks}
\asmac{fi}
\asmac{fi}
\ifmac{.cgbc}
\lnie
\endln
\lnie
inform sysgc that collection to commence\endln
\lnie
\endln
\inst{}{mnz}{xr}{non-zero flags start of collection}
\inst{}{mov}{dnamb,wa}{start of dynamic area}
\inst{}{mov}{dnamp,wb}{next available location}
\inst{}{mov}{dname,wc}{last available location + 1}
\inst{}{jsr}{sysgc}{inform of collection}
\asmac{fi}
\lnie
\endln
\lnie
process stack entries\endln
\lnie
\endln
\inst{}{mov}{xs,xr}{point to stack front}
\inst{}{mov}{stbas,xl}{point past end of stack}
\inst{}{bge}{xl,xr,gbc00}{ok if d-stack}
\inst{}{mov}{xl,xr}{reverse if ...}
\inst{}{mov}{xs,xl}{... u-stack}
\lnie
\endln
\lnie
process the stack\endln
\lnie
\endln
\inst{gbc00}{jsr}{gbcpf}{process pointers on stack}
\lnie
\endln
\lnie
process special work locations\endln
\lnie
\endln
\inst{}{mov}{=r$aaa,xr}{point to start of relocatable locs}
\inst{}{mov}{=r$yyy,xl}{point past end of relocatable locs}
\inst{}{jsr}{gbcpf}{process work fields}
\lnie
\endln
\lnie
prepare to process variable blocks\endln
\lnie
\endln
\inst{}{mov}{hshtb,wa}{point to first hash slot pointer}
\lnie
\endln
\lnie
loop through hash slots\endln
\lnie
\endln
\inst{gbc01}{mov}{wa,xl}{point to next slot}
\inst{}{ica}{wa}{bump bucket pointer}
\inst{}{mov}{wa,gbcnm}{save bucket pointer}
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\lnie
loop through variables on one hash chain\endln
\lnie
\endln
\inst{gbc02}{mov}{(xl),xr}{load ptr to next vrblk}
\inst{}{bze}{xr,gbc03}{jump if end of chain}
\inst{}{mov}{xr,xl}{else copy vrblk pointer}
\inst{}{add}{*vrval,xr}{point to first reloc fld}
\inst{}{add}{*vrnxt,xl}{point past last (and to link ptr)}
\inst{}{jsr}{gbcpf}{process reloc fields in vrblk}
\inst{}{brn}{gbc02}{loop back for next block}
\lnie
\endln
\lnie
here at end of one hash chain\endln
\lnie
\endln
\inst{gbc03}{mov}{gbcnm,wa}{restore bucket pointer}
\inst{}{bne}{wa,hshte,gbc01}{loop back if more buckets to go}
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\lnie
now we are ready to start pass two. registers are used\endln
\lnie
as follows in pass two.\endln
\lnie
\endln
\lnie
(xr)                  scans through all blocks\endln
\lnie
(wc)                  pointer to eventual location\endln
\lnie
\endln
\lnie
the move description blocks built in this pass have\endln
\lnie
the following format.\endln
\lnie
\endln
\lnie
word 1                pointer to next move block,\endln
\lnie
                      zero if end of chain of blocks\endln
\lnie
\endln
\lnie
word 2                length of blocks to be moved in\endln
\lnie
                      bytes. set to the address of the\endln
\lnie
                      first byte while actually scanning\endln
\lnie
                      the blocks.\endln
\lnie
\endln
\lnie
the first entry on this chain is a special entry\endln
\lnie
consisting of the two words gbcnm and gbcns. after\endln
\lnie
building the chain of move descriptors, gbcnm points to\endln
\lnie
the first real move block, and gbcns is the length of\endln
\lnie
blocks in use at the start of storage which need not\endln
\lnie
be moved since they are in the correct position.\endln
\lnie
\endln
\ifmac{.csed}
\inst{}{mov}{dnamb,xr}{point to first block}
\inst{}{zer}{wb}{accumulate size of dead blocks}
\inst{gbc04}{beq}{xr,gbcsd,gbc4c}{jump if end of sediment}
\inst{}{mov}{(xr),wa}{else get first word}
\ifmac{.cepp}
\inst{}{bod}{wa,gbc4b}{jump if entry pointer (unused)}
\inst{}{dcv}{wa}{restore entry pointer}
\asmac{else}
\inst{}{bhi}{wa,=p$yyy,gbc4a}{skip if not entry ptr (in use)}
\inst{}{bhi}{wa,=b$aaa,gbc4b}{jump if entry pointer (unused)}
\inst{gbc4a}{sub}{gbcmk,wa}{restore entry pointer}
\asmac{fi}
\inst{}{mov}{wa,(xr)}{restore first word}
\inst{}{jsr}{blkln}{get length of this block}
\inst{}{add}{wa,xr}{bump actual pointer}
\inst{}{brn}{gbc04}{continue scan through sediment}
\lnie
\endln
\lnie
here for unused sediment block\endln
\lnie
\endln
\inst{gbc4b}{jsr}{blkln}{get length of this block}
\inst{}{add}{wa,xr}{bump actual pointer}
\inst{}{add}{wa,wb}{count size of unused blocks}
\inst{}{brn}{gbc04}{continue scan through sediment}
\lnie
\endln
\lnie
here at end of sediment.  remember size of free blocks\endln
\lnie
within the sediment.  this will be used later to decide\endln
\lnie
how to set the sediment size returned to caller.\endln
\lnie
\endln
\lnie
then scan rest of dynamic area above sediment.\endln
\lnie
\endln
\lnie
(wb) = aggregate size of free blocks in sediment\endln
\lnie
(xr) = first location past sediment\endln
\lnie
\endln
\inst{gbc4c}{mov}{wb,gbcsf}{size of sediment free space}
\asmac{else}
\inst{}{mov}{dnamb,xr}{point to first block}
\asmac{fi}
\inst{}{mov}{xr,wc}{set as first eventual location}
\inst{}{add}{gbsvb,wc}{add offset for eventual move up}
\inst{}{zer}{gbcnm}{clear initial forward pointer}
\inst{}{mov}{=gbcnm,gbclm}{initialize ptr to last move block}
\inst{}{mov}{xr,gbcns}{initialize first address}
\lnie
\endln
\lnie
loop through a series of blocks in use\endln
\lnie
\endln
\inst{gbc05}{beq}{xr,dnamp,gbc07}{jump if end of used region}
\inst{}{mov}{(xr),wa}{else get first word}
\ifmac{.cepp}
\inst{}{bod}{wa,gbc07}{jump if entry pointer (unused)}
\asmac{else}
\inst{}{bhi}{wa,=p$yyy,gbc06}{skip if not entry ptr (in use)}
\inst{}{bhi}{wa,=b$aaa,gbc07}{jump if entry pointer (unused)}
\asmac{fi}
\lnie
\endln
\lnie
here for block in use, loop to relocate references\endln
\lnie
\endln
\inst{gbc06}{mov}{wa,xl}{copy pointer}
\inst{}{mov}{(xl),wa}{load forward pointer}
\inst{}{mov}{wc,(xl)}{relocate reference}
\ifmac{.cepp}
\inst{}{bev}{wa,gbc06}{loop back if not end of chain}
\asmac{else}
\inst{}{bhi}{wa,=p$yyy,gbc06}{loop back if not end of chain}
\inst{}{blo}{wa,=b$aaa,gbc06}{loop back if not end of chain}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\lnie
at end of chain, restore first word and bump past\endln
\lnie
\endln
\inst{}{mov}{wa,(xr)}{restore first word}
\inst{}{jsr}{blkln}{get length of this block}
\inst{}{add}{wa,xr}{bump actual pointer}
\inst{}{add}{wa,wc}{bump eventual pointer}
\inst{}{brn}{gbc05}{loop back for next block}
\lnie
\endln
\lnie
here at end of a series of blocks in use\endln
\lnie
\endln
\inst{gbc07}{mov}{xr,wa}{copy pointer past last block}
\inst{}{mov}{gbclm,xl}{point to previous move block}
\inst{}{sub}{num01(xl),wa}{subtract starting address}
\inst{}{mov}{wa,num01(xl)}{store length of block to be moved}
\lnie
\endln
\lnie
loop through a series of blocks not in use\endln
\lnie
\endln
\inst{gbc08}{beq}{xr,dnamp,gbc10}{jump if end of used region}
\inst{}{mov}{(xr),wa}{else load first word of next block}
\ifmac{.cepp}
\inst{}{bev}{wa,gbc09}{jump if in use}
\asmac{else}
\inst{}{bhi}{wa,=p$yyy,gbc09}{jump if in use}
\inst{}{blo}{wa,=b$aaa,gbc09}{jump if in use}
\asmac{fi}
\inst{}{jsr}{blkln}{else get length of next block}
\inst{}{add}{wa,xr}{push pointer}
\inst{}{brn}{gbc08}{and loop back}
\lnie
\endln
\lnie
here for a block in use after processing a series of\endln
\lnie
blocks which were not in use, build new move block.\endln
\lnie
\endln
\inst{gbc09}{sub}{*num02,xr}{point 2 words behind for move block}
\inst{}{mov}{gbclm,xl}{point to previous move block}
\inst{}{mov}{xr,(xl)}{set forward ptr in previous block}
\inst{}{zer}{(xr)}{zero forward ptr of new block}
\inst{}{mov}{xr,gbclm}{remember address of this block}
\inst{}{mov}{xr,xl}{copy ptr to move block}
\inst{}{add}{*num02,xr}{point back to block in use}
\inst{}{mov}{xr,num01(xl)}{store starting address}
\inst{}{brn}{gbc06}{jump to process block in use}
\vfill\break

\lnie
\endln
\lnie
gbcol (continued)\endln
\lnie
\endln
\lnie
here for pass three -- actually move the blocks down\endln
\lnie
\endln
\lnie
(xl)                  pointer to old location\endln
\lnie
(xr)                  pointer to new location\endln
\lnie
\endln
\ifmac{.csed}
\inst{gbc10}{mov}{gbcsd,xr}{point to storage above sediment}
\asmac{else}
\inst{gbc10}{mov}{dnamb,xr}{point to start of storage}
\asmac{fi}
\inst{}{add}{gbcns,xr}{bump past unmoved blocks at start}
\lnie
\endln
\lnie
loop through move descriptors\endln
\lnie
\endln
\inst{gbc11}{mov}{gbcnm,xl}{point to next move block}
\inst{}{bze}{xl,gbc12}{jump if end of chain}
\inst{}{mov}{(xl)+,gbcnm}{move pointer down chain}
\inst{}{mov}{(xl)+,wa}{get length to move}
\inst{}{mvw}{}{perform move}
\inst{}{brn}{gbc11}{loop back}
\lnie
\endln
\lnie
now test for move up\endln
\lnie
\endln
\inst{gbc12}{mov}{xr,dnamp}{set next available loc ptr}
\inst{}{mov}{gbsvb,wb}{reload move offset}
\inst{}{bze}{wb,gbc13}{jump if no move required}
\inst{}{mov}{xr,xl}{else copy old top of core}
\inst{}{add}{wb,xr}{point to new top of core}
\inst{}{mov}{xr,dnamp}{save new top of core pointer}
\inst{}{mov}{xl,wa}{copy old top}
\inst{}{sub}{dnamb,wa}{minus old bottom = length}
\inst{}{add}{wb,dnamb}{bump bottom to get new value}
\inst{}{mwb}{}{perform move (backwards)}
\lnie
\endln
\lnie
merge here to exit\endln
\lnie
\endln
\inst{gbc13}{zer}{xr}{clear garbage value in xr}
\inst{}{mov}{xr,gbcfl}{note exit from gbcol}
\ifmac{.cgbc}
\inst{}{mov}{dnamb,wa}{start of dynamic area}
\inst{}{mov}{dnamp,wb}{next available location}
\inst{}{mov}{dname,wc}{last available location + 1}
\inst{}{jsr}{sysgc}{inform sysgc of completion}
\asmac{fi}
\ifmac{.csed}
\lnie
\endln
\lnie
decide whether to mark sediment for collection next time.\endln
\lnie
this is done by examining the ratio of previous sediment\endln
\lnie
free space to the new sediment size.\endln
\lnie
\endln
\inst{}{sti}{gbcia}{save ia}
\inst{}{zer}{xr}{presume no sediment will remain}
\inst{}{mov}{gbcsf,wb}{free space in sediment}
\inst{}{btw}{wb}{convert bytes to words}
\inst{}{mti}{wb}{put sediment free store in ia}
\inst{}{mli}{gbsed}{multiply by sediment factor}
\inst{}{iov}{gb13a}{jump if overflowed}
\inst{}{mov}{dnamp,wb}{end of dynamic area in use}
\inst{}{sub}{dnamb,wb}{minus start is sediment remaining}
\inst{}{btw}{wb}{convert to words}
\inst{}{mov}{wb,gbcsf}{store it}
\inst{}{sbi}{gbcsf}{subtract from scaled up free store}
\inst{}{igt}{gb13a}{jump if large free store in sedimnt}
\inst{}{mov}{dnamp,xr}{below threshold, return sediment}
\inst{}{sub}{dnamb,xr}{for use by caller}
\inst{gb13a}{ldi}{gbcia}{restore ia}
\asmac{fi}
\inst{}{mov}{gbsva,wa}{restore wa}
\inst{}{mov}{gbsvb,wb}{restore wb}
\inst{}{scp}{wc}{get code pointer}
\inst{}{add}{r$cod,wc}{make absolute again}
\inst{}{lcp}{wc}{and replace absolute value}
\inst{}{mov}{gbsvc,wc}{restore wc}
\inst{}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{icv}{gbcnt}{increment count of collections}
\inst{}{exi}{}{exit to gbcol caller}
\lnie
\endln
\lnie
garbage collection not allowed whilst dumping\endln
\lnie
\endln
\inst{gbc14}{icv}{errft}{fatal error}
\inst{}{erb}{250,insufficient}{memory to complete dump}
\inst{}{enp}{}{end procedure gbcol}
\vfill\break

\lnie
\endln
\lnie
gbcpf -- process fields for garbage collector\endln
\lnie
\endln
\lnie
this procedure is used by the garbage collector to\endln
\lnie
process fields in pass one. see gbcol for full details.\endln
\lnie
\endln
\lnie
(xr)                  ptr to first location to process\endln
\lnie
(xl)                  ptr past last location to process\endln
\lnie
jsr  gbcpf            call to process fields\endln
\lnie
(xr,wa,wb,wc,ia)      destroyed\endln
\lnie
\endln
\lnie
note that although this procedure uses a recursive\endln
\lnie
approach, it controls its own stack and is not recursive.\endln
\lnie
\endln
\inst{gbcpf}{prc}{e,0}{entry point}
\inst{}{zer}{-(xs)}{set zero to mark bottom of stack}
\inst{}{mov}{xl,-(xs)}{save end pointer}
\lnie
\endln
\lnie
merge here to go down a level and start a new loop\endln
\lnie
\endln
\lnie
1(xs)                 next lvl field ptr (0 at outer lvl)\endln
\lnie
0(xs)                 ptr past last field to process\endln
\lnie
(xr)                  ptr to first field to process\endln
\lnie
\endln
\lnie
loop to process successive fields\endln
\lnie
\endln
\inst{gpf01}{mov}{(xr),xl}{load field contents}
\inst{}{mov}{xr,wc}{save field pointer}
\ifmac{.crpp}
\inst{}{bod}{xl,gpf2a}{jump if not ptr into dynamic area}
\asmac{fi}
\inst{}{blt}{xl,dnamb,gpf2a}{jump if not ptr into dynamic area}
\inst{}{bge}{xl,dnamp,gpf2a}{jump if not ptr into dynamic area}
\lnie
\endln
\lnie
here we have a ptr to a block in the dynamic area.\endln
\lnie
link this field onto the reference backchain.\endln
\lnie
\endln
\inst{}{mov}{(xl),wa}{load ptr to chain (or entry ptr)}
\ifmac{.csed}
\inst{}{blt}{xl,gbcsd,gpf1a}{do not chain if within sediment}
\asmac{fi}
\inst{}{mov}{xr,(xl)}{set this field as new head of chain}
\inst{}{mov}{wa,(xr)}{set forward pointer}
\lnie
\endln
\lnie
now see if this block has been processed before\endln
\lnie
\endln
\ifmac{.cepp}
\inst{gpf1a}{bod}{wa,gpf03}{jump if not already processed}
\asmac{else}
\inst{gpf1a}{bhi}{wa,=p$yyy,gpf2a}{jump if already processed}
\inst{}{bhi}{wa,=b$aaa,gpf03}{jump if not already processed}
\asmac{fi}
\lnie
\endln
\lnie
here to restore pointer in xr to field just processed\endln
\lnie
\endln
\inst{gpf02}{mov}{wc,xr}{restore field pointer}
\lnie
\endln
\lnie
here to move to next field\endln
\lnie
\endln
\inst{gpf2a}{ica}{xr}{bump to next field}
\inst{}{bne}{xr,(xs),gpf01}{loop back if more to go}
\vfill\break

\lnie
\endln
\lnie
gbcpf (continued)\endln
\lnie
\endln
\lnie
here we pop up a level after finishing a block\endln
\lnie
\endln
\inst{}{mov}{(xs)+,xl}{restore pointer past end}
\inst{}{mov}{(xs)+,xr}{restore block pointer}
\inst{}{bnz}{xr,gpf2a}{continue loop unless outer levl}
\inst{}{exi}{}{return to caller if outer level}
\lnie
\endln
\lnie
here to process an active block which has not been done\endln
\lnie
\endln
\ifmac{.csed}
\lnie
\endln
\lnie
since sediment blocks are not marked by putting them on\endln
\lnie
the back chain, they must be explicitly marked in another\endln
\lnie
manner.  if odd parity entry points are present, mark by\endln
\lnie
temporarily converting to even parity.  if odd parity not\endln
\lnie
available, the entry point is adjusted by the value in\endln
\lnie
gbcmk.\endln
\lnie
\endln
\inst{gpf03}{bge}{xl,gbcsd,gpf3a}{if not within sediment}
\ifmac{.cepp}
\inst{}{icv}{(xl)}{mark by making entry point even}
\asmac{else}
\inst{}{add}{gbcmk,(xl)}{mark by biasing entry point}
\asmac{fi}
\inst{gpf3a}{mov}{xl,xr}{copy block pointer}
\asmac{else}
\inst{gpf03}{mov}{xl,xr}{copy block pointer}
\asmac{fi}
\inst{}{mov}{wa,xl}{copy first word of block}
\inst{}{lei}{xl}{load entry point id (bl$xx)}
\lnie
\endln
\lnie
block type switch. note that blocks with no relocatable\endln
\lnie
fields just return to gpf02 here to continue to next fld.\endln
\lnie
\endln
\inst{}{bsw}{xl,bl$$$}{switch on block type}
\inst{}{iff}{bl$ar,gpf06}{arblk}
\ifmac{.cnbf}
\inst{}{iff}{bl$bc,gpf02}{bcblk - dummy to fill out iffs}
\asmac{else}
\inst{}{iff}{bl$bc,gpf18}{bcblk}
\asmac{fi}
\inst{}{iff}{bl$bf,gpf02}{bfblk}
\inst{}{iff}{bl$cc,gpf07}{ccblk}
\ifmac{.csln}
\inst{}{iff}{bl$cd,gpf19}{cdblk}
\asmac{else}
\inst{}{iff}{bl$cd,gpf08}{cdblk}
\asmac{fi}
\inst{}{iff}{bl$cm,gpf04}{cmblk}
\inst{}{iff}{bl$df,gpf02}{dfblk}
\inst{}{iff}{bl$ev,gpf10}{evblk}
\inst{}{iff}{bl$ex,gpf17}{exblk}
\inst{}{iff}{bl$ff,gpf11}{ffblk}
\inst{}{iff}{bl$nm,gpf10}{nmblk}
\inst{}{iff}{bl$p0,gpf10}{p0blk}
\inst{}{iff}{bl$p1,gpf12}{p1blk}
\inst{}{iff}{bl$p2,gpf12}{p2blk}
\inst{}{iff}{bl$pd,gpf13}{pdblk}
\inst{}{iff}{bl$pf,gpf14}{pfblk}
\inst{}{iff}{bl$tb,gpf08}{tbblk}
\inst{}{iff}{bl$te,gpf15}{teblk}
\inst{}{iff}{bl$tr,gpf16}{trblk}
\inst{}{iff}{bl$vc,gpf08}{vcblk}
\inst{}{iff}{bl$xr,gpf09}{xrblk}
\inst{}{iff}{bl$ct,gpf02}{ctblk}
\inst{}{iff}{bl$ef,gpf02}{efblk}
\inst{}{iff}{bl$ic,gpf02}{icblk}
\inst{}{iff}{bl$kv,gpf02}{kvblk}
\inst{}{iff}{bl$rc,gpf02}{rcblk}
\inst{}{iff}{bl$sc,gpf02}{scblk}
\inst{}{iff}{bl$se,gpf02}{seblk}
\inst{}{iff}{bl$xn,gpf02}{xnblk}
\inst{}{esw}{}{end of jump table}
\vfill\break

\lnie
\endln
\lnie
gbcpf (continued)\endln
\lnie
\endln
\lnie
cmblk\endln
\lnie
\endln
\inst{gpf04}{mov}{cmlen(xr),wa}{load length}
\inst{}{mov}{*cmtyp,wb}{set offset}
\lnie
\endln
\lnie
here to push down to new level\endln
\lnie
\endln
\lnie
(wc)                  field ptr at previous level\endln
\lnie
(xr)                  ptr to new block\endln
\lnie
(wa)                  length (reloc flds + flds at start)\endln
\lnie
(wb)                  offset to first reloc field\endln
\lnie
\endln
\inst{gpf05}{add}{xr,wa}{point past last reloc field}
\inst{}{add}{wb,xr}{point to first reloc field}
\inst{}{mov}{wc,-(xs)}{stack old field pointer}
\inst{}{mov}{wa,-(xs)}{stack new limit pointer}
\inst{}{chk}{}{check for stack overflow}
\inst{}{brn}{gpf01}{if ok, back to process}
\lnie
\endln
\lnie
arblk\endln
\lnie
\endln
\inst{gpf06}{mov}{arlen(xr),wa}{load length}
\inst{}{mov}{arofs(xr),wb}{set offset to 1st reloc fld (arpro)}
\inst{}{brn}{gpf05}{all set}
\lnie
\endln
\lnie
ccblk\endln
\lnie
\endln
\inst{gpf07}{mov}{ccuse(xr),wa}{set length in use}
\inst{}{mov}{*ccuse,wb}{1st word (make sure at least one)}
\inst{}{brn}{gpf05}{all set}
\vfill\break

\lnie
\endln
\lnie
gbcpf (continued)\endln
\lnie
\endln
\ifmac{.csln}
\lnie
cdblk\endln
\lnie
\endln
\inst{gpf19}{mov}{cdlen(xr),wa}{load length}
\inst{}{mov}{*cdfal,wb}{set offset}
\inst{}{brn}{gpf05}{jump back}
\lnie
\endln
\lnie
tbblk, vcblk\endln
\asmac{else}
\lnie
cdblk, tbblk, vcblk\endln
\asmac{fi}
\lnie
\endln
\inst{gpf08}{mov}{offs2(xr),wa}{load length}
\inst{}{mov}{*offs3,wb}{set offset}
\inst{}{brn}{gpf05}{jump back}
\lnie
\endln
\lnie
xrblk\endln
\lnie
\endln
\inst{gpf09}{mov}{xrlen(xr),wa}{load length}
\inst{}{mov}{*xrptr,wb}{set offset}
\inst{}{brn}{gpf05}{jump back}
\lnie
\endln
\lnie
evblk, nmblk, p0blk\endln
\lnie
\endln
\inst{gpf10}{mov}{*offs2,wa}{point past second field}
\inst{}{mov}{*offs1,wb}{offset is one (only reloc fld is 2)}
\inst{}{brn}{gpf05}{all set}
\lnie
\endln
\lnie
ffblk\endln
\lnie
\endln
\inst{gpf11}{mov}{*ffofs,wa}{set length}
\inst{}{mov}{*ffnxt,wb}{set offset}
\inst{}{brn}{gpf05}{all set}
\lnie
\endln
\lnie
p1blk, p2blk\endln
\lnie
\endln
\inst{gpf12}{mov}{*parm2,wa}{length (parm2 is non-relocatable)}
\inst{}{mov}{*pthen,wb}{set offset}
\inst{}{brn}{gpf05}{all set}
\vfill\break

\lnie
\endln
\lnie
gbcpf (continued)\endln
\lnie
\endln
\lnie
pdblk\endln
\lnie
\endln
\inst{gpf13}{mov}{pddfp(xr),xl}{load ptr to dfblk}
\inst{}{mov}{dfpdl(xl),wa}{get pdblk length}
\inst{}{mov}{*pdfld,wb}{set offset}
\inst{}{brn}{gpf05}{all set}
\lnie
\endln
\lnie
pfblk\endln
\lnie
\endln
\inst{gpf14}{mov}{*pfarg,wa}{length past last reloc}
\inst{}{mov}{*pfcod,wb}{offset to first reloc}
\inst{}{brn}{gpf05}{all set}
\lnie
\endln
\lnie
teblk\endln
\lnie
\endln
\inst{gpf15}{mov}{*tesi$,wa}{set length}
\inst{}{mov}{*tesub,wb}{and offset}
\inst{}{brn}{gpf05}{all set}
\lnie
\endln
\lnie
trblk\endln
\lnie
\endln
\inst{gpf16}{mov}{*trsi$,wa}{set length}
\inst{}{mov}{*trval,wb}{and offset}
\inst{}{brn}{gpf05}{all set}
\lnie
\endln
\lnie
exblk\endln
\lnie
\endln
\inst{gpf17}{mov}{exlen(xr),wa}{load length}
\inst{}{mov}{*exflc,wb}{set offset}
\inst{}{brn}{gpf05}{jump back}
\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
bcblk\endln
\lnie
\endln
\inst{gpf18}{mov}{*bcsi$,wa}{set length}
\inst{}{mov}{*bcbuf,wb}{and offset}
\inst{}{brn}{gpf05}{all set}
\asmac{fi}
\inst{}{enp}{}{end procedure gbcpf}
\vfill\break

\lnie
\endln
\lnie
gtarr -- get array\endln
\lnie
\endln
\lnie
gtarr is passed an object and returns an array if possibl\endln
\lnie
\endln
\lnie
(xr)                  value to be converted\endln
\lnie
(wa)                  0 to place table addresses in array\endln
\lnie
                      non-zero for keys/values in array\endln
\lnie
jsr  gtarr            call to get array\endln
\lnie
ppm  loc              transfer loc for all null table\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  resulting array\endln
\lnie
(xl,wa,wb,wc)         destroyed\endln
\lnie
\endln
\inst{gtarr}{prc}{e,2}{entry point}
\inst{}{mov}{wa,gtawa}{save wa indicator}
\inst{}{mov}{(xr),wa}{load type word}
\inst{}{beq}{wa,=b$art,gtar8}{exit if already an array}
\inst{}{beq}{wa,=b$vct,gtar8}{exit if already an array}
\inst{}{bne}{wa,=b$tbt,gta9a}{else fail if not a table (sgd02)}
\lnie
\endln
\lnie
here we convert a table to an array\endln
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{replace tbblk pointer on stack}
\inst{}{zer}{xr}{signal first pass}
\inst{}{zer}{wb}{zero non-null element count}
\lnie
\endln
\lnie
the following code is executed twice. on the first pass,\endln
\lnie
signalled by xr=0, the number of non-null elements in\endln
\lnie
the table is counted in wb. in the second pass, where\endln
\lnie
xr is a pointer into the arblk, the name and value are\endln
\lnie
entered into the current arblk location provided gtawa\endln
\lnie
is non-zero.  if gtawa is zero, the address of the teblk\endln
\lnie
is entered into the arblk twice (c3.762).\endln
\lnie
\endln
\inst{gtar1}{mov}{(xs),xl}{point to table}
\inst{}{add}{tblen(xl),xl}{point past last bucket}
\inst{}{sub}{*tbbuk,xl}{set first bucket offset}
\inst{}{mov}{xl,wa}{copy adjusted pointer}
\lnie
\endln
\lnie
loop through buckets in table block\endln
\lnie
next three lines of code rely on tenxt having a value\endln
\lnie
1 less than tbbuk.\endln
\lnie
\endln
\inst{gtar2}{mov}{wa,xl}{copy bucket pointer}
\inst{}{dca}{wa}{decrement bucket pointer}
\lnie
\endln
\lnie
loop through teblks on one bucket chain\endln
\lnie
\endln
\inst{gtar3}{mov}{tenxt(xl),xl}{point to next teblk}
\inst{}{beq}{xl,(xs),gtar6}{jump if chain end (tbblk ptr)}
\inst{}{mov}{xl,cnvtp}{else save teblk pointer}
\lnie
\endln
\lnie
loop to find value down trblk chain\endln
\lnie
\endln
\inst{gtar4}{mov}{teval(xl),xl}{load value}
\inst{}{beq}{(xl),=b$trt,gtar4}{loop till value found}
\inst{}{mov}{xl,wc}{copy value}
\inst{}{mov}{cnvtp,xl}{restore teblk pointer}
\vfill\break

\lnie
\endln
\lnie
gtarr (continued)\endln
\lnie
\endln
\lnie
now check for null and test cases\endln
\lnie
\endln
\inst{}{beq}{wc,=nulls,gtar3}{loop back to ignore null value}
\inst{}{bnz}{xr,gtar5}{jump if second pass}
\inst{}{icv}{wb}{for the first pass, bump count}
\inst{}{brn}{gtar3}{and loop back for next teblk}
\lnie
\endln
\lnie
here in second pass\endln
\lnie
\endln
\inst{gtar5}{bze}{gtawa,gta5a}{jump if address wanted}
\inst{}{mov}{tesub(xl),(xr)+}{store subscript name}
\inst{}{mov}{wc,(xr)+}{store value in arblk}
\inst{}{brn}{gtar3}{loop back for next teblk}
\lnie
\endln
\lnie
here to record teblk address in arblk.  this allows\endln
\lnie
a sort routine to sort by ascending address.\endln
\lnie
\endln
\inst{gta5a}{mov}{xl,(xr)+}{store teblk address in name}
\inst{}{mov}{xl,(xr)+}{and value slots}
\inst{}{brn}{gtar3}{loop back for next teblk}
\lnie
\endln
\lnie
here after scanning teblks on one chain\endln
\lnie
\endln
\inst{gtar6}{bne}{wa,(xs),gtar2}{loop back if more buckets to go}
\inst{}{bnz}{xr,gtar7}{else jump if second pass}
\lnie
\endln
\lnie
here after counting non-null elements\endln
\lnie
\endln
\inst{}{bze}{wb,gtar9}{fail if no non-null elements}
\inst{}{mov}{wb,wa}{else copy count}
\inst{}{add}{wb,wa}{double (two words/element)}
\inst{}{add}{=arvl2,wa}{add space for standard fields}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{bgt}{wa,mxlen,gta9b}{error if too long for array}
\inst{}{jsr}{alloc}{else allocate space for arblk}
\inst{}{mov}{=b$art,(xr)}{store type word}
\inst{}{zer}{idval(xr)}{zero id for the moment}
\inst{}{mov}{wa,arlen(xr)}{store length}
\inst{}{mov}{=num02,arndm(xr)}{set dimensions = 2}
\inst{}{ldi}{intv1}{get integer one}
\inst{}{sti}{arlbd(xr)}{store as lbd 1}
\inst{}{sti}{arlb2(xr)}{store as lbd 2}
\inst{}{ldi}{intv2}{load integer two}
\inst{}{sti}{ardm2(xr)}{store as dim 2}
\inst{}{mti}{wb}{get element count as integer}
\inst{}{sti}{ardim(xr)}{store as dim 1}
\inst{}{zer}{arpr2(xr)}{zero prototype field for now}
\inst{}{mov}{*arpr2,arofs(xr)}{set offset field (signal pass 2)}
\inst{}{mov}{xr,wb}{save arblk pointer}
\inst{}{add}{*arvl2,xr}{point to first element location}
\inst{}{brn}{gtar1}{jump back to fill in elements}
\vfill\break

\lnie
\endln
\lnie
gtarr (continued)\endln
\lnie
\endln
\lnie
here after filling in element values\endln
\lnie
\endln
\inst{gtar7}{mov}{wb,xr}{restore arblk pointer}
\inst{}{mov}{wb,(xs)}{store as result}
\lnie
\endln
\lnie
now we need the array prototype which is of the form nn,2\endln
\lnie
this is obtained by building the string for nn02 and\endln
\lnie
changing the zero to a comma before storing it.\endln
\lnie
\endln
\inst{}{ldi}{ardim(xr)}{get number of elements (nn)}
\inst{}{mli}{intvh}{multiply by 100}
\inst{}{adi}{intv2}{add 2 (nn02)}
\inst{}{jsr}{icbld}{build integer}
\inst{}{mov}{xr,-(xs)}{store ptr for gtstg}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{}{convert fail is impossible}
\inst{}{mov}{xr,xl}{copy string pointer}
\inst{}{mov}{(xs)+,xr}{reload arblk pointer}
\inst{}{mov}{xl,arpr2(xr)}{store prototype ptr (nn02)}
\inst{}{sub}{=num02,wa}{adjust length to point to zero}
\inst{}{psc}{xl,wa}{point to zero}
\inst{}{mov}{=ch$cm,wb}{load a comma}
\inst{}{sch}{wb,(xl)}{store a comma over the zero}
\inst{}{csc}{xl}{complete store characters}
\lnie
\endln
\lnie
normal return\endln
\lnie
\endln
\inst{gtar8}{exi}{}{return to caller}
\lnie
\endln
\lnie
null table non-conversion return\endln
\lnie
\endln
\inst{gtar9}{mov}{(xs)+,xr}{restore stack for conv err (sgd02)}
\inst{}{exi}{1}{return}
\lnie
\endln
\lnie
impossible conversion return\endln
\lnie
\endln
\inst{gta9a}{exi}{2}{return}
\lnie
\endln
\lnie
array size too large\endln
\lnie
\endln
\inst{gta9b}{erb}{260,conversion array}{size exceeds maximum permitted}
\inst{}{enp}{}{procedure gtarr}
\vfill\break

\lnie
\endln
\lnie
gtcod -- convert to code\endln
\lnie
\endln
\lnie
(xr)                  object to be converted\endln
\lnie
jsr  gtcod            call to convert to code\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  pointer to resulting cdblk\endln
\lnie
(xl,wa,wb,wc,ra)      destroyed\endln
\lnie
\endln
\lnie
if a spitbol error occurs during compilation or pre-\endln
\lnie
evaluation, control is passed via error section to exfal\endln
\lnie
without returning to this routine.\endln
\lnie
\endln
\inst{gtcod}{prc}{e,1}{entry point}
\inst{}{beq}{(xr),=b$cds,gtcd1}{jump if already code}
\inst{}{beq}{(xr),=b$cdc,gtcd1}{jump if already code}
\lnie
\endln
\lnie
here we must generate a cdblk by compilation\endln
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{stack argument for gtstg}
\inst{}{jsr}{gtstg}{convert argument to string}
\inst{}{ppm}{gtcd2}{jump if non-convertible}
\inst{}{mov}{flptr,gtcef}{save fail ptr in case of error}
\inst{}{mov}{r$cod,r$gtc}{also save code ptr}
\inst{}{mov}{xr,r$cim}{else set image pointer}
\inst{}{mov}{wa,scnil}{set image length}
\inst{}{zer}{scnpt}{set scan pointer}
\inst{}{mov}{=stgxc,stage}{set stage for execute compile}
\inst{}{mov}{cmpsn,lstsn}{in case listr called}
\ifmac{.csln}
\inst{}{icv}{cmpln}{bump line number}
\asmac{fi}
\inst{}{jsr}{cmpil}{compile string}
\inst{}{mov}{=stgxt,stage}{reset stage for execute time}
\inst{}{zer}{r$cim}{clear image}
\lnie
\endln
\lnie
merge here if no convert required\endln
\lnie
\endln
\inst{gtcd1}{exi}{}{give normal gtcod return}
\lnie
\endln
\lnie
here if unconvertible\endln
\lnie
\endln
\inst{gtcd2}{exi}{1}{give error return}
\inst{}{enp}{}{end procedure gtcod}
\vfill\break

\lnie
\endln
\lnie
gtexp -- convert to expression\endln
\lnie
\endln
\ifmac{.cevb}
\lnie
(wb)                  0 if by value, 1 if by name\endln
\asmac{fi}
\lnie
(xr)                  input value to be converted\endln
\lnie
jsr  gtexp            call to convert to expression\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  pointer to result exblk or seblk\endln
\lnie
(xl,wa,wb,wc,ra)      destroyed\endln
\lnie
\endln
\lnie
if a spitbol error occurs during compilation or pre-\endln
\lnie
evaluation, control is passed via error section to exfal\endln
\lnie
without returning to this routine.\endln
\lnie
\endln
\inst{gtexp}{prc}{e,1}{entry point}
\inst{}{blo}{(xr),=b$e$$,gtex1}{jump if already an expression}
\inst{}{mov}{xr,-(xs)}{store argument for gtstg}
\inst{}{jsr}{gtstg}{convert argument to string}
\inst{}{ppm}{gtex2}{jump if unconvertible}
\lnie
\endln
\lnie
check the last character of the string for colon or\endln
\lnie
semicolon.  these characters can legitimately end an\endln
\lnie
expression in open code, so expan will not detect them\endln
\lnie
as errors, but they are invalid as terminators for a\endln
\lnie
string that is being converted to expression form.\endln
\lnie
\endln
\inst{}{mov}{xr,xl}{copy input string pointer}
\inst{}{plc}{xl,wa}{point one past the string end}
\inst{}{lch}{xl,-(xl)}{fetch the last character}
\inst{}{beq}{xl,=ch$cl,gtex2}{error if it is a semicolon}
\inst{}{beq}{xl,=ch$sm,gtex2}{or if it is a colon}
\lnie
\endln
\lnie
here we convert a string by compilation\endln
\lnie
\endln
\inst{}{mov}{xr,r$cim}{set input image pointer}
\inst{}{zer}{scnpt}{set scan pointer}
\inst{}{mov}{wa,scnil}{set input image length}
\ifmac{.cevb}
\inst{}{mov}{wb,-(xs)}{save value/name flag}
\asmac{fi}
\inst{}{zer}{wb}{set code for normal scan}
\inst{}{mov}{flptr,gtcef}{save fail ptr in case of error}
\inst{}{mov}{r$cod,r$gtc}{also save code ptr}
\inst{}{mov}{=stgev,stage}{adjust stage for compile}
\inst{}{mov}{=t$uok,scntp}{indicate unary operator acceptable}
\inst{}{jsr}{expan}{build tree for expression}
\inst{}{zer}{scnrs}{reset rescan flag}
\ifmac{.cevb}
\inst{}{mov}{(xs)+,wa}{restore value/name flag}
\asmac{fi}
\inst{}{bne}{scnpt,scnil,gtex2}{error if not end of image}
\inst{}{zer}{wb}{set ok value for cdgex call}
\inst{}{mov}{xr,xl}{copy tree pointer}
\inst{}{jsr}{cdgex}{build expression block}
\inst{}{zer}{r$cim}{clear pointer}
\inst{}{mov}{=stgxt,stage}{restore stage for execute time}
\lnie
\endln
\lnie
merge here if no conversion required\endln
\lnie
\endln
\inst{gtex1}{exi}{}{return to gtexp caller}
\lnie
\endln
\lnie
here if unconvertible\endln
\lnie
\endln
\inst{gtex2}{exi}{1}{take error exit}
\inst{}{enp}{}{end procedure gtexp}
\vfill\break

\lnie
\endln
\lnie
gtint -- get integer value\endln
\lnie
\endln
\lnie
gtint is passed an object and returns an integer after\endln
\lnie
performing any necessary conversions.\endln
\lnie
\endln
\lnie
(xr)                  value to be converted\endln
\lnie
jsr  gtint            call to convert to integer\endln
\lnie
ppm  loc              transfer loc for convert impossible\endln
\lnie
(xr)                  resulting integer\endln
\lnie
(wc,ra)               destroyed\endln
\lnie
(wa,wb)               destroyed (only on conversion err)\endln
\lnie
(xr)                  unchanged (on convert error)\endln
\lnie
\endln
\inst{gtint}{prc}{e,1}{entry point}
\inst{}{beq}{(xr),=b$icl,gtin2}{jump if already an integer}
\inst{}{mov}{wa,gtina}{else save wa}
\inst{}{mov}{wb,gtinb}{save wb}
\inst{}{jsr}{gtnum}{convert to numeric}
\inst{}{ppm}{gtin3}{jump if unconvertible}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$icl,gtin1}{jump if integer}
\lnie
\endln
\lnie
here we convert a real to integer\endln
\lnie
\endln
\inst{}{ldr}{rcval(xr)}{load real value}
\inst{}{rti}{gtin3}{convert to integer (err if ovflow)}
\inst{}{jsr}{icbld}{if ok build icblk}
\asmac{fi}
\lnie
\endln
\lnie
here after successful conversion to integer\endln
\lnie
\endln
\inst{gtin1}{mov}{gtina,wa}{restore wa}
\inst{}{mov}{gtinb,wb}{restore wb}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{gtin2}{exi}{}{return to gtint caller}
\lnie
\endln
\lnie
here on conversion error\endln
\lnie
\endln
\inst{gtin3}{exi}{1}{take convert error exit}
\inst{}{enp}{}{end procedure gtint}
\vfill\break

\lnie
\endln
\lnie
gtnum -- get numeric value\endln
\lnie
\endln
\lnie
gtnum is given an object and returns either an integer\endln
\lnie
or a real, performing any necessary conversions.\endln
\lnie
\endln
\lnie
(xr)                  object to be converted\endln
\lnie
jsr  gtnum            call to convert to numeric\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  pointer to result (int or real)\endln
\lnie
(wa)                  first word of result block\endln
\lnie
(wb,wc,ra)            destroyed\endln
\lnie
(xr)                  unchanged (on convert error)\endln
\lnie
\endln
\inst{gtnum}{prc}{e,1}{entry point}
\inst{}{mov}{(xr),wa}{load first word of block}
\inst{}{beq}{wa,=b$icl,gtn34}{jump if integer (no conversion)}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$rcl,gtn34}{jump if real (no conversion)}
\asmac{fi}
\lnie
\endln
\lnie
at this point the only possibility is to convert a string\endln
\lnie
to an integer or real as appropriate.\endln
\lnie
\endln
\inst{}{mov}{xr,-(xs)}{stack argument in case convert err}
\inst{}{mov}{xr,-(xs)}{stack argument for gtstg}
\ifmac{.cnbf}
\inst{}{jsr}{gtstg}{convert argument to string}
\asmac{else}
\inst{}{jsr}{gtstb}{get argument as string or buffer}
\asmac{fi}
\inst{}{ppm}{gtn36}{jump if unconvertible}
\lnie
\endln
\lnie
initialize numeric conversion\endln
\lnie
\endln
\inst{}{ldi}{intv0}{initialize integer result to zero}
\inst{}{bze}{wa,gtn32}{jump to exit with zero if null}
\inst{}{lct}{wa,wa}{set bct counter for following loops}
\inst{}{zer}{gtnnf}{tentatively indicate result +}
\ifmac{.cnra}
\asmac{else}
\inst{}{sti}{gtnex}{initialise exponent to zero}
\inst{}{zer}{gtnsc}{zero scale in case real}
\inst{}{zer}{gtndf}{reset flag for dec point found}
\inst{}{zer}{gtnrd}{reset flag for digits found}
\inst{}{ldr}{reav0}{zero real accum in case real}
\asmac{fi}
\inst{}{plc}{xr}{point to argument characters}
\lnie
\endln
\lnie
merge back here after ignoring leading blank\endln
\lnie
\endln
\inst{gtn01}{lch}{wb,(xr)+}{load first character}
\inst{}{blt}{wb,=ch$d0,gtn02}{jump if not digit}
\inst{}{ble}{wb,=ch$d9,gtn06}{jump if first char is a digit}
\vfill\break

\lnie
\endln
\lnie
gtnum (continued)\endln
\lnie
\endln
\lnie
here if first digit is non-digit\endln
\lnie
\endln
\inst{gtn02}{bne}{wb,=ch$bl,gtn03}{jump if non-blank}
\inst{gtna2}{bct}{wa,gtn01}{else decr count and loop back}
\inst{}{brn}{gtn07}{jump to return zero if all blanks}
\lnie
\endln
\lnie
here for first character non-blank, non-digit\endln
\lnie
\endln
\inst{gtn03}{beq}{wb,=ch$pl,gtn04}{jump if plus sign}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,gtna2}{horizontal tab equiv to blank}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wb,=ch$vt,gtna2}{vertical tab equiv to blank}
\asmac{fi}
\ifmac{.cnra}
\inst{}{bne}{wb,=ch$mn,gtn36}{else fail}
\asmac{else}
\inst{}{bne}{wb,=ch$mn,gtn12}{jump if not minus (may be real)}
\asmac{fi}
\inst{}{mnz}{gtnnf}{if minus sign, set negative flag}
\lnie
\endln
\lnie
merge here after processing sign\endln
\lnie
\endln
\inst{gtn04}{bct}{wa,gtn05}{jump if chars left}
\inst{}{brn}{gtn36}{else error}
\lnie
\endln
\lnie
loop to fetch characters of an integer\endln
\lnie
\endln
\inst{gtn05}{lch}{wb,(xr)+}{load next character}
\inst{}{blt}{wb,=ch$d0,gtn08}{jump if not a digit}
\inst{}{bgt}{wb,=ch$d9,gtn08}{jump if not a digit}
\lnie
\endln
\lnie
merge here for first digit\endln
\lnie
\endln
\inst{gtn06}{sti}{gtnsi}{save current value}
\ifmac{.cnra}
\inst{}{cvm}{gtn36}{current*10-(new dig) jump if ovflow}
\asmac{else}
\inst{}{cvm}{gtn35}{current*10-(new dig) jump if ovflow}
\inst{}{mnz}{gtnrd}{set digit read flag}
\asmac{fi}
\inst{}{bct}{wa,gtn05}{else loop back if more chars}
\lnie
\endln
\lnie
here to exit with converted integer value\endln
\lnie
\endln
\inst{gtn07}{bnz}{gtnnf,gtn32}{jump if negative (all set)}
\inst{}{ngi}{}{else negate}
\inst{}{ino}{gtn32}{jump if no overflow}
\inst{}{brn}{gtn36}{else signal error}
\vfill\break

\lnie
\endln
\lnie
gtnum (continued)\endln
\lnie
\endln
\lnie
here for a non-digit character while attempting to\endln
\lnie
convert an integer, check for trailing blanks or real.\endln
\lnie
\endln
\inst{gtn08}{beq}{wb,=ch$bl,gtna9}{jump if a blank}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,gtna9}{jump if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wb,=ch$vt,gtna9}{jump if vertical tab}
\asmac{fi}
\ifmac{.cnra}
\inst{}{brn}{gtn36}{error}
\asmac{else}
\inst{}{itr}{}{else convert integer to real}
\inst{}{ngr}{}{negate to get positive value}
\inst{}{brn}{gtn12}{jump to try for real}
\asmac{fi}
\lnie
\endln
\lnie
here we scan out blanks to end of string\endln
\lnie
\endln
\inst{gtn09}{lch}{wb,(xr)+}{get next char}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,gtna9}{jump if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wb,=ch$vt,gtna9}{jump if vertical tab}
\asmac{fi}
\inst{}{bne}{wb,=ch$bl,gtn36}{error if non-blank}
\inst{gtna9}{bct}{wa,gtn09}{loop back if more chars to check}
\inst{}{brn}{gtn07}{return integer if all blanks}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
loop to collect mantissa of real\endln
\lnie
\endln
\inst{gtn10}{lch}{wb,(xr)+}{load next character}
\inst{}{blt}{wb,=ch$d0,gtn12}{jump if non-numeric}
\inst{}{bgt}{wb,=ch$d9,gtn12}{jump if non-numeric}
\lnie
\endln
\lnie
merge here to collect first real digit\endln
\lnie
\endln
\inst{gtn11}{sub}{=ch$d0,wb}{convert digit to number}
\inst{}{mlr}{reavt}{multiply real by 10.0}
\inst{}{rov}{gtn36}{convert error if overflow}
\inst{}{str}{gtnsr}{save result}
\inst{}{mti}{wb}{get new digit as integer}
\inst{}{itr}{}{convert new digit to real}
\inst{}{adr}{gtnsr}{add to get new total}
\inst{}{add}{gtndf,gtnsc}{increment scale if after dec point}
\inst{}{mnz}{gtnrd}{set digit found flag}
\inst{}{bct}{wa,gtn10}{loop back if more chars}
\inst{}{brn}{gtn22}{else jump to scale}
\vfill\break

\lnie
\endln
\lnie
gtnum (continued)\endln
\lnie
\endln
\lnie
here if non-digit found while collecting a real\endln
\lnie
\endln
\inst{gtn12}{bne}{wb,=ch$dt,gtn13}{jump if not dec point}
\inst{}{bnz}{gtndf,gtn36}{if dec point, error if one already}
\inst{}{mov}{=num01,gtndf}{else set flag for dec point}
\inst{}{bct}{wa,gtn10}{loop back if more chars}
\inst{}{brn}{gtn22}{else jump to scale}
\lnie
\endln
\lnie
here if not decimal point\endln
\lnie
\endln
\inst{gtn13}{beq}{wb,=ch$le,gtn15}{jump if e for exponent}
\inst{}{beq}{wb,=ch$ld,gtn15}{jump if d for exponent}
\ifmac{.culc}
\inst{}{beq}{wb,=ch$$e,gtn15}{jump if e for exponent}
\inst{}{beq}{wb,=ch$$d,gtn15}{jump if d for exponent}
\asmac{fi}
\lnie
\endln
\lnie
here check for trailing blanks\endln
\lnie
\endln
\inst{gtn14}{beq}{wb,=ch$bl,gtnb4}{jump if blank}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,gtnb4}{jump if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wb,=ch$vt,gtnb4}{jump if vertical tab}
\asmac{fi}
\inst{}{brn}{gtn36}{error if non-blank}
\lnie
\endln
\inst{gtnb4}{lch}{wb,(xr)+}{get next character}
\inst{}{bct}{wa,gtn14}{loop back to check if more}
\inst{}{brn}{gtn22}{else jump to scale}
\lnie
\endln
\lnie
here to read and process an exponent\endln
\lnie
\endln
\inst{gtn15}{zer}{gtnes}{set exponent sign positive}
\inst{}{ldi}{intv0}{initialize exponent to zero}
\inst{}{mnz}{gtndf}{reset no dec point indication}
\inst{}{bct}{wa,gtn16}{jump skipping past e or d}
\inst{}{brn}{gtn36}{error if null exponent}
\lnie
\endln
\lnie
check for exponent sign\endln
\lnie
\endln
\inst{gtn16}{lch}{wb,(xr)+}{load first exponent character}
\inst{}{beq}{wb,=ch$pl,gtn17}{jump if plus sign}
\inst{}{bne}{wb,=ch$mn,gtn19}{else jump if not minus sign}
\inst{}{mnz}{gtnes}{set sign negative if minus sign}
\lnie
\endln
\lnie
merge here after processing exponent sign\endln
\lnie
\endln
\inst{gtn17}{bct}{wa,gtn18}{jump if chars left}
\inst{}{brn}{gtn36}{else error}
\lnie
\endln
\lnie
loop to convert exponent digits\endln
\lnie
\endln
\inst{gtn18}{lch}{wb,(xr)+}{load next character}
\vfill\break

\lnie
\endln
\lnie
gtnum (continued)\endln
\lnie
\endln
\lnie
merge here for first exponent digit\endln
\lnie
\endln
\inst{gtn19}{blt}{wb,=ch$d0,gtn20}{jump if not digit}
\inst{}{bgt}{wb,=ch$d9,gtn20}{jump if not digit}
\inst{}{cvm}{gtn36}{else current*10, subtract new digit}
\inst{}{bct}{wa,gtn18}{loop back if more chars}
\inst{}{brn}{gtn21}{jump if exponent field is exhausted}
\lnie
\endln
\lnie
here to check for trailing blanks after exponent\endln
\lnie
\endln
\inst{gtn20}{beq}{wb,=ch$bl,gtnc0}{jump if blank}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,gtnc0}{jump if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wc,=ch$vt,gtnc0}{jump if vertical tab}
\asmac{fi}
\inst{}{brn}{gtn36}{error if non-blank}
\lnie
\endln
\inst{gtnc0}{lch}{wb,(xr)+}{get next character}
\inst{}{bct}{wa,gtn20}{loop back till all blanks scanned}
\lnie
\endln
\lnie
merge here after collecting exponent\endln
\lnie
\endln
\inst{gtn21}{sti}{gtnex}{save collected exponent}
\inst{}{bnz}{gtnes,gtn22}{jump if it was negative}
\inst{}{ngi}{}{else complement}
\inst{}{iov}{gtn36}{error if overflow}
\inst{}{sti}{gtnex}{and store positive exponent}
\lnie
\endln
\lnie
merge here with exponent (0 if none given)\endln
\lnie
\endln
\inst{gtn22}{bze}{gtnrd,gtn36}{error if not digits collected}
\inst{}{bze}{gtndf,gtn36}{error if no exponent or dec point}
\inst{}{mti}{gtnsc}{else load scale as integer}
\inst{}{sbi}{gtnex}{subtract exponent}
\inst{}{iov}{gtn36}{error if overflow}
\inst{}{ilt}{gtn26}{jump if we must scale up}
\lnie
\endln
\lnie
here we have a negative exponent, so scale down\endln
\lnie
\endln
\inst{}{mfi}{wa,gtn36}{load scale factor, err if ovflow}
\lnie
\endln
\lnie
loop to scale down in steps of 10**10\endln
\lnie
\endln
\inst{gtn23}{ble}{wa,=num10,gtn24}{jump if 10 or less to go}
\inst{}{dvr}{reatt}{else divide by 10**10}
\inst{}{sub}{=num10,wa}{decrement scale}
\inst{}{brn}{gtn23}{and loop back}
\vfill\break

\lnie
\endln
\lnie
gtnum (continued)\endln
\lnie
\endln
\lnie
here scale rest of way from powers of ten table\endln
\lnie
\endln
\inst{gtn24}{bze}{wa,gtn30}{jump if scaled}
\inst{}{lct}{wb,=cfp$r}{else get indexing factor}
\inst{}{mov}{=reav1,xr}{point to powers of ten table}
\inst{}{wtb}{wa}{convert remaining scale to byte ofs}
\lnie
\endln
\lnie
loop to point to powers of ten table entry\endln
\lnie
\endln
\inst{gtn25}{add}{wa,xr}{bump pointer}
\inst{}{bct}{wb,gtn25}{once for each value word}
\inst{}{dvr}{(xr)}{scale down as required}
\inst{}{brn}{gtn30}{and jump}
\lnie
\endln
\lnie
come here to scale result up (positive exponent)\endln
\lnie
\endln
\inst{gtn26}{ngi}{}{get absolute value of exponent}
\inst{}{iov}{gtn36}{error if overflow}
\inst{}{mfi}{wa,gtn36}{acquire scale, error if ovflow}
\lnie
\endln
\lnie
loop to scale up in steps of 10**10\endln
\lnie
\endln
\inst{gtn27}{ble}{wa,=num10,gtn28}{jump if 10 or less to go}
\inst{}{mlr}{reatt}{else multiply by 10**10}
\inst{}{rov}{gtn36}{error if overflow}
\inst{}{sub}{=num10,wa}{else decrement scale}
\inst{}{brn}{gtn27}{and loop back}
\lnie
\endln
\lnie
here to scale up rest of way with table\endln
\lnie
\endln
\inst{gtn28}{bze}{wa,gtn30}{jump if scaled}
\inst{}{lct}{wb,=cfp$r}{else get indexing factor}
\inst{}{mov}{=reav1,xr}{point to powers of ten table}
\inst{}{wtb}{wa}{convert remaining scale to byte ofs}
\lnie
\endln
\lnie
loop to point to proper entry in powers of ten table\endln
\lnie
\endln
\inst{gtn29}{add}{wa,xr}{bump pointer}
\inst{}{bct}{wb,gtn29}{once for each word in value}
\inst{}{mlr}{(xr)}{scale up}
\inst{}{rov}{gtn36}{error if overflow}
\vfill\break

\lnie
\endln
\lnie
gtnum (continued)\endln
\lnie
\endln
\lnie
here with real value scaled and ready except for sign\endln
\lnie
\endln
\inst{gtn30}{bze}{gtnnf,gtn31}{jump if positive}
\inst{}{ngr}{}{else negate}
\lnie
\endln
\lnie
here with properly signed real value in (ra)\endln
\lnie
\endln
\inst{gtn31}{jsr}{rcbld}{build real block}
\inst{}{brn}{gtn33}{merge to exit}
\asmac{fi}
\lnie
\endln
\lnie
here with properly signed integer value in (ia)\endln
\lnie
\endln
\inst{gtn32}{jsr}{icbld}{build icblk}
\lnie
\endln
\lnie
real merges here\endln
\lnie
\endln
\inst{gtn33}{mov}{(xr),wa}{load first word of result block}
\inst{}{ica}{xs}{pop argument off stack}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{gtn34}{exi}{}{return to gtnum caller}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
come here if overflow occurs during collection of integer\endln
\lnie
have to restore wb which cvm may have destroyed.\endln
\lnie
\endln
\inst{gtn35}{lch}{wb,-(xr)}{reload current character}
\inst{}{lch}{wb,(xr)+}{bump character pointer}
\inst{}{ldi}{gtnsi}{reload integer so far}
\inst{}{itr}{}{convert to real}
\inst{}{ngr}{}{make value positive}
\inst{}{brn}{gtn11}{merge with real circuit}
\asmac{fi}
\lnie
\endln
\lnie
here for unconvertible to string or conversion error\endln
\lnie
\endln
\inst{gtn36}{mov}{(xs)+,xr}{reload original argument}
\inst{}{exi}{1}{take convert-error exit}
\inst{}{enp}{}{end procedure gtnum}
\vfill\break

\lnie
\endln
\lnie
gtnvr -- convert to natural variable\endln
\lnie
\endln
\lnie
gtnvr locates a variable block (vrblk) given either an\endln
\lnie
appropriate name (nmblk) or a non-null string (scblk).\endln
\lnie
\endln
\lnie
(xr)                  argument\endln
\lnie
jsr  gtnvr            call to convert to natural variable\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  pointer to vrblk\endln
\lnie
(wa,wb)               destroyed (conversion error only)\endln
\lnie
(wc)                  destroyed\endln
\lnie
\endln
\inst{gtnvr}{prc}{e,1}{entry point}
\inst{}{bne}{(xr),=b$nml,gnv02}{jump if not name}
\inst{}{mov}{nmbas(xr),xr}{else load name base if name}
\inst{}{blo}{xr,state,gnv07}{skip if vrblk (in static region)}
\lnie
\endln
\lnie
common error exit\endln
\lnie
\endln
\inst{gnv01}{exi}{1}{take convert-error exit}
\lnie
\endln
\lnie
here if not name\endln
\lnie
\endln
\inst{gnv02}{mov}{wa,gnvsa}{save wa}
\inst{}{mov}{wb,gnvsb}{save wb}
\inst{}{mov}{xr,-(xs)}{stack argument for gtstg}
\inst{}{jsr}{gtstg}{convert argument to string}
\inst{}{ppm}{gnv01}{jump if conversion error}
\inst{}{bze}{wa,gnv01}{null string is an error}
\ifmac{.culc}
\inst{}{jsr}{flstg}{fold lower case to upper case}
\asmac{fi}
\inst{}{mov}{xl,-(xs)}{save xl}
\inst{}{mov}{xr,-(xs)}{stack string ptr for later}
\inst{}{mov}{xr,wb}{copy string pointer}
\inst{}{add}{*schar,wb}{point to characters of string}
\inst{}{mov}{wb,gnvst}{save pointer to characters}
\inst{}{mov}{wa,wb}{copy length}
\inst{}{ctw}{wb,0}{get number of words in name}
\inst{}{mov}{wb,gnvnw}{save for later}
\inst{}{jsr}{hashs}{compute hash index for string}
\inst{}{rmi}{hshnb}{compute hash offset by taking mod}
\inst{}{mfi}{wc}{get as offset}
\inst{}{wtb}{wc}{convert offset to bytes}
\inst{}{add}{hshtb,wc}{point to proper hash chain}
\inst{}{sub}{*vrnxt,wc}{subtract offset to merge into loop}
\vfill\break

\lnie
\endln
\lnie
gtnvr (continued)\endln
\lnie
\endln
\lnie
loop to search hash chain\endln
\lnie
\endln
\inst{gnv03}{mov}{wc,xl}{copy hash chain pointer}
\inst{}{mov}{vrnxt(xl),xl}{point to next vrblk on chain}
\inst{}{bze}{xl,gnv08}{jump if end of chain}
\inst{}{mov}{xl,wc}{save pointer to this vrblk}
\inst{}{bnz}{vrlen(xl),gnv04}{jump if not system variable}
\inst{}{mov}{vrsvp(xl),xl}{else point to svblk}
\inst{}{sub}{*vrsof,xl}{adjust offset for merge}
\lnie
\endln
\lnie
merge here with string ptr (like vrblk) in xl\endln
\lnie
\endln
\inst{gnv04}{bne}{wa,vrlen(xl),gnv03}{back for next vrblk if lengths ne}
\inst{}{add}{*vrchs,xl}{else point to chars of chain entry}
\inst{}{lct}{wb,gnvnw}{get word counter to control loop}
\inst{}{mov}{gnvst,xr}{point to chars of new name}
\lnie
\endln
\lnie
loop to compare characters of the two names\endln
\lnie
\endln
\inst{gnv05}{cne}{(xr),(xl),gnv03}{jump if no match for next vrblk}
\inst{}{ica}{xr}{bump new name pointer}
\inst{}{ica}{xl}{bump vrblk in chain name pointer}
\inst{}{bct}{wb,gnv05}{else loop till all compared}
\inst{}{mov}{wc,xr}{we have found a match, get vrblk}
\lnie
\endln
\lnie
exit point after finding vrblk or building new one\endln
\lnie
\endln
\inst{gnv06}{mov}{gnvsa,wa}{restore wa}
\inst{}{mov}{gnvsb,wb}{restore wb}
\inst{}{ica}{xs}{pop string pointer}
\inst{}{mov}{(xs)+,xl}{restore xl}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{gnv07}{exi}{}{return to gtnvr caller}
\lnie
\endln
\lnie
not found, prepare to search system variable table\endln
\lnie
\endln
\inst{gnv08}{zer}{xr}{clear garbage xr pointer}
\inst{}{mov}{wc,gnvhe}{save ptr to end of hash chain}
\inst{}{bgt}{wa,=num09,gnv14}{cannot be system var if length gt 9}
\inst{}{mov}{wa,xl}{else copy length}
\inst{}{wtb}{xl}{convert to byte offset}
\inst{}{mov}{vsrch(xl),xl}{point to first svblk of this length}
\vfill\break

\lnie
\endln
\lnie
gtnvr (continued)\endln
\lnie
\endln
\lnie
loop to search entries in standard variable table\endln
\lnie
\endln
\inst{gnv09}{mov}{xl,gnvsp}{save table pointer}
\inst{}{mov}{(xl)+,wc}{load svbit bit string}
\inst{}{mov}{(xl)+,wb}{load length from table entry}
\inst{}{bne}{wa,wb,gnv14}{jump if end of right length entries}
\inst{}{lct}{wb,gnvnw}{get word counter to control loop}
\inst{}{mov}{gnvst,xr}{point to chars of new name}
\lnie
\endln
\lnie
loop to check for matching names\endln
\lnie
\endln
\inst{gnv10}{cne}{(xr),(xl),gnv11}{jump if name mismatch}
\inst{}{ica}{xr}{else bump new name pointer}
\inst{}{ica}{xl}{bump svblk pointer}
\inst{}{bct}{wb,gnv10}{else loop until all checked}
\lnie
\endln
\lnie
here we have a match in the standard variable table\endln
\lnie
\endln
\inst{}{zer}{wc}{set vrlen value zero}
\inst{}{mov}{*vrsi$,wa}{set standard size}
\inst{}{brn}{gnv15}{jump to build vrblk}
\lnie
\endln
\lnie
here if no match with table entry in svblks table\endln
\lnie
\endln
\inst{gnv11}{ica}{xl}{bump past word of chars}
\inst{}{bct}{wb,gnv11}{loop back if more to go}
\inst{}{rsh}{wc,svnbt}{remove uninteresting bits}
\lnie
\endln
\lnie
loop to bump table ptr for each flagged word\endln
\lnie
\endln
\inst{gnv12}{mov}{bits1,wb}{load bit to test}
\inst{}{anb}{wc,wb}{test for word present}
\inst{}{zrb}{wb,gnv13}{jump if not present}
\inst{}{ica}{xl}{else bump table pointer}
\lnie
\endln
\lnie
here after dealing with one word (one bit)\endln
\lnie
\endln
\inst{gnv13}{rsh}{wc,1}{remove bit already processed}
\inst{}{nzb}{wc,gnv12}{loop back if more bits to test}
\inst{}{brn}{gnv09}{else loop back for next svblk}
\lnie
\endln
\lnie
here if not system variable\endln
\lnie
\endln
\inst{gnv14}{mov}{wa,wc}{copy vrlen value}
\inst{}{mov}{=vrchs,wa}{load standard size -chars}
\inst{}{add}{gnvnw,wa}{adjust for chars of name}
\inst{}{wtb}{wa}{convert length to bytes}
\vfill\break

\lnie
\endln
\lnie
gtnvr (continued)\endln
\lnie
\endln
\lnie
merge here to build vrblk\endln
\lnie
\endln
\inst{gnv15}{jsr}{alost}{allocate space for vrblk (static)}
\inst{}{mov}{xr,wb}{save vrblk pointer}
\inst{}{mov}{=stnvr,xl}{point to model variable block}
\inst{}{mov}{*vrlen,wa}{set length of standard fields}
\inst{}{mvw}{}{set initial fields of new block}
\inst{}{mov}{gnvhe,xl}{load pointer to end of hash chain}
\inst{}{mov}{wb,vrnxt(xl)}{add new block to end of chain}
\inst{}{mov}{wc,(xr)+}{set vrlen field, bump ptr}
\inst{}{mov}{gnvnw,wa}{get length in words}
\inst{}{wtb}{wa}{convert to length in bytes}
\inst{}{bze}{wc,gnv16}{jump if system variable}
\lnie
\endln
\lnie
here for non-system variable -- set chars of name\endln
\lnie
\endln
\inst{}{mov}{(xs),xl}{point back to string name}
\inst{}{add}{*schar,xl}{point to chars of name}
\inst{}{mvw}{}{move characters into place}
\inst{}{mov}{wb,xr}{restore vrblk pointer}
\inst{}{brn}{gnv06}{jump back to exit}
\lnie
\endln
\lnie
here for system variable case to fill in fields where\endln
\lnie
necessary from the fields present in the svblk.\endln
\lnie
\endln
\inst{gnv16}{mov}{gnvsp,xl}{load pointer to svblk}
\inst{}{mov}{xl,(xr)}{set svblk ptr in vrblk}
\inst{}{mov}{wb,xr}{restore vrblk pointer}
\inst{}{mov}{svbit(xl),wb}{load bit indicators}
\inst{}{add}{*svchs,xl}{point to characters of name}
\inst{}{add}{wa,xl}{point past characters}
\lnie
\endln
\lnie
skip past keyword number (svknm) if present\endln
\lnie
\endln
\inst{}{mov}{btknm,wc}{load test bit}
\inst{}{anb}{wb,wc}{and to test}
\inst{}{zrb}{wc,gnv17}{jump if no keyword number}
\inst{}{ica}{xl}{else bump pointer}
\vfill\break

\lnie
\endln
\lnie
gtnvr (continued)\endln
\lnie
\endln
\lnie
here test for function (svfnc and svnar)\endln
\lnie
\endln
\inst{gnv17}{mov}{btfnc,wc}{get test bit}
\inst{}{anb}{wb,wc}{and to test}
\inst{}{zrb}{wc,gnv18}{skip if no system function}
\inst{}{mov}{xl,vrfnc(xr)}{else point vrfnc to svfnc field}
\inst{}{add}{*num02,xl}{and bump past svfnc, svnar fields}
\lnie
\endln
\lnie
now test for label (svlbl)\endln
\lnie
\endln
\inst{gnv18}{mov}{btlbl,wc}{get test bit}
\inst{}{anb}{wb,wc}{and to test}
\inst{}{zrb}{wc,gnv19}{jump if bit is off (no system labl)}
\inst{}{mov}{xl,vrlbl(xr)}{else point vrlbl to svlbl field}
\inst{}{ica}{xl}{bump past svlbl field}
\lnie
\endln
\lnie
now test for value (svval)\endln
\lnie
\endln
\inst{gnv19}{mov}{btval,wc}{load test bit}
\inst{}{anb}{wb,wc}{and to test}
\inst{}{zrb}{wc,gnv06}{all done if no value}
\inst{}{mov}{(xl),vrval(xr)}{else set initial value}
\inst{}{mov}{=b$vre,vrsto(xr)}{set error store access}
\inst{}{brn}{gnv06}{merge back to exit to caller}
\inst{}{enp}{}{end procedure gtnvr}
\vfill\break

\lnie
\endln
\lnie
gtpat -- get pattern\endln
\lnie
\endln
\lnie
gtpat is passed an object in (xr) and returns a\endln
\lnie
pattern after performing any necessary conversions\endln
\lnie
\endln
\lnie
(xr)                  input argument\endln
\lnie
jsr  gtpat            call to convert to pattern\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  resulting pattern\endln
\lnie
(wa)                  destroyed\endln
\lnie
(wb)                  destroyed (only on convert error)\endln
\lnie
(xr)                  unchanged (only on convert error)\endln
\lnie
\endln
\inst{gtpat}{prc}{e,1}{entry point}
\inst{}{bhi}{(xr),=p$aaa,gtpt5}{jump if pattern already}
\lnie
\endln
\lnie
here if not pattern, try for string\endln
\lnie
\endln
\inst{}{mov}{wb,gtpsb}{save wb}
\inst{}{mov}{xr,-(xs)}{stack argument for gtstg}
\inst{}{jsr}{gtstg}{convert argument to string}
\inst{}{ppm}{gtpt2}{jump if impossible}
\lnie
\endln
\lnie
here we have a string\endln
\lnie
\endln
\inst{}{bnz}{wa,gtpt1}{jump if non-null}
\lnie
\endln
\lnie
here for null string. generate pointer to null pattern.\endln
\lnie
\endln
\inst{}{mov}{=ndnth,xr}{point to nothen node}
\inst{}{brn}{gtpt4}{jump to exit}
\vfill\break

\lnie
\endln
\lnie
gtpat (continued)\endln
\lnie
\endln
\lnie
here for non-null string\endln
\lnie
\endln
\inst{gtpt1}{mov}{=p$str,wb}{load pcode for multi-char string}
\inst{}{bne}{wa,=num01,gtpt3}{jump if multi-char string}
\lnie
\endln
\lnie
here for one character string, share one character any\endln
\lnie
\endln
\inst{}{plc}{xr}{point to character}
\inst{}{lch}{wa,(xr)}{load character}
\inst{}{mov}{wa,xr}{set as parm1}
\inst{}{mov}{=p$ans,wb}{point to pcode for 1-char any}
\inst{}{brn}{gtpt3}{jump to build node}
\lnie
\endln
\lnie
here if argument is not convertible to string\endln
\lnie
\endln
\inst{gtpt2}{mov}{=p$exa,wb}{set pcode for expression in case}
\inst{}{blo}{(xr),=b$e$$,gtpt3}{jump to build node if expression}
\lnie
\endln
\lnie
here we have an error (conversion impossible)\endln
\lnie
\endln
\inst{}{exi}{1}{take convert error exit}
\lnie
\endln
\lnie
merge here to build node for string or expression\endln
\lnie
\endln
\inst{gtpt3}{jsr}{pbild}{call routine to build pattern node}
\lnie
\endln
\lnie
common exit after successful conversion\endln
\lnie
\endln
\inst{gtpt4}{mov}{gtpsb,wb}{restore wb}
\lnie
\endln
\lnie
merge here to exit if no conversion required\endln
\lnie
\endln
\inst{gtpt5}{exi}{}{return to gtpat caller}
\inst{}{enp}{}{end procedure gtpat}
\ifmac{.cnra}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
gtrea -- get real value\endln
\lnie
\endln
\lnie
gtrea is passed an object and returns a real value\endln
\lnie
performing any necessary conversions.\endln
\lnie
\endln
\lnie
(xr)                  object to be converted\endln
\lnie
jsr  gtrea            call to convert object to real\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  pointer to resulting real\endln
\lnie
(wa,wb,wc,ra)         destroyed\endln
\lnie
(xr)                  unchanged (convert error only)\endln
\lnie
\endln
\inst{gtrea}{prc}{e,1}{entry point}
\inst{}{mov}{(xr),wa}{get first word of block}
\inst{}{beq}{wa,=b$rcl,gtre2}{jump if real}
\inst{}{jsr}{gtnum}{else convert argument to numeric}
\inst{}{ppm}{gtre3}{jump if unconvertible}
\inst{}{beq}{wa,=b$rcl,gtre2}{jump if real was returned}
\lnie
\endln
\lnie
here for case of an integer to convert to real\endln
\lnie
\endln
\inst{gtre1}{ldi}{icval(xr)}{load integer}
\inst{}{itr}{}{convert to real}
\inst{}{jsr}{rcbld}{build rcblk}
\lnie
\endln
\lnie
exit with real\endln
\lnie
\endln
\inst{gtre2}{exi}{}{return to gtrea caller}
\lnie
\endln
\lnie
here on conversion error\endln
\lnie
\endln
\inst{gtre3}{exi}{1}{take convert error exit}
\inst{}{enp}{}{end procedure gtrea}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
gtsmi -- get small integer\endln
\lnie
\endln
\lnie
gtsmi is passed a snobol object and returns an address\endln
\lnie
integer in the range (0 le n le dnamb). such a value can\endln
\lnie
only be derived from an integer in the appropriate range.\endln
\lnie
small integers never appear as snobol values. however,\endln
\lnie
they are used internally for a variety of purposes.\endln
\lnie
\endln
\lnie
-(xs)                 argument to convert (on stack)\endln
\lnie
jsr  gtsmi            call to convert to small integer\endln
\lnie
ppm  loc              transfer loc for not integer\endln
\lnie
ppm  loc              transfer loc for lt 0, gt dnamb\endln
\lnie
(xr,wc)               resulting small int (two copies)\endln
\lnie
(xs)                  popped\endln
\lnie
(ra)                  destroyed\endln
\lnie
(wa,wb)               destroyed (on convert error only)\endln
\lnie
(xr)                  input arg (convert error only)\endln
\lnie
\endln
\inst{gtsmi}{prc}{n,2}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument}
\inst{}{beq}{(xr),=b$icl,gtsm1}{skip if already an integer}
\lnie
\endln
\lnie
here if not an integer\endln
\lnie
\endln
\inst{}{jsr}{gtint}{convert argument to integer}
\inst{}{ppm}{gtsm2}{jump if convert is impossible}
\lnie
\endln
\lnie
merge here with integer\endln
\lnie
\endln
\inst{gtsm1}{ldi}{icval(xr)}{load integer value}
\inst{}{mfi}{wc,gtsm3}{move as one word, jump if ovflow}
\inst{}{bgt}{wc,mxlen,gtsm3}{or if too large}
\inst{}{mov}{wc,xr}{copy result to xr}
\inst{}{exi}{}{return to gtsmi caller}
\lnie
\endln
\lnie
here if unconvertible to integer\endln
\lnie
\endln
\inst{gtsm2}{exi}{1}{take non-integer error exit}
\lnie
\endln
\lnie
here if out of range\endln
\lnie
\endln
\inst{gtsm3}{exi}{2}{take out-of-range error exit}
\inst{}{enp}{}{end procedure gtsmi}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
gtstb -- get string or buffer\endln
\lnie
\endln
\lnie
gtstb is passed an object and returns it unchanged if\endln
\lnie
it is a buffer block, else it returns it as a string with\endln
\lnie
any necessary conversions performed.\endln
\lnie
\endln
\lnie
-(xs)                 input argument (on stack)\endln
\lnie
jsr  gtstb            call to get buffer or cnvrt to stg\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  pointer to resulting scblk or bfblk\endln
\lnie
(wa)                  length of string in characters\endln
\lnie
(wb)                  zero/bcblk if string/buffer\endln
\lnie
(xs)                  popped\endln
\lnie
(ra)                  destroyed\endln
\lnie
(xr)                  input arg (convert error only)\endln
\lnie
\endln
\inst{gtstb}{prc}{n,1}{entry point}
\inst{}{mov}{(xs),xr}{load argument, leave on stack}
\inst{}{mov}{(xr),wa}{load block type}
\inst{}{beq}{wa,=b$scl,gtsb2}{jump if already a string}
\inst{}{beq}{wa,=b$bct,gtsb3}{jump if already a buffer}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{gtsb1}{conversion failed}
\inst{}{zer}{wb}{signal string result}
\inst{}{exi}{}{convert with string result}
\lnie
\endln
\lnie
here if conversion failed\endln
\lnie
\endln
\inst{gtsb1}{exi}{1}{take convert error exit}
\lnie
\endln
\lnie
here if a string already\endln
\lnie
\endln
\inst{gtsb2}{ica}{xs}{pop argument}
\inst{}{mov}{sclen(xr),wa}{load string length}
\inst{}{zer}{wb}{signal string result}
\inst{}{exi}{}{return with string result}
\lnie
\endln
\lnie
here if it is already a buffer\endln
\lnie
\endln
\inst{gtsb3}{ica}{xs}{pop argument}
\inst{}{mov}{bclen(xr),wa}{load length of string in buffer}
\inst{}{mov}{xr,wb}{return bcblk pointer in wb}
\inst{}{mov}{bcbuf(xr),xr}{return bfblk pointer in xr}
\inst{}{exi}{}{return with buffer result}
\inst{}{enp}{}{end procedure gtstg}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
gtstg -- get string\endln
\lnie
\endln
\lnie
gtstg is passed an object and returns a string with\endln
\lnie
any necessary conversions performed.\endln
\lnie
\endln
\lnie
-(xs)                 input argument (on stack)\endln
\lnie
jsr  gtstg            call to convert to string\endln
\lnie
ppm  loc              transfer loc if convert impossible\endln
\lnie
(xr)                  pointer to resulting string\endln
\lnie
(wa)                  length of string in characters\endln
\lnie
(xs)                  popped\endln
\lnie
(ra)                  destroyed\endln
\lnie
(xr)                  input arg (convert error only)\endln
\lnie
\endln
\inst{gtstg}{prc}{n,1}{entry point}
\inst{}{mov}{(xs)+,xr}{load argument, pop stack}
\inst{}{beq}{(xr),=b$scl,gts30}{jump if already a string}
\lnie
\endln
\lnie
here if not a string already\endln
\lnie
\endln
\inst{gts01}{mov}{xr,-(xs)}{restack argument in case error}
\inst{}{mov}{xl,-(xs)}{save xl}
\inst{}{mov}{wb,gtsvb}{save wb}
\inst{}{mov}{wc,gtsvc}{save wc}
\inst{}{mov}{(xr),wa}{load first word of block}
\inst{}{beq}{wa,=b$icl,gts05}{jump to convert integer}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wa,=b$rcl,gts10}{jump to convert real}
\asmac{fi}
\inst{}{beq}{wa,=b$nml,gts03}{jump to convert name}
\ifmac{.cnbf}
\asmac{else}
\inst{}{beq}{wa,=b$bct,gts32}{jump to convert buffer}
\asmac{fi}
\lnie
\endln
\lnie
here on conversion error\endln
\lnie
\endln
\inst{gts02}{mov}{(xs)+,xl}{restore xl}
\inst{}{mov}{(xs)+,xr}{reload input argument}
\inst{}{exi}{1}{take convert error exit}
\vfill\break

\lnie
\endln
\lnie
gtstg (continued)\endln
\lnie
\endln
\lnie
here to convert a name (only possible if natural var)\endln
\lnie
\endln
\inst{gts03}{mov}{nmbas(xr),xl}{load name base}
\inst{}{bhi}{xl,state,gts02}{error if not natural var (static)}
\inst{}{add}{*vrsof,xl}{else point to possible string name}
\inst{}{mov}{sclen(xl),wa}{load length}
\inst{}{bnz}{wa,gts04}{jump if not system variable}
\inst{}{mov}{vrsvo(xl),xl}{else point to svblk}
\inst{}{mov}{svlen(xl),wa}{and load name length}
\lnie
\endln
\lnie
merge here with string in xr, length in wa\endln
\lnie
\endln
\inst{gts04}{zer}{wb}{set offset to zero}
\inst{}{jsr}{sbstr}{use sbstr to copy string}
\inst{}{brn}{gts29}{jump to exit}
\lnie
\endln
\lnie
come here to convert an integer\endln
\lnie
\endln
\inst{gts05}{ldi}{icval(xr)}{load integer value}
\ifmac{.cnci}
\inst{}{jsr}{sysci}{convert integer}
\inst{}{mov}{sclen(xl),wa}{get length}
\inst{}{zer}{wb}{zero offset for sbstr}
\inst{}{jsr}{sbstr}{copy in result from sysci}
\inst{}{brn}{gts29}{exit}
\asmac{else}
\inst{}{mov}{=num01,gtssf}{set sign flag negative}
\inst{}{ilt}{gts06}{skip if integer is negative}
\inst{}{ngi}{}{else negate integer}
\inst{}{zer}{gtssf}{and reset negative flag}
\vfill\break

\lnie
\endln
\lnie
gtstg (continued)\endln
\lnie
\endln
\lnie
here with sign flag set and sign forced negative as\endln
\lnie
required by the cvd instruction.\endln
\lnie
\endln
\inst{gts06}{mov}{gtswk,xr}{point to result work area}
\inst{}{mov}{=nstmx,wb}{initialize counter to max length}
\inst{}{psc}{xr,wb}{prepare to store (right-left)}
\lnie
\endln
\lnie
loop to convert digits into work area\endln
\lnie
\endln
\inst{gts07}{cvd}{}{convert one digit into wa}
\inst{}{sch}{wa,-(xr)}{store in work area}
\inst{}{dcv}{wb}{decrement counter}
\inst{}{ine}{gts07}{loop if more digits to go}
\inst{}{csc}{xr}{complete store characters}
\asmac{fi}
\lnie
\endln
\lnie
merge here after converting integer or real into work\endln
\lnie
area. wb is set to nstmx - (number of chars in result).\endln
\lnie
\endln
\inst{gts08}{mov}{=nstmx,wa}{get max number of characters}
\inst{}{sub}{wb,wa}{compute length of result}
\inst{}{mov}{wa,xl}{remember length for move later on}
\inst{}{add}{gtssf,wa}{add one for negative sign if needed}
\inst{}{jsr}{alocs}{allocate string for result}
\inst{}{mov}{xr,wc}{save result pointer for the moment}
\inst{}{psc}{xr}{point to chars of result block}
\inst{}{bze}{gtssf,gts09}{skip if positive}
\inst{}{mov}{=ch$mn,wa}{else load negative sign}
\inst{}{sch}{wa,(xr)+}{and store it}
\inst{}{csc}{xr}{complete store characters}
\lnie
\endln
\lnie
here after dealing with sign\endln
\lnie
\endln
\inst{gts09}{mov}{xl,wa}{recall length to move}
\inst{}{mov}{gtswk,xl}{point to result work area}
\inst{}{plc}{xl,wb}{point to first result character}
\inst{}{mvc}{}{move chars to result string}
\inst{}{mov}{wc,xr}{restore result pointer}
\ifmac{.cnra}
\asmac{else}
\inst{}{brn}{gts29}{jump to exit}
\vfill\break

\lnie
\endln
\lnie
gtstg (continued)\endln
\lnie
\endln
\lnie
here to convert a real\endln
\lnie
\endln
\inst{gts10}{ldr}{rcval(xr)}{load real}
\ifmac{.cncr}
\inst{}{mov}{=nstmr,wa}{max number of result chars}
\inst{}{zer}{xl}{clear dud value}
\inst{}{jsr}{alocs}{allocate result area}
\inst{}{mov}{=cfp$s,wa}{significant digits to produce}
\inst{}{zer}{wb}{conversion type}
\inst{}{jsr}{syscr}{convert real to string}
\inst{}{mov}{wa,sclen(xr)}{store result size}
\inst{}{zer}{wb}{no trailing blanks to remove}
\inst{}{jsr}{trimr}{discard excess memory}
\asmac{else}
\inst{}{zer}{gtssf}{reset negative flag}
\inst{}{req}{gts31}{skip if zero}
\inst{}{rge}{gts11}{jump if real is positive}
\inst{}{mov}{=num01,gtssf}{else set negative flag}
\inst{}{ngr}{}{and get absolute value of real}
\lnie
\endln
\lnie
now scale the real to the range (0.1 le x lt 1.0)\endln
\lnie
\endln
\inst{gts11}{ldi}{intv0}{initialize exponent to zero}
\lnie
\endln
\lnie
loop to scale up in steps of 10**10\endln
\lnie
\endln
\inst{gts12}{str}{gtsrs}{save real value}
\inst{}{sbr}{reap1}{subtract 0.1 to compare}
\inst{}{rge}{gts13}{jump if scale up not required}
\inst{}{ldr}{gtsrs}{else reload value}
\inst{}{mlr}{reatt}{multiply by 10**10}
\inst{}{sbi}{intvt}{decrement exponent by 10}
\inst{}{brn}{gts12}{loop back to test again}
\lnie
\endln
\lnie
test for scale down required\endln
\lnie
\endln
\inst{gts13}{ldr}{gtsrs}{reload value}
\inst{}{sbr}{reav1}{subtract 1.0}
\inst{}{rlt}{gts17}{jump if no scale down required}
\inst{}{ldr}{gtsrs}{else reload value}
\lnie
\endln
\lnie
loop to scale down in steps of 10**10\endln
\lnie
\endln
\inst{gts14}{sbr}{reatt}{subtract 10**10 to compare}
\inst{}{rlt}{gts15}{jump if large step not required}
\inst{}{ldr}{gtsrs}{else restore value}
\inst{}{dvr}{reatt}{divide by 10**10}
\inst{}{str}{gtsrs}{store new value}
\inst{}{adi}{intvt}{increment exponent by 10}
\inst{}{brn}{gts14}{loop back}
\vfill\break

\lnie
\endln
\lnie
gtstg (continued)\endln
\lnie
\endln
\lnie
at this point we have (1.0 le x lt 10**10)\endln
\lnie
complete scaling with powers of ten table\endln
\lnie
\endln
\inst{gts15}{mov}{=reav1,xr}{point to powers of ten table}
\lnie
\endln
\lnie
loop to locate correct entry in table\endln
\lnie
\endln
\inst{gts16}{ldr}{gtsrs}{reload value}
\inst{}{adi}{intv1}{increment exponent}
\inst{}{add}{*cfp$r,xr}{point to next entry in table}
\inst{}{sbr}{(xr)}{subtract it to compare}
\inst{}{rge}{gts16}{loop till we find a larger entry}
\inst{}{ldr}{gtsrs}{then reload the value}
\inst{}{dvr}{(xr)}{and complete scaling}
\inst{}{str}{gtsrs}{store value}
\lnie
\endln
\lnie
we are now scaled, so round by adding 0.5 * 10**(-cfp$s)\endln
\lnie
\endln
\inst{gts17}{ldr}{gtsrs}{get value again}
\inst{}{adr}{gtsrn}{add rounding factor}
\inst{}{str}{gtsrs}{store result}
\lnie
\endln
\lnie
the rounding operation may have pushed us up past\endln
\lnie
1.0 again, so check one more time.\endln
\lnie
\endln
\inst{}{sbr}{reav1}{subtract 1.0 to compare}
\inst{}{rlt}{gts18}{skip if ok}
\inst{}{adi}{intv1}{else increment exponent}
\inst{}{ldr}{gtsrs}{reload value}
\inst{}{dvr}{reavt}{divide by 10.0 to rescale}
\inst{}{brn}{gts19}{jump to merge}
\lnie
\endln
\lnie
here if rounding did not muck up scaling\endln
\lnie
\endln
\inst{gts18}{ldr}{gtsrs}{reload rounded value}
\vfill\break

\lnie
\endln
\lnie
gtstg (continued)\endln
\lnie
\endln
\lnie
now we have completed the scaling as follows\endln
\lnie
\endln
\lnie
(ia)                  signed exponent\endln
\lnie
(ra)                  scaled real (absolute value)\endln
\lnie
\endln
\lnie
if the exponent is negative or greater than cfp$s, then\endln
\lnie
we convert the number in the form.\endln
\lnie
\endln
\lnie
(neg sign) 0 . (cpf$s digits) e (exp sign) (exp digits)\endln
\lnie
\endln
\lnie
if the exponent is positive and less than or equal to\endln
\lnie
cfp$s, the number is converted in the form.\endln
\lnie
\endln
\lnie
(neg sign) (exponent digits) . (cfp$s-exponent digits)\endln
\lnie
\endln
\lnie
in both cases, the formats obtained from the above\endln
\lnie
rules are modified by deleting trailing zeros after the\endln
\lnie
decimal point. there are no leading zeros in the exponent\endln
\lnie
and the exponent sign is always present.\endln
\lnie
\endln
\inst{gts19}{mov}{=cfp$s,xl}{set num dec digits = cfp$s}
\inst{}{mov}{=ch$mn,gtses}{set exponent sign negative}
\inst{}{ilt}{gts21}{all set if exponent is negative}
\inst{}{mfi}{wa}{else fetch exponent}
\inst{}{ble}{wa,=cfp$s,gts20}{skip if we can use special format}
\inst{}{mti}{wa}{else restore exponent}
\inst{}{ngi}{}{set negative for cvd}
\inst{}{mov}{=ch$pl,gtses}{set plus sign for exponent sign}
\inst{}{brn}{gts21}{jump to generate exponent}
\lnie
\endln
\lnie
here if we can use the format without an exponent\endln
\lnie
\endln
\inst{gts20}{sub}{wa,xl}{compute digits after decimal point}
\inst{}{ldi}{intv0}{reset exponent to zero}
\vfill\break

\lnie
\endln
\lnie
gtstg (continued)\endln
\lnie
\endln
\lnie
merge here as follows\endln
\lnie
\endln
\lnie
(ia)                  exponent absolute value\endln
\lnie
gtses                 character for exponent sign\endln
\lnie
(ra)                  positive fraction\endln
\lnie
(xl)                  number of digits after dec point\endln
\lnie
\endln
\inst{gts21}{mov}{gtswk,xr}{point to work area}
\inst{}{mov}{=nstmx,wb}{set character ctr to max length}
\inst{}{psc}{xr,wb}{prepare to store (right to left)}
\inst{}{ieq}{gts23}{skip exponent if it is zero}
\lnie
\endln
\lnie
loop to generate digits of exponent\endln
\lnie
\endln
\inst{gts22}{cvd}{}{convert a digit into wa}
\inst{}{sch}{wa,-(xr)}{store in work area}
\inst{}{dcv}{wb}{decrement counter}
\inst{}{ine}{gts22}{loop back if more digits to go}
\lnie
\endln
\lnie
here generate exponent sign and e\endln
\lnie
\endln
\inst{}{mov}{gtses,wa}{load exponent sign}
\inst{}{sch}{wa,-(xr)}{store in work area}
\inst{}{mov}{=ch$le,wa}{get character letter e}
\inst{}{sch}{wa,-(xr)}{store in work area}
\inst{}{sub}{=num02,wb}{decrement counter for sign and e}
\lnie
\endln
\lnie
here to generate the fraction\endln
\lnie
\endln
\inst{gts23}{mlr}{gtssc}{convert real to integer (10**cfp$s)}
\inst{}{rti}{}{get integer (overflow impossible)}
\inst{}{ngi}{}{negate as required by cvd}
\lnie
\endln
\lnie
loop to suppress trailing zeros\endln
\lnie
\endln
\inst{gts24}{bze}{xl,gts27}{jump if no digits left to do}
\inst{}{cvd}{}{else convert one digit}
\inst{}{bne}{wa,=ch$d0,gts26}{jump if not a zero}
\inst{}{dcv}{xl}{decrement counter}
\inst{}{brn}{gts24}{loop back for next digit}
\vfill\break

\lnie
\endln
\lnie
gtstg (continued)\endln
\lnie
\endln
\lnie
loop to generate digits after decimal point\endln
\lnie
\endln
\inst{gts25}{cvd}{}{convert a digit into wa}
\lnie
\endln
\lnie
merge here first time\endln
\lnie
\endln
\inst{gts26}{sch}{wa,-(xr)}{store digit}
\inst{}{dcv}{wb}{decrement counter}
\inst{}{dcv}{xl}{decrement counter}
\inst{}{bnz}{xl,gts25}{loop back if more to go}
\lnie
\endln
\lnie
here generate the decimal point\endln
\lnie
\endln
\inst{gts27}{mov}{=ch$dt,wa}{load decimal point}
\inst{}{sch}{wa,-(xr)}{store in work area}
\inst{}{dcv}{wb}{decrement counter}
\lnie
\endln
\lnie
here generate the digits before the decimal point\endln
\lnie
\endln
\inst{gts28}{cvd}{}{convert a digit into wa}
\inst{}{sch}{wa,-(xr)}{store in work area}
\inst{}{dcv}{wb}{decrement counter}
\inst{}{ine}{gts28}{loop back if more to go}
\inst{}{csc}{xr}{complete store characters}
\inst{}{brn}{gts08}{else jump back to exit}
\asmac{fi}
\asmac{fi}
\lnie
\endln
\lnie
exit point after successful conversion\endln
\lnie
\endln
\inst{gts29}{mov}{(xs)+,xl}{restore xl}
\inst{}{ica}{xs}{pop argument}
\inst{}{mov}{gtsvb,wb}{restore wb}
\inst{}{mov}{gtsvc,wc}{restore wc}
\lnie
\endln
\lnie
merge here if no conversion required\endln
\lnie
\endln
\inst{gts30}{mov}{sclen(xr),wa}{load string length}
\inst{}{exi}{}{return to caller}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here to return string for real zero\endln
\lnie
\endln
\inst{gts31}{mov}{=scre0,xl}{point to string}
\inst{}{mov}{=num02,wa}{2 chars}
\inst{}{zer}{wb}{zero offset}
\inst{}{jsr}{sbstr}{copy string}
\inst{}{brn}{gts29}{return}
\asmac{fi}
\ifmac{.cnbf}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
here to convert a buffer block\endln
\lnie
\endln
\inst{gts32}{mov}{xr,xl}{copy arg ptr}
\inst{}{mov}{bclen(xl),wa}{get size to allocate}
\inst{}{bze}{wa,gts33}{if null then return null}
\inst{}{jsr}{alocs}{allocate string frame}
\inst{}{mov}{xr,wb}{save string ptr}
\inst{}{mov}{sclen(xr),wa}{get length to move}
\inst{}{ctb}{wa,0}{get as multiple of word size}
\inst{}{mov}{bcbuf(xl),xl}{point to bfblk}
\inst{}{add}{*scsi$,xr}{point to start of character area}
\inst{}{add}{*bfsi$,xl}{point to start of buffer chars}
\inst{}{mvw}{}{copy words}
\inst{}{mov}{wb,xr}{restore scblk ptr}
\inst{}{brn}{gts29}{exit with scblk}
\lnie
\endln
\lnie
here when null buffer is being converted\endln
\lnie
\endln
\inst{gts33}{mov}{=nulls,xr}{point to null}
\inst{}{brn}{gts29}{exit with null}
\asmac{fi}
\inst{}{enp}{}{end procedure gtstg}
\vfill\break

\lnie
\endln
\lnie
gtvar -- get variable for i/o/trace association\endln
\lnie
\endln
\lnie
gtvar is used to point to an actual variable location\endln
\lnie
for the detach,input,output,trace,stoptr system functions\endln
\lnie
\endln
\lnie
(xr)                  argument to function\endln
\lnie
jsr  gtvar            call to locate variable pointer\endln
\lnie
ppm  loc              transfer loc if not ok variable\endln
\lnie
(xl,wa)               name base,offset of variable\endln
\lnie
(xr,ra)               destroyed\endln
\lnie
(wb,wc)               destroyed (convert error only)\endln
\lnie
(xr)                  input arg (convert error only)\endln
\lnie
\endln
\inst{gtvar}{prc}{e,1}{entry point}
\inst{}{bne}{(xr),=b$nml,gtvr2}{jump if not a name}
\inst{}{mov}{nmofs(xr),wa}{else load name offset}
\inst{}{mov}{nmbas(xr),xl}{load name base}
\inst{}{beq}{(xl),=b$evt,gtvr1}{error if expression variable}
\inst{}{bne}{(xl),=b$kvt,gtvr3}{all ok if not keyword variable}
\lnie
\endln
\lnie
here on conversion error\endln
\lnie
\endln
\inst{gtvr1}{exi}{1}{take convert error exit}
\lnie
\endln
\lnie
here if not a name, try convert to natural variable\endln
\lnie
\endln
\inst{gtvr2}{mov}{wc,gtvrc}{save wc}
\inst{}{jsr}{gtnvr}{locate vrblk if possible}
\inst{}{ppm}{gtvr1}{jump if convert error}
\inst{}{mov}{xr,xl}{else copy vrblk name base}
\inst{}{mov}{*vrval,wa}{and set offset}
\inst{}{mov}{gtvrc,wc}{restore wc}
\lnie
\endln
\lnie
here for name obtained\endln
\lnie
\endln
\inst{gtvr3}{bhi}{xl,state,gtvr4}{all ok if not natural variable}
\inst{}{beq}{vrsto(xl),=b$vre,gtvr1}{error if protected variable}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{gtvr4}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure gtvar}
\vfill\break

\lnie
\endln
\lnie
hashs -- compute hash index for string\endln
\lnie
\endln
\lnie
hashs is used to convert a string to a unique integer\endln
\lnie
value. the resulting hash value is a positive integer\endln
\lnie
in the range 0 to cfp$m\endln
\lnie
\endln
\lnie
(xr)                  string to be hashed\endln
\lnie
jsr  hashs            call to hash string\endln
\lnie
(ia)                  hash value\endln
\lnie
(xr,wb,wc)            destroyed\endln
\lnie
\endln
\lnie
the hash function used is as follows.\endln
\lnie
\endln
\lnie
start with the length of the string (sgd07)\endln
\lnie
\endln
\lnie
take the first e$hnw words of the characters from\endln
\lnie
the string or all the words if fewer than e$hnw.\endln
\lnie
\endln
\lnie
compute the exclusive or of all these words treating\endln
\lnie
them as one word bit string values.\endln
\lnie
\endln
\lnie
move the result as an integer with the mti instruction.\endln
\lnie
\endln
\inst{hashs}{prc}{e,0}{entry point}
\inst{}{mov}{sclen(xr),wc}{load string length in characters}
\inst{}{mov}{wc,wb}{initialize with length}
\inst{}{bze}{wc,hshs3}{jump if null string}
\inst{}{zgb}{wb}{correct byte ordering if necessary}
\inst{}{ctw}{wc,0}{get number of words of chars}
\inst{}{add}{*schar,xr}{point to characters of string}
\inst{}{blo}{wc,=e$hnw,hshs1}{use whole string if short}
\inst{}{mov}{=e$hnw,wc}{else set to involve first e$hnw wds}
\lnie
\endln
\lnie
here with count of words to check in wc\endln
\lnie
\endln
\inst{hshs1}{lct}{wc,wc}{set counter to control loop}
\lnie
\endln
\lnie
loop to compute exclusive or\endln
\lnie
\endln
\inst{hshs2}{xob}{(xr)+,wb}{exclusive or next word of chars}
\inst{}{bct}{wc,hshs2}{loop till all processed}
\lnie
\endln
\lnie
merge here with exclusive or in wb\endln
\lnie
\endln
\inst{hshs3}{zgb}{wb}{zeroise undefined bits}
\inst{}{anb}{bitsm,wb}{ensure in range 0 to cfp$m}
\inst{}{mti}{wb}{move result as integer}
\inst{}{zer}{xr}{clear garbage value in xr}
\inst{}{exi}{}{return to hashs caller}
\inst{}{enp}{}{end procedure hashs}
\vfill\break

\lnie
\endln
\lnie
icbld -- build integer block\endln
\lnie
\endln
\lnie
(ia)                  integer value for icblk\endln
\lnie
jsr  icbld            call to build integer block\endln
\lnie
(xr)                  pointer to result icblk\endln
\lnie
(wa)                  destroyed\endln
\lnie
\endln
\inst{icbld}{prc}{e,0}{entry point}
\inst{}{mfi}{xr,icbl1}{copy small integers}
\inst{}{ble}{xr,=num02,icbl3}{jump if 0,1 or 2}
\lnie
\endln
\lnie
construct icblk\endln
\lnie
\endln
\inst{icbl1}{mov}{dnamp,xr}{load pointer to next available loc}
\inst{}{add}{*icsi$,xr}{point past new icblk}
\inst{}{blo}{xr,dname,icbl2}{jump if there is room}
\inst{}{mov}{*icsi$,wa}{else load length of icblk}
\inst{}{jsr}{alloc}{use standard allocator to get block}
\inst{}{add}{wa,xr}{point past block to merge}
\lnie
\endln
\lnie
merge here with xr pointing past the block obtained\endln
\lnie
\endln
\inst{icbl2}{mov}{xr,dnamp}{set new pointer}
\inst{}{sub}{*icsi$,xr}{point back to start of block}
\inst{}{mov}{=b$icl,(xr)}{store type word}
\inst{}{sti}{icval(xr)}{store integer value in icblk}
\inst{}{exi}{}{return to icbld caller}
\lnie
\endln
\lnie
optimise by not building icblks for small integers\endln
\lnie
\endln
\inst{icbl3}{wtb}{xr}{convert integer to offset}
\inst{}{mov}{intab(xr),xr}{point to pre-built icblk}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure icbld}
\vfill\break

\lnie
\endln
\lnie
ident -- compare two values\endln
\lnie
\endln
\lnie
ident compares two values in the sense of the ident\endln
\lnie
differ functions available at the snobol level.\endln
\lnie
\endln
\lnie
(xr)                  first argument\endln
\lnie
(xl)                  second argument\endln
\lnie
jsr  ident            call to compare arguments\endln
\lnie
ppm  loc              transfer loc if ident\endln
\lnie
(normal return if differ)\endln
\lnie
(xr,xl,wc,ra)         destroyed\endln
\lnie
\endln
\inst{ident}{prc}{e,1}{entry point}
\inst{}{beq}{xr,xl,iden7}{jump if same pointer (ident)}
\inst{}{mov}{(xr),wc}{else load arg 1 type word}
\ifmac{.cnbf}
\inst{}{bne}{wc,(xl),iden1}{differ if arg 2 type word differ}
\asmac{else}
\inst{}{bne}{wc,(xl),iden0}{differ if arg 2 type word differ}
\asmac{fi}
\inst{}{beq}{wc,=b$scl,iden2}{jump if strings}
\inst{}{beq}{wc,=b$icl,iden4}{jump if integers}
\ifmac{.cnra}
\asmac{else}
\inst{}{beq}{wc,=b$rcl,iden5}{jump if reals}
\asmac{fi}
\inst{}{beq}{wc,=b$nml,iden6}{jump if names}
\ifmac{.cnbf}
\asmac{else}
\inst{}{bne}{wc,=b$bct,iden1}{jump if not buffers}
\lnie
\endln
\lnie
here for buffers, ident only if lengths and chars same\endln
\lnie
\endln
\inst{}{mov}{bclen(xr),wc}{load arg 1 length}
\inst{}{bne}{wc,bclen(xl),iden1}{differ if lengths differ}
\inst{}{bze}{wc,iden7}{identical if length 0}
\inst{}{mov}{bcbuf(xr),xr}{arg 1 buffer block}
\inst{}{mov}{bcbuf(xl),xl}{arg 2 buffer block}
\inst{}{brn}{idn2a}{compare characters}
\lnie
\endln
\lnie
here if the type words differ.\endln
\lnie
check if string/buffer comparison\endln
\lnie
\endln
\inst{iden0}{beq}{wc,=b$scl,idn0a}{jump if arg 1 is a string}
\inst{}{bne}{wc,=b$bct,iden1}{jump if arg 1 not string or buffer}
\lnie
\endln
\lnie
here if arg 1 is a buffer\endln
\lnie
\endln
\inst{}{bne}{(xl),=b$scl,iden1}{jump if arg 2 is not string}
\inst{}{mov}{bclen(xr),wc}{load arg 1 length}
\inst{}{bne}{wc,sclen(xl),iden1}{differ if lengths differ}
\inst{}{bze}{wc,iden7}{identical if length 0}
\inst{}{mov}{bcbuf(xr),xr}{arg 1 buffer block}
\inst{}{brn}{idn2a}{compare characters}
\lnie
\endln
\lnie
here if arg 1 is a string\endln
\lnie
\endln
\inst{idn0a}{bne}{(xl),=b$bct,iden1}{jump if arg 2 is not buffer}
\inst{}{mov}{sclen(xr),wc}{load arg 1 length}
\inst{}{bne}{wc,bclen(xl),iden1}{differ if lengths differ}
\inst{}{bze}{wc,iden7}{identical if length 0}
\inst{}{mov}{bcbuf(xl),xl}{arg 2 buffer block}
\inst{}{brn}{idn2a}{compare characters}
\asmac{fi}
\lnie
\endln
\lnie
for all other datatypes, must be differ if xr ne xl\endln
\lnie
\endln
\lnie
merge here for differ\endln
\lnie
\endln
\inst{iden1}{exi}{}{take differ exit}
\lnie
\endln
\lnie
here for strings, ident only if lengths and chars same\endln
\lnie
\endln
\inst{iden2}{mov}{sclen(xr),wc}{load arg 1 length}
\inst{}{bne}{wc,sclen(xl),iden1}{differ if lengths differ}
\lnie
\endln
\lnie
buffer and string comparisons merge here\endln
\lnie
\endln
\inst{idn2a}{add}{*schar,xr}{point to chars of arg 1}
\inst{}{add}{*schar,xl}{point to chars of arg 2}
\inst{}{ctw}{wc,0}{get number of words in strings}
\inst{}{lct}{wc,wc}{set loop counter}
\lnie
\endln
\lnie
loop to compare characters. note that wc cannot be zero\endln
\lnie
since all null strings point to nulls and give xl=xr.\endln
\lnie
\endln
\inst{iden3}{cne}{(xr),(xl),iden8}{differ if chars do not match}
\inst{}{ica}{xr}{else bump arg one pointer}
\inst{}{ica}{xl}{bump arg two pointer}
\inst{}{bct}{wc,iden3}{loop back till all checked}
\vfill\break

\lnie
\endln
\lnie
ident (continued)\endln
\lnie
\endln
\lnie
here to exit for case of two ident strings\endln
\lnie
\endln
\inst{}{zer}{xl}{clear garbage value in xl}
\inst{}{zer}{xr}{clear garbage value in xr}
\inst{}{exi}{1}{take ident exit}
\lnie
\endln
\lnie
here for integers, ident if same values\endln
\lnie
\endln
\inst{iden4}{ldi}{icval(xr)}{load arg 1}
\inst{}{sbi}{icval(xl)}{subtract arg 2 to compare}
\inst{}{iov}{iden1}{differ if overflow}
\inst{}{ine}{iden1}{differ if result is not zero}
\inst{}{exi}{1}{take ident exit}
\ifmac{.cnra}
\asmac{else}
\lnie
\endln
\lnie
here for reals, ident if same values\endln
\lnie
\endln
\inst{iden5}{ldr}{rcval(xr)}{load arg 1}
\inst{}{sbr}{rcval(xl)}{subtract arg 2 to compare}
\inst{}{rov}{iden1}{differ if overflow}
\inst{}{rne}{iden1}{differ if result is not zero}
\inst{}{exi}{1}{take ident exit}
\asmac{fi}
\lnie
\endln
\lnie
here for names, ident if bases and offsets same\endln
\lnie
\endln
\inst{iden6}{bne}{nmofs(xr),nmofs(xl),iden1}{differ if different offset}
\inst{}{bne}{nmbas(xr),nmbas(xl),iden1}{differ if different base}
\lnie
\endln
\lnie
merge here to signal ident for identical pointers\endln
\lnie
\endln
\inst{iden7}{exi}{1}{take ident exit}
\lnie
\endln
\lnie
here for differ strings\endln
\lnie
\endln
\inst{iden8}{zer}{xr}{clear garbage ptr in xr}
\inst{}{zer}{xl}{clear garbage ptr in xl}
\inst{}{exi}{}{return to caller (differ)}
\inst{}{enp}{}{end procedure ident}
\vfill\break

\lnie
\endln
\lnie
inout - used to initialise input and output variables\endln
\lnie
\endln
\lnie
(xl)                  pointer to vbl name string\endln
\lnie
(wb)                  trblk type\endln
\lnie
jsr  inout            call to perform initialisation\endln
\lnie
(xl)                  vrblk ptr\endln
\lnie
(xr)                  trblk ptr\endln
\lnie
(wa,wc)               destroyed\endln
\lnie
\endln
\lnie
note that trter (= trtrf) field of standard i/o variables\endln
\lnie
points to corresponding svblk not to a trblk as is the\endln
\lnie
case for ordinary variables.\endln
\lnie
\endln
\inst{inout}{prc}{e,0}{entry point}
\inst{}{mov}{wb,-(xs)}{stack trblk type}
\inst{}{mov}{sclen(xl),wa}{get name length}
\inst{}{zer}{wb}{point to start of name}
\inst{}{jsr}{sbstr}{build a proper scblk}
\inst{}{jsr}{gtnvr}{build vrblk}
\inst{}{ppm}{}{no error return}
\inst{}{mov}{xr,wc}{save vrblk pointer}
\inst{}{mov}{(xs)+,wb}{get trter field}
\inst{}{zer}{xl}{zero trfpt}
\inst{}{jsr}{trbld}{build trblk}
\inst{}{mov}{wc,xl}{recall vrblk pointer}
\inst{}{mov}{vrsvp(xl),trter(xr)}{store svblk pointer}
\inst{}{mov}{xr,vrval(xl)}{store trblk ptr in vrblk}
\inst{}{mov}{=b$vra,vrget(xl)}{set trapped access}
\inst{}{mov}{=b$vrv,vrsto(xl)}{set trapped store}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure inout}
\vfill\break

\ifmac{.cnbf}
\asmac{else}
\lnie
\endln
\lnie
insbf -- insert string in buffer\endln
\lnie
\endln
\lnie
this routine will replace a section of a buffer with the\endln
\lnie
contents of a given string.  if the length of the\endln
\lnie
section to be replaced is different than the length of\endln
\lnie
the given string, and the replacement is not an append,\endln
\lnie
then the upper section of the buffer is shifted up or\endln
\lnie
down to create the proper space for the insert.\endln
\lnie
\endln
\lnie
(xr)                  pointer to bcblk\endln
\lnie
(xl)                  object which is string convertable\endln
\lnie
(wa)                  offset of start of insert in buffer\endln
\lnie
(wb)                  length of section to replace\endln
\lnie
jsr  insbf            call to insert characters in buffer\endln
\lnie
ppm  loc              thread if (xl) not convertable\endln
\lnie
ppm  loc              thread if insert not possible\endln
\lnie
\endln
\lnie
the second alternate exit is taken if the insert would\endln
\lnie
overflow the buffer, or if the insert is out past the\endln
\lnie
defined end of the buffer as given.\endln
\lnie
\endln
\inst{insbf}{prc}{e,2}{entry point}
\inst{}{mov}{wa,inssa}{save entry wa}
\inst{}{mov}{wb,inssb}{save entry wb}
\inst{}{mov}{wc,inssc}{save entry wc}
\inst{}{add}{wb,wa}{add to get offset past replace part}
\inst{}{mov}{wa,insab}{save wa+wb}
\inst{}{mov}{bclen(xr),wc}{get current defined length}
\inst{}{bgt}{inssa,wc,ins07}{fail if start offset too big}
\inst{}{bgt}{wa,wc,ins07}{fail if final offset too big}
\inst{}{mov}{xl,-(xs)}{save entry xl}
\inst{}{mov}{xr,-(xs)}{save bcblk ptr}
\inst{}{mov}{xl,-(xs)}{stack again for gtstg or gtstb}
\inst{}{beq}{xr,xl,ins08}{b if inserting same buffer}
\inst{}{jsr}{gtstb}{call to get string or buffer}
\inst{}{ppm}{ins05}{take string convert err exit}
\lnie
\endln
\lnie
merge here with xr pointing to the scblk or bfblk of\endln
\lnie
the object being inserted, and wa containing the\endln
\lnie
number of characters in that object.\endln
\lnie
\endln
\inst{ins09}{mov}{xr,xl}{save string ptr}
\inst{}{mov}{wa,insln}{save its length}
\inst{}{mov}{(xs),xr}{restore bcblk ptr}
\inst{}{add}{wc,wa}{add buffer len to string len}
\inst{}{sub}{inssb,wa}{bias out component being replaced}
\inst{}{mov}{bcbuf(xr),xr}{point to bfblk}
\inst{}{bgt}{wa,bfalc(xr),ins06}{fail if result exceeds allocation}
\inst{}{mov}{(xs),xr}{restore bcblk ptr}
\inst{}{mov}{wc,wa}{get buffer length}
\inst{}{sub}{insab,wa}{subtract to get shift length}
\inst{}{add}{insln,wc}{add length of new}
\inst{}{sub}{inssb,wc}{subtract old to get total new len}
\inst{}{mov}{bclen(xr),wb}{get old bclen}
\inst{}{mov}{wc,bclen(xr)}{stuff new length}
\inst{}{bze}{wa,ins04}{skip shift if nothing to do}
\inst{}{beq}{inssb,insln,ins04}{skip shift if lengths match}
\inst{}{mov}{bcbuf(xr),xr}{point to bfblk}
\inst{}{mov}{xl,-(xs)}{save scblk ptr}
\inst{}{blo}{inssb,insln,ins01}{brn if shift is for more room}
\vfill\break

\lnie
\endln
\lnie
insbf (continued)\endln
\lnie
\endln
\lnie
we are shifting the upper segment down to compact\endln
\lnie
the buffer.  (the string length is smaller than the\endln
\lnie
segment being replaced.)  registers are set as\endln
\lnie
\endln
\lnie
(wa)                  move (shift down) length\endln
\lnie
(wb)                  old bclen\endln
\lnie
(wc)                  new bclen\endln
\lnie
(xr)                  bfblk ptr\endln
\lnie
(xl),(xs)             scblk or bfblk ptr\endln
\lnie
\endln
\inst{}{mov}{inssa,wb}{get offset to insert}
\inst{}{add}{insln,wb}{add insert length to get dest off}
\inst{}{mov}{xr,xl}{make copy}
\inst{}{plc}{xl,insab}{prepare source for move}
\inst{}{psc}{xr,wb}{prepare destination reg for move}
\inst{}{mvc}{}{move em out}
\inst{}{brn}{ins02}{branch to pad}
\lnie
\endln
\lnie
we are shifting the upper segment up to expand\endln
\lnie
the buffer.  (the string length is larger than the\endln
\lnie
segment being replaced.)\endln
\lnie
\endln
\inst{ins01}{mov}{xr,xl}{copy bfblk ptr}
\inst{}{plc}{xl,wb}{set source reg for move backwards}
\inst{}{psc}{xr,wc}{set destination ptr for move}
\inst{}{mcb}{}{move backwards (possible overlap)}
\lnie
\endln
\lnie
merge here after move to adjust padding at new buffer end\endln
\lnie
\endln
\inst{ins02}{mov}{(xs)+,xl}{restore scblk or bfblk ptr}
\inst{}{mov}{wc,wa}{copy new buffer end}
\inst{}{ctb}{wa,0}{round out}
\inst{}{sub}{wc,wa}{subtract to get remainder}
\inst{}{bze}{wa,ins04}{no pad if already even boundary}
\inst{}{mov}{(xs),xr}{get bcblk ptr}
\inst{}{mov}{bcbuf(xr),xr}{get bfblk ptr}
\inst{}{psc}{xr,wc}{prepare to pad}
\inst{}{zer}{wb}{clear wb}
\inst{}{lct}{wa,wa}{load loop count}
\lnie
\endln
\lnie
loop here to stuff pad characters\endln
\lnie
\endln
\inst{ins03}{sch}{wb,(xr)+}{stuff zero pad}
\inst{}{bct}{wa,ins03}{branch for more}
\inst{}{csc}{xr}{complete store character}
\vfill\break

\lnie
\endln
\lnie
insbf (continued)\endln
\lnie
\endln
\lnie
merge here when padding ok.  now copy in the insert\endln
\lnie
string to the hole.\endln
\lnie
\endln
\inst{ins04}{mov}{insln,wa}{get insert length}
\inst{}{bze}{wa,ins4b}{if nothing to insert}
\inst{}{mov}{(xs),xr}{get bcblk ptr}
\inst{}{mov}{bcbuf(xr),xr}{get bfblk ptr}
\inst{}{plc}{xl}{prepare to copy from first char}
\inst{}{psc}{xr,inssa}{prepare to store in hole}
\inst{}{mvc}{}{copy the characters}
\lnie
\endln
\lnie
continue here after possible insertion copy\endln
\lnie
\endln
\inst{ins4b}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{mov}{inssa,wa}{restore entry wa}
\inst{}{mov}{inssb,wb}{restore entry wb}
\inst{}{mov}{inssc,wc}{restore entry wc}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
here to take string convert error exit\endln
\lnie
\endln
\inst{ins05}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{mov}{inssa,wa}{restore entry wa}
\inst{}{mov}{inssb,wb}{restore entry wb}
\inst{}{mov}{inssc,wc}{restore entry wc}
\inst{}{exi}{1}{alternate exit}
\lnie
\endln
\lnie
here for invalid offset or length\endln
\lnie
\endln
\inst{ins06}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{mov}{(xs)+,xl}{restore entry xl}
\lnie
\endln
\lnie
merge for length failure exit with stack set\endln
\lnie
\endln
\inst{ins07}{mov}{inssa,wa}{restore entry wa}
\inst{}{mov}{inssb,wb}{restore entry wb}
\inst{}{mov}{inssc,wc}{restore entry wc}
\inst{}{exi}{2}{alternate exit}
\lnie
\endln
\lnie
here if inserting the same buffer into itself.  have\endln
\lnie
to convert the inserted buffer to an intermediate\endln
\lnie
string to prevent garbled data.\endln
\lnie
\endln
\inst{ins08}{jsr}{gtstg}{call to get string}
\inst{}{ppm}{ins05}{take string convert err exit}
\inst{}{brn}{ins09}{merge back to perform insertion}
\inst{}{enp}{}{end procedure insbf}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
insta - used to initialize structures in static region\endln
\lnie
\endln
\lnie
(xr)                  pointer to starting static location\endln
\lnie
jsr  insta            call to initialize static structure\endln
\lnie
(xr)                  ptr to next free static location\endln
\lnie
(wa,wb,wc)            destroyed\endln
\lnie
\endln
\lnie
note that this procedure establishes the pointers\endln
\lnie
prbuf, gtswk, and kvalp.\endln
\lnie
\endln
\inst{insta}{prc}{e,0}{entry point}
\lnie
\endln
\lnie
initialize print buffer with blank words\endln
\lnie
\endln
\inst{}{mov}{prlen,wc}{no. of chars in print bfr}
\inst{}{mov}{xr,prbuf}{print bfr is put at static start}
\inst{}{mov}{=b$scl,(xr)+}{store string type code}
\inst{}{mov}{wc,(xr)+}{and string length}
\inst{}{ctw}{wc,0}{get number of words in buffer}
\inst{}{mov}{wc,prlnw}{store for buffer clear}
\inst{}{lct}{wc,wc}{words to clear}
\lnie
\endln
\lnie
loop to clear buffer\endln
\lnie
\endln
\inst{inst1}{mov}{nullw,(xr)+}{store blank}
\inst{}{bct}{wc,inst1}{loop}
\lnie
\endln
\lnie
allocate work area for gtstg conversion procedure\endln
\lnie
\endln
\inst{}{mov}{=nstmx,wa}{get max num chars in output number}
\inst{}{ctb}{wa,scsi$}{no of bytes needed}
\inst{}{mov}{xr,gtswk}{store bfr adrs}
\inst{}{add}{wa,xr}{bump for work bfr}
\lnie
\endln
\lnie
build alphabet string for alphabet keyword and replace\endln
\lnie
\endln
\inst{}{mov}{xr,kvalp}{save alphabet pointer}
\inst{}{mov}{=b$scl,(xr)}{string blk type}
\inst{}{mov}{=cfp$a,wc}{no of chars in alphabet}
\inst{}{mov}{wc,sclen(xr)}{store as string length}
\inst{}{mov}{wc,wb}{copy char count}
\inst{}{ctb}{wb,scsi$}{no. of bytes needed}
\inst{}{add}{xr,wb}{current end address for static}
\inst{}{mov}{wb,wa}{save adrs past alphabet string}
\inst{}{lct}{wc,wc}{loop counter}
\inst{}{psc}{xr}{point to chars of string}
\inst{}{zer}{wb}{set initial character value}
\lnie
\endln
\lnie
loop to enter character codes in order\endln
\lnie
\endln
\inst{inst2}{sch}{wb,(xr)+}{store next code}
\inst{}{icv}{wb}{bump code value}
\inst{}{bct}{wc,inst2}{loop till all stored}
\inst{}{csc}{xr}{complete store characters}
\inst{}{mov}{wa,xr}{return current static ptr}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure insta}
\vfill\break

\lnie
\endln
\lnie
iofcb -- get input/output fcblk pointer\endln
\lnie
\endln
\lnie
used by endfile, eject and rewind to find the fcblk\endln
\lnie
(if any) corresponding to their argument.\endln
\lnie
\endln
\lnie
-(xs)                 argument\endln
\lnie
jsr  iofcb            call to find fcblk\endln
\lnie
ppm  loc              arg is an unsuitable name\endln
\lnie
ppm  loc              arg is null string\endln
\lnie
ppm  loc              arg file not found\endln
\lnie
(xs)                  popped\endln
\lnie
(xl)                  ptr to filearg1 vrblk\endln
\lnie
(xr)                  argument\endln
\lnie
(wa)                  fcblk ptr or 0\endln
\lnie
(wb,wc)               destroyed\endln
\lnie
\endln
\inst{iofcb}{prc}{n,3}{entry point}
\inst{}{jsr}{gtstg}{get arg as string}
\inst{}{ppm}{iofc2}{fail}
\inst{}{mov}{xr,xl}{copy string ptr}
\inst{}{jsr}{gtnvr}{get as natural variable}
\inst{}{ppm}{iofc3}{fail if null}
\inst{}{mov}{xl,wb}{copy string pointer again}
\inst{}{mov}{xr,xl}{copy vrblk ptr for return}
\inst{}{zer}{wa}{in case no trblk found}
\lnie
\endln
\lnie
loop to find file arg1 trblk\endln
\lnie
\endln
\inst{iofc1}{mov}{vrval(xr),xr}{get possible trblk ptr}
\inst{}{bne}{(xr),=b$trt,iofc4}{fail if end of chain}
\inst{}{bne}{trtyp(xr),=trtfc,iofc1}{loop if not file arg trblk}
\inst{}{mov}{trfpt(xr),wa}{get fcblk ptr}
\inst{}{mov}{wb,xr}{copy arg}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
fail return\endln
\lnie
\endln
\inst{iofc2}{exi}{1}{fail}
\lnie
\endln
\lnie
null arg\endln
\lnie
\endln
\inst{iofc3}{exi}{2}{null arg return}
\lnie
\endln
\lnie
file not found\endln
\lnie
\endln
\inst{iofc4}{exi}{3}{file not found return}
\inst{}{enp}{}{end procedure iofcb}
\vfill\break

\lnie
\endln
\lnie
ioppf -- process filearg2 for ioput\endln
\lnie
\endln
\lnie
(r$xsc)               filearg2 ptr\endln
\lnie
jsr  ioppf            call to process filearg2\endln
\lnie
(xl)                  filearg1 ptr\endln
\lnie
(xr)                  file arg2 ptr\endln
\lnie
-(xs)...-(xs)         fields extracted from filearg2\endln
\lnie
(wc)                  no. of fields extracted\endln
\lnie
(wb)                  input/output flag\endln
\lnie
(wa)                  fcblk ptr or 0\endln
\lnie
\endln
\inst{ioppf}{prc}{n,0}{entry point}
\inst{}{zer}{wb}{to count fields extracted}
\lnie
\endln
\lnie
loop to extract fields\endln
\lnie
\endln
\inst{iopp1}{mov}{=iodel,xl}{get delimiter}
\inst{}{mov}{xl,wc}{copy it}
\inst{}{zer}{wa}{retain leading blanks in filearg2}
\inst{}{jsr}{xscan}{get next field}
\inst{}{mov}{xr,-(xs)}{stack it}
\inst{}{icv}{wb}{increment count}
\inst{}{bnz}{wa,iopp1}{loop}
\inst{}{mov}{wb,wc}{count of fields}
\inst{}{mov}{ioptt,wb}{i/o marker}
\inst{}{mov}{r$iof,wa}{fcblk ptr or 0}
\inst{}{mov}{r$io2,xr}{file arg2 ptr}
\inst{}{mov}{r$io1,xl}{filearg1}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure ioppf}
\vfill\break

\lnie
\endln
\lnie
ioput -- routine used by input and output\endln
\lnie
\endln
\lnie
ioput sets up input/output  associations. it builds\endln
\lnie
such trace and file control blocks as are necessary and\endln
\lnie
calls sysfc,sysio to perform checks on the\endln
\lnie
arguments and to open the files.\endln
\lnie
\endln
\lnie
   +-----------+   +---------------+       +-----------+\endln
\lnie
+-.i           i   i               i------.i   =b$xrt  i\endln
\lnie
i  +-----------+   +---------------+       +-----------+\endln
\lnie
i  /           /        (r$fcb)            i    *4     i\endln
\lnie
i  /           /                           +-----------+\endln
\lnie
i  +-----------+   +---------------+       i           i-\endln
\lnie
i  i   name    +--.i    =b$trt     i       +-----------+\endln
\lnie
i  /           /   +---------------+       i           i\endln
\lnie
i   (first arg)    i =trtin/=trtou i       +-----------+\endln
\lnie
i                  +---------------+             i\endln
\lnie
i                  i     value     i             i\endln
\lnie
i                  +---------------+             i\endln
\lnie
i                  i(trtrf) 0   or i--+          i\endln
\lnie
i                  +---------------+  i          i\endln
\lnie
i                  i(trfpt) 0   or i----+        i\endln
\lnie
i                  +---------------+  i i        i\endln
\lnie
i                     (i/o trblk)     i i        i\endln
\lnie
i  +-----------+                      i i        i\endln
\lnie
i  i           i                      i i        i\endln
\lnie
i  +-----------+                      i i        i\endln
\lnie
i  i           i                      i i        i\endln
\lnie
i  +-----------+   +---------------+  i i        i\endln
\lnie
i  i           +--.i    =b$trt     i.-+ i        i\endln
\lnie
i  +-----------+   +---------------+    i        i\endln
\lnie
i  /           /   i    =trtfc     i    i        i\endln
\lnie
i  /           /   +---------------+    i        i\endln
\lnie
i    (filearg1     i     value     i    i        i\endln
\lnie
i         vrblk)   +---------------+    i        i\endln
\lnie
i                  i(trtrf) 0   or i--+ i        .\endln
\lnie
i                  +---------------+  i .  +-----------+\endln
\lnie
i                  i(trfpt) 0   or i------./   fcblk   /\endln
\lnie
i                  +---------------+  i    +-----------+\endln
\lnie
i                       (trtrf)       i\endln
\lnie
i                                     i\endln
\lnie
i                                     i\endln
\lnie
i                  +---------------+  i\endln
\lnie
i                  i    =b$xrt     i.-+\endln
\lnie
i                  +---------------+\endln
\lnie
i                  i      *5       i\endln
\lnie
i                  +---------------+\endln
\lnie
+------------------i               i\endln
\lnie
                   +---------------+       +-----------+\endln
\lnie
                   i(trtrf) o   or i------.i  =b$xrt   i\endln
\lnie
                   +---------------+       +-----------+\endln
\lnie
                   i  name offset  i       i    etc    i\endln
\lnie
                   +---------------+\endln
\lnie
                     (iochn - chain of name pointers)\endln
\vfill\break

\lnie
\endln
\lnie
ioput (continued)\endln
\lnie
\endln
\lnie
no additional trap blocks are used for standard input/out\endln
\lnie
files. otherwise an i/o trap block is attached to second\endln
\lnie
arg (filearg1) vrblk. see diagram above for details of\endln
\lnie
the structure built.\endln
\lnie
\endln
\lnie
-(xs)                 1st arg (vbl to be associated)\endln
\lnie
-(xs)                 2nd arg (file arg1)\endln
\lnie
-(xs)                 3rd arg (file arg2)\endln
\lnie
(wb)                  0 for input, 3 for output assoc.\endln
\lnie
jsr  ioput            call for input/output association\endln
\lnie
ppm  loc              3rd arg not a string\endln
\lnie
ppm  loc              2nd arg not a suitable name\endln
\lnie
ppm  loc              1st arg not a suitable name\endln
\lnie
ppm  loc              inappropriate file spec for i/o\endln
\lnie
ppm  loc              i/o file does not exist\endln
\lnie
ppm  loc              i/o file cannot be read/written\endln
\lnie
ppm  loc              i/o fcblk currently in use\endln
\lnie
(xs)                  popped\endln
\lnie
(xl,xr,wa,wb,wc)      destroyed\endln
\lnie
\endln
\inst{ioput}{prc}{n,7}{entry point}
\inst{}{zer}{r$iot}{in case no trtrf block used}
\inst{}{zer}{r$iof}{in case no fcblk alocated}
\inst{}{zer}{r$iop}{in case sysio fails}
\inst{}{mov}{wb,ioptt}{store i/o trace type}
\inst{}{jsr}{xscni}{prepare to scan filearg2}
\inst{}{ppm}{iop13}{fail}
\inst{}{ppm}{iopa0}{null file arg2}
\lnie
\endln
\inst{iopa0}{mov}{xr,r$io2}{keep file arg2}
\inst{}{mov}{wa,xl}{copy length}
\inst{}{jsr}{gtstg}{convert filearg1 to string}
\inst{}{ppm}{iop14}{fail}
\inst{}{mov}{xr,r$io1}{keep filearg1 ptr}
\inst{}{jsr}{gtnvr}{convert to natural variable}
\inst{}{ppm}{iop00}{jump if null}
\inst{}{brn}{iop04}{jump to process non-null args}
\lnie
\endln
\lnie
null filearg1\endln
\lnie
\endln
\inst{iop00}{bze}{xl,iop01}{skip if both args null}
\inst{}{jsr}{ioppf}{process filearg2}
\inst{}{jsr}{sysfc}{call for filearg2 check}
\inst{}{ppm}{iop16}{fail}
\inst{}{ppm}{iop26}{fail}
\inst{}{brn}{iop11}{complete file association}
\vfill\break

\lnie
\endln
\lnie
ioput (continued)\endln
\lnie
\endln
\lnie
here with 0 or fcblk ptr in (xl)\endln
\lnie
\endln
\inst{iop01}{mov}{ioptt,wb}{get trace type}
\inst{}{mov}{r$iot,xr}{get 0 or trtrf ptr}
\inst{}{jsr}{trbld}{build trblk}
\inst{}{mov}{xr,wc}{copy trblk pointer}
\inst{}{mov}{(xs)+,xr}{get variable from stack}
\inst{}{mov}{wc,-(xs)}{make trblk collectable}
\inst{}{jsr}{gtvar}{point to variable}
\inst{}{ppm}{iop15}{fail}
\inst{}{mov}{(xs)+,wc}{recover trblk pointer}
\inst{}{mov}{xl,r$ion}{save name pointer}
\inst{}{mov}{xl,xr}{copy name pointer}
\inst{}{add}{wa,xr}{point to variable}
\inst{}{sub}{*vrval,xr}{subtract offset,merge into loop}
\lnie
\endln
\lnie
loop to end of trblk chain if any\endln
\lnie
\endln
\inst{iop02}{mov}{xr,xl}{copy blk ptr}
\inst{}{mov}{vrval(xr),xr}{load ptr to next trblk}
\inst{}{bne}{(xr),=b$trt,iop03}{   jump if not trapped}
\inst{}{bne}{trtyp(xr),ioptt,iop02}{loop if not same assocn}
\inst{}{mov}{trnxt(xr),xr}{get value and delete old trblk}
\lnie
\endln
\lnie
ioput (continued)\endln
\lnie
\endln
\lnie
store new association\endln
\lnie
\endln
\inst{iop03}{mov}{wc,vrval(xl)}{link to this trblk}
\inst{}{mov}{wc,xl}{copy pointer}
\inst{}{mov}{xr,trnxt(xl)}{store value in trblk}
\inst{}{mov}{r$ion,xr}{restore possible vrblk pointer}
\inst{}{mov}{wa,wb}{keep offset to name}
\inst{}{jsr}{setvr}{if vrblk, set vrget,vrsto}
\inst{}{mov}{r$iot,xr}{get 0 or trtrf ptr}
\inst{}{bnz}{xr,iop19}{jump if trtrf block exists}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
non standard file\endln
\lnie
see if an fcblk has already been allocated.\endln
\lnie
\endln
\inst{iop04}{zer}{wa}{in case no fcblk found}
\vfill\break

\lnie
\endln
\lnie
ioput (continued)\endln
\lnie
\endln
\lnie
search possible trblk chain to pick up the fcblk\endln
\lnie
\endln
\inst{iop05}{mov}{xr,wb}{remember blk ptr}
\inst{}{mov}{vrval(xr),xr}{chain along}
\inst{}{bne}{(xr),=b$trt,iop06}{jump if end of trblk chain}
\inst{}{bne}{trtyp(xr),=trtfc,iop05}{loop if more to go}
\inst{}{mov}{xr,r$iot}{point to file arg1 trblk}
\inst{}{mov}{trfpt(xr),wa}{get fcblk ptr from trblk}
\lnie
\endln
\lnie
wa = 0 or fcblk ptr\endln
\lnie
wb = ptr to preceding blk to which any trtrf block\endln
\lnie
     for file arg1 must be chained.\endln
\lnie
\endln
\inst{iop06}{mov}{wa,r$iof}{keep possible fcblk ptr}
\inst{}{mov}{wb,r$iop}{keep preceding blk ptr}
\inst{}{jsr}{ioppf}{process filearg2}
\inst{}{jsr}{sysfc}{see if fcblk required}
\inst{}{ppm}{iop16}{fail}
\inst{}{ppm}{iop26}{fail}
\inst{}{bze}{wa,iop12}{skip if no new fcblk wanted}
\inst{}{blt}{wc,=num02,iop6a}{jump if fcblk in dynamic}
\inst{}{jsr}{alost}{get it in static}
\inst{}{brn}{iop6b}{skip}
\lnie
\endln
\lnie
obtain fcblk in dynamic\endln
\lnie
\endln
\inst{iop6a}{jsr}{alloc}{get space for fcblk}
\lnie
\endln
\lnie
merge\endln
\lnie
\endln
\inst{iop6b}{mov}{xr,xl}{point to fcblk}
\inst{}{mov}{wa,wb}{copy its length}
\inst{}{btw}{wb}{get count as words (sgd apr80)}
\inst{}{lct}{wb,wb}{loop counter}
\lnie
\endln
\lnie
clear fcblk\endln
\lnie
\endln
\inst{iop07}{zer}{(xr)+}{clear a word}
\inst{}{bct}{wb,iop07}{loop}
\inst{}{beq}{wc,=num02,iop09}{skip if in static - dont set fields}
\inst{}{mov}{=b$xnt,(xl)}{store xnblk code in case}
\inst{}{mov}{wa,num01(xl)}{store length}
\inst{}{bnz}{wc,iop09}{jump if xnblk wanted}
\inst{}{mov}{=b$xrt,(xl)}{xrblk code requested}
\lnie
\endln
\vfill\break

\lnie
ioput (continued)\endln
\lnie
\endln
\lnie
complete fcblk initialisation\endln
\lnie
\endln
\inst{iop09}{mov}{r$iot,xr}{get possible trblk ptr}
\inst{}{mov}{xl,r$iof}{store fcblk ptr}
\inst{}{bnz}{xr,iop10}{jump if trblk already found}
\lnie
\endln
\lnie
a new trblk is needed\endln
\lnie
\endln
\inst{}{mov}{=trtfc,wb}{trtyp for fcblk trap blk}
\inst{}{jsr}{trbld}{make the block}
\inst{}{mov}{xr,r$iot}{copy trtrf ptr}
\inst{}{mov}{r$iop,xl}{point to preceding blk}
\inst{}{mov}{vrval(xl),vrval(xr)}{copy value field to trblk}
\inst{}{mov}{xr,vrval(xl)}{link new trblk into chain}
\inst{}{mov}{xl,xr}{point to predecessor blk}
\inst{}{jsr}{setvr}{set trace intercepts}
\inst{}{mov}{vrval(xr),xr}{recover trblk ptr}
\inst{}{brn}{iop1a}{store fcblk ptr}
\lnie
\endln
\lnie
here if existing trblk\endln
\lnie
\endln
\inst{iop10}{zer}{r$iop}{do not release if sysio fails}
\lnie
\endln
\lnie
xr is ptr to trblk, xl is fcblk ptr or 0\endln
\lnie
\endln
\inst{iop1a}{mov}{r$iof,trfpt(xr)}{store fcblk ptr}
\lnie
\endln
\lnie
call sysio to complete file accessing\endln
\lnie
\endln
\inst{iop11}{mov}{r$iof,wa}{copy fcblk ptr or 0}
\inst{}{mov}{ioptt,wb}{get input/output flag}
\inst{}{mov}{r$io2,xr}{get file arg2}
\inst{}{mov}{r$io1,xl}{get file arg1}
\inst{}{jsr}{sysio}{associate to the file}
\inst{}{ppm}{iop17}{fail}
\inst{}{ppm}{iop18}{fail}
\inst{}{bnz}{r$iot,iop01}{not std input if non-null trtrf blk}
\inst{}{bnz}{ioptt,iop01}{jump if output}
\inst{}{bze}{wc,iop01}{no change to standard read length}
\inst{}{mov}{wc,cswin}{store new read length for std file}
\inst{}{brn}{iop01}{merge to finish the task}
\lnie
\endln
\lnie
sysfc may have returned a pointer to a private fcblk\endln
\lnie
\endln
\inst{iop12}{bnz}{xl,iop09}{jump if private fcblk}
\inst{}{brn}{iop11}{finish the association}
\lnie
\endln
\lnie
failure returns\endln
\lnie
\endln
\inst{iop13}{exi}{1}{3rd arg not a string}
\inst{iop14}{exi}{2}{2nd arg unsuitable}
\inst{iop15}{ica}{xs}{discard trblk pointer}
\inst{}{exi}{3}{1st arg unsuitable}
\inst{iop16}{exi}{4}{file spec wrong}
\inst{iop26}{exi}{7}{fcblk in use}
\lnie
\endln
\lnie
i/o file does not exist\endln
\lnie
\endln
\inst{iop17}{mov}{r$iop,xr}{is there a trblk to release}
\inst{}{bze}{xr,iopa7}{if not}
\inst{}{mov}{vrval(xr),xl}{point to trblk}
\inst{}{mov}{vrval(xl),vrval(xr)}{unsplice it}
\inst{}{jsr}{setvr}{adjust trace intercepts}
\inst{iopa7}{exi}{5}{i/o file does not exist}
\lnie
\endln
\lnie
i/o file cannot be read/written\endln
\lnie
\endln
\inst{iop18}{mov}{r$iop,xr}{is there a trblk to release}
\inst{}{bze}{xr,iopa7}{if not}
\inst{}{mov}{vrval(xr),xl}{point to trblk}
\inst{}{mov}{vrval(xl),vrval(xr)}{unsplice it}
\inst{}{jsr}{setvr}{adjust trace intercepts}
\inst{iopa8}{exi}{6}{i/o file cannot be read/written}
\vfill\break

\lnie
\endln
\lnie
ioput (continued)\endln
\lnie
\endln
\lnie
add to iochn chain of associated variables unless\endln
\lnie
already present.\endln
\lnie
\endln
\inst{iop19}{mov}{r$ion,wc}{wc = name base, wb = name offset}
\lnie
\endln
\lnie
search loop\endln
\lnie
\endln
\inst{iop20}{mov}{trtrf(xr),xr}{next link of chain}
\inst{}{bze}{xr,iop21}{not found}
\inst{}{bne}{wc,ionmb(xr),iop20}{no match}
\inst{}{beq}{wb,ionmo(xr),iop22}{exit if matched}
\inst{}{brn}{iop20}{loop}
\lnie
\endln
\lnie
not found\endln
\lnie
\endln
\inst{iop21}{mov}{*num05,wa}{space needed}
\inst{}{jsr}{alloc}{get it}
\inst{}{mov}{=b$xrt,(xr)}{store xrblk code}
\inst{}{mov}{wa,num01(xr)}{store length}
\inst{}{mov}{wc,ionmb(xr)}{store name base}
\inst{}{mov}{wb,ionmo(xr)}{store name offset}
\inst{}{mov}{r$iot,xl}{point to trtrf blk}
\inst{}{mov}{trtrf(xl),wa}{get ptr field contents}
\inst{}{mov}{xr,trtrf(xl)}{store ptr to new block}
\inst{}{mov}{wa,trtrf(xr)}{complete the linking}
\lnie
\endln
\lnie
insert fcblk on fcblk chain for sysej, sysxi\endln
\lnie
\endln
\inst{iop22}{bze}{r$iof,iop25}{skip if no fcblk}
\inst{}{mov}{r$fcb,xl}{ptr to head of existing chain}
\lnie
\endln
\lnie
see if fcblk already on chain\endln
\lnie
\endln
\inst{iop23}{bze}{xl,iop24}{not on if end of chain}
\inst{}{beq}{num03(xl),r$iof,iop25}{dont duplicate if find it}
\inst{}{mov}{num02(xl),xl}{get next link}
\inst{}{brn}{iop23}{loop}
\lnie
\endln
\lnie
not found so add an entry for this fcblk\endln
\lnie
\endln
\inst{iop24}{mov}{*num04,wa}{space needed}
\inst{}{jsr}{alloc}{get it}
\inst{}{mov}{=b$xrt,(xr)}{store block code}
\inst{}{mov}{wa,num01(xr)}{store length}
\inst{}{mov}{r$fcb,num02(xr)}{store previous link in this node}
\inst{}{mov}{r$iof,num03(xr)}{store fcblk ptr}
\inst{}{mov}{xr,r$fcb}{insert node into fcblk chain}
\lnie
\endln
\lnie
return\endln
\lnie
\endln
\inst{iop25}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure ioput}
\vfill\break

\lnie
\endln
\lnie
ktrex -- execute keyword trace\endln
\lnie
\endln
\lnie
ktrex is used to execute a possible keyword trace. it\endln
\lnie
includes the test on trace and tests for trace active.\endln
\lnie
\endln
\lnie
(xl)                  ptr to trblk (or 0 if untraced)\endln
\lnie
jsr  ktrex            call to execute keyword trace\endln
\lnie
(xl,wa,wb,wc)         destroyed\endln
\lnie
(ra)                  destroyed\endln
\lnie
\endln
\inst{ktrex}{prc}{r,0}{entry point (recursive)}
\inst{}{bze}{xl,ktrx3}{immediate exit if keyword untraced}
\inst{}{bze}{kvtra,ktrx3}{immediate exit if trace = 0}
\inst{}{dcv}{kvtra}{else decrement trace}
\inst{}{mov}{xr,-(xs)}{save xr}
\inst{}{mov}{xl,xr}{copy trblk pointer}
\inst{}{mov}{trkvr(xr),xl}{load vrblk pointer (nmbas)}
\inst{}{mov}{*vrval,wa}{set name offset}
\inst{}{bze}{trfnc(xr),ktrx1}{jump if print trace}
\inst{}{jsr}{trxeq}{else execute full trace}
\inst{}{brn}{ktrx2}{and jump to exit}
\lnie
\endln
\lnie
here for print trace\endln
\lnie
\endln
\inst{ktrx1}{mov}{xl,-(xs)}{stack vrblk ptr for kwnam}
\inst{}{mov}{wa,-(xs)}{stack offset for kwnam}
\inst{}{jsr}{prtsn}{print statement number}
\inst{}{mov}{=ch$am,wa}{load ampersand}
\inst{}{jsr}{prtch}{print ampersand}
\inst{}{jsr}{prtnm}{print keyword name}
\inst{}{mov}{=tmbeb,xr}{point to blank-equal-blank}
\inst{}{jsr}{prtst}{print blank-equal-blank}
\inst{}{jsr}{kwnam}{get keyword pseudo-variable name}
\inst{}{mov}{xr,dnamp}{reset ptr to delete kvblk}
\inst{}{jsr}{acess}{get keyword value}
\inst{}{ppm}{}{failure is impossible}
\inst{}{jsr}{prtvl}{print keyword value}
\inst{}{jsr}{prtnl}{terminate print line}
\lnie
\endln
\lnie
here to exit after completing trace\endln
\lnie
\endln
\inst{ktrx2}{mov}{(xs)+,xr}{restore entry xr}
\lnie
\endln
\lnie
merge here to exit if no trace required\endln
\lnie
\endln
\inst{ktrx3}{exi}{}{return to ktrex caller}
\inst{}{enp}{}{end procedure ktrex}
\vfill\break

\lnie
\endln
\lnie
kwnam -- get pseudo-variable name for keyword\endln
\lnie
\endln
\lnie
1(xs)                 name base for vrblk\endln
\lnie
0(xs)                 offset (should be *vrval)\endln
\lnie
jsr  kwnam            call to get pseudo-variable name\endln
\lnie
(xs)                  popped twice\endln
\lnie
(xl,wa)               resulting pseudo-variable name\endln
\lnie
(xr,wa,wb)            destroyed\endln
\lnie
\endln
\inst{kwnam}{prc}{n,0}{entry point}
\inst{}{ica}{xs}{ignore name offset}
\inst{}{mov}{(xs)+,xr}{load name base}
\inst{}{bge}{xr,state,kwnm1}{jump if not natural variable name}
\inst{}{bnz}{vrlen(xr),kwnm1}{error if not system variable}
\inst{}{mov}{vrsvp(xr),xr}{else point to svblk}
\inst{}{mov}{svbit(xr),wa}{load bit mask}
\inst{}{anb}{btknm,wa}{and with keyword bit}
\inst{}{zrb}{wa,kwnm1}{error if no keyword association}
\inst{}{mov}{svlen(xr),wa}{else load name length in characters}
\inst{}{ctb}{wa,svchs}{compute offset to field we want}
\inst{}{add}{wa,xr}{point to svknm field}
\inst{}{mov}{(xr),wb}{load svknm value}
\inst{}{mov}{*kvsi$,wa}{set size of kvblk}
\inst{}{jsr}{alloc}{allocate kvblk}
\inst{}{mov}{=b$kvt,(xr)}{store type word}
\inst{}{mov}{wb,kvnum(xr)}{store keyword number}
\inst{}{mov}{=trbkv,kvvar(xr)}{set dummy trblk pointer}
\inst{}{mov}{xr,xl}{copy kvblk pointer}
\inst{}{mov}{*kvvar,wa}{set proper offset}
\inst{}{exi}{}{return to kvnam caller}
\lnie
\endln
\lnie
here if not keyword name\endln
\lnie
\endln
\inst{kwnm1}{erb}{251,keyword operand}{is not name of defined keyword}
\inst{}{enp}{}{end procedure kwnam}
\vfill\break

\lnie
\endln
\lnie
lcomp-- compare two strings lexically\endln
\lnie
\endln
\lnie
1(xs)                 first argument\endln
\lnie
0(xs)                 second argument\endln
\lnie
jsr  lcomp            call to compare aruments\endln
\lnie
ppm  loc              transfer loc for arg1 not string\endln
\lnie
ppm  loc              transfer loc for arg2 not string\endln
\lnie
ppm  loc              transfer loc if arg1 llt arg2\endln
\lnie
ppm  loc              transfer loc if arg1 leq arg2\endln
\lnie
ppm  loc              transfer loc if arg1 lgt arg2\endln
\lnie
(the normal return is never taken)\endln
\lnie
(xs)                  popped twice\endln
\lnie
(xr,xl)               destroyed\endln
\lnie
(wa,wb,wc,ra)         destroyed\endln
\lnie
\endln
\inst{lcomp}{prc}{n,5}{entry point}
\ifmac{.cnbf}
\inst{}{jsr}{gtstg}{convert second arg to string}
\asmac{else}
\inst{}{jsr}{gtstb}{get second arg as string or buffer}
\asmac{fi}
\inst{}{ppm}{lcmp6}{jump if second arg not string}
\inst{}{mov}{xr,xl}{else save pointer}
\inst{}{mov}{wa,wc}{and length}
\ifmac{.cnbf}
\inst{}{jsr}{gtstg}{convert first argument to string}
\asmac{else}
\inst{}{jsr}{gtstb}{get first arg as string or buffer}
\asmac{fi}
\inst{}{ppm}{lcmp5}{jump if not string}
\inst{}{mov}{wa,wb}{save arg 1 length}
\inst{}{plc}{xr}{point to chars of arg 1}
\inst{}{plc}{xl}{point to chars of arg 2}
\ifmac{.ccmc}
\inst{}{mov}{wc,wa}{arg 2 length to wa}
\inst{}{jsr}{syscm}{compare (xl,wa=arg2  xr,wb=arg1)}
\inst{}{err}{283,string length}{exceeded for generalized lexical comparison}
\inst{}{ppm}{lcmp4}{arg 2 lt arg 1, lgt exit}
\inst{}{ppm}{lcmp3}{arg 2 gt arg 1, llt exit}
\inst{}{exi}{4}{else identical strings, leq exit}
\vfill\break

\lnie
\endln
\lnie
lcomp (continued)\endln
\asmac{else}
\inst{}{blo}{wa,wc,lcmp1}{jump if arg 1 length is smaller}
\inst{}{mov}{wc,wa}{else set arg 2 length as smaller}
\lnie
\endln
\lnie
here with smaller length in (wa)\endln
\lnie
\endln
\inst{lcmp1}{bze}{wa,lcmp7}{if null string, compare lengths}
\inst{}{cmc}{lcmp4,lcmp3}{compare strings, jump if unequal}
\inst{lcmp7}{bne}{wb,wc,lcmp2}{if equal, jump if lengths unequal}
\inst{}{exi}{4}{else identical strings, leq exit}
\vfill\break

\lnie
\endln
\lnie
lcomp (continued)\endln
\lnie
\endln
\lnie
here if initial strings identical, but lengths unequal\endln
\lnie
\endln
\inst{lcmp2}{bhi}{wb,wc,lcmp4}{jump if arg 1 length gt arg 2 leng}
\asmac{fi}
\lnie
\endln
\lnie
here if first arg llt second arg\endln
\lnie
\endln
\inst{lcmp3}{exi}{3}{take llt exit}
\lnie
\endln
\lnie
here if first arg lgt second arg\endln
\lnie
\endln
\inst{lcmp4}{exi}{5}{take lgt exit}
\lnie
\endln
\lnie
here if first arg is not a string\endln
\lnie
\endln
\inst{lcmp5}{exi}{1}{take bad first arg exit}
\lnie
\endln
\lnie
here for second arg not a string\endln
\lnie
\endln
\inst{lcmp6}{exi}{2}{take bad second arg error exit}
\inst{}{enp}{}{end procedure lcomp}
\vfill\break

\lnie
\endln
\lnie
listr -- list source line\endln
\lnie
\endln
\lnie
listr is used to list a source line during the initial\endln
\lnie
compilation. it is called from scane and scanl.\endln
\lnie
\endln
\lnie
jsr  listr            call to list line\endln
\lnie
(xr,xl,wa,wb,wc)      destroyed\endln
\lnie
\endln
\lnie
global locations used by listr\endln
\lnie
\endln
\lnie
cnttl                 flag for -title, -stitl\endln
\lnie
\endln
\lnie
erlst                 if listing on account of an error\endln
\lnie
\endln
\ifmac{.cinc}
\lnie
lstid                 include depth of current image\endln
\lnie
\endln
\asmac{fi}
\lnie
lstlc                 count lines on current page\endln
\lnie
\endln
\lnie
lstnp                 max number of lines/page\endln
\lnie
\endln
\lnie
lstpf                 set non-zero if the current source\endln
\lnie
                      line has been listed, else zero.\endln
\lnie
\endln
\lnie
lstpg                 compiler listing page number\endln
\lnie
\endln
\lnie
lstsn                 set if stmnt num to be listed\endln
\lnie
\endln
\lnie
r$cim                 pointer to current input line.\endln
\lnie
\endln
\lnie
r$ttl                 title for source listing\endln
\lnie
\endln
\lnie
r$stl                 ptr to sub-title string\endln
\lnie
\endln
\lnie
entry point\endln
\lnie
\endln
\inst{listr}{prc}{e,0}{entry point}
\inst{}{bnz}{cnttl,list5}{jump if -title or -stitl}
\inst{}{bnz}{lstpf,list4}{immediate exit if already listed}
\inst{}{bge}{lstlc,lstnp,list6}{jump if no room}
\lnie
\endln
\lnie
here after printing title (if needed)\endln
\lnie
\endln
\inst{list0}{mov}{r$cim,xr}{load pointer to current image}
\inst{}{bze}{xr,list4}{jump if no image to print}
\inst{}{plc}{xr}{point to characters}
\inst{}{lch}{wa,(xr)}{load first character}
\inst{}{mov}{lstsn,xr}{load statement number}
\inst{}{bze}{xr,list2}{jump if no statement number}
\inst{}{mti}{xr}{else get stmnt number as integer}
\inst{}{bne}{stage,=stgic,list1}{skip if execute time}
\inst{}{beq}{wa,=ch$as,list2}{no stmnt number list if comment}
\inst{}{beq}{wa,=ch$mn,list2}{no stmnt no. if control card}
\lnie
\endln
\lnie
print statement number\endln
\lnie
\endln
\inst{list1}{jsr}{prtin}{else print statement number}
\inst{}{zer}{lstsn}{and clear for next time in}
\ifmac{.cinc}
\lnie
\endln
\lnie
here to test for printing include depth\endln
\lnie
\endln
\inst{list2}{mov}{lstid,xr}{include depth of image}
\inst{}{bze}{xr,list8}{if not from an include file}
\inst{}{mov}{=stnpd,wa}{position for start of statement}
\inst{}{sub}{=num03,wa}{position to place include depth}
\inst{}{mov}{wa,profs}{set as starting position}
\inst{}{mti}{xr}{include depth as integer}
\inst{}{jsr}{prtin}{print include depth}
\vfill\break

\lnie
\endln
\lnie
listr (continued)\endln
\lnie
\endln
\lnie
here after printing statement number and include depth\endln
\lnie
\endln
\inst{list8}{mov}{=stnpd,profs}{point past statement number}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
listr (continued)\endln
\lnie
\endln
\lnie
merge here after printing statement number (if required)\endln
\lnie
\endln
\inst{list2}{mov}{=stnpd,profs}{point past statement number}
\asmac{fi}
\inst{}{mov}{r$cim,xr}{load pointer to current image}
\inst{}{jsr}{prtst}{print it}
\inst{}{icv}{lstlc}{bump line counter}
\inst{}{bnz}{erlst,list3}{jump if error copy to int.ch.}
\inst{}{jsr}{prtnl}{terminate line}
\inst{}{bze}{cswdb,list3}{jump if -single mode}
\inst{}{jsr}{prtnl}{else add a blank line}
\inst{}{icv}{lstlc}{and bump line counter}
\lnie
\endln
\lnie
here after printing source image\endln
\lnie
\endln
\inst{list3}{mnz}{lstpf}{set flag for line printed}
\lnie
\endln
\lnie
merge here to exit\endln
\lnie
\endln
\inst{list4}{exi}{}{return to listr caller}
\lnie
\endln
\lnie
print title after -title or -stitl card\endln
\lnie
\endln
\inst{list5}{zer}{cnttl}{clear flag}
\lnie
\endln
\lnie
eject to new page and list title\endln
\lnie
\endln
\inst{list6}{jsr}{prtps}{eject}
\inst{}{bze}{prich,list7}{skip if listing to regular printer}
\inst{}{beq}{r$ttl,=nulls,list0}{terminal listing omits null title}
\lnie
\endln
\lnie
list title\endln
\lnie
\endln
\inst{list7}{jsr}{listt}{list title}
\inst{}{brn}{list0}{merge}
\inst{}{enp}{}{end procedure listr}
\vfill\break

\lnie
\endln
\lnie
listt -- list title and subtitle\endln
\lnie
\endln
\lnie
used during compilation to print page heading\endln
\lnie
\endln
\lnie
jsr  listt            call to list title\endln
\lnie
(xr,wa)               destroyed\endln
\lnie
\endln
\inst{listt}{prc}{e,0}{entry point}
\inst{}{mov}{r$ttl,xr}{point to source listing title}
\inst{}{jsr}{prtst}{print title}
\inst{}{mov}{lstpo,profs}{set offset}
\inst{}{mov}{=lstms,xr}{set page message}
\inst{}{jsr}{prtst}{print page message}
\inst{}{icv}{lstpg}{bump page number}
\inst{}{mti}{lstpg}{load page number as integer}
\inst{}{jsr}{prtin}{print page number}
\inst{}{jsr}{prtnl}{terminate title line}
\inst{}{add}{=num02,lstlc}{count title line and blank line}
\lnie
\endln
\lnie
print sub-title (if any)\endln
\lnie
\endln
\inst{}{mov}{r$stl,xr}{load pointer to sub-title}
\inst{}{bze}{xr,lstt1}{jump if no sub-title}
\inst{}{jsr}{prtst}{else print sub-title}
\inst{}{jsr}{prtnl}{terminate line}
\inst{}{icv}{lstlc}{bump line count}
\lnie
\endln
\lnie
return point\endln
\lnie
\endln
\inst{lstt1}{jsr}{prtnl}{print a blank line}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure listt}
\vfill\break

\ifmac{.csfn}
\lnie
\endln
\lnie
newfn -- record new source file name\endln
\lnie
\endln
\lnie
newfn is used after switching to a new include file, or\endln
\lnie
after a -line statement which contains a file name.\endln
\lnie
\endln
\lnie
(xr)                  file name scblk\endln
\lnie
jsr  newfn\endln
\lnie
(wa,wb,wc,xl,xr,ra)   destroyed\endln
\lnie
\endln
\lnie
on return, the table that maps statement numbers to file\endln
\lnie
names has been updated to include this new file name and\endln
\lnie
the current statement number.  the entry is made only if\endln
\lnie
the file name had changed from its previous value.\endln
\lnie
\endln
\inst{newfn}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save new name}
\inst{}{mov}{r$sfc,xl}{load previous name}
\inst{}{jsr}{ident}{check for equality}
\inst{}{ppm}{nwfn1}{jump if identical}
\inst{}{mov}{(xs)+,xr}{different, restore name}
\inst{}{mov}{xr,r$sfc}{record current file name}
\inst{}{mov}{cmpsn,wb}{get current statement}
\inst{}{mti}{wb}{convert to integer}
\inst{}{jsr}{icbld}{build icblk for stmt number}
\inst{}{mov}{r$sfn,xl}{file name table}
\inst{}{mnz}{wb}{lookup statement number by name}
\inst{}{jsr}{tfind}{allocate new teblk}
\inst{}{ppm}{}{always possible to allocate block}
\inst{}{mov}{r$sfc,teval(xl)}{record file name as entry value}
\inst{}{exi}{r$sfc,teval(xl)}{record file name as entry value}
\lnie
\endln
\lnie
ere if new name and old name identical\endln
\lnie
\endln
\inst{nwfn1}{ica}{xs}{pop stack}
\inst{}{exi}{xs}{pop stack}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
nexts -- acquire next source image\endln
\lnie
\endln
\lnie
nexts is used to acquire the next source image at compile\endln
\lnie
time. it assumes that a prior call to readr has input\endln
\lnie
a line image (see procedure readr). before the current\endln
\lnie
image is finally lost it may be listed here.\endln
\lnie
\endln
\lnie
jsr  nexts            call to acquire next input line\endln
\lnie
(xr,xl,wa,wb,wc)      destroyed\endln
\lnie
\endln
\lnie
global values affected\endln
\lnie
\endln
\ifmac{.cinc}
\lnie
lstid                 include depth of next image\endln
\lnie
\endln
\asmac{fi}
\lnie
r$cni                 on input, next image. on\endln
\lnie
                      exit reset to zero\endln
\lnie
\endln
\lnie
r$cim                 on exit, set to point to image\endln
\lnie
\endln
\lnie
rdcln                 current ln set from next line num\endln
\lnie
\endln
\lnie
scnil                 input image length on exit\endln
\lnie
\endln
\lnie
scnse                 reset to zero on exit\endln
\lnie
\endln
\lnie
lstpf                 set on exit if line is listed\endln
\lnie
\endln
\inst{nexts}{prc}{e,0}{entry point}
\inst{}{bze}{cswls,nxts2}{jump if -nolist}
\inst{}{mov}{r$cim,xr}{point to image}
\inst{}{bze}{xr,nxts2}{jump if no image}
\inst{}{plc}{xr}{get char ptr}
\inst{}{lch}{wa,(xr)}{get first char}
\inst{}{bne}{wa,=ch$mn,nxts1}{jump if not ctrl card}
\inst{}{bze}{cswpr,nxts2}{jump if -noprint}
\lnie
\endln
\lnie
here to call lister\endln
\lnie
\endln
\inst{nxts1}{jsr}{listr}{list line}
\lnie
\endln
\lnie
here after possible listing\endln
\lnie
\endln
\inst{nxts2}{mov}{r$cni,xr}{point to next image}
\inst{}{mov}{xr,r$cim}{set as next image}
\inst{}{mov}{rdnln,rdcln}{set as current line number}
\ifmac{.cinc}
\inst{}{mov}{cnind,lstid}{set as current include depth}
\asmac{fi}
\inst{}{zer}{r$cni}{clear next image pointer}
\inst{}{mov}{sclen(xr),wa}{get input image length}
\inst{}{mov}{cswin,wb}{get max allowable length}
\inst{}{blo}{wa,wb,nxts3}{skip if not too long}
\inst{}{mov}{wb,wa}{else truncate}
\lnie
\endln
\lnie
here with length in (wa)\endln
\lnie
\endln
\inst{nxts3}{mov}{wa,scnil}{use as record length}
\inst{}{zer}{scnse}{reset scnse}
\inst{}{zer}{lstpf}{set line not listed yet}
\inst{}{exi}{}{return to nexts caller}
\inst{}{enp}{}{end procedure nexts}
\vfill\break

\lnie
\endln
\lnie
patin -- pattern construction for len,pos,rpos,tab,rtab\endln
\lnie
\endln
\lnie
these pattern types all generate a similar node type. so\endln
\lnie
the construction code is shared. see functions section\endln
\lnie
for actual entry points for these five functions.\endln
\lnie
\endln
\lnie
(wa)                  pcode for expression arg case\endln
\lnie
(wb)                  pcode for integer arg case\endln
\lnie
jsr  patin            call to build pattern node\endln
\lnie
ppm  loc              transfer loc for not integer or exp\endln
\lnie
ppm  loc              transfer loc for int out of range\endln
\lnie
(xr)                  pointer to constructed node\endln
\lnie
(xl,wa,wb,wc,ia)      destroyed\endln
\lnie
\endln
\inst{patin}{prc}{n,2}{entry point}
\inst{}{mov}{wa,xl}{preserve expression arg pcode}
\inst{}{jsr}{gtsmi}{try to convert arg as small integer}
\inst{}{ppm}{ptin2}{jump if not integer}
\inst{}{ppm}{ptin3}{jump if out of range}
\lnie
\endln
\lnie
common successful exit point\endln
\lnie
\endln
\inst{ptin1}{jsr}{pbild}{build pattern node}
\inst{}{exi}{}{return to caller}
\lnie
\endln
\lnie
here if argument is not an integer\endln
\lnie
\endln
\inst{ptin2}{mov}{xl,wb}{copy expr arg case pcode}
\inst{}{blo}{(xr),=b$e$$,ptin1}{all ok if expression arg}
\inst{}{exi}{1}{else take error exit for wrong type}
\lnie
\endln
\lnie
here for error of out of range integer argument\endln
\lnie
\endln
\inst{ptin3}{exi}{2}{take out-of-range error exit}
\inst{}{enp}{}{end procedure patin}
\vfill\break

\lnie
\endln
\lnie
patst -- pattern construction for any,notany,\endln
\lnie
         break,span and breakx pattern functions.\endln
\lnie
\endln
\lnie
these pattern functions build similar types of nodes and\endln
\lnie
the construction code is shared. see functions section\endln
\lnie
for actual entry points for these five pattern functions.\endln
\lnie
\endln
\lnie
0(xs)                 string argument\endln
\lnie
(wb)                  pcode for one char argument\endln
\lnie
(xl)                  pcode for multi-char argument\endln
\lnie
(wc)                  pcode for expression argument\endln
\lnie
jsr  patst            call to build node\endln
\lnie
ppm  loc              if not string or expr (or null)\endln
\lnie
(xs)                  popped past string argument\endln
\lnie
(xr)                  pointer to constructed node\endln
\lnie
(xl)                  destroyed\endln
\lnie
(wa,wb,wc,ra)         destroyed\endln
\lnie
\endln
\lnie
note that there is a special call to patst in the evals\endln
\lnie
procedure with a slightly different form. see evals\endln
\lnie
for details of the form of this call.\endln
\lnie
\endln
\inst{patst}{prc}{n,1}{entry point}
\inst{}{jsr}{gtstg}{convert argument as string}
\inst{}{ppm}{pats7}{jump if not string}
\inst{}{bze}{wa,pats7}{jump if null string (catspaw)}
\inst{}{bne}{wa,=num01,pats2}{jump if not one char string}
\lnie
\endln
\lnie
here for one char string case\endln
\lnie
\endln
\inst{}{bze}{wb,pats2}{treat as multi-char if evals call}
\inst{}{plc}{xr}{point to character}
\inst{}{lch}{xr,(xr)}{load character}
\lnie
\endln
\lnie
common exit point after successful construction\endln
\lnie
\endln
\inst{pats1}{jsr}{pbild}{call routine to build node}
\inst{}{exi}{}{return to patst caller}
\vfill\break

\lnie
\endln
\lnie
patst (continued)\endln
\lnie
\endln
\lnie
here for multi-character string case\endln
\lnie
\endln
\inst{pats2}{mov}{xl,-(xs)}{save multi-char pcode}
\inst{}{mov}{ctmsk,wc}{load current mask bit}
\inst{}{beq}{xr,r$cts,pats6}{jump if same as last string c3.738}
\inst{}{mov}{xr,-(xs)}{save string pointer}
\inst{}{lsh}{wc,1}{shift to next position}
\inst{}{nzb}{wc,pats4}{skip if position left in this tbl}
\lnie
\endln
\lnie
here we must allocate a new character table\endln
\lnie
\endln
\inst{}{mov}{*ctsi$,wa}{set size of ctblk}
\inst{}{jsr}{alloc}{allocate ctblk}
\inst{}{mov}{xr,r$ctp}{store ptr to new ctblk}
\inst{}{mov}{=b$ctt,(xr)+}{store type code, bump ptr}
\inst{}{lct}{wb,=cfp$a}{set number of words to clear}
\inst{}{mov}{bits0,wc}{load all zero bits}
\lnie
\endln
\lnie
loop to clear all bits in table to zeros\endln
\lnie
\endln
\inst{pats3}{mov}{wc,(xr)+}{move word of zero bits}
\inst{}{bct}{wb,pats3}{loop till all cleared}
\inst{}{mov}{bits1,wc}{set initial bit position}
\lnie
\endln
\lnie
merge here with bit position available\endln
\lnie
\endln
\inst{pats4}{mov}{wc,ctmsk}{save parm2 (new bit position)}
\inst{}{mov}{(xs)+,xl}{restore pointer to argument string}
\inst{}{mov}{xl,r$cts}{save for next time   c3.738}
\inst{}{mov}{sclen(xl),wb}{load string length}
\inst{}{bze}{wb,pats6}{jump if null string case}
\inst{}{lct}{wb,wb}{else set loop counter}
\inst{}{plc}{xl}{point to characters in argument}
\vfill\break

\lnie
\endln
\lnie
patst (continued)\endln
\lnie
\endln
\lnie
loop to set bits in column of table\endln
\lnie
\endln
\inst{pats5}{lch}{wa,(xl)+}{load next character}
\inst{}{wtb}{wa}{convert to byte offset}
\inst{}{mov}{r$ctp,xr}{point to ctblk}
\inst{}{add}{wa,xr}{point to ctblk entry}
\inst{}{mov}{wc,wa}{copy bit mask}
\inst{}{orb}{ctchs(xr),wa}{or in bits already set}
\inst{}{mov}{wa,ctchs(xr)}{store resulting bit string}
\inst{}{bct}{wb,pats5}{loop till all bits set}
\lnie
\endln
\lnie
complete processing for multi-char string case\endln
\lnie
\endln
\inst{pats6}{mov}{r$ctp,xr}{load ctblk ptr as parm1 for pbild}
\inst{}{zer}{xl}{clear garbage ptr in xl}
\inst{}{mov}{(xs)+,wb}{load pcode for multi-char str case}
\inst{}{brn}{pats1}{back to exit (wc=bitstring=parm2)}
\lnie
\endln
\lnie
here if argument is not a string\endln
\lnie
\endln
\lnie
note that the call from evals cannot pass an expression\endln
\lnie
since evalp always reevaluates expressions.\endln
\lnie
\endln
\inst{pats7}{mov}{wc,wb}{set pcode for expression argument}
\inst{}{blo}{(xr),=b$e$$,pats1}{jump to exit if expression arg}
\inst{}{exi}{1}{else take wrong type error exit}
\inst{}{enp}{}{end procedure patst}
\vfill\break

\lnie
\endln
\lnie
pbild -- build pattern node\endln
\lnie
\endln
\lnie
(xr)                  parm1 (only if required)\endln
\lnie
(wb)                  pcode for node\endln
\lnie
(wc)                  parm2 (only if required)\endln
\lnie
jsr  pbild            call to build node\endln
\lnie
(xr)                  pointer to constructed node\endln
\lnie
(wa)                  destroyed\endln
\lnie
\endln
\inst{pbild}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{stack possible parm1}
\inst{}{mov}{wb,xr}{copy pcode}
\inst{}{lei}{xr}{load entry point id (bl$px)}
\inst{}{beq}{xr,=bl$p1,pbld1}{jump if one parameter}
\inst{}{beq}{xr,=bl$p0,pbld3}{jump if no parameters}
\lnie
\endln
\lnie
here for two parameter case\endln
\lnie
\endln
\inst{}{mov}{*pcsi$,wa}{set size of p2blk}
\inst{}{jsr}{alloc}{allocate block}
\inst{}{mov}{wc,parm2(xr)}{store second parameter}
\inst{}{brn}{pbld2}{merge with one parm case}
\lnie
\endln
\lnie
here for one parameter case\endln
\lnie
\endln
\inst{pbld1}{mov}{*pbsi$,wa}{set size of p1blk}
\inst{}{jsr}{alloc}{allocate node}
\lnie
\endln
\lnie
merge here from two parm case\endln
\lnie
\endln
\inst{pbld2}{mov}{(xs),parm1(xr)}{store first parameter}
\inst{}{brn}{pbld4}{merge with no parameter case}
\lnie
\endln
\lnie
here for case of no parameters\endln
\lnie
\endln
\inst{pbld3}{mov}{*pasi$,wa}{set size of p0blk}
\inst{}{jsr}{alloc}{allocate node}
\lnie
\endln
\lnie
merge here from other cases\endln
\lnie
\endln
\inst{pbld4}{mov}{wb,(xr)}{store pcode}
\inst{}{ica}{xs}{pop first parameter}
\inst{}{mov}{=ndnth,pthen(xr)}{set nothen successor pointer}
\inst{}{exi}{}{return to pbild caller}
\inst{}{enp}{}{end procedure pbild}
\vfill\break

\lnie
\endln
\lnie
pconc -- concatenate two patterns\endln
\lnie
\endln
\lnie
(xl)                  ptr to right pattern\endln
\lnie
(xr)                  ptr to left pattern\endln
\lnie
jsr  pconc            call to concatenate patterns\endln
\lnie
(xr)                  ptr to concatenated pattern\endln
\lnie
(xl,wa,wb,wc)         destroyed\endln
\lnie
\endln
\lnie
\endln
\lnie
to concatenate two patterns, all successors in the left\endln
\lnie
pattern which point to the nothen node must be changed to\endln
\lnie
point to the right pattern. however, this modification\endln
\lnie
must be performed on a copy of the left argument rather\endln
\lnie
than the left argument itself, since the left argument\endln
\lnie
may be pointed to by some other variable value.\endln
\lnie
\endln
\lnie
accordingly, it is necessary to copy the left argument.\endln
\lnie
this is not a trivial process since we must avoid copying\endln
\lnie
nodes more than once and the pattern is a graph structure\endln
\lnie
the following algorithm is employed.\endln
\lnie
\endln
\lnie
the stack is used to store a list of nodes which\endln
\lnie
have already been copied. the format of the entries on\endln
\lnie
this list consists of a two word block. the first word\endln
\lnie
is the old address and the second word is the address\endln
\lnie
of the copy. this list is searched by the pcopy\endln
\lnie
routine to avoid making duplicate copies. a trick is\endln
\lnie
used to accomplish the concatenation at the same time.\endln
\lnie
a special entry is made to start with on the stack. this\endln
\lnie
entry records that the nothen node has been copied\endln
\lnie
already and the address of its copy is the right pattern.\endln
\lnie
this automatically performs the correct replacements.\endln
\lnie
\endln
\inst{pconc}{prc}{e,0}{entry point}
\inst{}{zer}{-(xs)}{make room for one entry at bottom}
\inst{}{mov}{xs,wc}{store pointer to start of list}
\inst{}{mov}{=ndnth,-(xs)}{stack nothen node as old node}
\inst{}{mov}{xl,-(xs)}{store right arg as copy of nothen}
\inst{}{mov}{xs,xt}{initialize pointer to stack entries}
\inst{}{jsr}{pcopy}{copy first node of left arg}
\inst{}{mov}{wa,num02(xt)}{store as result under list}
\vfill\break

\lnie
\endln
\lnie
pconc (continued)\endln
\lnie
\endln
\lnie
the following loop scans entries in the list and makes\endln
\lnie
sure that their successors have been copied.\endln
\lnie
\endln
\inst{pcnc1}{beq}{xt,xs,pcnc2}{jump if all entries processed}
\inst{}{mov}{-(xt),xr}{else load next old address}
\inst{}{mov}{pthen(xr),xr}{load pointer to successor}
\inst{}{jsr}{pcopy}{copy successor node}
\inst{}{mov}{-(xt),xr}{load pointer to new node (copy)}
\inst{}{mov}{wa,pthen(xr)}{store ptr to new successor}
\lnie
\endln
\lnie
now check for special case of alternation node where\endln
\lnie
parm1 points to a node and must be copied like pthen.\endln
\lnie
\endln
\inst{}{bne}{(xr),=p$alt,pcnc1}{loop back if not}
\inst{}{mov}{parm1(xr),xr}{else load pointer to alternative}
\inst{}{jsr}{pcopy}{copy it}
\inst{}{mov}{(xt),xr}{restore ptr to new node}
\inst{}{mov}{wa,parm1(xr)}{store ptr to copied alternative}
\inst{}{brn}{pcnc1}{loop back for next entry}
\lnie
\endln
\lnie
here at end of copy process\endln
\lnie
\endln
\inst{pcnc2}{mov}{wc,xs}{restore stack pointer}
\inst{}{mov}{(xs)+,xr}{load pointer to copy}
\inst{}{exi}{}{return to pconc caller}
\inst{}{enp}{}{end procedure pconc}
\vfill\break

\lnie
\endln
\lnie
pcopy -- copy a pattern node\endln
\lnie
\endln
\lnie
pcopy is called from the pconc procedure to copy a single\endln
\lnie
pattern node. the copy is only carried out if the node\endln
\lnie
has not been copied already.\endln
\lnie
\endln
\lnie
(xr)                  pointer to node to be copied\endln
\lnie
(xt)                  ptr to current loc in copy list\endln
\lnie
(wc)                  pointer to list of copied nodes\endln
\lnie
jsr  pcopy            call to copy a node\endln
\lnie
(wa)                  pointer to copy\endln
\lnie
(wb,xr)               destroyed\endln
\lnie
\endln
\inst{pcopy}{prc}{n,0}{entry point}
\inst{}{mov}{xt,wb}{save xt}
\inst{}{mov}{wc,xt}{point to start of list}
\lnie
\endln
\lnie
loop to search list of nodes copied already\endln
\lnie
\endln
\inst{pcop1}{dca}{xt}{point to next entry on list}
\inst{}{beq}{xr,(xt),pcop2}{jump if match}
\inst{}{dca}{xt}{else skip over copied address}
\inst{}{bne}{xt,xs,pcop1}{loop back if more to test}
\lnie
\endln
\lnie
here if not in list, perform copy\endln
\lnie
\endln
\inst{}{mov}{(xr),wa}{load first word of block}
\inst{}{jsr}{blkln}{get length of block}
\inst{}{mov}{xr,xl}{save pointer to old node}
\inst{}{jsr}{alloc}{allocate space for copy}
\inst{}{mov}{xl,-(xs)}{store old address on list}
\inst{}{mov}{xr,-(xs)}{store new address on list}
\inst{}{chk}{}{check for stack overflow}
\inst{}{mvw}{}{move words from old block to copy}
\inst{}{mov}{(xs),wa}{load pointer to copy}
\inst{}{brn}{pcop3}{jump to exit}
\lnie
\endln
\lnie
here if we find entry in list\endln
\lnie
\endln
\inst{pcop2}{mov}{-(xt),wa}{load address of copy from list}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{pcop3}{mov}{wb,xt}{restore xt}
\inst{}{exi}{}{return to pcopy caller}
\inst{}{enp}{}{end procedure pcopy}
\vfill\break

\ifmac{.cnpf}
\asmac{else}
\lnie
\endln
\lnie
prflr -- print profile\endln
\lnie
prflr is called to print the contents of the profile\endln
\lnie
table in a fairly readable tabular format.\endln
\lnie
\endln
\lnie
jsr  prflr            call to print profile\endln
\lnie
(wa,ia)               destroyed\endln
\lnie
\endln
\inst{prflr}{prc}{}{}
\inst{}{bze}{pfdmp,prfl4}{no printing if no profiling done}
\inst{}{mov}{xr,-(xs)}{preserve entry xr}
\inst{}{mov}{wb,pfsvw}{and also wb}
\inst{}{jsr}{prtpg}{eject}
\inst{}{mov}{=pfms1,xr}{load msg /program profile/}
\inst{}{jsr}{prtst}{and print it}
\inst{}{jsr}{prtnl}{followed by newline}
\inst{}{jsr}{prtnl}{and another}
\inst{}{mov}{=pfms2,xr}{point to first hdr}
\inst{}{jsr}{prtst}{print it}
\inst{}{jsr}{prtnl}{new line}
\inst{}{mov}{=pfms3,xr}{second hdr}
\inst{}{jsr}{prtst}{print it}
\inst{}{jsr}{prtnl}{new line}
\inst{}{jsr}{prtnl}{and another blank line}
\inst{}{zer}{wb}{initial stmt count}
\inst{}{mov}{pftbl,xr}{point to table origin}
\inst{}{add}{*xndta,xr}{bias past xnblk header (sgd07)}
\lnie
\endln
\lnie
loop here to print successive entries\endln
\lnie
\endln
\inst{prfl1}{icv}{wb}{bump stmt nr}
\inst{}{ldi}{(xr)}{load nr of executions}
\inst{}{ieq}{prfl3}{no printing if zero}
\inst{}{mov}{=pfpd1,profs}{point where to print}
\inst{}{jsr}{prtin}{and print it}
\inst{}{zer}{profs}{back to start of line}
\inst{}{mti}{wb}{load stmt nr}
\inst{}{jsr}{prtin}{print it there}
\inst{}{mov}{=pfpd2,profs}{and pad past count}
\inst{}{ldi}{cfp$i(xr)}{load total exec time}
\inst{}{jsr}{prtin}{print that too}
\inst{}{ldi}{cfp$i(xr)}{reload time}
\inst{}{mli}{intth}{convert to microsec}
\inst{}{iov}{prfl2}{omit next bit if overflow}
\inst{}{dvi}{(xr)}{divide by executions}
\inst{}{mov}{=pfpd3,profs}{pad last print}
\inst{}{jsr}{prtin}{and print mcsec/execn}
\lnie
\endln
\lnie
merge after printing time\endln
\lnie
\endln
\inst{prfl2}{jsr}{prtnl}{thats another line}
\lnie
\endln
\lnie
here to go to next entry\endln
\lnie
\endln
\inst{prfl3}{add}{*pf$i2,xr}{bump index ptr (sgd07)}
\inst{}{blt}{wb,pfnte,prfl1}{loop if more stmts}
\inst{}{mov}{(xs)+,xr}{restore callers xr}
\inst{}{mov}{pfsvw,wb}{and wb too}
\lnie
\endln
\lnie
here to exit\endln
\lnie
\endln
\inst{prfl4}{exi}{}{return}
\inst{}{enp}{}{end of prflr}
\vfill\break

\lnie
\endln
\lnie
prflu -- update an entry in the profile table\endln
\lnie
\endln
\lnie
on entry, kvstn contains nr of stmt to profile\endln
\lnie
\endln
\lnie
jsr  prflu            call to update entry\endln
\lnie
(ia)                  destroyed\endln
\lnie
\endln
\inst{prflu}{prc}{}{}
\inst{}{bnz}{pffnc,pflu4}{skip if just entered function}
\inst{}{mov}{xr,-(xs)}{preserve entry xr}
\inst{}{mov}{wa,pfsvw}{save wa (sgd07)}
\inst{}{bnz}{pftbl,pflu2}{branch if table allocated}
\lnie
\endln
\lnie
here if space for profile table not yet allocated.\endln
\lnie
calculate size needed, allocate a static xnblk, and\endln
\lnie
initialize it all to zero.\endln
\lnie
the time taken for this will be attributed to the current\endln
\lnie
statement (assignment to keywd profile), but since the\endln
\lnie
timing for this statement is up the pole anyway, this\endln
\lnie
doesnt really matter...\endln
\lnie
\endln
\inst{}{sub}{=num01,pfnte}{adjust for extra count (sgd07)}
\inst{}{mti}{pfi2a}{convrt entry size to int}
\inst{}{sti}{pfste}{and store safely for later}
\inst{}{mti}{pfnte}{load table length as integer}
\inst{}{mli}{pfste}{multiply by entry size}
\inst{}{mfi}{wa}{get back address-style}
\inst{}{add}{=num02,wa}{add on 2 word overhead}
\inst{}{wtb}{wa}{convert the whole lot to bytes}
\inst{}{jsr}{alost}{gimme the space}
\inst{}{mov}{xr,pftbl}{save block pointer}
\inst{}{mov}{=b$xnt,(xr)+}{put block type and ...}
\inst{}{mov}{wa,(xr)+}{... length into header}
\inst{}{mfi}{wa}{get back nr of wds in data area}
\inst{}{lct}{wa,wa}{load the counter}
\lnie
\endln
\lnie
loop here to zero the block data\endln
\lnie
\endln
\inst{pflu1}{zer}{(xr)+}{blank a word}
\inst{}{bct}{wa,pflu1}{and alllllll the rest}
\lnie
\endln
\lnie
end of allocation. merge back into routine\endln
\lnie
\endln
\inst{pflu2}{mti}{kvstn}{load nr of stmt just ended}
\inst{}{sbi}{intv1}{make into index offset}
\inst{}{mli}{pfste}{make offset of table entry}
\inst{}{mfi}{wa}{convert to address}
\inst{}{wtb}{wa}{get as baus}
\inst{}{add}{*num02,wa}{offset includes table header}
\inst{}{mov}{pftbl,xr}{get table start}
\inst{}{bge}{wa,num01(xr),pflu3}{ if out of table, skip it}
\inst{}{add}{wa,xr}{else point to entry}
\inst{}{ldi}{(xr)}{get nr of executions so far}
\inst{}{adi}{intv1}{nudge up one}
\inst{}{sti}{(xr)}{and put back}
\inst{}{jsr}{systm}{get time now}
\inst{}{sti}{pfetm}{stash ending time}
\inst{}{sbi}{pfstm}{subtract start time}
\inst{}{adi}{cfp$i(xr)}{add cumulative time so far}
\inst{}{sti}{cfp$i(xr)}{and put back new total}
\inst{}{ldi}{pfetm}{load end time of this stmt ...}
\inst{}{sti}{pfstm}{... which is start time of next}
\lnie
\endln
\lnie
merge here to exit\endln
\lnie
\endln
\inst{pflu3}{mov}{(xs)+,xr}{restore callers xr}
\inst{}{mov}{pfsvw,wa}{restore saved reg}
\inst{}{exi}{}{and return}
\lnie
\endln
\lnie
here if profile is suppressed because a program defined\endln
\lnie
function is about to be entered, and so the current stmt\endln
\lnie
has not yet finished\endln
\lnie
\endln
\inst{pflu4}{zer}{pffnc}{reset the condition flag}
\inst{}{exi}{}{and immediate return}
\inst{}{enp}{}{end of procedure prflu}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
prpar - process print parameters\endln
\lnie
\endln
\lnie
(wc)                  if nonzero associate terminal only\endln
\lnie
jsr  prpar            call to process print parameters\endln
\lnie
(xl,xr,wa,wb,wc)      destroyed\endln
\lnie
\endln
\lnie
since memory allocation is undecided on initial call,\endln
\lnie
terminal cannot be associated. the entry with wc non-zero\endln
\lnie
is provided so a later call can be made to complete this.\endln
\lnie
\endln
\inst{prpar}{prc}{e,0}{entry point}
\inst{}{bnz}{wc,prpa8}{jump to associate terminal}
\inst{}{jsr}{syspp}{get print parameters}
\inst{}{bnz}{wb,prpa1}{jump if lines/page specified}
\inst{}{mov}{=cfp$m,wb}{else use a large value}
\inst{}{rsh}{wb,1}{but not too large}
\lnie
\endln
\lnie
store line count/page\endln
\lnie
\endln
\inst{prpa1}{mov}{wb,lstnp}{store number of lines/page}
\inst{}{mov}{wb,lstlc}{pretend page is full initially}
\inst{}{zer}{lstpg}{clear page number}
\inst{}{mov}{prlen,wb}{get prior length if any}
\inst{}{bze}{wb,prpa2}{skip if no length}
\inst{}{bgt}{wa,wb,prpa3}{skip storing if too big}
\lnie
\endln
\lnie
store print buffer length\endln
\lnie
\endln
\inst{prpa2}{mov}{wa,prlen}{store value}
\lnie
\endln
\lnie
process bits options\endln
\lnie
\endln
\inst{prpa3}{mov}{bits3,wb}{bit 3 mask}
\inst{}{anb}{wc,wb}{get -nolist bit}
\inst{}{zrb}{wb,prpa4}{skip if clear}
\inst{}{zer}{cswls}{set -nolist}
\lnie
\endln
\lnie
check if fail reports goto interactive channel\endln
\lnie
\endln
\inst{prpa4}{mov}{bits1,wb}{bit 1 mask}
\inst{}{anb}{wc,wb}{get bit}
\inst{}{mov}{wb,erich}{store int. chan. error flag}
\inst{}{mov}{bits2,wb}{bit 2 mask}
\inst{}{anb}{wc,wb}{get bit}
\inst{}{mov}{wb,prich}{flag for std printer on int. chan.}
\inst{}{mov}{bits4,wb}{bit 4 mask}
\inst{}{anb}{wc,wb}{get bit}
\inst{}{mov}{wb,cpsts}{flag for compile stats suppressn.}
\inst{}{mov}{bits5,wb}{bit 5 mask}
\inst{}{anb}{wc,wb}{get bit}
\inst{}{mov}{wb,exsts}{flag for exec stats suppression}
\vfill\break

\lnie
\endln
\lnie
prpar (continued)\endln
\lnie
\endln
\inst{}{mov}{bits6,wb}{bit 6 mask}
\inst{}{anb}{wc,wb}{get bit}
\inst{}{mov}{wb,precl}{extended/compact listing flag}
\inst{}{sub}{=num08,wa}{point 8 chars from line end}
\inst{}{zrb}{wb,prpa5}{jump if not extended}
\inst{}{mov}{wa,lstpo}{store for listing page headings}
\lnie
\endln
\lnie
 continue option processing\endln
\lnie
\endln
\inst{prpa5}{mov}{bits7,wb}{bit 7 mask}
\inst{}{anb}{wc,wb}{get bit 7}
\inst{}{mov}{wb,cswex}{set -noexecute if non-zero}
\inst{}{mov}{bit10,wb}{bit 10 mask}
\inst{}{anb}{wc,wb}{get bit 10}
\inst{}{mov}{wb,headp}{pretend printed to omit headers}
\inst{}{mov}{bits9,wb}{bit 9 mask}
\inst{}{anb}{wc,wb}{get bit 9}
\inst{}{mov}{wb,prsto}{keep it as std listing option}
\ifmac{.culc}
\inst{}{mov}{wc,wb}{copy flags}
\inst{}{rsh}{wb,12}{right justify bit 13}
\inst{}{anb}{bits1,wb}{get bit}
\inst{}{mov}{wb,kvcas}{set -case}
\asmac{fi}
\inst{}{mov}{bit12,wb}{bit 12 mask}
\inst{}{anb}{wc,wb}{get bit 12}
\inst{}{mov}{wb,cswer}{keep it as errors/noerrors option}
\inst{}{zrb}{wb,prpa6}{skip if clear}
\inst{}{mov}{prlen,wa}{get print buffer length}
\inst{}{sub}{=num08,wa}{point 8 chars from line end}
\inst{}{mov}{wa,lstpo}{store page offset}
\lnie
\endln
\lnie
check for -print/-noprint\endln
\lnie
\endln
\inst{prpa6}{mov}{bit11,wb}{bit 11 mask}
\inst{}{anb}{wc,wb}{get bit 11}
\inst{}{mov}{wb,cswpr}{set -print if non-zero}
\lnie
\endln
\lnie
check for terminal\endln
\lnie
\endln
\inst{}{anb}{bits8,wc}{see if terminal to be activated}
\inst{}{bnz}{wc,prpa8}{jump if terminal required}
\inst{}{bze}{initr,prpa9}{jump if no terminal to detach}
\inst{}{mov}{=v$ter,xl}{ptr to /terminal/}
\inst{}{jsr}{gtnvr}{get vrblk pointer}
\inst{}{ppm}{}{cant fail}
\inst{}{mov}{=nulls,vrval(xr)}{clear value of terminal}
\inst{}{jsr}{setvr}{remove association}
\inst{}{brn}{prpa9}{return}
\lnie
\endln
\lnie
associate terminal\endln
\lnie
\endln
\inst{prpa8}{mnz}{initr}{note terminal associated}
\inst{}{bze}{dnamb,prpa9}{cant if memory not organised}
\inst{}{mov}{=v$ter,xl}{point to terminal string}
\inst{}{mov}{=trtou,wb}{output trace type}
\inst{}{jsr}{inout}{attach output trblk to vrblk}
\inst{}{mov}{xr,-(xs)}{stack trblk ptr}
\inst{}{mov}{=v$ter,xl}{point to terminal string}
\inst{}{mov}{=trtin,wb}{input trace type}
\inst{}{jsr}{inout}{attach input trace blk}
\inst{}{mov}{(xs)+,vrval(xr)}{add output trblk to chain}
\lnie
\endln
\lnie
return point\endln
\lnie
\endln
\inst{prpa9}{exi}{}{return}
\inst{}{enp}{}{end procedure prpar}
\vfill\break

\lnie
\endln
\lnie
prtch -- print a character\endln
\lnie
\endln
\lnie
prtch is used to print a single character\endln
\lnie
\endln
\lnie
(wa)                  character to be printed\endln
\lnie
jsr  prtch            call to print character\endln
\lnie
\endln
\inst{prtch}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save xr}
\inst{}{bne}{profs,prlen,prch1}{jump if room in buffer}
\inst{}{jsr}{prtnl}{else print this line}
\lnie
\endln
\lnie
here after making sure we have room\endln
\lnie
\endln
\inst{prch1}{mov}{prbuf,xr}{point to print buffer}
\inst{}{psc}{xr,profs}{point to next character location}
\inst{}{sch}{wa,(xr)}{store new character}
\inst{}{csc}{xr}{complete store characters}
\inst{}{icv}{profs}{bump pointer}
\inst{}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{exi}{}{return to prtch caller}
\inst{}{enp}{}{end procedure prtch}
\vfill\break

\lnie
\endln
\lnie
prtic -- print to interactive channel\endln
\lnie
\endln
\lnie
prtic is called to print the contents of the standard\endln
\lnie
print buffer to the interactive channel. it is only\endln
\lnie
called after prtst has set up the string for printing.\endln
\lnie
it does not clear the buffer.\endln
\lnie
\endln
\lnie
jsr  prtic            call for print\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\inst{prtic}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save xr}
\inst{}{mov}{prbuf,xr}{point to buffer}
\inst{}{mov}{profs,wa}{no of chars}
\inst{}{jsr}{syspi}{print}
\inst{}{ppm}{prtc2}{fail return}
\lnie
\endln
\lnie
return\endln
\lnie
\endln
\inst{prtc1}{mov}{(xs)+,xr}{restore xr}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
error occured\endln
\lnie
\endln
\inst{prtc2}{zer}{erich}{prevent looping}
\inst{}{erb}{252,error on printing}{to interactive channel}
\inst{}{brn}{prtc1}{return}
\inst{}{enp}{}{procedure prtic}
\vfill\break

\lnie
\endln
\lnie
prtis -- print to interactive and standard printer\endln
\lnie
\endln
\lnie
prtis puts a line from the print buffer onto the\endln
\lnie
interactive channel (if any) and the standard printer.\endln
\lnie
it always prints to the standard printer but does\endln
\lnie
not duplicate lines if the standard printer is\endln
\lnie
interactive.  it clears down the print buffer.\endln
\lnie
\endln
\lnie
jsr  prtis            call for printing\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\inst{prtis}{prc}{e,0}{entry point}
\inst{}{bnz}{prich,prts1}{jump if standard printer is int.ch.}
\inst{}{bze}{erich,prts1}{skip if not doing int. error reps.}
\inst{}{jsr}{prtic}{print to interactive channel}
\lnie
\endln
\lnie
merge and exit\endln
\lnie
\endln
\inst{prts1}{jsr}{prtnl}{print to standard printer}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure prtis}
\vfill\break

\lnie
\endln
\lnie
prtin -- print an integer\endln
\lnie
\endln
\lnie
prtin prints the integer value which is in the integer\endln
\lnie
accumulator. blocks built in dynamic storage\endln
\lnie
during this process are immediately deleted.\endln
\lnie
\endln
\lnie
(ia)                  integer value to be printed\endln
\lnie
jsr  prtin            call to print integer\endln
\lnie
(ia,ra)               destroyed\endln
\lnie
\endln
\inst{prtin}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save xr}
\inst{}{jsr}{icbld}{build integer block}
\inst{}{blo}{xr,dnamb,prti1}{jump if icblk below dynamic}
\inst{}{bhi}{xr,dnamp,prti1}{jump if above dynamic}
\inst{}{mov}{xr,dnamp}{immediately delete it}
\lnie
\endln
\lnie
delete icblk from dynamic store\endln
\lnie
\endln
\inst{prti1}{mov}{xr,-(xs)}{stack ptr for gtstg}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{}{convert error is impossible}
\inst{}{mov}{xr,dnamp}{reset pointer to delete scblk}
\inst{}{jsr}{prtst}{print integer string}
\inst{}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{exi}{}{return to prtin caller}
\inst{}{enp}{}{end procedure prtin}
\vfill\break

\lnie
\endln
\lnie
prtmi -- print message and integer\endln
\lnie
\endln
\lnie
prtmi is used to print messages together with an integer\endln
\lnie
value starting in column 15 (used by the routines at\endln
\lnie
the end of compilation).\endln
\lnie
\endln
\lnie
jsr  prtmi            call to print message and integer\endln
\lnie
\endln
\inst{prtmi}{prc}{e,0}{entry point}
\inst{}{jsr}{prtst}{print string message}
\inst{}{mov}{=prtmf,profs}{set column offset}
\inst{}{jsr}{prtin}{print integer}
\inst{}{jsr}{prtnl}{print line}
\inst{}{exi}{}{return to prtmi caller}
\inst{}{enp}{}{end procedure prtmi}
\vfill\break

\lnie
\endln
\lnie
prtmm -- print memory used and available\endln
\lnie
\endln
\lnie
prtmm is used to provide memory usage information in\endln
\lnie
both the end-of-compile and end-of-run statistics.\endln
\lnie
\endln
\lnie
jsr  prtmm            call to print memory stats\endln
\lnie
\endln
\inst{prtmm}{prc}{}{}
\inst{}{mov}{dnamp,wa}{next available loc}
\inst{}{sub}{statb,wa}{minus start}
\ifmac{.cbyt}
\asmac{else}
\inst{}{btw}{wa}{convert to words}
\asmac{fi}
\inst{}{mti}{wa}{convert to integer}
\inst{}{mov}{=encm1,xr}{point to /memory used (words)/}
\inst{}{jsr}{prtmi}{print message}
\inst{}{mov}{dname,wa}{end of memory}
\inst{}{sub}{dnamp,wa}{minus next available loc}
\ifmac{.cbyt}
\asmac{else}
\inst{}{btw}{wa}{convert to words}
\asmac{fi}
\inst{}{mti}{wa}{convert to integer}
\inst{}{mov}{=encm2,xr}{point to /memory available (words)/}
\inst{}{jsr}{prtmi}{print line}
\inst{}{exi}{}{return to prtmm caller}
\inst{}{enp}{}{end of procedure prtmm}
\vfill\break

\lnie
\endln
\lnie
prtmx  -- as prtmi with extra copy to interactive chan.\endln
\lnie
\endln
\lnie
jsr  prtmx            call for printing\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\inst{prtmx}{prc}{e,0}{entry point}
\inst{}{jsr}{prtst}{print string message}
\inst{}{mov}{=prtmf,profs}{set column offset}
\inst{}{jsr}{prtin}{print integer}
\inst{}{jsr}{prtis}{print line}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure prtmx}
\vfill\break

\lnie
\endln
\lnie
prtnl -- print new line (end print line)\endln
\lnie
\endln
\lnie
prtnl prints the contents of the print buffer, resets\endln
\lnie
the buffer to all blanks and resets the print pointer.\endln
\lnie
\endln
\lnie
jsr  prtnl            call to print line\endln
\lnie
\endln
\inst{prtnl}{prc}{r,0}{entry point}
\inst{}{bnz}{headp,prnl0}{were headers printed}
\inst{}{jsr}{prtps}{no - print them}
\lnie
\endln
\lnie
call syspr\endln
\lnie
\endln
\inst{prnl0}{mov}{xr,-(xs)}{save entry xr}
\inst{}{mov}{wa,prtsa}{save wa}
\inst{}{mov}{wb,prtsb}{save wb}
\inst{}{mov}{prbuf,xr}{load pointer to buffer}
\inst{}{mov}{profs,wa}{load number of chars in buffer}
\inst{}{jsr}{syspr}{call system print routine}
\inst{}{ppm}{prnl2}{jump if failed}
\inst{}{lct}{wa,prlnw}{load length of buffer in words}
\inst{}{add}{*schar,xr}{point to chars of buffer}
\inst{}{mov}{nullw,wb}{get word of blanks}
\lnie
\endln
\lnie
loop to blank buffer\endln
\lnie
\endln
\inst{prnl1}{mov}{wb,(xr)+}{store word of blanks, bump ptr}
\inst{}{bct}{wa,prnl1}{loop till all blanked}
\lnie
\endln
\lnie
exit point\endln
\lnie
\endln
\inst{}{mov}{prtsb,wb}{restore wb}
\inst{}{mov}{prtsa,wa}{restore wa}
\inst{}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{zer}{profs}{reset print buffer pointer}
\inst{}{exi}{}{return to prtnl caller}
\lnie
\endln
\lnie
file full or no output file for load module\endln
\lnie
\endln
\inst{prnl2}{bnz}{prtef,prnl3}{jump if not first time}
\inst{}{mnz}{prtef}{mark first occurrence}
\inst{}{erb}{253,print limit exceeded}{on standard output channel}
\lnie
\endln
\lnie
stop at once\endln
\lnie
\endln
\inst{prnl3}{mov}{=nini8,wb}{ending code}
\inst{}{mov}{kvstn,wa}{statement number}
\inst{}{mov}{r$fcb,xl}{get fcblk chain head}
\inst{}{jsr}{sysej}{stop}
\inst{}{enp}{}{end procedure prtnl}
\vfill\break

\lnie
\endln
\lnie
prtnm -- print variable name\endln
\lnie
\endln
\lnie
prtnm is used to print a character representation of the\endln
\lnie
name of a variable (not a value of datatype name)\endln
\lnie
names of pseudo-variables may not be passed to prtnm.\endln
\lnie
\endln
\lnie
(xl)                  name base\endln
\lnie
(wa)                  name offset\endln
\lnie
jsr  prtnm            call to print name\endln
\lnie
(wb,wc,ra)            destroyed\endln
\lnie
\endln
\inst{prtnm}{prc}{r,0}{entry point (recursive, see prtvl)}
\inst{}{mov}{wa,-(xs)}{save wa (offset is collectable)}
\inst{}{mov}{xr,-(xs)}{save entry xr}
\inst{}{mov}{xl,-(xs)}{save name base}
\inst{}{bhi}{xl,state,prn02}{jump if not natural variable}
\lnie
\endln
\lnie
here for natural variable name, recognized by the fact\endln
\lnie
that the name base points into the static area.\endln
\lnie
\endln
\inst{}{mov}{xl,xr}{point to vrblk}
\inst{}{jsr}{prtvn}{print name of variable}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{prn01}{mov}{(xs)+,xl}{restore name base}
\inst{}{mov}{(xs)+,xr}{restore entry value of xr}
\inst{}{mov}{(xs)+,wa}{restore wa}
\inst{}{exi}{}{return to prtnm caller}
\lnie
\endln
\lnie
here for case of non-natural variable\endln
\lnie
\endln
\inst{prn02}{mov}{wa,wb}{copy name offset}
\inst{}{bne}{(xl),=b$pdt,prn03}{jump if array or table}
\lnie
\endln
\lnie
for program defined datatype, prt fld name, left paren\endln
\lnie
\endln
\inst{}{mov}{pddfp(xl),xr}{load pointer to dfblk}
\inst{}{add}{wa,xr}{add name offset}
\inst{}{mov}{pdfof(xr),xr}{load vrblk pointer for field}
\inst{}{jsr}{prtvn}{print field name}
\inst{}{mov}{=ch$pp,wa}{load left paren}
\inst{}{jsr}{prtch}{print character}
\vfill\break

\lnie
\endln
\lnie
prtnm (continued)\endln
\lnie
\endln
\lnie
now we print an identifying name for the object if one\endln
\lnie
can be found. the following code searches for a natural\endln
\lnie
variable which contains this object as value. if such a\endln
\lnie
variable is found, its name is printed, else the value\endln
\lnie
of the object (as printed by prtvl) is used instead.\endln
\lnie
\endln
\lnie
first we point to the parent tbblk if this is the case of\endln
\lnie
a table element. to do this, chase down the trnxt chain.\endln
\lnie
\endln
\inst{prn03}{bne}{(xl),=b$tet,prn04}{jump if we got there (or not te)}
\inst{}{mov}{tenxt(xl),xl}{else move out on chain}
\inst{}{brn}{prn03}{and loop back}
\lnie
\endln
\lnie
now we are ready for the search. to speed things up in\endln
\lnie
the case of calls from dump where the same name base\endln
\lnie
will occur repeatedly while dumping an array or table,\endln
\lnie
we remember the last vrblk pointer found in prnmv. so\endln
\lnie
first check to see if we have this one again.\endln
\lnie
\endln
\inst{prn04}{mov}{prnmv,xr}{point to vrblk we found last time}
\inst{}{mov}{hshtb,wa}{point to hash table in case not}
\inst{}{brn}{prn07}{jump into search for special check}
\lnie
\endln
\lnie
loop through hash slots\endln
\lnie
\endln
\inst{prn05}{mov}{wa,xr}{copy slot pointer}
\inst{}{ica}{wa}{bump slot pointer}
\inst{}{sub}{*vrnxt,xr}{introduce standard vrblk offset}
\lnie
\endln
\lnie
loop through vrblks on one hash chain\endln
\lnie
\endln
\inst{prn06}{mov}{vrnxt(xr),xr}{point to next vrblk on hash chain}
\lnie
\endln
\lnie
merge here first time to check block we found last time\endln
\lnie
\endln
\inst{prn07}{mov}{xr,wc}{copy vrblk pointer}
\inst{}{bze}{wc,prn09}{jump if chain end (or prnmv zero)}
\vfill\break

\lnie
\endln
\lnie
prtnm (continued)\endln
\lnie
\endln
\lnie
loop to find value (chase down possible trblk chain)\endln
\lnie
\endln
\inst{prn08}{mov}{vrval(xr),xr}{load value}
\inst{}{beq}{(xr),=b$trt,prn08}{loop if that was a trblk}
\lnie
\endln
\lnie
now we have the value, is this the block we want\endln
\lnie
\endln
\inst{}{beq}{xr,xl,prn10}{jump if this matches the name base}
\inst{}{mov}{wc,xr}{else point back to that vrblk}
\inst{}{brn}{prn06}{and loop back}
\lnie
\endln
\lnie
here to move to next hash slot\endln
\lnie
\endln
\inst{prn09}{blt}{wa,hshte,prn05}{loop back if more to go}
\inst{}{mov}{xl,xr}{else not found, copy value pointer}
\inst{}{jsr}{prtvl}{print value}
\inst{}{brn}{prn11}{and merge ahead}
\lnie
\endln
\lnie
here when we find a matching entry\endln
\lnie
\endln
\inst{prn10}{mov}{wc,xr}{copy vrblk pointer}
\inst{}{mov}{xr,prnmv}{save for next time in}
\inst{}{jsr}{prtvn}{print variable name}
\lnie
\endln
\lnie
merge here if no entry found\endln
\lnie
\endln
\inst{prn11}{mov}{(xl),wc}{load first word of name base}
\inst{}{bne}{wc,=b$pdt,prn13}{jump if not program defined}
\lnie
\endln
\lnie
for program defined datatype, add right paren and exit\endln
\lnie
\endln
\inst{}{mov}{=ch$rp,wa}{load right paren, merge}
\lnie
\endln
\lnie
merge here to print final right paren or bracket\endln
\lnie
\endln
\inst{prn12}{jsr}{prtch}{print final character}
\inst{}{mov}{wb,wa}{restore name offset}
\inst{}{brn}{prn01}{merge back to exit}
\vfill\break

\lnie
\endln
\lnie
prtnm (continued)\endln
\lnie
\endln
\lnie
here for array or table\endln
\lnie
\endln
\inst{prn13}{mov}{=ch$bb,wa}{load left bracket}
\inst{}{jsr}{prtch}{and print it}
\inst{}{mov}{(xs),xl}{restore block pointer}
\inst{}{mov}{(xl),wc}{load type word again}
\inst{}{bne}{wc,=b$tet,prn15}{jump if not table}
\lnie
\endln
\lnie
here for table, print subscript value\endln
\lnie
\endln
\inst{}{mov}{tesub(xl),xr}{load subscript value}
\inst{}{mov}{wb,xl}{save name offset}
\inst{}{jsr}{prtvl}{print subscript value}
\inst{}{mov}{xl,wb}{restore name offset}
\lnie
\endln
\lnie
merge here from array case to print right bracket\endln
\lnie
\endln
\inst{prn14}{mov}{=ch$rb,wa}{load right bracket}
\inst{}{brn}{prn12}{merge back to print it}
\lnie
\endln
\lnie
here for array or vector, to print subscript(s)\endln
\lnie
\endln
\inst{prn15}{mov}{wb,wa}{copy name offset}
\inst{}{btw}{wa}{convert to words}
\inst{}{beq}{wc,=b$art,prn16}{jump if arblk}
\lnie
\endln
\lnie
here for vector\endln
\lnie
\endln
\inst{}{sub}{=vcvlb,wa}{adjust for standard fields}
\inst{}{mti}{wa}{move to integer accum}
\inst{}{jsr}{prtin}{print linear subscript}
\inst{}{brn}{prn14}{merge back for right bracket}
\vfill\break

\lnie
\endln
\lnie
prtnm (continued)\endln
\lnie
\endln
\lnie
here for array. first calculate absolute subscript\endln
\lnie
offsets by successive divisions by the dimension values.\endln
\lnie
this must be done right to left since the elements are\endln
\lnie
stored row-wise. the subscripts are stacked as integers.\endln
\lnie
\endln
\inst{prn16}{mov}{arofs(xl),wc}{load length of bounds info}
\inst{}{ica}{wc}{adjust for arpro field}
\inst{}{btw}{wc}{convert to words}
\inst{}{sub}{wc,wa}{get linear zero-origin subscript}
\inst{}{mti}{wa}{get integer value}
\inst{}{lct}{wa,arndm(xl)}{set num of dimensions as loop count}
\inst{}{add}{arofs(xl),xl}{point past bounds information}
\inst{}{sub}{*arlbd,xl}{set ok offset for proper ptr later}
\lnie
\endln
\lnie
loop to stack subscript offsets\endln
\lnie
\endln
\inst{prn17}{sub}{*ardms,xl}{point to next set of bounds}
\inst{}{sti}{prnsi}{save current offset}
\inst{}{rmi}{ardim(xl)}{get remainder on dividing by dimens}
\inst{}{mfi}{-(xs)}{store on stack (one word)}
\inst{}{ldi}{prnsi}{reload argument}
\inst{}{dvi}{ardim(xl)}{divide to get quotient}
\inst{}{bct}{wa,prn17}{loop till all stacked}
\inst{}{zer}{xr}{set offset to first set of bounds}
\inst{}{lct}{wb,arndm(xl)}{load count of dims to control loop}
\inst{}{brn}{prn19}{jump into print loop}
\lnie
\endln
\lnie
loop to print subscripts from stack adjusting by adding\endln
\lnie
the appropriate low bound value from the arblk\endln
\lnie
\endln
\inst{prn18}{mov}{=ch$cm,wa}{load a comma}
\inst{}{jsr}{prtch}{print it}
\lnie
\endln
\lnie
merge here first time in (no comma required)\endln
\lnie
\endln
\inst{prn19}{mti}{(xs)+}{load subscript offset as integer}
\inst{}{add}{xr,xl}{point to current lbd}
\inst{}{adi}{arlbd(xl)}{add lbd to get signed subscript}
\inst{}{sub}{xr,xl}{point back to start of arblk}
\inst{}{jsr}{prtin}{print subscript}
\inst{}{add}{*ardms,xr}{bump offset to next bounds}
\inst{}{bct}{wb,prn18}{loop back till all printed}
\inst{}{brn}{prn14}{merge back to print right bracket}
\inst{}{enp}{}{end procedure prtnm}
\vfill\break

\lnie
\endln
\lnie
prtnv -- print name value\endln
\lnie
\endln
\lnie
prtnv is used by the trace and dump routines to print\endln
\lnie
a line of the form\endln
\lnie
\endln
\lnie
name = value\endln
\lnie
\endln
\lnie
note that the name involved can never be a pseudo-var\endln
\lnie
\endln
\lnie
(xl)                  name base\endln
\lnie
(wa)                  name offset\endln
\lnie
jsr  prtnv            call to print name = value\endln
\lnie
(wb,wc,ra)            destroyed\endln
\lnie
\endln
\inst{prtnv}{prc}{e,0}{entry point}
\inst{}{jsr}{prtnm}{print argument name}
\inst{}{mov}{xr,-(xs)}{save entry xr}
\inst{}{mov}{wa,-(xs)}{save name offset (collectable)}
\inst{}{mov}{=tmbeb,xr}{point to blank equal blank}
\inst{}{jsr}{prtst}{print it}
\inst{}{mov}{xl,xr}{copy name base}
\inst{}{add}{wa,xr}{point to value}
\inst{}{mov}{(xr),xr}{load value pointer}
\inst{}{jsr}{prtvl}{print value}
\inst{}{jsr}{prtnl}{terminate line}
\inst{}{mov}{(xs)+,wa}{restore name offset}
\inst{}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure prtnv}
\vfill\break

\lnie
\endln
\lnie
prtpg  -- print a page throw\endln
\lnie
\endln
\lnie
prints a page throw or a few blank lines on the standard\endln
\lnie
listing channel depending on the listing options chosen.\endln
\lnie
\endln
\lnie
jsr  prtpg            call for page eject\endln
\lnie
\endln
\inst{prtpg}{prc}{e,0}{entry point}
\inst{}{beq}{stage,=stgxt,prp01}{jump if execution time}
\inst{}{bze}{lstlc,prp06}{return if top of page already}
\inst{}{zer}{lstlc}{clear line count}
\lnie
\endln
\lnie
check type of listing\endln
\lnie
\endln
\inst{prp01}{mov}{xr,-(xs)}{preserve xr}
\inst{}{bnz}{prstd,prp02}{eject if flag set}
\inst{}{bnz}{prich,prp03}{jump if interactive listing channel}
\inst{}{bze}{precl,prp03}{jump if compact listing}
\lnie
\endln
\lnie
perform an eject\endln
\lnie
\endln
\inst{prp02}{jsr}{sysep}{eject}
\inst{}{brn}{prp04}{merge}
\lnie
\endln
\lnie
compact or interactive channel listing. cant print\endln
\lnie
blanks until check made for headers printed and flag set.\endln
\lnie
\endln
\lnie
\endln
\inst{prp03}{mov}{headp,xr}{remember headp}
\inst{}{mnz}{headp}{set to avoid repeated prtpg calls}
\inst{}{jsr}{prtnl}{print blank line}
\inst{}{jsr}{prtnl}{print blank line}
\inst{}{jsr}{prtnl}{print blank line}
\inst{}{mov}{=num03,lstlc}{count blank lines}
\inst{}{mov}{xr,headp}{restore header flag}
\vfill\break

\lnie
\endln
\lnie
prptg (continued)\endln
\lnie
\endln
\lnie
print the heading\endln
\lnie
\endln
\inst{prp04}{bnz}{headp,prp05}{jump if header listed}
\inst{}{mnz}{headp}{mark headers printed}
\inst{}{mov}{xl,-(xs)}{keep xl}
\inst{}{mov}{=headr,xr}{point to listing header}
\inst{}{jsr}{prtst}{place it}
\inst{}{jsr}{sysid}{get system identification}
\inst{}{jsr}{prtst}{append extra chars}
\inst{}{jsr}{prtnl}{print it}
\inst{}{mov}{xl,xr}{extra header line}
\inst{}{jsr}{prtst}{place it}
\inst{}{jsr}{prtnl}{print it}
\inst{}{jsr}{prtnl}{print a blank}
\inst{}{jsr}{prtnl}{and another}
\inst{}{add}{=num04,lstlc}{four header lines printed}
\inst{}{mov}{(xs)+,xl}{restore xl}
\lnie
\endln
\lnie
merge if header not printed\endln
\lnie
\endln
\inst{prp05}{mov}{(xs)+,xr}{restore xr}
\lnie
\endln
\lnie
return\endln
\lnie
\endln
\inst{prp06}{exi}{}{return}
\inst{}{enp}{}{end procedure prtpg}
\vfill\break

\lnie
\endln
\lnie
prtps - print page with test for standard listing option\endln
\lnie
\endln
\lnie
if the standard listing option is selected, insist that\endln
\lnie
an eject be done\endln
\lnie
\endln
\lnie
jsr  prtps            call for eject\endln
\lnie
\endln
\inst{prtps}{prc}{e,0}{entry point}
\inst{}{mov}{prsto,prstd}{copy option flag}
\inst{}{jsr}{prtpg}{print page}
\inst{}{zer}{prstd}{clear flag}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure prtps}
\vfill\break

\lnie
\endln
\lnie
prtsn -- print statement number\endln
\lnie
\endln
\lnie
prtsn is used to initiate a print trace line by printing\endln
\lnie
asterisks and the current statement number. the actual\endln
\lnie
format of the output generated is.\endln
\lnie
\endln
\lnie
***nnnnn**** iii.....iiii\endln
\lnie
\endln
\lnie
nnnnn is the statement number with leading zeros replaced\endln
\lnie
by asterisks (e.g. *******9****)\endln
\lnie
\endln
\lnie
iii...iii represents a variable length output consisting\endln
\lnie
of a number of letter i characters equal to fnclevel.\endln
\lnie
\endln
\lnie
jsr  prtsn            call to print statement number\endln
\lnie
(wc)                  destroyed\endln
\lnie
\endln
\inst{prtsn}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save entry xr}
\inst{}{mov}{wa,prsna}{save entry wa}
\inst{}{mov}{=tmasb,xr}{point to asterisks}
\inst{}{jsr}{prtst}{print asterisks}
\inst{}{mov}{=num04,profs}{point into middle of asterisks}
\inst{}{mti}{kvstn}{load statement number as integer}
\inst{}{jsr}{prtin}{print integer statement number}
\inst{}{mov}{=prsnf,profs}{point past asterisks plus blank}
\inst{}{mov}{kvfnc,xr}{get fnclevel}
\inst{}{mov}{=ch$li,wa}{set letter i}
\lnie
\endln
\lnie
loop to generate letter i fnclevel times\endln
\lnie
\endln
\inst{prsn1}{bze}{xr,prsn2}{jump if all set}
\inst{}{jsr}{prtch}{else print an i}
\inst{}{dcv}{xr}{decrement counter}
\inst{}{brn}{prsn1}{loop back}
\lnie
\endln
\lnie
merge with all letter i characters generated\endln
\lnie
\endln
\inst{prsn2}{mov}{=ch$bl,wa}{get blank}
\inst{}{jsr}{prtch}{print blank}
\inst{}{mov}{prsna,wa}{restore entry wa}
\inst{}{mov}{(xs)+,xr}{restore entry xr}
\inst{}{exi}{}{return to prtsn caller}
\inst{}{enp}{}{end procedure prtsn}
\vfill\break

\lnie
\endln
\lnie
prtst -- print string\endln
\lnie
\endln
\lnie
prtst places a string of characters in the print buffer\endln
\lnie
\endln
\lnie
see prtnl for global locations used\endln
\lnie
\endln
\lnie
note that the first word of the block (normally b$scl)\endln
\lnie
is not used and need not be set correctly (see prtvn)\endln
\lnie
\endln
\lnie
(xr)                  string to be printed\endln
\lnie
jsr  prtst            call to print string\endln
\lnie
(profs)               updated past chars placed\endln
\lnie
\endln
\inst{prtst}{prc}{r,0}{entry point}
\inst{}{bnz}{headp,prst0}{were headers printed}
\inst{}{jsr}{prtps}{no - print them}
\lnie
\endln
\lnie
call syspr\endln
\lnie
\endln
\inst{prst0}{mov}{wa,prsva}{save wa}
\inst{}{mov}{wb,prsvb}{save wb}
\inst{}{zer}{wb}{set chars printed count to zero}
\lnie
\endln
\lnie
loop to print successive lines for long string\endln
\lnie
\endln
\inst{prst1}{mov}{sclen(xr),wa}{load string length}
\inst{}{sub}{wb,wa}{subtract count of chars already out}
\inst{}{bze}{wa,prst4}{jump to exit if none left}
\inst{}{mov}{xl,-(xs)}{else stack entry xl}
\inst{}{mov}{xr,-(xs)}{save argument}
\inst{}{mov}{xr,xl}{copy for eventual move}
\inst{}{mov}{prlen,xr}{load print buffer length}
\inst{}{sub}{profs,xr}{get chars left in print buffer}
\inst{}{bnz}{xr,prst2}{skip if room left on this line}
\inst{}{jsr}{prtnl}{else print this line}
\inst{}{mov}{prlen,xr}{and set full width available}
\vfill\break

\lnie
\endln
\lnie
prtst (continued)\endln
\lnie
\endln
\lnie
here with chars to print and some room in buffer\endln
\lnie
\endln
\inst{prst2}{blo}{wa,xr,prst3}{jump if room for rest of string}
\inst{}{mov}{xr,wa}{else set to fill line}
\lnie
\endln
\lnie
merge here with character count in wa\endln
\lnie
\endln
\inst{prst3}{mov}{prbuf,xr}{point to print buffer}
\inst{}{plc}{xl,wb}{point to location in string}
\inst{}{psc}{xr,profs}{point to location in buffer}
\inst{}{add}{wa,wb}{bump string chars count}
\inst{}{add}{wa,profs}{bump buffer pointer}
\inst{}{mov}{wb,prsvc}{preserve char counter}
\inst{}{mvc}{}{move characters to buffer}
\inst{}{mov}{prsvc,wb}{recover char counter}
\inst{}{mov}{(xs)+,xr}{restore argument pointer}
\inst{}{mov}{(xs)+,xl}{restore entry xl}
\inst{}{brn}{prst1}{loop back to test for more}
\lnie
\endln
\lnie
here to exit after printing string\endln
\lnie
\endln
\inst{prst4}{mov}{prsvb,wb}{restore entry wb}
\inst{}{mov}{prsva,wa}{restore entry wa}
\inst{}{exi}{}{return to prtst caller}
\inst{}{enp}{}{end procedure prtst}
\vfill\break

\lnie
\endln
\lnie
prttr -- print to terminal\endln
\lnie
\endln
\lnie
called to print contents of standard print buffer to\endln
\lnie
online terminal. clears buffer down and resets profs.\endln
\lnie
\endln
\lnie
jsr  prttr            call for print\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\inst{prttr}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{save xr}
\inst{}{jsr}{prtic}{print buffer contents}
\inst{}{mov}{prbuf,xr}{point to print bfr to clear it}
\inst{}{lct}{wa,prlnw}{get buffer length}
\inst{}{add}{*schar,xr}{point past scblk header}
\inst{}{mov}{nullw,wb}{get blanks}
\lnie
\endln
\lnie
loop to clear buffer\endln
\lnie
\endln
\inst{prtt1}{mov}{wb,(xr)+}{clear a word}
\inst{}{bct}{wa,prtt1}{loop}
\inst{}{zer}{profs}{reset profs}
\inst{}{mov}{(xs)+,xr}{restore xr}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure prttr}
\vfill\break

\lnie
\endln
\lnie
prtvl -- print a value\endln
\lnie
\endln
\lnie
prtvl places an appropriate character representation of\endln
\lnie
a data value in the print buffer for dump/trace use.\endln
\lnie
\endln
\lnie
(xr)                  value to be printed\endln
\lnie
jsr  prtvl            call to print value\endln
\lnie
(wa,wb,wc,ra)         destroyed\endln
\lnie
\endln
\inst{prtvl}{prc}{r,0}{entry point, recursive}
\inst{}{mov}{xl,-(xs)}{save entry xl}
\inst{}{mov}{xr,-(xs)}{save argument}
\inst{}{chk}{}{check for stack overflow}
\lnie
\endln
\lnie
loop back here after finding a trap block (trblk)\endln
\lnie
\endln
\inst{prv01}{mov}{idval(xr),prvsi}{copy idval (if any)}
\inst{}{mov}{(xr),xl}{load first word of block}
\inst{}{lei}{xl}{load entry point id}
\inst{}{bsw}{xl,bl$$t,prv02}{switch on block type}
\inst{}{iff}{bl$tr,prv04}{trblk}
\inst{}{iff}{bl$ar,prv05}{arblk}
\inst{}{iff}{bl$ic,prv08}{icblk}
\inst{}{iff}{bl$nm,prv09}{nmblk}
\inst{}{iff}{bl$pd,prv10}{pdblk}
\ifmac{.cnra}
\asmac{else}
\inst{}{iff}{bl$rc,prv08}{rcblk}
\asmac{fi}
\inst{}{iff}{bl$sc,prv11}{scblk}
\inst{}{iff}{bl$se,prv12}{seblk}
\inst{}{iff}{bl$tb,prv13}{tbblk}
\inst{}{iff}{bl$vc,prv13}{vcblk}
\ifmac{.cnbf}
\asmac{else}
\inst{}{iff}{bl$bc,prv15}{bcblk}
\asmac{fi}
\inst{}{esw}{}{end of switch on block type}
\lnie
\endln
\lnie
here for blocks for which we just print datatype name\endln
\lnie
\endln
\inst{prv02}{jsr}{dtype}{get datatype name}
\inst{}{jsr}{prtst}{print datatype name}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{prv03}{mov}{(xs)+,xr}{reload argument}
\inst{}{mov}{(xs)+,xl}{restore xl}
\inst{}{exi}{}{return to prtvl caller}
\lnie
\endln
\lnie
here for trblk\endln
\lnie
\endln
\inst{prv04}{mov}{trval(xr),xr}{load real value}
\inst{}{brn}{prv01}{and loop back}
\vfill\break

\lnie
\endln
\lnie
prtvl (continued)\endln
\lnie
\endln
\lnie
here for array (arblk)\endln
\lnie
\endln
\lnie
print array ( prototype ) blank number idval\endln
\lnie
\endln
\inst{prv05}{mov}{xr,xl}{preserve argument}
\inst{}{mov}{=scarr,xr}{point to datatype name (array)}
\inst{}{jsr}{prtst}{print it}
\inst{}{mov}{=ch$pp,wa}{load left paren}
\inst{}{jsr}{prtch}{print left paren}
\inst{}{add}{arofs(xl),xl}{point to prototype}
\inst{}{mov}{(xl),xr}{load prototype}
\inst{}{jsr}{prtst}{print prototype}
\lnie
\endln
\lnie
vcblk, tbblk, bcblk merge here for ) blank number idval\endln
\lnie
\endln
\inst{prv06}{mov}{=ch$rp,wa}{load right paren}
\inst{}{jsr}{prtch}{print right paren}
\lnie
\endln
\lnie
pdblk merges here to print blank number idval\endln
\lnie
\endln
\inst{prv07}{mov}{=ch$bl,wa}{load blank}
\inst{}{jsr}{prtch}{print it}
\inst{}{mov}{=ch$nm,wa}{load number sign}
\inst{}{jsr}{prtch}{print it}
\inst{}{mti}{prvsi}{get idval}
\inst{}{jsr}{prtin}{print id number}
\inst{}{brn}{prv03}{back to exit}
\lnie
\endln
\lnie
here for integer (icblk), real (rcblk)\endln
\lnie
\endln
\lnie
print character representation of value\endln
\lnie
\endln
\inst{prv08}{mov}{xr,-(xs)}{stack argument for gtstg}
\inst{}{jsr}{gtstg}{convert to string}
\inst{}{ppm}{}{error return is impossible}
\inst{}{jsr}{prtst}{print the string}
\inst{}{mov}{xr,dnamp}{delete garbage string from storage}
\inst{}{brn}{prv03}{back to exit}
\vfill\break

\lnie
\endln
\lnie
prtvl (continued)\endln
\lnie
\endln
\lnie
name (nmblk)\endln
\lnie
\endln
\lnie
for pseudo-variable, just print datatype name (name)\endln
\lnie
for all other names, print dot followed by name rep\endln
\lnie
\endln
\inst{prv09}{mov}{nmbas(xr),xl}{load name base}
\inst{}{mov}{(xl),wa}{load first word of block}
\inst{}{beq}{wa,=b$kvt,prv02}{just print name if keyword}
\inst{}{beq}{wa,=b$evt,prv02}{just print name if expression var}
\inst{}{mov}{=ch$dt,wa}{else get dot}
\inst{}{jsr}{prtch}{and print it}
\inst{}{mov}{nmofs(xr),wa}{load name offset}
\inst{}{jsr}{prtnm}{print name}
\inst{}{brn}{prv03}{back to exit}
\lnie
\endln
\lnie
program datatype (pdblk)\endln
\lnie
\endln
\lnie
print datatype name ch$bl ch$nm idval\endln
\lnie
\endln
\inst{prv10}{jsr}{dtype}{get datatype name}
\inst{}{jsr}{prtst}{print datatype name}
\inst{}{brn}{prv07}{merge back to print id}
\lnie
\endln
\lnie
here for string (scblk)\endln
\lnie
\endln
\lnie
print quote string-characters quote\endln
\lnie
\endln
\inst{prv11}{mov}{=ch$sq,wa}{load single quote}
\inst{}{jsr}{prtch}{print quote}
\inst{}{jsr}{prtst}{print string value}
\inst{}{jsr}{prtch}{print another quote}
\inst{}{brn}{prv03}{back to exit}
\vfill\break

\lnie
\endln
\lnie
prtvl (continued)\endln
\lnie
\endln
\lnie
here for simple expression (seblk)\endln
\lnie
\endln
\lnie
print asterisk variable-name\endln
\lnie
\endln
\inst{prv12}{mov}{=ch$as,wa}{load asterisk}
\inst{}{jsr}{prtch}{print asterisk}
\inst{}{mov}{sevar(xr),xr}{load variable pointer}
\inst{}{jsr}{prtvn}{print variable name}
\inst{}{brn}{prv03}{jump back to exit}
\lnie
\endln
\lnie
here for table (tbblk) and array (vcblk)\endln
\lnie
\endln
\lnie
print datatype ( prototype ) blank number idval\endln
\lnie
\endln
\inst{prv13}{mov}{xr,xl}{preserve argument}
\inst{}{jsr}{dtype}{get datatype name}
\inst{}{jsr}{prtst}{print datatype name}
\inst{}{mov}{=ch$pp,wa}{load left paren}
\inst{}{jsr}{prtch}{print left paren}
\inst{}{mov}{tblen(xl),wa}{load length of block (=vclen)}
\inst{}{btw}{wa}{convert to word count}
\inst{}{sub}{=tbsi$,wa}{allow for standard fields}
\inst{}{beq}{(xl),=b$tbt,prv14}{jump if table}
\inst{}{add}{=vctbd,wa}{for vcblk, adjust size}
\lnie
\endln
\lnie
print prototype\endln
\lnie
\endln
\inst{prv14}{mti}{wa}{move as integer}
\inst{}{jsr}{prtin}{print integer prototype}
\inst{}{brn}{prv06}{merge back for rest}
\ifmac{.cnbf}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
prtvl (continued)\endln
\lnie
\endln
\lnie
here for buffer (bcblk)\endln
\lnie
\endln
\inst{prv15}{mov}{xr,xl}{preserve argument}
\inst{}{mov}{=scbuf,xr}{point to datatype name (buffer)}
\inst{}{jsr}{prtst}{print it}
\inst{}{mov}{=ch$pp,wa}{load left paren}
\inst{}{jsr}{prtch}{print left paren}
\inst{}{mov}{bcbuf(xl),xr}{point to bfblk}
\inst{}{mti}{bfalc(xr)}{load allocation size}
\inst{}{jsr}{prtin}{print it}
\inst{}{mov}{=ch$cm,wa}{load comma}
\inst{}{jsr}{prtch}{print it}
\inst{}{mti}{bclen(xl)}{load defined length}
\inst{}{jsr}{prtin}{print it}
\inst{}{brn}{prv06}{merge to finish up}
\asmac{fi}
\inst{}{enp}{}{end procedure prtvl}
\vfill\break

\lnie
\endln
\lnie
prtvn -- print natural variable name\endln
\lnie
\endln
\lnie
prtvn prints the name of a natural variable\endln
\lnie
\endln
\lnie
(xr)                  pointer to vrblk\endln
\lnie
jsr  prtvn            call to print variable name\endln
\lnie
\endln
\inst{prtvn}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{stack vrblk pointer}
\inst{}{add}{*vrsof,xr}{point to possible string name}
\inst{}{bnz}{sclen(xr),prvn1}{jump if not system variable}
\inst{}{mov}{vrsvo(xr),xr}{point to svblk with name}
\lnie
\endln
\lnie
merge here with dummy scblk pointer in xr\endln
\lnie
\endln
\inst{prvn1}{jsr}{prtst}{print string name of variable}
\inst{}{mov}{(xs)+,xr}{restore vrblk pointer}
\inst{}{exi}{}{return to prtvn caller}
\inst{}{enp}{}{end procedure prtvn}
\ifmac{.cnra}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
rcbld -- build a real block\endln
\lnie
\endln
\lnie
(ra)                  real value for rcblk\endln
\lnie
jsr  rcbld            call to build real block\endln
\lnie
(xr)                  pointer to result rcblk\endln
\lnie
(wa)                  destroyed\endln
\lnie
\endln
\inst{rcbld}{prc}{e,0}{entry point}
\inst{}{mov}{dnamp,xr}{load pointer to next available loc}
\inst{}{add}{*rcsi$,xr}{point past new rcblk}
\inst{}{blo}{xr,dname,rcbl1}{jump if there is room}
\inst{}{mov}{*rcsi$,wa}{else load rcblk length}
\inst{}{jsr}{alloc}{use standard allocator to get block}
\inst{}{add}{wa,xr}{point past block to merge}
\lnie
\endln
\lnie
merge here with xr pointing past the block obtained\endln
\lnie
\endln
\inst{rcbl1}{mov}{xr,dnamp}{set new pointer}
\inst{}{sub}{*rcsi$,xr}{point back to start of block}
\inst{}{mov}{=b$rcl,(xr)}{store type word}
\inst{}{str}{rcval(xr)}{store real value in rcblk}
\inst{}{exi}{}{return to rcbld caller}
\inst{}{enp}{}{end procedure rcbld}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
readr -- read next source image at compile time\endln
\lnie
\endln
\lnie
readr is used to read the next source image. to process\endln
\lnie
continuation cards properly, the compiler must read one\endln
\lnie
line ahead. thus readr does not destroy the current image\endln
\lnie
see also the nexts routine which actually gets the image.\endln
\lnie
\endln
\lnie
jsr  readr            call to read next image\endln
\lnie
(xr)                  ptr to next image (0 if none)\endln
\lnie
(r$cni)               copy of pointer\endln
\lnie
(wa,wb,wc,xl)         destroyed\endln
\lnie
\endln
\inst{readr}{prc}{e,0}{entry point}
\inst{}{mov}{r$cni,xr}{get ptr to next image}
\inst{}{bnz}{xr,read3}{exit if already read}
\ifmac{.cinc}
\inst{}{bnz}{cnind,reada}{if within include file}
\asmac{fi}
\inst{}{bne}{stage,=stgic,read3}{exit if not initial compile}
\inst{reada}{mov}{cswin,wa}{max read length}
\inst{}{zer}{xl}{clear any dud value in xl}
\inst{}{jsr}{alocs}{allocate buffer}
\inst{}{jsr}{sysrd}{read input image}
\inst{}{ppm}{read4}{jump if eof or new file name}
\inst{}{icv}{rdnln}{increment next line number}
\ifmac{.cpol}
\inst{}{dcv}{polct}{test if time to poll interface}
\inst{}{bnz}{polct,read0}{not yet}
\inst{}{zer}{wa}{=0 for poll}
\inst{}{mov}{rdnln,wb}{line number}
\inst{}{jsr}{syspl}{allow interactive access}
\inst{}{err}{syspl}{allow interactive access}
\inst{}{ppm}{}{single step}
\inst{}{ppm}{}{expression evaluation}
\inst{}{mov}{wa,polcs}{new countdown start value}
\inst{}{mov}{wa,polct}{new counter value}
\asmac{fi}
\inst{read0}{ble}{sclen(xr),cswin,read1}{ use smaller of string lnth ...}
\inst{}{mov}{cswin,sclen(xr)}{... and xxx of -inxxx}
\lnie
\endln
\lnie
perform the trim\endln
\lnie
\endln
\inst{read1}{mnz}{wb}{set trimr to perform trim}
\inst{}{jsr}{trimr}{trim trailing blanks}
\lnie
\endln
\lnie
merge here after read\endln
\lnie
\endln
\inst{read2}{mov}{xr,r$cni}{store copy of pointer}
\lnie
\endln
\lnie
merge here if no read attempted\endln
\lnie
\endln
\inst{read3}{exi}{}{return to readr caller}
\ifmac{.csfn}
\lnie
\endln
\lnie
here on end of file or new source file name.\endln
\lnie
if this is a new source file name, the r$sfn table will\endln
\lnie
be augmented with a new table entry consisting of the\endln
\lnie
current compiler statement number as subscript, and the\endln
\lnie
file name as value.\endln
\lnie
\endln
\inst{read4}{bze}{sclen(xr),read5}{jump if true end of file}
\inst{}{zer}{wb}{new source file name}
\inst{}{mov}{wb,rdnln}{restart line counter for new file}
\inst{}{jsr}{trimr}{remove unused space in block}
\inst{}{jsr}{newfn}{record new file name}
\inst{}{brn}{reada}{now reissue read for record data}
\lnie
\endln
\lnie
here on end of file\endln
\lnie
\endln
\inst{read5}{mov}{xr,dnamp}{pop unused scblk}
\ifmac{.cinc}
\inst{}{bze}{cnind,read6}{jump if not within an include file}
\inst{}{zer}{xl}{eof within include file}
\inst{}{jsr}{sysif}{switch stream back to previous file}
\inst{}{ppm}{sysif}{switch stream back to previous file}
\inst{}{mov}{cnind,wa}{restore prev line number, file name}
\inst{}{add}{=vcvlb,wa}{vector offset in words}
\inst{}{wtb}{wa}{convert to bytes}
\inst{}{mov}{r$ifa,xr}{file name array}
\inst{}{add}{wa,xr}{ptr to element}
\inst{}{mov}{(xr),r$sfc}{change source file name}
\inst{}{mov}{=nulls,(xr)}{release scblk}
\inst{}{mov}{r$ifl,xr}{line number array}
\inst{}{add}{wa,xr}{ptr to element}
\inst{}{mov}{(xr),xl}{icblk containing saved line number}
\inst{}{ldi}{icval(xl)}{line number integer}
\inst{}{mfi}{rdnln}{change source line number}
\inst{}{mov}{=inton,(xr)}{release icblk}
\inst{}{dcv}{cnind}{decrement nesting level}
\inst{}{mov}{cmpsn,wb}{current statement number}
\inst{}{icv}{wb}{anticipate end of previous stmt}
\inst{}{mti}{wb}{convert to integer}
\inst{}{jsr}{icbld}{build icblk for stmt number}
\inst{}{mov}{r$sfn,xl}{file name table}
\inst{}{mnz}{wb}{lookup statement number by name}
\inst{}{jsr}{tfind}{allocate new teblk}
\inst{}{ppm}{}{always possible to allocate block}
\inst{}{mov}{r$sfc,teval(xl)}{record file name as entry value}
\inst{}{beq}{stage,=stgic,reada}{if initial compile, reissue read}
\inst{}{bnz}{cnind,reada}{still reading from include file}
\lnie
\endln
\lnie
outer nesting of execute-time compile of -include\endln
\lnie
resume with any string remaining prior to -include.\endln
\lnie
\endln
\inst{}{mov}{r$ici,xl}{restore code argument string}
\inst{}{zer}{r$ici}{release original string}
\inst{}{mov}{cnsil,wa}{get length of string}
\inst{}{mov}{cnspt,wb}{offset of characters left}
\inst{}{sub}{wb,wa}{number of characters left}
\inst{}{mov}{wa,scnil}{set new scan length}
\inst{}{zer}{scnpt}{scan from start of substring}
\inst{}{jsr}{sbstr}{create substring of remainder}
\inst{}{mov}{xr,r$cim}{set scan image}
\inst{}{brn}{read2}{return}
\asmac{fi}
\asmac{else}
\lnie
\endln
\lnie
here on end of file\endln
\lnie
\endln
\inst{read4}{mov}{xr,dnamp}{pop unused scblk}
\ifmac{.cinc}
\inst{}{bze}{cnind,read6}{jump if not within an include file}
\inst{}{zer}{xl}{eof within include file}
\inst{}{jsr}{sysif}{switch stream back to previous file}
\inst{}{ppm}{sysif}{switch stream back to previous file}
\inst{}{dcv}{cnind}{decrement nesting level}
\inst{}{brn}{reada}{reissue read from previous stream}
\asmac{fi}
\asmac{fi}
\inst{read6}{zer}{xr}{zero ptr as result}
\inst{}{brn}{read2}{merge}
\inst{}{enp}{}{end procedure readr}
\vfill\break

\ifmac{.c370}
\lnie
\endln
\lnie
sbool-- setup for boolean operations on strings\endln
\lnie
\endln
\lnie
1(xs)                 first argument (if two)\endln
\lnie
0(xs)                 second argument\endln
\lnie
(wb)                  number of arguments\endln
\lnie
                       zero = one arguments\endln
\lnie
                       non-zero = two arguments\endln
\lnie
jsr  sbool            call to perform operation\endln
\lnie
ppm  loc              transfer loc for arg1 not string\endln
\lnie
ppm  loc              transfer loc for arg2 not string\endln
\lnie
ppm  loc              transfer loc arg lengths not equal\endln
\lnie
ppm  loc              transfer loc if null string args\endln
\lnie
(xs)                  arguments popped, result stacked\endln
\lnie
(xl)                  arg 1 chars to operate upon\endln
\lnie
(xr)                  copy of arg 2 if two arguments\endln
\lnie
(wa)                  no. of characters to process\endln
\lnie
(wc)                  no. of words to process (bct ready)\endln
\lnie
(wb)                  destroyed\endln
\lnie
\endln
\lnie
the second argument string block is copied to a result\endln
\lnie
block, and pointers returned to allow the caller to\endln
\lnie
proceed with the desired operation if two arguments.\endln
\lnie
\endln
\lnie
operations like and/or that do not alter the trailing\endln
\lnie
zeros in the last word of the string block can be\endln
\lnie
performed a word at a time.  operations such as compl\endln
\lnie
may either be performed a character at a time or will\endln
\lnie
have to adjust the last word if done a word at a time.\endln
\lnie
\endln
\inst{sbool}{prc}{n,3}{entry point}
\inst{}{jsr}{gtstg}{convert second arg to string}
\inst{}{ppm}{sbl05}{jump if second arg not string}
\inst{}{mov}{xr,xl}{else save pointer}
\inst{}{mov}{wa,wc}{and length}
\inst{}{bze}{wb,sbl01}{only one argument if compl}
\inst{}{jsr}{gtstg}{convert first argument to string}
\inst{}{ppm}{sbl04}{jump if not string}
\inst{}{bne}{wa,wc,sbl03}{jump if lengths unequal}
\lnie
\endln
\lnie
merge here if only one argument\endln
\lnie
\endln
\inst{sbl01}{mov}{xr,-(xs)}{stack first argument}
\inst{}{bze}{wc,sbl02}{return null if null argument}
\inst{}{jsr}{alocs}{allocate space for copy}
\inst{}{bze}{wb,sbl06}{only one argument if compl}
\inst{}{mov}{wc,wa}{string length}
\inst{}{mov}{xr,wb}{save address of copy}
\inst{}{ctb}{wa,schar}{get scblk length}
\inst{}{mvw}{}{move arg2 contents to copy}
\inst{}{mov}{wb,xr}{reload result ptr}
\inst{sbl06}{mov}{(xs)+,xl}{reload first argument}
\inst{}{mov}{xr,-(xs)}{stack result}
\inst{}{add}{*schar,xl}{point to characters in arg 1 block}
\inst{}{add}{*schar,xr}{point to characters in result block}
\inst{}{mov}{wc,wa}{character count}
\inst{}{ctw}{wc,0}{number of words of characters}
\inst{}{lct}{wc,wc}{prepare counter}
\inst{}{exi}{wc,wc}{prepare counter}
\lnie
\endln
\lnie
here if null arguments\endln
\lnie
\endln
\inst{sbl02}{exi}{4}{take null string exit}
\lnie
\endln
\lnie
here if argument lengths unequal\endln
\lnie
\endln
\inst{sbl03}{exi}{3}{take unequal length error exit}
\lnie
\endln
\lnie
here if first arg is not a string\endln
\lnie
\endln
\inst{sbl04}{exi}{1}{take bad first arg error exit}
\lnie
\endln
\lnie
here for second arg not a string\endln
\lnie
\endln
\inst{sbl05}{exi}{2}{take bad second arg error exit}
\inst{}{enp}{}{end procedure sbool}
\vfill\break

\asmac{fi}
\lnie
\endln
\lnie
sbstr -- build a substring\endln
\lnie
\endln
\lnie
(xl)                  ptr to scblk/bfblk with chars\endln
\lnie
(wa)                  number of chars in substring\endln
\lnie
(wb)                  offset to first char in scblk\endln
\lnie
jsr  sbstr            call to build substring\endln
\lnie
(xr)                  ptr to new scblk with substring\endln
\lnie
(xl)                  zero\endln
\lnie
(wa,wb,wc,xl,ia)      destroyed\endln
\lnie
\endln
\lnie
note that sbstr is called with a dummy string pointer\endln
\lnie
(pointing into a vrblk or svblk) to copy the name of a\endln
\lnie
variable as a standard string value.\endln
\lnie
\endln
\inst{sbstr}{prc}{e,0}{entry point}
\inst{}{bze}{wa,sbst2}{jump if null substring}
\inst{}{jsr}{alocs}{else allocate scblk}
\inst{}{mov}{wc,wa}{move number of characters}
\inst{}{mov}{xr,wc}{save ptr to new scblk}
\inst{}{plc}{xl,wb}{prepare to load chars from old blk}
\inst{}{psc}{xr}{prepare to store chars in new blk}
\inst{}{mvc}{}{move characters to new string}
\inst{}{mov}{wc,xr}{then restore scblk pointer}
\lnie
\endln
\lnie
return point\endln
\lnie
\endln
\inst{sbst1}{zer}{xl}{clear garbage pointer in xl}
\inst{}{exi}{}{return to sbstr caller}
\lnie
\endln
\lnie
here for null substring\endln
\lnie
\endln
\inst{sbst2}{mov}{=nulls,xr}{set null string as result}
\inst{}{brn}{sbst1}{return}
\inst{}{enp}{}{end procedure sbstr}
\vfill\break

\lnie
\endln
\lnie
stgcc -- compute counters for stmt startup testing\endln
\lnie
\endln
\lnie
jsr  stgcc            call to recompute counters\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\lnie
on exit, stmcs and stmct contain the counter value to\endln
\lnie
tested in stmgo.\endln
\lnie
\endln
\lnie
\endln
\inst{stgcc}{prc}{}{}
\ifmac{.cpol}
\inst{}{mov}{polcs,wa}{assume no profiling or stcount tracing}
\inst{}{mov}{=num01,wb}{poll each time polcs expires}
\asmac{else}
\inst{}{mov}{cfp$m,wa}{assume no profiling or stcount tracing}
\asmac{fi}
\inst{}{ldi}{kvstl}{get stmt limit}
\inst{}{bnz}{kvpfl,stgc1}{jump if profiling enabled}
\inst{}{ilt}{stgc3}{no stcount tracing if negative}
\inst{}{bze}{r$stc,stgc2}{jump if not stcount tracing}
\lnie
\endln
\lnie
here if profiling or if stcount tracing enabled\endln
\lnie
\endln
\ifmac{.cpol}
\inst{stgc1}{mov}{wa,wb}{count polcs times within stmg}
\inst{}{mov}{=num01,wa}{break out of stmgo on each stmt}
\asmac{else}
\inst{stgc1}{mov}{=num01,wa}{break out of stmgo on each stmt}
\asmac{fi}
\inst{}{brn}{=num01,wa}{break out of stmgo on each stmt}
\lnie
\endln
\lnie
check that stmcs does not exceed kvstl\endln
\lnie
\endln
\inst{stgc2}{mti}{wa}{breakout count start value}
\inst{}{sbi}{kvstl}{proposed stmcs minus stmt limit}
\inst{}{ile}{stgc3}{jump if stmt count does not limit}
\inst{}{ldi}{kvstl}{stlimit limits breakcount count}
\inst{}{mfi}{wa}{use it instead}
\lnie
\endln
\lnie
re-initialize counter\endln
\lnie
\endln
\inst{stgc3}{mov}{wa,stmcs}{update breakout count start value}
\inst{}{mov}{wa,stmct}{reset breakout counter}
\ifmac{.cpol}
\inst{}{mov}{wa,stmct}{reset breakout counter}
\asmac{fi}
\inst{}{exi}{wa,stmct}{reset breakout counter}
\vfill\break

\lnie
\endln
\lnie
tfind -- locate table element\endln
\lnie
\endln
\lnie
(xr)                  subscript value for element\endln
\lnie
(xl)                  pointer to table\endln
\lnie
(wb)                  zero by value, non-zero by name\endln
\lnie
jsr  tfind            call to locate element\endln
\lnie
ppm  loc              transfer location if access fails\endln
\lnie
(xr)                  element value (if by value)\endln
\lnie
(xr)                  destroyed (if by name)\endln
\lnie
(xl,wa)               teblk name (if by name)\endln
\lnie
(xl,wa)               destroyed (if by value)\endln
\lnie
(wc,ra)               destroyed\endln
\lnie
\endln
\lnie
note that if a call by value specifies a non-existent\endln
\lnie
subscript, the default value is returned without building\endln
\lnie
a new teblk.\endln
\lnie
\endln
\inst{tfind}{prc}{e,1}{entry point}
\inst{}{mov}{wb,-(xs)}{save name/value indicator}
\inst{}{mov}{xr,-(xs)}{save subscript value}
\inst{}{mov}{xl,-(xs)}{save table pointer}
\inst{}{mov}{tblen(xl),wa}{load length of tbblk}
\inst{}{btw}{wa}{convert to word count}
\inst{}{sub}{=tbbuk,wa}{get number of buckets}
\inst{}{mti}{wa}{convert to integer value}
\inst{}{sti}{tfnsi}{save for later}
\inst{}{mov}{(xr),xl}{load first word of subscript}
\inst{}{lei}{xl}{load block entry id (bl$xx)}
\inst{}{bsw}{xl,bl$$d,tfn00}{switch on block type}
\inst{}{iff}{bl$ic,tfn02}{jump if integer}
\ifmac{.cnra}
\asmac{else}
\inst{}{iff}{bl$rc,tfn02}{real}
\asmac{fi}
\inst{}{iff}{bl$p0,tfn03}{jump if pattern}
\inst{}{iff}{bl$p1,tfn03}{jump if pattern}
\inst{}{iff}{bl$p2,tfn03}{jump if pattern}
\inst{}{iff}{bl$nm,tfn04}{jump if name}
\inst{}{iff}{bl$sc,tfn05}{jump if string}
\inst{}{esw}{}{end switch on block type}
\lnie
\endln
\lnie
here for blocks for which we use the second word of the\endln
\lnie
block as the hash source (see block formats for details).\endln
\lnie
\endln
\inst{tfn00}{mov}{1(xr),wa}{load second word}
\lnie
\endln
\lnie
merge here with one word hash source in wa\endln
\lnie
\endln
\inst{tfn01}{mti}{wa}{convert to integer}
\inst{}{brn}{tfn06}{jump to merge}
\vfill\break

\lnie
\endln
\lnie
tfind (continued)\endln
\lnie
\endln
\lnie
here for integer or real\endln
\lnie
possibility of overflow exist on twos complement\endln
\lnie
machine if hash source is most negative integer or is\endln
\lnie
a real having the same bit pattern.\endln
\lnie
\endln
\lnie
\endln
\inst{tfn02}{ldi}{1(xr)}{load value as hash source}
\inst{}{ige}{tfn06}{ok if positive or zero}
\inst{}{ngi}{}{make positive}
\inst{}{iov}{tfn06}{clear possible overflow}
\inst{}{brn}{tfn06}{merge}
\lnie
\endln
\lnie
for pattern, use first word (pcode) as source\endln
\lnie
\endln
\inst{tfn03}{mov}{(xr),wa}{load first word as hash source}
\inst{}{brn}{tfn01}{merge back}
\lnie
\endln
\lnie
for name, use offset as hash source\endln
\lnie
\endln
\inst{tfn04}{mov}{nmofs(xr),wa}{load offset as hash source}
\inst{}{brn}{tfn01}{merge back}
\lnie
\endln
\lnie
here for string\endln
\lnie
\endln
\inst{tfn05}{jsr}{hashs}{call routine to compute hash}
\lnie
\endln
\lnie
merge here with hash source in (ia)\endln
\lnie
\endln
\inst{tfn06}{rmi}{tfnsi}{compute hash index by remaindering}
\inst{}{mfi}{wc}{get as one word integer}
\inst{}{wtb}{wc}{convert to byte offset}
\inst{}{mov}{(xs),xl}{get table ptr again}
\inst{}{add}{wc,xl}{point to proper bucket}
\inst{}{mov}{tbbuk(xl),xr}{load first teblk pointer}
\inst{}{beq}{xr,(xs),tfn10}{jump if no teblks on chain}
\lnie
\endln
\lnie
loop through teblks on hash chain\endln
\lnie
\endln
\inst{tfn07}{mov}{xr,wb}{save teblk pointer}
\inst{}{mov}{tesub(xr),xr}{load subscript value}
\inst{}{mov}{1(xs),xl}{load input argument subscript val}
\inst{}{jsr}{ident}{compare them}
\inst{}{ppm}{tfn08}{jump if equal (ident)}
\lnie
\endln
\lnie
here if no match with that teblk\endln
\lnie
\endln
\inst{}{mov}{wb,xl}{restore teblk pointer}
\inst{}{mov}{tenxt(xl),xr}{point to next teblk on chain}
\inst{}{bne}{xr,(xs),tfn07}{jump if there is one}
\lnie
\endln
\lnie
here if no match with any teblk on chain\endln
\lnie
\endln
\inst{}{mov}{*tenxt,wc}{set offset to link field (xl base)}
\inst{}{brn}{tfn11}{jump to merge}
\vfill\break

\lnie
\endln
\lnie
tfind (continued)\endln
\lnie
\endln
\lnie
here we have found a matching element\endln
\lnie
\endln
\inst{tfn08}{mov}{wb,xl}{restore teblk pointer}
\inst{}{mov}{*teval,wa}{set teblk name offset}
\inst{}{mov}{2(xs),wb}{restore name/value indicator}
\inst{}{bnz}{wb,tfn09}{jump if called by name}
\inst{}{jsr}{acess}{else get value}
\inst{}{ppm}{tfn12}{jump if reference fails}
\inst{}{zer}{wb}{restore name/value indicator}
\lnie
\endln
\lnie
common exit for entry found\endln
\lnie
\endln
\inst{tfn09}{add}{*num03,xs}{pop stack entries}
\inst{}{exi}{}{return to tfind caller}
\lnie
\endln
\lnie
here if no teblks on the hash chain\endln
\lnie
\endln
\inst{tfn10}{add}{*tbbuk,wc}{get offset to bucket ptr}
\inst{}{mov}{(xs),xl}{set tbblk ptr as base}
\lnie
\endln
\lnie
merge here with (xl,wc) base,offset of final link\endln
\lnie
\endln
\inst{tfn11}{mov}{(xs),xr}{tbblk pointer}
\inst{}{mov}{tbinv(xr),xr}{load default value in case}
\inst{}{mov}{2(xs),wb}{load name/value indicator}
\inst{}{bze}{wb,tfn09}{exit with default if value call}
\inst{}{mov}{xr,wb}{copy default value}
\lnie
\endln
\lnie
here we must build a new teblk\endln
\lnie
\endln
\inst{}{mov}{*tesi$,wa}{set size of teblk}
\inst{}{jsr}{alloc}{allocate teblk}
\inst{}{add}{wc,xl}{point to hash link}
\inst{}{mov}{xr,(xl)}{link new teblk at end of chain}
\inst{}{mov}{=b$tet,(xr)}{store type word}
\inst{}{mov}{wb,teval(xr)}{set default as initial value}
\inst{}{mov}{(xs)+,tenxt(xr)}{set tbblk ptr to mark end of chain}
\inst{}{mov}{(xs)+,tesub(xr)}{store subscript value}
\inst{}{mov}{(xs)+,wb}{restore name/value indicator}
\inst{}{mov}{xr,xl}{copy teblk pointer (name base)}
\inst{}{mov}{*teval,wa}{set offset}
\inst{}{exi}{}{return to caller with new teblk}
\lnie
\endln
\lnie
acess fail return\endln
\lnie
\endln
\inst{tfn12}{exi}{1}{alternative return}
\inst{}{enp}{}{end procedure tfind}
\vfill\break

\lnie
\endln
\lnie
tmake -- make new table\endln
\lnie
\endln
\lnie
(xl)                  initial lookup value\endln
\lnie
(wc)                  number of buckets desired\endln
\lnie
jsr  tmake            call to make new table\endln
\lnie
(xr)                  new table\endln
\lnie
(wa,wb)               destroyed\endln
\lnie
\endln
\inst{tmake}{prc}{}{}
\inst{}{mov}{wc,wa}{copy number of headers}
\inst{}{add}{=tbsi$,wa}{adjust for standard fields}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{jsr}{alloc}{allocate space for tbblk}
\inst{}{mov}{xr,wb}{copy pointer to tbblk}
\inst{}{mov}{=b$tbt,(xr)+}{store type word}
\inst{}{zer}{(xr)+}{zero id for the moment}
\inst{}{mov}{wa,(xr)+}{store length (tblen)}
\inst{}{mov}{xl,(xr)+}{store initial lookup value}
\inst{}{lct}{wc,wc}{set loop counter (num headers)}
\lnie
\endln
\lnie
loop to initialize all bucket pointers\endln
\lnie
\endln
\inst{tma01}{mov}{wb,(xr)+}{store tbblk ptr in bucket header}
\inst{}{bct}{wc,tma01}{loop till all stored}
\inst{}{mov}{wb,xr}{recall pointer to tbblk}
\inst{}{exi}{wb,xr}{recall pointer to tbblk}
\inst{}{enp}{wb,xr}{recall pointer to tbblk}
\vfill\break

\lnie
\endln
\lnie
vmake -- create a vector\endln
\lnie
\endln
\lnie
(wa)                  number of elements in vector\endln
\lnie
(xl)                  default value for vector elements\endln
\lnie
jsr  vmake            call to create vector\endln
\lnie
ppm  loc              if vector too large\endln
\lnie
\endln
\lnie
(xr)                  pointer to vcblk\endln
\lnie
(wa,wb,wc,xl)         destroyed\endln
\lnie
\endln
\inst{vmake}{prc}{e,1}{entry point}
\inst{}{lct}{wb,wa}{copy elements for loop later on}
\inst{}{add}{=vcsi$,wa}{add space for standard fields}
\inst{}{wtb}{wa}{convert length to bytes}
\inst{}{bgt}{wa,mxlen,vmak2}{fail if too large}
\inst{}{jsr}{alloc}{allocate space for vcblk}
\inst{}{mov}{=b$vct,(xr)}{store type word}
\inst{}{zer}{idval(xr)}{initialize idval}
\inst{}{mov}{wa,vclen(xr)}{set length}
\inst{}{mov}{xl,wc}{copy default value}
\inst{}{mov}{xr,xl}{copy vcblk pointer}
\inst{}{add}{*vcvls,xl}{point to first element value}
\lnie
\endln
\lnie
loop to set vector elements to default value\endln
\lnie
\endln
\inst{vmak1}{mov}{wc,(xl)+}{store one value}
\inst{}{bct}{wb,vmak1}{loop till all stored}
\inst{}{exi}{}{success return}
\lnie
\endln
\lnie
here if desired vector size too large\endln
\lnie
\endln
\inst{vmak2}{exi}{1}{fail return}
\inst{}{enp}{1}{fail return}
\vfill\break

\lnie
\endln
\lnie
scane -- scan an element\endln
\lnie
\endln
\lnie
scane is called at compile time (by expan ,cmpil,cncrd)\endln
\lnie
to scan one element from the input image.\endln
\lnie
\endln
\lnie
(scncc)               non-zero if called from cncrd\endln
\lnie
jsr  scane            call to scan element\endln
\lnie
(xr)                  result pointer (see below)\endln
\lnie
(xl)                  syntax type code (t$xxx)\endln
\lnie
\endln
\lnie
the following global locations are used.\endln
\lnie
\endln
\lnie
r$cim                 pointer to string block (scblk)\endln
\lnie
                      for current input image.\endln
\lnie
\endln
\lnie
r$cni                 pointer to next input image string\endln
\lnie
                      pointer (zero if none).\endln
\lnie
\endln
\lnie
r$scp                 save pointer (exit xr) from last\endln
\lnie
                      call in case rescan is set.\endln
\lnie
\endln
\lnie
scnbl                 this location is set non-zero on\endln
\lnie
                      exit if scane scanned past blanks\endln
\lnie
                      before locating the current element\endln
\lnie
                      the end of a line counts as blanks.\endln
\lnie
\endln
\lnie
scncc                 cncrd sets this non-zero to scan\endln
\lnie
                      control card names and clears it\endln
\lnie
                      on return\endln
\lnie
\endln
\lnie
scnil                 length of current input image\endln
\lnie
\endln
\lnie
scngo                 if set non-zero on entry, f and s\endln
\lnie
                      are returned as separate syntax\endln
\lnie
                      types (not letters) (goto pro-\endln
\lnie
                      cessing). scngo is reset on exit.\endln
\lnie
\endln
\lnie
scnpt                 offset to current loc in r$cim\endln
\lnie
\endln
\lnie
scnrs                 if set non-zero on entry, scane\endln
\lnie
                      returns the same result as on the\endln
\lnie
                      last call (rescan). scnrs is reset\endln
\lnie
                      on exit from any call to scane.\endln
\lnie
\endln
\lnie
scntp                 save syntax type from last\endln
\lnie
                      call (in case rescan is set).\endln
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
\endln
\lnie
\endln
\lnie
element scanned       xl        xr\endln
\lnie
---------------       --        --\endln
\lnie
\endln
\lnie
control card name     0         pointer to scblk for name\endln
\lnie
\endln
\lnie
unary operator        t$uop     ptr to operator dvblk\endln
\lnie
\endln
\lnie
left paren            t$lpr     t$lpr\endln
\lnie
\endln
\lnie
left bracket          t$lbr     t$lbr\endln
\lnie
\endln
\lnie
comma                 t$cma     t$cma\endln
\lnie
\endln
\lnie
function call         t$fnc     ptr to function vrblk\endln
\lnie
\endln
\lnie
variable              t$var     ptr to vrblk\endln
\lnie
\endln
\lnie
string constant       t$con     ptr to scblk\endln
\lnie
\endln
\lnie
integer constant      t$con     ptr to icblk\endln
\lnie
\endln
\ifmac{.cnra}
\asmac{else}
\lnie
real constant         t$con     ptr to rcblk\endln
\lnie
\endln
\asmac{fi}
\lnie
binary operator       t$bop     ptr to operator dvblk\endln
\lnie
\endln
\lnie
right paren           t$rpr     t$rpr\endln
\lnie
\endln
\lnie
right bracket         t$rbr     t$rbr\endln
\lnie
\endln
\lnie
colon                 t$col     t$col\endln
\lnie
\endln
\lnie
semi-colon            t$smc     t$smc\endln
\lnie
\endln
\lnie
f (scngo ne 0)        t$fgo     t$fgo\endln
\lnie
\endln
\lnie
s (scngo ne 0)        t$sgo     t$sgo\endln
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
entry point\endln
\lnie
\endln
\inst{scane}{prc}{e,0}{entry point}
\inst{}{zer}{scnbl}{reset blanks flag}
\inst{}{mov}{wa,scnsa}{save wa}
\inst{}{mov}{wb,scnsb}{save wb}
\inst{}{mov}{wc,scnsc}{save wc}
\inst{}{bze}{scnrs,scn03}{jump if no rescan}
\lnie
\endln
\lnie
here for rescan request\endln
\lnie
\endln
\inst{}{mov}{scntp,xl}{set previous returned scan type}
\inst{}{mov}{r$scp,xr}{set previous returned pointer}
\inst{}{zer}{scnrs}{reset rescan switch}
\inst{}{brn}{scn13}{jump to exit}
\lnie
\endln
\lnie
come here to read new image to test for continuation\endln
\lnie
\endln
\inst{scn01}{jsr}{readr}{read next image}
\inst{}{mov}{*dvubs,wb}{set wb for not reading name}
\inst{}{bze}{xr,scn30}{treat as semi-colon if none}
\inst{}{plc}{xr}{else point to first character}
\inst{}{lch}{wc,(xr)}{load first character}
\inst{}{beq}{wc,=ch$dt,scn02}{jump if dot for continuation}
\inst{}{bne}{wc,=ch$pl,scn30}{else treat as semicolon unless plus}
\lnie
\endln
\lnie
here for continuation line\endln
\lnie
\endln
\inst{scn02}{jsr}{nexts}{acquire next source image}
\inst{}{mov}{=num01,scnpt}{set scan pointer past continuation}
\inst{}{mnz}{scnbl}{set blanks flag}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
merge here to scan next element on current line\endln
\lnie
\endln
\inst{scn03}{mov}{scnpt,wa}{load current offset}
\inst{}{beq}{wa,scnil,scn01}{check continuation if end}
\inst{}{mov}{r$cim,xl}{point to current line}
\inst{}{plc}{xl,wa}{point to current character}
\inst{}{mov}{wa,scnse}{set start of element location}
\inst{}{mov}{=opdvs,wc}{point to operator dv list}
\inst{}{mov}{*dvubs,wb}{set constant for operator circuit}
\inst{}{brn}{scn06}{start scanning}
\lnie
\endln
\lnie
loop here to ignore leading blanks and tabs\endln
\lnie
\endln
\inst{scn05}{bze}{wb,scn10}{jump if trailing}
\inst{}{icv}{scnse}{increment start of element}
\inst{}{beq}{wa,scnil,scn01}{jump if end of image}
\inst{}{mnz}{scnbl}{note blanks seen}
\lnie
\endln
\lnie
the following jump is used repeatedly for scanning out\endln
\lnie
the characters of a numeric constant or variable name.\endln
\lnie
the registers are used as follows.\endln
\lnie
\endln
\lnie
(xr)                  scratch\endln
\lnie
(xl)                  ptr to next character\endln
\lnie
(wa)                  current scan offset\endln
\lnie
(wb)                  *dvubs (0 if scanning name,const)\endln
\lnie
(wc)                  =opdvs (0 if scanning constant)\endln
\lnie
\endln
\inst{scn06}{lch}{xr,(xl)+}{get next character}
\inst{}{icv}{wa}{bump scan offset}
\inst{}{mov}{wa,scnpt}{store offset past char scanned}
\ifmac{.cucf}
\inst{}{bsw}{xr,cfp$u,scn07}{switch on scanned character}
\asmac{else}
\inst{}{bsw}{xr,cfp$a,scn07}{switch on scanned character}
\asmac{fi}
\lnie
\endln
\lnie
switch table for switch on character\endln
\lnie
\endln
\inst{}{iff}{ch$bl,scn05}{blank}
\ifmac{.caht}
\inst{}{iff}{ch$ht,scn05}{horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{iff}{ch$vt,scn05}{vertical tab}
\asmac{fi}
\ifmac{.caex}
\inst{}{iff}{ch$ey,scn37}{up arrow}
\asmac{fi}
\inst{}{iff}{ch$d0,scn08}{digit 0}
\inst{}{iff}{ch$d1,scn08}{digit 1}
\inst{}{iff}{ch$d2,scn08}{digit 2}
\inst{}{iff}{ch$d3,scn08}{digit 3}
\inst{}{iff}{ch$d4,scn08}{digit 4}
\inst{}{iff}{ch$d5,scn08}{digit 5}
\inst{}{iff}{ch$d6,scn08}{digit 6}
\inst{}{iff}{ch$d7,scn08}{digit 7}
\inst{}{iff}{ch$d8,scn08}{digit 8}
\inst{}{iff}{ch$d9,scn08}{digit 9}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\inst{}{iff}{ch$la,scn09}{letter a}
\inst{}{iff}{ch$lb,scn09}{letter b}
\inst{}{iff}{ch$lc,scn09}{letter c}
\inst{}{iff}{ch$ld,scn09}{letter d}
\inst{}{iff}{ch$le,scn09}{letter e}
\inst{}{iff}{ch$lg,scn09}{letter g}
\inst{}{iff}{ch$lh,scn09}{letter h}
\inst{}{iff}{ch$li,scn09}{letter i}
\inst{}{iff}{ch$lj,scn09}{letter j}
\inst{}{iff}{ch$lk,scn09}{letter k}
\inst{}{iff}{ch$ll,scn09}{letter l}
\inst{}{iff}{ch$lm,scn09}{letter m}
\inst{}{iff}{ch$ln,scn09}{letter n}
\inst{}{iff}{ch$lo,scn09}{letter o}
\inst{}{iff}{ch$lp,scn09}{letter p}
\inst{}{iff}{ch$lq,scn09}{letter q}
\inst{}{iff}{ch$lr,scn09}{letter r}
\inst{}{iff}{ch$lt,scn09}{letter t}
\inst{}{iff}{ch$lu,scn09}{letter u}
\inst{}{iff}{ch$lv,scn09}{letter v}
\inst{}{iff}{ch$lw,scn09}{letter w}
\inst{}{iff}{ch$lx,scn09}{letter x}
\inst{}{iff}{ch$ly,scn09}{letter y}
\inst{}{iff}{ch$l$,scn09}{letter z}
\ifmac{.casl}
\inst{}{iff}{ch$$a,scn09}{shifted a}
\inst{}{iff}{ch$$b,scn09}{shifted b}
\inst{}{iff}{ch$$c,scn09}{shifted c}
\inst{}{iff}{ch$$d,scn09}{shifted d}
\inst{}{iff}{ch$$e,scn09}{shifted e}
\inst{}{iff}{ch$$f,scn20}{shifted f}
\inst{}{iff}{ch$$g,scn09}{shifted g}
\inst{}{iff}{ch$$h,scn09}{shifted h}
\inst{}{iff}{ch$$i,scn09}{shifted i}
\inst{}{iff}{ch$$j,scn09}{shifted j}
\inst{}{iff}{ch$$k,scn09}{shifted k}
\inst{}{iff}{ch$$l,scn09}{shifted l}
\inst{}{iff}{ch$$m,scn09}{shifted m}
\inst{}{iff}{ch$$n,scn09}{shifted n}
\inst{}{iff}{ch$$o,scn09}{shifted o}
\inst{}{iff}{ch$$p,scn09}{shifted p}
\inst{}{iff}{ch$$q,scn09}{shifted q}
\inst{}{iff}{ch$$r,scn09}{shifted r}
\inst{}{iff}{ch$$s,scn21}{shifted s}
\inst{}{iff}{ch$$t,scn09}{shifted t}
\inst{}{iff}{ch$$u,scn09}{shifted u}
\inst{}{iff}{ch$$v,scn09}{shifted v}
\inst{}{iff}{ch$$w,scn09}{shifted w}
\inst{}{iff}{ch$$x,scn09}{shifted x}
\inst{}{iff}{ch$$y,scn09}{shifted y}
\inst{}{iff}{ch$$$,scn09}{shifted z}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\inst{}{iff}{ch$sq,scn16}{single quote}
\inst{}{iff}{ch$dq,scn17}{double quote}
\inst{}{iff}{ch$lf,scn20}{letter f}
\inst{}{iff}{ch$ls,scn21}{letter s}
\inst{}{iff}{ch$un,scn24}{underline}
\inst{}{iff}{ch$pp,scn25}{left paren}
\inst{}{iff}{ch$rp,scn26}{right paren}
\inst{}{iff}{ch$rb,scn27}{right bracket}
\inst{}{iff}{ch$bb,scn28}{left bracket}
\inst{}{iff}{ch$cb,scn27}{right bracket}
\inst{}{iff}{ch$ob,scn28}{left bracket}
\inst{}{iff}{ch$cl,scn29}{colon}
\inst{}{iff}{ch$sm,scn30}{semi-colon}
\inst{}{iff}{ch$cm,scn31}{comma}
\inst{}{iff}{ch$dt,scn32}{dot}
\inst{}{iff}{ch$pl,scn33}{plus}
\inst{}{iff}{ch$mn,scn34}{minus}
\inst{}{iff}{ch$nt,scn35}{not}
\inst{}{iff}{ch$dl,scn36}{dollar}
\inst{}{iff}{ch$ex,scn37}{exclamation mark}
\inst{}{iff}{ch$pc,scn38}{percent}
\inst{}{iff}{ch$sl,scn40}{slash}
\inst{}{iff}{ch$nm,scn41}{number sign}
\inst{}{iff}{ch$at,scn42}{at}
\inst{}{iff}{ch$br,scn43}{vertical bar}
\inst{}{iff}{ch$am,scn44}{ampersand}
\inst{}{iff}{ch$qu,scn45}{question mark}
\inst{}{iff}{ch$eq,scn46}{equal}
\inst{}{iff}{ch$as,scn49}{asterisk}
\inst{}{esw}{}{end switch on character}
\lnie
\endln
\lnie
here for illegal character (underline merges)\endln
\lnie
\endln
\inst{scn07}{bze}{wb,scn10}{jump if scanning name or constant}
\inst{}{erb}{230,syntax error:}{illegal character}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
here for digits 0-9\endln
\lnie
\endln
\inst{scn08}{bze}{wb,scn09}{keep scanning if name/constant}
\inst{}{zer}{wc}{else set flag for scanning constant}
\lnie
\endln
\lnie
here for letter. loop here when scanning name/constant\endln
\lnie
\endln
\inst{scn09}{beq}{wa,scnil,scn11}{jump if end of image}
\inst{}{zer}{wb}{set flag for scanning name/const}
\inst{}{brn}{scn06}{merge back to continue scan}
\lnie
\endln
\lnie
come here for delimiter ending name or constant\endln
\lnie
\endln
\inst{scn10}{dcv}{wa}{reset offset to point to delimiter}
\lnie
\endln
\lnie
come here after finishing scan of name or constant\endln
\lnie
\endln
\inst{scn11}{mov}{wa,scnpt}{store updated scan offset}
\inst{}{mov}{scnse,wb}{point to start of element}
\inst{}{sub}{wb,wa}{get number of characters}
\inst{}{mov}{r$cim,xl}{point to line image}
\inst{}{bnz}{wc,scn15}{jump if name}
\lnie
\endln
\lnie
here after scanning out numeric constant\endln
\lnie
\endln
\inst{}{jsr}{sbstr}{get string for constant}
\inst{}{mov}{xr,dnamp}{delete from storage (not needed)}
\inst{}{jsr}{gtnum}{convert to numeric}
\inst{}{ppm}{scn14}{jump if conversion failure}
\lnie
\endln
\lnie
merge here to exit with constant\endln
\lnie
\endln
\inst{scn12}{mov}{=t$con,xl}{set result type of constant}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
common exit point (xr,xl) set\endln
\lnie
\endln
\inst{scn13}{mov}{scnsa,wa}{restore wa}
\inst{}{mov}{scnsb,wb}{restore wb}
\inst{}{mov}{scnsc,wc}{restore wc}
\inst{}{mov}{xr,r$scp}{save xr in case rescan}
\inst{}{mov}{xl,scntp}{save xl in case rescan}
\inst{}{zer}{scngo}{reset possible goto flag}
\inst{}{exi}{}{return to scane caller}
\lnie
\endln
\lnie
here if conversion error on numeric item\endln
\lnie
\endln
\inst{scn14}{erb}{231,syntax error:}{invalid numeric item}
\lnie
\endln
\lnie
here after scanning out variable name\endln
\lnie
\endln
\inst{scn15}{jsr}{sbstr}{build string name of variable}
\inst{}{bnz}{scncc,scn13}{return if cncrd call}
\inst{}{jsr}{gtnvr}{locate/build vrblk}
\inst{}{ppm}{}{dummy (unused) error return}
\inst{}{mov}{=t$var,xl}{set type as variable}
\inst{}{brn}{scn13}{back to exit}
\lnie
\endln
\lnie
here for single quote (start of string constant)\endln
\lnie
\endln
\inst{scn16}{bze}{wb,scn10}{terminator if scanning name or cnst}
\inst{}{mov}{=ch$sq,wb}{set terminator as single quote}
\inst{}{brn}{scn18}{merge}
\lnie
\endln
\lnie
here for double quote (start of string constant)\endln
\lnie
\endln
\inst{scn17}{bze}{wb,scn10}{terminator if scanning name or cnst}
\inst{}{mov}{=ch$dq,wb}{set double quote terminator, merge}
\lnie
\endln
\lnie
loop to scan out string constant\endln
\lnie
\endln
\inst{scn18}{beq}{wa,scnil,scn19}{error if end of image}
\inst{}{lch}{wc,(xl)+}{else load next character}
\inst{}{icv}{wa}{bump offset}
\inst{}{bne}{wc,wb,scn18}{loop back if not terminator}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
here after scanning out string constant\endln
\lnie
\endln
\inst{}{mov}{scnpt,wb}{point to first character}
\inst{}{mov}{wa,scnpt}{save offset past final quote}
\inst{}{dcv}{wa}{point back past last character}
\inst{}{sub}{wb,wa}{get number of characters}
\inst{}{mov}{r$cim,xl}{point to input image}
\inst{}{jsr}{sbstr}{build substring value}
\inst{}{brn}{scn12}{back to exit with constant result}
\lnie
\endln
\lnie
here if no matching quote found\endln
\lnie
\endln
\inst{scn19}{mov}{wa,scnpt}{set updated scan pointer}
\inst{}{erb}{232,syntax error:}{unmatched string quote}
\lnie
\endln
\lnie
here for f (possible failure goto)\endln
\lnie
\endln
\inst{scn20}{mov}{=t$fgo,xr}{set return code for fail goto}
\inst{}{brn}{scn22}{jump to merge}
\lnie
\endln
\lnie
here for s (possible success goto)\endln
\lnie
\endln
\inst{scn21}{mov}{=t$sgo,xr}{set success goto as return code}
\lnie
\endln
\lnie
special goto cases merge here\endln
\lnie
\endln
\inst{scn22}{bze}{scngo,scn09}{treat as normal letter if not goto}
\lnie
\endln
\lnie
merge here for special character exit\endln
\lnie
\endln
\inst{scn23}{bze}{wb,scn10}{jump if end of name/constant}
\inst{}{mov}{xr,xl}{else copy code}
\inst{}{brn}{scn13}{and jump to exit}
\lnie
\endln
\lnie
here for underline\endln
\lnie
\endln
\inst{scn24}{bze}{wb,scn09}{part of name if scanning name}
\inst{}{brn}{scn07}{else illegal}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
here for left paren\endln
\lnie
\endln
\inst{scn25}{mov}{=t$lpr,xr}{set left paren return code}
\inst{}{bnz}{wb,scn23}{return left paren unless name}
\inst{}{bze}{wc,scn10}{delimiter if scanning constant}
\lnie
\endln
\lnie
here for left paren after name (function call)\endln
\lnie
\endln
\inst{}{mov}{scnse,wb}{point to start of name}
\inst{}{mov}{wa,scnpt}{set pointer past left paren}
\inst{}{dcv}{wa}{point back past last char of name}
\inst{}{sub}{wb,wa}{get name length}
\inst{}{mov}{r$cim,xl}{point to input image}
\inst{}{jsr}{sbstr}{get string name for function}
\inst{}{jsr}{gtnvr}{locate/build vrblk}
\inst{}{ppm}{}{dummy (unused) error return}
\inst{}{mov}{=t$fnc,xl}{set code for function call}
\inst{}{brn}{scn13}{back to exit}
\lnie
\endln
\lnie
processing for special characters\endln
\lnie
\endln
\inst{scn26}{mov}{=t$rpr,xr}{right paren, set code}
\inst{}{brn}{scn23}{take special character exit}
\lnie
\endln
\inst{scn27}{mov}{=t$rbr,xr}{right bracket, set code}
\inst{}{brn}{scn23}{take special character exit}
\lnie
\endln
\inst{scn28}{mov}{=t$lbr,xr}{left bracket, set code}
\inst{}{brn}{scn23}{take special character exit}
\lnie
\endln
\inst{scn29}{mov}{=t$col,xr}{colon, set code}
\inst{}{brn}{scn23}{take special character exit}
\lnie
\endln
\inst{scn30}{mov}{=t$smc,xr}{semi-colon, set code}
\inst{}{brn}{scn23}{take special character exit}
\lnie
\endln
\inst{scn31}{mov}{=t$cma,xr}{comma, set code}
\inst{}{brn}{scn23}{take special character exit}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
here for operators. on entry, wc points to the table of\endln
\lnie
operator dope vectors and wb is the increment to step\endln
\lnie
to the next pair (binary/unary) of dope vectors in the\endln
\lnie
list. on reaching scn46, the pointer has been adjusted to\endln
\lnie
point to the appropriate pair of dope vectors.\endln
\lnie
the first three entries are special since they can occur\endln
\lnie
as part of a variable name (.) or constant (.+-).\endln
\lnie
\endln
\inst{scn32}{bze}{wb,scn09}{dot can be part of name or constant}
\inst{}{add}{wb,wc}{else bump pointer}
\lnie
\endln
\inst{scn33}{bze}{wc,scn09}{plus can be part of constant}
\inst{}{bze}{wb,scn48}{plus cannot be part of name}
\inst{}{add}{wb,wc}{else bump pointer}
\lnie
\endln
\inst{scn34}{bze}{wc,scn09}{minus can be part of constant}
\inst{}{bze}{wb,scn48}{minus cannot be part of name}
\inst{}{add}{wb,wc}{else bump pointer}
\lnie
\endln
\inst{scn35}{add}{wb,wc}{not}
\inst{scn36}{add}{wb,wc}{dollar}
\inst{scn37}{add}{wb,wc}{exclamation}
\inst{scn38}{add}{wb,wc}{percent}
\inst{scn39}{add}{wb,wc}{asterisk}
\inst{scn40}{add}{wb,wc}{slash}
\inst{scn41}{add}{wb,wc}{number sign}
\inst{scn42}{add}{wb,wc}{at sign}
\inst{scn43}{add}{wb,wc}{vertical bar}
\inst{scn44}{add}{wb,wc}{ampersand}
\inst{scn45}{add}{wb,wc}{question mark}
\lnie
\endln
\lnie
all operators come here (equal merges directly)\endln
\lnie
(wc) points to the binary/unary pair of operator dvblks.\endln
\lnie
\endln
\inst{scn46}{bze}{wb,scn10}{operator terminates name/constant}
\inst{}{mov}{wc,xr}{else copy dv pointer}
\inst{}{lch}{wc,(xl)}{load next character}
\inst{}{mov}{=t$bop,xl}{set binary op in case}
\inst{}{beq}{wa,scnil,scn47}{should be binary if image end}
\inst{}{beq}{wc,=ch$bl,scn47}{should be binary if followed by blk}
\ifmac{.caht}
\inst{}{beq}{wc,=ch$ht,scn47}{jump if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wc,=ch$vt,scn47}{jump if vertical tab}
\asmac{fi}
\inst{}{beq}{wc,=ch$sm,scn47}{semicolon can immediately follow =}
\inst{}{beq}{wc,=ch$cl,scn47}{colon can immediately follow =}
\inst{}{beq}{wc,=ch$rp,scn47}{right paren can immediately follow =}
\inst{}{beq}{wc,=ch$rb,scn47}{right bracket can immediately follow =}
\inst{}{beq}{wc,=ch$cb,scn47}{right bracket can immediately follow =}
\lnie
\endln
\lnie
here for unary operator\endln
\lnie
\endln
\inst{}{add}{*dvbs$,xr}{point to dv for unary op}
\inst{}{mov}{=t$uop,xl}{set type for unary operator}
\inst{}{ble}{scntp,=t$uok,scn13}{ok unary if ok preceding element}
\vfill\break

\lnie
\endln
\lnie
scane (continued)\endln
\lnie
\endln
\lnie
merge here to require preceding blanks\endln
\lnie
\endln
\inst{scn47}{bnz}{scnbl,scn13}{all ok if preceding blanks, exit}
\lnie
\endln
\lnie
fail operator in this position\endln
\lnie
\endln
\inst{scn48}{erb}{233,syntax error:}{invalid use of operator}
\lnie
\endln
\lnie
here for asterisk, could be ** substitute for exclamation\endln
\lnie
\endln
\inst{scn49}{bze}{wb,scn10}{end of name if scanning name}
\inst{}{beq}{wa,scnil,scn39}{not ** if * at image end}
\inst{}{mov}{wa,xr}{else save offset past first *}
\inst{}{mov}{wa,scnof}{save another copy}
\inst{}{lch}{wa,(xl)+}{load next character}
\inst{}{bne}{wa,=ch$as,scn50}{not ** if next char not *}
\inst{}{icv}{xr}{else step offset past second *}
\inst{}{beq}{xr,scnil,scn51}{ok exclam if end of image}
\inst{}{lch}{wa,(xl)}{else load next character}
\inst{}{beq}{wa,=ch$bl,scn51}{exclamation if blank}
\ifmac{.caht}
\inst{}{beq}{wa,=ch$ht,scn51}{exclamation if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wa,=ch$vt,scn51}{exclamation if vertical tab}
\asmac{fi}
\lnie
\endln
\lnie
unary *\endln
\lnie
\endln
\inst{scn50}{mov}{scnof,wa}{recover stored offset}
\inst{}{mov}{r$cim,xl}{point to line again}
\inst{}{plc}{xl,wa}{point to current char}
\inst{}{brn}{scn39}{merge with unary *}
\lnie
\endln
\lnie
here for ** as substitute for exclamation\endln
\lnie
\endln
\inst{scn51}{mov}{xr,scnpt}{save scan pointer past 2nd *}
\inst{}{mov}{xr,wa}{copy scan pointer}
\inst{}{brn}{scn37}{merge with exclamation}
\inst{}{enp}{}{end procedure scane}
\vfill\break

\lnie
\endln
\lnie
scngf -- scan goto field\endln
\lnie
\endln
\lnie
scngf is called from cmpil to scan and analyze a goto\endln
\lnie
field including the surrounding brackets or parentheses.\endln
\lnie
for a normal goto, the result returned is either a vrblk\endln
\lnie
pointer for a simple label operand, or a pointer to an\endln
\lnie
expression tree with a special outer unary operator\endln
\lnie
(o$goc). for a direct goto, the result returned is a\endln
\lnie
pointer to an expression tree with the special outer\endln
\lnie
unary operator o$god.\endln
\lnie
\endln
\lnie
jsr  scngf            call to scan goto field\endln
\lnie
(xr)                  result (see above)\endln
\lnie
(xl,wa,wb,wc)         destroyed\endln
\lnie
\endln
\inst{scngf}{prc}{e,0}{entry point}
\inst{}{jsr}{scane}{scan initial element}
\inst{}{beq}{xl,=t$lpr,scng1}{skip if left paren (normal goto)}
\inst{}{beq}{xl,=t$lbr,scng2}{skip if left bracket (direct goto)}
\inst{}{erb}{234,syntax error:}{goto field incorrect}
\lnie
\endln
\lnie
here for left paren (normal goto)\endln
\lnie
\endln
\inst{scng1}{mov}{=num01,wb}{set expan flag for normal goto}
\inst{}{jsr}{expan}{analyze goto field}
\inst{}{mov}{=opdvn,wa}{point to opdv for complex goto}
\inst{}{ble}{xr,statb,scng3}{jump if not in static (sgd15)}
\inst{}{blo}{xr,state,scng4}{jump to exit if simple label name}
\inst{}{brn}{scng3}{complex goto - merge}
\lnie
\endln
\lnie
here for left bracket (direct goto)\endln
\lnie
\endln
\inst{scng2}{mov}{=num02,wb}{set expan flag for direct goto}
\inst{}{jsr}{expan}{scan goto field}
\inst{}{mov}{=opdvd,wa}{set opdv pointer for direct goto}
\vfill\break

\lnie
\endln
\lnie
scngf (continued)\endln
\lnie
\endln
\lnie
merge here to build outer unary operator block\endln
\lnie
\endln
\inst{scng3}{mov}{wa,-(xs)}{stack operator dv pointer}
\inst{}{mov}{xr,-(xs)}{stack pointer to expression tree}
\inst{}{jsr}{expop}{pop operator off}
\inst{}{mov}{(xs)+,xr}{reload new expression tree pointer}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{scng4}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure scngf}
\vfill\break

\lnie
\endln
\lnie
setvr -- set vrget,vrsto fields of vrblk\endln
\lnie
\endln
\lnie
setvr sets the proper values in the vrget and vrsto\endln
\lnie
fields of a vrblk. it is called whenever trblks are\endln
\lnie
added or subtracted (trace,stoptr,input,output,detach)\endln
\lnie
\endln
\lnie
(xr)                  pointer to vrblk\endln
\lnie
jsr  setvr            call to set fields\endln
\lnie
(xl,wa)               destroyed\endln
\lnie
\endln
\lnie
note that setvr ignores the call if xr does not point\endln
\lnie
into the static region (i.e. is some other name base)\endln
\lnie
\endln
\inst{setvr}{prc}{e,0}{entry point}
\inst{}{bhi}{xr,state,setv1}{exit if not natural variable}
\lnie
\endln
\lnie
here if we have a vrblk\endln
\lnie
\endln
\inst{}{mov}{xr,xl}{copy vrblk pointer}
\inst{}{mov}{=b$vrl,vrget(xr)}{store normal get value}
\inst{}{beq}{vrsto(xr),=b$vre,setv1}{skip if protected variable}
\inst{}{mov}{=b$vrs,vrsto(xr)}{store normal store value}
\inst{}{mov}{vrval(xl),xl}{point to next entry on chain}
\inst{}{bne}{(xl),=b$trt,setv1}{jump if end of trblk chain}
\inst{}{mov}{=b$vra,vrget(xr)}{store trapped routine address}
\inst{}{mov}{=b$vrv,vrsto(xr)}{set trapped routine address}
\lnie
\endln
\lnie
merge here to exit to caller\endln
\lnie
\endln
\inst{setv1}{exi}{}{return to setvr caller}
\inst{}{enp}{}{end procedure setvr}
\ifmac{.cnsr}
\asmac{else}
\vfill\break

\lnie
\endln
\lnie
sorta -- sort array\endln
\lnie
\endln
\lnie
routine to sort an array or table on same basis as in\endln
\lnie
sitbol. a table is converted to an array, leaving two\endln
\lnie
dimensional arrays and vectors as cases to be considered.\endln
\lnie
whole rows of arrays are permuted according to the\endln
\lnie
ordering of the keys they contain, and the stride\endln
\lnie
referred to, is the the length of a row. it is one\endln
\lnie
for a vector.\endln
\lnie
the sort used is heapsort, fundamentals of data structure\endln
\lnie
horowitz and sahni, pitman 1977, page 347.\endln
\lnie
it is an order n*log(n) algorithm. in order\endln
\lnie
to make it stable, comparands may not compare equal. this\endln
\lnie
is achieved by sorting a copy array (referred to as the\endln
\lnie
sort array) containing at its high address end, byte\endln
\lnie
offsets to the rows to be sorted held in the original\endln
\lnie
array (referred to as the key array). sortc, the\endln
\lnie
comparison routine, accesses the keys through these\endln
\lnie
offsets and in the case of equality, resolves it by\endln
\lnie
comparing the offsets themselves. the sort permutes the\endln
\lnie
offsets which are then used in a final operation to copy\endln
\lnie
the actual items into the new array in sorted order.\endln
\lnie
references to zeroth item are to notional item\endln
\lnie
preceding first actual item.\endln
\lnie
reverse sorting for rsort is done by having the less than\endln
\lnie
test for keys effectively be replaced by a\endln
\lnie
greater than test.\endln
\lnie
\endln
\lnie
1(xs)                 first arg - array or table\endln
\lnie
0(xs)                 2nd arg - index or pdtype name\endln
\lnie
(wa)                  0 , non-zero for sort , rsort\endln
\lnie
jsr  sorta            call to sort array\endln
\lnie
ppm  loc              transfer loc if table is empty\endln
\lnie
(xr)                  sorted array\endln
\lnie
(xl,wa,wb,wc)         destroyed\endln
\vfill\break

\lnie
\endln
\lnie
sorta (continued)\endln
\lnie
\endln
\inst{sorta}{prc}{n,1}{entry point}
\inst{}{mov}{wa,srtsr}{sort/rsort indicator}
\inst{}{mov}{*num01,srtst}{default stride of 1}
\inst{}{zer}{srtof}{default zero offset to sort key}
\inst{}{mov}{=nulls,srtdf}{clear datatype field name}
\inst{}{mov}{(xs)+,r$sxr}{unstack argument 2}
\inst{}{mov}{(xs)+,xr}{get first argument}
\inst{}{mnz}{wa}{use key/values of table entries}
\inst{}{jsr}{gtarr}{convert to array}
\inst{}{ppm}{srt18}{signal that table is empty}
\inst{}{ppm}{srt16}{error if non-convertable}
\inst{}{mov}{xr,-(xs)}{stack ptr to resulting key array}
\inst{}{mov}{xr,-(xs)}{another copy for copyb}
\inst{}{jsr}{copyb}{get copy array for sorting into}
\inst{}{ppm}{}{cant fail}
\inst{}{mov}{xr,-(xs)}{stack pointer to sort array}
\inst{}{mov}{r$sxr,xr}{get second arg}
\inst{}{mov}{num01(xs),xl}{get ptr to key array}
\inst{}{bne}{(xl),=b$vct,srt02}{jump if arblk}
\inst{}{beq}{xr,=nulls,srt01}{jump if null second arg}
\inst{}{jsr}{gtnvr}{get vrblk ptr for it}
\inst{}{err}{257,erroneous 2nd}{arg in sort/rsort of vector}
\inst{}{mov}{xr,srtdf}{store datatype field name vrblk}
\lnie
\endln
\lnie
compute n and offset to item a(0) in vector case\endln
\lnie
\endln
\inst{srt01}{mov}{*vclen,wc}{offset to a(0)}
\inst{}{mov}{*vcvls,wb}{offset to first item}
\inst{}{mov}{vclen(xl),wa}{get block length}
\inst{}{sub}{*vcsi$,wa}{get no. of entries, n (in bytes)}
\inst{}{brn}{srt04}{merge}
\lnie
\endln
\lnie
here for array\endln
\lnie
\endln
\inst{srt02}{ldi}{ardim(xl)}{get possible dimension}
\inst{}{mfi}{wa}{convert to short integer}
\inst{}{wtb}{wa}{further convert to baus}
\inst{}{mov}{*arvls,wb}{offset to first value if one}
\inst{}{mov}{*arpro,wc}{offset before values if one dim.}
\inst{}{beq}{arndm(xl),=num01,srt04}{jump in fact if one dim.}
\inst{}{bne}{arndm(xl),=num02,srt16}{ fail unless two dimens}
\inst{}{ldi}{arlb2(xl)}{get lower bound 2 as default}
\inst{}{beq}{xr,=nulls,srt03}{jump if default second arg}
\inst{}{jsr}{gtint}{convert to integer}
\inst{}{ppm}{srt17}{fail}
\inst{}{ldi}{icval(xr)}{get actual integer value}
\vfill\break

\lnie
\endln
\lnie
sorta (continued)\endln
\lnie
\endln
\lnie
here with sort column index in ia in array case\endln
\lnie
\endln
\inst{srt03}{sbi}{arlb2(xl)}{subtract low bound}
\inst{}{iov}{srt17}{fail if overflow}
\inst{}{ilt}{srt17}{fail if below low bound}
\inst{}{sbi}{ardm2(xl)}{check against dimension}
\inst{}{ige}{srt17}{fail if too large}
\inst{}{adi}{ardm2(xl)}{restore value}
\inst{}{mfi}{wa}{get as small integer}
\inst{}{wtb}{wa}{offset within row to key}
\inst{}{mov}{wa,srtof}{keep offset}
\inst{}{ldi}{ardm2(xl)}{second dimension is row length}
\inst{}{mfi}{wa}{convert to short integer}
\inst{}{mov}{wa,xr}{copy row length}
\inst{}{wtb}{wa}{convert to bytes}
\inst{}{mov}{wa,srtst}{store as stride}
\inst{}{ldi}{ardim(xl)}{get number of rows}
\inst{}{mfi}{wa}{as a short integer}
\inst{}{wtb}{wa}{convert n to baus}
\inst{}{mov}{arlen(xl),wc}{offset past array end}
\inst{}{sub}{wa,wc}{adjust, giving space for n offsets}
\inst{}{dca}{wc}{point to a(0)}
\inst{}{mov}{arofs(xl),wb}{offset to word before first item}
\inst{}{ica}{wb}{offset to first item}
\lnie
\endln
\lnie
separate pre-processing for arrays and vectors done.\endln
\lnie
to simplify later key comparisons, removal of any trblk\endln
\lnie
trap blocks from entries in key array is effected.\endln
\lnie
\endln
\lnie
(xl) = 1(xs) = pointer to key array\endln
\lnie
(xs) = pointer to sort array\endln
\lnie
wa = number of items, n (converted to bytes).\endln
\lnie
wb = offset to first item of arrays.\endln
\lnie
wc = offset to a(0)\endln
\lnie
\endln
\inst{srt04}{ble}{wa,*num01,srt15}{return if only a single item}
\inst{}{mov}{wa,srtsn}{store number of items (in baus)}
\inst{}{mov}{wc,srtso}{store offset to a(0)}
\inst{}{mov}{arlen(xl),wc}{length of array or vec (=vclen)}
\inst{}{add}{xl,wc}{point past end of array or vector}
\inst{}{mov}{wb,srtsf}{store offset to first row}
\inst{}{add}{wb,xl}{point to first item in key array}
\lnie
\endln
\lnie
loop through array\endln
\lnie
\endln
\inst{srt05}{mov}{(xl),xr}{get an entry}
\lnie
\endln
\lnie
hunt along trblk chain\endln
\lnie
\endln
\inst{srt06}{bne}{(xr),=b$trt,srt07}{jump out if not trblk}
\inst{}{mov}{trval(xr),xr}{get value field}
\inst{}{brn}{srt06}{loop}
\vfill\break

\lnie
\endln
\lnie
sorta (continued)\endln
\lnie
\endln
\lnie
xr is value from end of chain\endln
\lnie
\endln
\inst{srt07}{mov}{xr,(xl)+}{store as array entry}
\inst{}{blt}{xl,wc,srt05}{loop if not done}
\inst{}{mov}{(xs),xl}{get adrs of sort array}
\inst{}{mov}{srtsf,xr}{initial offset to first key}
\inst{}{mov}{srtst,wb}{get stride}
\inst{}{add}{srtso,xl}{offset to a(0)}
\inst{}{ica}{xl}{point to a(1)}
\inst{}{mov}{srtsn,wc}{get n}
\inst{}{btw}{wc}{convert from bytes}
\inst{}{mov}{wc,srtnr}{store as row count}
\inst{}{lct}{wc,wc}{loop counter}
\lnie
\endln
\lnie
store key offsets at top of sort array\endln
\lnie
\endln
\inst{srt08}{mov}{xr,(xl)+}{store an offset}
\inst{}{add}{wb,xr}{bump offset by stride}
\inst{}{bct}{wc,srt08}{loop through rows}
\lnie
\endln
\lnie
perform the sort on offsets in sort array.\endln
\lnie
\endln
\lnie
(srtsn)               number of items to sort, n (bytes)\endln
\lnie
(srtso)               offset to a(0)\endln
\lnie
\endln
\inst{srt09}{mov}{srtsn,wa}{get n}
\inst{}{mov}{srtnr,wc}{get number of rows}
\inst{}{rsh}{wc,1}{i = n / 2 (wc=i, index into array)}
\inst{}{wtb}{wc}{convert back to bytes}
\lnie
\endln
\lnie
loop to form initial heap\endln
\lnie
\endln
\inst{srt10}{jsr}{sorth}{sorth(i,n)}
\inst{}{dca}{wc}{i = i - 1}
\inst{}{bnz}{wc,srt10}{loop if i gt 0}
\inst{}{mov}{wa,wc}{i = n}
\lnie
\endln
\lnie
sorting loop. at this point, a(1) is the largest\endln
\lnie
item, since algorithm initialises it as, and then maintains\endln
\lnie
it as, root of tree.\endln
\lnie
\endln
\inst{srt11}{dca}{wc}{i = i - 1 (n - 1 initially)}
\inst{}{bze}{wc,srt12}{jump if done}
\inst{}{mov}{(xs),xr}{get sort array address}
\inst{}{add}{srtso,xr}{point to a(0)}
\inst{}{mov}{xr,xl}{a(0) address}
\inst{}{add}{wc,xl}{a(i) address}
\inst{}{mov}{num01(xl),wb}{copy a(i+1)}
\inst{}{mov}{num01(xr),num01(xl)}{ move a(1) to a(i+1)}
\inst{}{mov}{wb,num01(xr)}{complete exchange of a(1), a(i+1)}
\inst{}{mov}{wc,wa}{n = i for sorth}
\inst{}{mov}{*num01,wc}{i = 1 for sorth}
\inst{}{jsr}{sorth}{sorth(1,n)}
\inst{}{mov}{wa,wc}{restore wc}
\inst{}{brn}{srt11}{loop}
\vfill\break

\lnie
\endln
\lnie
sorta (continued)\endln
\lnie
\endln
\lnie
offsets have been permuted into required order by sort.\endln
\lnie
copy array elements over them.\endln
\lnie
\endln
\inst{srt12}{mov}{(xs),xr}{base adrs of key array}
\inst{}{mov}{xr,wc}{copy it}
\inst{}{add}{srtso,wc}{offset of a(0)}
\inst{}{add}{srtsf,xr}{adrs of first row of sort array}
\inst{}{mov}{srtst,wb}{get stride}
\lnie
\endln
\lnie
copying loop for successive items. sorted offsets are\endln
\lnie
held at end of sort array.\endln
\lnie
\endln
\inst{srt13}{ica}{wc}{adrs of next of sorted offsets}
\inst{}{mov}{wc,xl}{copy it for access}
\inst{}{mov}{(xl),xl}{get offset}
\inst{}{add}{num01(xs),xl}{add key array base adrs}
\inst{}{mov}{wb,wa}{get count of characters in row}
\inst{}{mvw}{}{copy a complete row}
\inst{}{dcv}{srtnr}{decrement row count}
\inst{}{bnz}{srtnr,srt13}{repeat till all rows done}
\lnie
\endln
\lnie
return point\endln
\lnie
\endln
\inst{srt15}{mov}{(xs)+,xr}{pop result array ptr}
\inst{}{ica}{xs}{pop key array ptr}
\inst{}{zer}{r$sxl}{clear junk}
\inst{}{zer}{r$sxr}{clear junk}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
error point\endln
\lnie
\endln
\inst{srt16}{erb}{256,sort/rsort 1st}{arg not suitable array or table}
\inst{srt17}{erb}{258,sort/rsort 2nd}{arg out of range or non-integer}
\lnie
\endln
\lnie
return point if input table is empty\endln
\lnie
\endln
\inst{srt18}{exi}{1}{return indication of null table}
\inst{}{enp}{}{end procudure sorta}
\vfill\break

\lnie
\endln
\lnie
sortc --  compare sort keys\endln
\lnie
\endln
\lnie
compare two sort keys given their offsets. if\endln
\lnie
equal, compare key offsets to give stable sort.\endln
\lnie
note that if srtsr is non-zero (request for reverse\endln
\lnie
sort), the quoted returns are inverted.\endln
\lnie
for objects of differing datatypes, the entry point\endln
\lnie
identifications are compared.\endln
\lnie
\endln
\lnie
(xl)                  base adrs for keys\endln
\lnie
(wa)                  offset to key 1 item\endln
\lnie
(wb)                  offset to key 2 item\endln
\lnie
(srtsr)               zero/non-zero for sort/rsort\endln
\lnie
(srtof)               offset within row to comparands\endln
\lnie
jsr  sortc            call to compare keys\endln
\lnie
ppm  loc              key1 less than key2\endln
\lnie
                      normal return, key1 gt than key2\endln
\lnie
(xl,xr,wa,wb)         destroyed\endln
\lnie
\endln
\inst{sortc}{prc}{e,1}{entry point}
\inst{}{mov}{wa,srts1}{save offset 1}
\inst{}{mov}{wb,srts2}{save offset 2}
\inst{}{mov}{wc,srtsc}{save wc}
\inst{}{add}{srtof,xl}{add offset to comparand field}
\inst{}{mov}{xl,xr}{copy base + offset}
\inst{}{add}{wa,xl}{add key1 offset}
\inst{}{add}{wb,xr}{add key2 offset}
\inst{}{mov}{(xl),xl}{get key1}
\inst{}{mov}{(xr),xr}{get key2}
\inst{}{bne}{srtdf,=nulls,src12}{jump if datatype field name used}
\vfill\break

\lnie
\endln
\lnie
sortc (continued)\endln
\lnie
\endln
\lnie
merge after dealing with field name. try for strings.\endln
\lnie
\endln
\inst{src01}{mov}{(xl),wc}{get type code}
\inst{}{bne}{wc,(xr),src02}{skip if not same datatype}
\inst{}{beq}{wc,=b$scl,src09}{jump if both strings}
\inst{}{beq}{wc,=b$icl,src14}{jump if both integers}
\ifmac{.cnbf}
\asmac{else}
\inst{}{beq}{wc,=b$bct,src09}{jump if both buffers}
\asmac{fi}
\lnie
\endln
\lnie
datatypes different.  now try for numeric\endln
\lnie
\endln
\inst{src02}{mov}{xl,r$sxl}{keep arg1}
\inst{}{mov}{xr,r$sxr}{keep arg2}
\ifmac{.cnbf}
\ifmac{.cnsc}
\inst{}{beq}{wc,=b$scl,src11}{do not allow conversion to number}
\inst{}{beq}{(xr),=b$scl,src11}{if either arg is a string}
\asmac{fi}
\asmac{else}
\lnie
\endln
\lnie
first examine for string/buffer comparison.  if so,\endln
\lnie
allow lcomp to compare chars in string and buffer\endln
\lnie
without converting buffer to a string.\endln
\lnie
\endln
\inst{}{beq}{wc,=b$scl,src13}{jump if key1 is a string}
\ifmac{.cnsc}
\inst{}{bne}{wc,=b$bct,src15}{j if key1 is not a string or buffer}
\asmac{else}
\inst{}{bne}{wc,=b$bct,src14}{try converting key 2 to a number}
\asmac{fi}
\lnie
\endln
\lnie
here if key1 is a buffer, key2 known not to be a buffer.\endln
\lnie
if key2 is a string, then lcomp can proceed.\endln
\lnie
\endln
\inst{}{beq}{(xr),=b$scl,src09}{j if keys 1/2 are buffer/string}
\ifmac{.cnsc}
\inst{}{brn}{src11}{prevent convert of key 1 to number}
\asmac{else}
\inst{}{brn}{src14}{try converting key 1 to number}
\asmac{fi}
\lnie
\endln
\lnie
here if key1 is a string, key2 known not to be a string.\endln
\lnie
if key2 is a buffer, then lcomp can proceed.\endln
\lnie
\endln
\inst{src13}{beq}{(xr),=b$bct,src09}{j if keys 1/2 are string/buffer}
\ifmac{.cnsc}
\inst{}{brn}{src11}{prevent convert of key 1 to number}
\lnie
\endln
\lnie
here if key1 is not a string or buffer.\endln
\lnie
examine key2.  if it is a string or buffer, then do not\endln
\lnie
convert key2 to a number.\endln
\lnie
\endln
\inst{src15}{beq}{(xr),=b$scl,src11}{j if key 2 is a string}
\inst{}{beq}{(xr),=b$bct,src11}{j if key 2 is a buffer}
\lnie
\endln
\lnie
here with keys 1/2 not strings or buffers\endln
\lnie
\endln
\asmac{fi}
\asmac{fi}
\inst{src14}{mov}{xl,-(xs)}{stack}
\inst{}{mov}{xr,-(xs)}{args}
\inst{}{jsr}{acomp}{compare objects}
\inst{}{ppm}{src10}{not numeric}
\inst{}{ppm}{src10}{not numeric}
\inst{}{ppm}{src03}{key1 less}
\inst{}{ppm}{src08}{keys equal}
\inst{}{ppm}{src05}{key1 greater}
\lnie
\endln
\lnie
return if key1 smaller (sort), greater (rsort)\endln
\lnie
\endln
\inst{src03}{bnz}{srtsr,src06}{jump if rsort}
\lnie
\endln
\inst{src04}{mov}{srtsc,wc}{restore wc}
\inst{}{exi}{1}{return}
\lnie
\endln
\lnie
return if key1 greater (sort), smaller (rsort)\endln
\lnie
\endln
\inst{src05}{bnz}{srtsr,src04}{jump if rsort}
\lnie
\endln
\inst{src06}{mov}{srtsc,wc}{restore wc}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
keys are of same datatype\endln
\lnie
\endln
\inst{src07}{blt}{xl,xr,src03}{item first created is less}
\inst{}{bgt}{xl,xr,src05}{addresses rise in order of creation}
\lnie
\endln
\lnie
drop through or merge for identical or equal objects\endln
\lnie
\endln
\inst{src08}{blt}{srts1,srts2,src04}{test offsets or key addrss instead}
\inst{}{brn}{src06}{offset 1 greater}
\vfill\break

\lnie
\endln
\lnie
sortc (continued)\endln
\lnie
\endln
\ifmac{.cnbf}
\lnie
strings\endln
\asmac{else}
\lnie
strings or buffers or some combination of same\endln
\asmac{fi}
\lnie
\endln
\inst{src09}{mov}{xl,-(xs)}{stack}
\inst{}{mov}{xr,-(xs)}{args}
\inst{}{jsr}{lcomp}{compare objects}
\inst{}{ppm}{}{cant}
\inst{}{ppm}{}{fail}
\inst{}{ppm}{src03}{key1 less}
\inst{}{ppm}{src08}{keys equal}
\inst{}{ppm}{src05}{key1 greater}
\lnie
\endln
\lnie
arithmetic comparison failed - recover args\endln
\lnie
\endln
\inst{src10}{mov}{r$sxl,xl}{get arg1}
\inst{}{mov}{r$sxr,xr}{get arg2}
\inst{}{mov}{(xl),wc}{get type of key1}
\inst{}{beq}{wc,(xr),src07}{jump if keys of same type}
\lnie
\endln
\lnie
here to compare datatype ids\endln
\lnie
\endln
\inst{src11}{mov}{wc,xl}{get block type word}
\inst{}{mov}{(xr),xr}{get block type word}
\inst{}{lei}{xl}{entry point id for key1}
\inst{}{lei}{xr}{entry point id for key2}
\inst{}{bgt}{xl,xr,src05}{jump if key1 gt key2}
\inst{}{brn}{src03}{key1 lt key2}
\lnie
\endln
\lnie
datatype field name used\endln
\lnie
\endln
\inst{src12}{jsr}{sortf}{call routine to find field 1}
\inst{}{mov}{xl,-(xs)}{stack item pointer}
\inst{}{mov}{xr,xl}{get key2}
\inst{}{jsr}{sortf}{find field 2}
\inst{}{mov}{xl,xr}{place as key2}
\inst{}{mov}{(xs)+,xl}{recover key1}
\inst{}{brn}{src01}{merge}
\inst{}{enp}{}{procedure sortc}
\vfill\break

\lnie
\endln
\lnie
sortf -- find field for sortc\endln
\lnie
\endln
\lnie
routine used by sortc to obtain item corresponding\endln
\lnie
to a given field name, if this exists, in a programmer\endln
\lnie
defined object passed as argument.\endln
\lnie
if such a match occurs, record is kept of datatype\endln
\lnie
name, field name and offset to field in order to\endln
\lnie
short-circuit later searches on same type. note that\endln
\lnie
dfblks are stored in static and hence cannot be moved.\endln
\lnie
\endln
\lnie
(srtdf)               vrblk pointer of field name\endln
\lnie
(xl)                  possible pdblk pointer\endln
\lnie
jsr  sortf            call to search for field name\endln
\lnie
(xl)                  item found or original pdblk ptr\endln
\lnie
(wc)                  destroyed\endln
\lnie
\endln
\inst{sortf}{prc}{e,0}{entry point}
\inst{}{bne}{(xl),=b$pdt,srtf3}{return if not pdblk}
\inst{}{mov}{xr,-(xs)}{keep xr}
\inst{}{mov}{srtfd,xr}{get possible former dfblk ptr}
\inst{}{bze}{xr,srtf4}{jump if not}
\inst{}{bne}{xr,pddfp(xl),srtf4}{jump if not right datatype}
\inst{}{bne}{srtdf,srtff,srtf4}{jump if not right field name}
\inst{}{add}{srtfo,xl}{add offset to required field}
\lnie
\endln
\lnie
here with xl pointing to found field\endln
\lnie
\endln
\inst{srtf1}{mov}{(xl),xl}{get item from field}
\lnie
\endln
\lnie
return point\endln
\lnie
\endln
\inst{srtf2}{mov}{(xs)+,xr}{restore xr}
\lnie
\endln
\inst{srtf3}{exi}{}{return}
\vfill\break

\lnie
\endln
\lnie
sortf (continued)\endln
\lnie
\endln
\lnie
conduct a search\endln
\lnie
\endln
\inst{srtf4}{mov}{xl,xr}{copy original pointer}
\inst{}{mov}{pddfp(xr),xr}{point to dfblk}
\inst{}{mov}{xr,srtfd}{keep a copy}
\inst{}{mov}{fargs(xr),wc}{get number of fields}
\inst{}{wtb}{wc}{convert to bytes}
\inst{}{add}{dflen(xr),xr}{point past last field}
\lnie
\endln
\lnie
loop to find name in pdfblk\endln
\lnie
\endln
\inst{srtf5}{dca}{wc}{count down}
\inst{}{dca}{xr}{point in front}
\inst{}{beq}{(xr),srtdf,srtf6}{skip out if found}
\inst{}{bnz}{wc,srtf5}{loop}
\inst{}{brn}{srtf2}{return - not found}
\lnie
\endln
\lnie
found\endln
\lnie
\endln
\inst{srtf6}{mov}{(xr),srtff}{keep field name ptr}
\inst{}{add}{*pdfld,wc}{add offset to first field}
\inst{}{mov}{wc,srtfo}{store as field offset}
\inst{}{add}{wc,xl}{point to field}
\inst{}{brn}{srtf1}{return}
\inst{}{enp}{}{procedure sortf}
\vfill\break

\lnie
\endln
\lnie
sorth -- heap routine for sorta\endln
\lnie
\endln
\lnie
this routine constructs a heap from elements of array, a.\endln
\lnie
in this application, the elements are offsets to keys in\endln
\lnie
a key array.\endln
\lnie
\endln
\lnie
(xs)                  pointer to sort array base\endln
\lnie
1(xs)                 pointer to key array base\endln
\lnie
(wa)                  max array index, n (in bytes)\endln
\lnie
(wc)                  offset j in a to root (in *1 to *n)\endln
\lnie
jsr  sorth            call sorth(j,n) to make heap\endln
\lnie
(xl,xr,wb)            destroyed\endln
\lnie
\endln
\inst{sorth}{prc}{n,0}{entry point}
\inst{}{mov}{wa,srtsn}{save n}
\inst{}{mov}{wc,srtwc}{keep wc}
\inst{}{mov}{(xs),xl}{sort array base adrs}
\inst{}{add}{srtso,xl}{add offset to a(0)}
\inst{}{add}{wc,xl}{point to a(j)}
\inst{}{mov}{(xl),srtrt}{get offset to root}
\inst{}{add}{wc,wc}{double j - cant exceed n}
\lnie
\endln
\lnie
loop to move down tree using doubled index j\endln
\lnie
\endln
\inst{srh01}{bgt}{wc,srtsn,srh03}{done if j gt n}
\inst{}{beq}{wc,srtsn,srh02}{skip if j equals n}
\inst{}{mov}{(xs),xr}{sort array base adrs}
\inst{}{mov}{num01(xs),xl}{key array base adrs}
\inst{}{add}{srtso,xr}{point to a(0)}
\inst{}{add}{wc,xr}{adrs of a(j)}
\inst{}{mov}{num01(xr),wa}{get a(j+1)}
\inst{}{mov}{(xr),wb}{get a(j)}
\lnie
\endln
\lnie
compare sons. (wa) right son, (wb) left son\endln
\lnie
\endln
\inst{}{jsr}{sortc}{compare keys - lt(a(j+1),a(j))}
\inst{}{ppm}{srh02}{a(j+1) lt a(j)}
\inst{}{ica}{wc}{point to greater son, a(j+1)}
\vfill\break

\lnie
\endln
\lnie
sorth (continued)\endln
\lnie
\endln
\lnie
compare root with greater son\endln
\lnie
\endln
\inst{srh02}{mov}{num01(xs),xl}{key array base adrs}
\inst{}{mov}{(xs),xr}{get sort array address}
\inst{}{add}{srtso,xr}{adrs of a(0)}
\inst{}{mov}{xr,wb}{copy this adrs}
\inst{}{add}{wc,xr}{adrs of greater son, a(j)}
\inst{}{mov}{(xr),wa}{get a(j)}
\inst{}{mov}{wb,xr}{point back to a(0)}
\inst{}{mov}{srtrt,wb}{get root}
\inst{}{jsr}{sortc}{compare them - lt(a(j),root)}
\inst{}{ppm}{srh03}{father exceeds sons - done}
\inst{}{mov}{(xs),xr}{get sort array adrs}
\inst{}{add}{srtso,xr}{point to a(0)}
\inst{}{mov}{xr,xl}{copy it}
\inst{}{mov}{wc,wa}{copy j}
\inst{}{btw}{wc}{convert to words}
\inst{}{rsh}{wc,1}{get j/2}
\inst{}{wtb}{wc}{convert back to bytes}
\inst{}{add}{wa,xl}{point to a(j)}
\inst{}{add}{wc,xr}{adrs of a(j/2)}
\inst{}{mov}{(xl),(xr)}{a(j/2) = a(j)}
\inst{}{mov}{wa,wc}{recover j}
\inst{}{aov}{wc,wc,srh03}{j = j*2. done if too big}
\inst{}{brn}{srh01}{loop}
\lnie
\endln
\lnie
finish by copying root offset back into array\endln
\lnie
\endln
\inst{srh03}{btw}{wc}{convert to words}
\inst{}{rsh}{wc,1}{j = j/2}
\inst{}{wtb}{wc}{convert back to bytes}
\inst{}{mov}{(xs),xr}{sort array adrs}
\inst{}{add}{srtso,xr}{adrs of a(0)}
\inst{}{add}{wc,xr}{adrs of a(j/2)}
\inst{}{mov}{srtrt,(xr)}{a(j/2) = root}
\inst{}{mov}{srtsn,wa}{restore wa}
\inst{}{mov}{srtwc,wc}{restore wc}
\inst{}{exi}{}{return}
\inst{}{enp}{}{end procedure sorth}
\asmac{fi}
\vfill\break

\lnie
\endln
\lnie
trace -- set/reset a trace association\endln
\lnie
\endln
\lnie
this procedure is shared by trace and stoptr to\endln
\lnie
either initiate or stop a trace respectively.\endln
\lnie
\endln
\lnie
(xl)                  trblk ptr (trace) or zero (stoptr)\endln
\lnie
1(xs)                 first argument (name)\endln
\lnie
0(xs)                 second argument (trace type)\endln
\lnie
jsr  trace            call to set/reset trace\endln
\lnie
ppm  loc              transfer loc if 1st arg is bad name\endln
\lnie
ppm  loc              transfer loc if 2nd arg is bad type\endln
\lnie
(xs)                  popped\endln
\lnie
(xl,xr,wa,wb,wc,ia)   destroyed\endln
\lnie
\endln
\inst{trace}{prc}{n,2}{entry point}
\inst{}{jsr}{gtstg}{get trace type string}
\inst{}{ppm}{trc15}{jump if not string}
\inst{}{plc}{xr}{else point to string}
\inst{}{lch}{wa,(xr)}{load first character}
\ifmac{.culc}
\inst{}{flc}{wa}{fold to upper case}
\asmac{fi}
\inst{}{mov}{(xs),xr}{load name argument}
\inst{}{mov}{xl,(xs)}{stack trblk ptr or zero}
\inst{}{mov}{=trtac,wc}{set trtyp for access trace}
\inst{}{beq}{wa,=ch$la,trc10}{jump if a (access)}
\inst{}{mov}{=trtvl,wc}{set trtyp for value trace}
\inst{}{beq}{wa,=ch$lv,trc10}{jump if v (value)}
\inst{}{beq}{wa,=ch$bl,trc10}{jump if blank (value)}
\lnie
\endln
\lnie
here for l,k,f,c,r\endln
\lnie
\endln
\inst{}{beq}{wa,=ch$lf,trc01}{jump if f (function)}
\inst{}{beq}{wa,=ch$lr,trc01}{jump if r (return)}
\inst{}{beq}{wa,=ch$ll,trc03}{jump if l (label)}
\inst{}{beq}{wa,=ch$lk,trc06}{jump if k (keyword)}
\inst{}{bne}{wa,=ch$lc,trc15}{else error if not c (call)}
\lnie
\endln
\lnie
here for f,c,r\endln
\lnie
\endln
\inst{trc01}{jsr}{gtnvr}{point to vrblk for name}
\inst{}{ppm}{trc16}{jump if bad name}
\inst{}{ica}{xs}{pop stack}
\inst{}{mov}{vrfnc(xr),xr}{point to function block}
\inst{}{bne}{(xr),=b$pfc,trc17}{error if not program function}
\inst{}{beq}{wa,=ch$lr,trc02}{jump if r (return)}
\vfill\break

\lnie
\endln
\lnie
trace (continued)\endln
\lnie
\endln
\lnie
here for f,c to set/reset call trace\endln
\lnie
\endln
\inst{}{mov}{xl,pfctr(xr)}{set/reset call trace}
\inst{}{beq}{wa,=ch$lc,exnul}{exit with null if c (call)}
\lnie
\endln
\lnie
here for f,r to set/reset return trace\endln
\lnie
\endln
\inst{trc02}{mov}{xl,pfrtr(xr)}{set/reset return trace}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
here for l to set/reset label trace\endln
\lnie
\endln
\inst{trc03}{jsr}{gtnvr}{point to vrblk}
\inst{}{ppm}{trc16}{jump if bad name}
\inst{}{mov}{vrlbl(xr),xl}{load label pointer}
\inst{}{bne}{(xl),=b$trt,trc04}{jump if no old trace}
\inst{}{mov}{trlbl(xl),xl}{else delete old trace association}
\lnie
\endln
\lnie
here with old label trace association deleted\endln
\lnie
\endln
\inst{trc04}{beq}{xl,=stndl,trc16}{error if undefined label}
\inst{}{mov}{(xs)+,wb}{get trblk ptr again}
\inst{}{bze}{wb,trc05}{jump if stoptr case}
\inst{}{mov}{wb,vrlbl(xr)}{else set new trblk pointer}
\inst{}{mov}{=b$vrt,vrtra(xr)}{set label trace routine address}
\inst{}{mov}{wb,xr}{copy trblk pointer}
\inst{}{mov}{xl,trlbl(xr)}{store real label in trblk}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
here for stoptr case for label\endln
\lnie
\endln
\inst{trc05}{mov}{xl,vrlbl(xr)}{store label ptr back in vrblk}
\inst{}{mov}{=b$vrg,vrtra(xr)}{store normal transfer address}
\inst{}{exi}{}{return}
\vfill\break

\lnie
\endln
\lnie
trace (continued)\endln
\lnie
\endln
\lnie
here for k (keyword)\endln
\lnie
\endln
\inst{trc06}{jsr}{gtnvr}{point to vrblk}
\inst{}{ppm}{trc16}{error if not natural var}
\inst{}{bnz}{vrlen(xr),trc16}{error if not system var}
\inst{}{ica}{xs}{pop stack}
\inst{}{bze}{xl,trc07}{jump if stoptr case}
\inst{}{mov}{xr,trkvr(xl)}{store vrblk ptr in trblk for ktrex}
\lnie
\endln
\lnie
merge here with trblk set up in wb (or zero)\endln
\lnie
\endln
\inst{trc07}{mov}{vrsvp(xr),xr}{point to svblk}
\inst{}{beq}{xr,=v$ert,trc08}{jump if errtype}
\inst{}{beq}{xr,=v$stc,trc09}{jump if stcount}
\inst{}{bne}{xr,=v$fnc,trc17}{else error if not fnclevel}
\lnie
\endln
\lnie
fnclevel\endln
\lnie
\endln
\inst{}{mov}{xl,r$fnc}{set/reset fnclevel trace}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
errtype\endln
\lnie
\endln
\inst{trc08}{mov}{xl,r$ert}{set/reset errtype trace}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
stcount\endln
\lnie
\endln
\inst{trc09}{mov}{xl,r$stc}{set/reset stcount trace}
\inst{}{jsr}{stgcc}{update countdown counters}
\inst{}{exi}{}{return}
\vfill\break

\lnie
\endln
\lnie
trace (continued)\endln
\lnie
\endln
\lnie
a,v merge here with trtyp value in wc\endln
\lnie
\endln
\inst{trc10}{jsr}{gtvar}{locate variable}
\inst{}{ppm}{trc16}{error if not appropriate name}
\inst{}{mov}{(xs)+,wb}{get new trblk ptr again}
\inst{}{add}{xl,wa}{point to variable location}
\inst{}{mov}{wa,xr}{copy variable pointer}
\lnie
\endln
\lnie
loop to search trblk chain\endln
\lnie
\endln
\inst{trc11}{mov}{(xr),xl}{point to next entry}
\inst{}{bne}{(xl),=b$trt,trc13}{ jump if not trblk}
\inst{}{blt}{wc,trtyp(xl),trc13}{jump if too far out on chain}
\inst{}{beq}{wc,trtyp(xl),trc12}{jump if this matches our type}
\inst{}{add}{*trnxt,xl}{else point to link field}
\inst{}{mov}{xl,xr}{copy pointer}
\inst{}{brn}{trc11}{and loop back}
\lnie
\endln
\lnie
here to delete an old trblk of the type we were given\endln
\lnie
\endln
\inst{trc12}{mov}{trnxt(xl),xl}{get ptr to next block or value}
\inst{}{mov}{xl,(xr)}{store to delete this trblk}
\lnie
\endln
\lnie
here after deleting any old association of this type\endln
\lnie
\endln
\inst{trc13}{bze}{wb,trc14}{jump if stoptr case}
\inst{}{mov}{wb,(xr)}{else link new trblk in}
\inst{}{mov}{wb,xr}{copy trblk pointer}
\inst{}{mov}{xl,trnxt(xr)}{store forward pointer}
\inst{}{mov}{wc,trtyp(xr)}{store appropriate trap type code}
\lnie
\endln
\lnie
here to make sure vrget,vrsto are set properly\endln
\lnie
\endln
\inst{trc14}{mov}{wa,xr}{recall possible vrblk pointer}
\inst{}{sub}{*vrval,xr}{point back to vrblk}
\inst{}{jsr}{setvr}{set fields if vrblk}
\inst{}{exi}{}{return}
\lnie
\endln
\lnie
here for bad trace type\endln
\lnie
\endln
\inst{trc15}{exi}{2}{take bad trace type error exit}
\lnie
\endln
\lnie
pop stack before failing\endln
\lnie
\endln
\inst{trc16}{ica}{xs}{pop stack}
\lnie
\endln
\lnie
here for bad name argument\endln
\lnie
\endln
\inst{trc17}{exi}{1}{take bad name error exit}
\inst{}{enp}{}{end procedure trace}
\vfill\break

\lnie
\endln
\lnie
trbld -- build trblk\endln
\lnie
\endln
\lnie
trblk is used by the input, output and trace functions\endln
\lnie
to construct a trblk (trap block)\endln
\lnie
\endln
\lnie
(xr)                  trtag or trter\endln
\lnie
(xl)                  trfnc or trfpt\endln
\lnie
(wb)                  trtyp\endln
\lnie
jsr  trbld            call to build trblk\endln
\lnie
(xr)                  pointer to trblk\endln
\lnie
(wa)                  destroyed\endln
\lnie
\endln
\inst{trbld}{prc}{e,0}{entry point}
\inst{}{mov}{xr,-(xs)}{stack trtag (or trfnm)}
\inst{}{mov}{*trsi$,wa}{set size of trblk}
\inst{}{jsr}{alloc}{allocate trblk}
\inst{}{mov}{=b$trt,(xr)}{store first word}
\inst{}{mov}{xl,trfnc(xr)}{store trfnc (or trfpt)}
\inst{}{mov}{(xs)+,trtag(xr)}{store trtag (or trfnm)}
\inst{}{mov}{wb,trtyp(xr)}{store type}
\inst{}{mov}{=nulls,trval(xr)}{for now, a null value}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure trbld}
\vfill\break

\lnie
\endln
\lnie
trimr -- trim trailing blanks\endln
\lnie
\endln
\lnie
trimr is passed a pointer to an scblk which must be the\endln
\lnie
last block in dynamic storage. trailing blanks are\endln
\lnie
trimmed off and the dynamic storage pointer reset to\endln
\lnie
the end of the (possibly) shortened block.\endln
\lnie
\endln
\lnie
(wb)                  non-zero to trim trailing blanks\endln
\lnie
(xr)                  pointer to string to trim\endln
\lnie
jsr  trimr            call to trim string\endln
\lnie
(xr)                  pointer to trimmed string\endln
\lnie
(xl,wa,wb,wc)         destroyed\endln
\lnie
\endln
\lnie
the call with wb zero still performs the end zero pad\endln
\lnie
and dnamp readjustment. it is used from acess if kvtrm=0.\endln
\lnie
\endln
\inst{trimr}{prc}{e,0}{entry point}
\inst{}{mov}{xr,xl}{copy string pointer}
\inst{}{mov}{sclen(xr),wa}{load string length}
\inst{}{bze}{wa,trim2}{jump if null input}
\inst{}{plc}{xl,wa}{else point past last character}
\inst{}{bze}{wb,trim3}{jump if no trim}
\inst{}{mov}{=ch$bl,wc}{load blank character}
\lnie
\endln
\lnie
loop through characters from right to left\endln
\lnie
\endln
\inst{trim0}{lch}{wb,-(xl)}{load next character}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,trim1}{jump if horizontal tab}
\asmac{fi}
\inst{}{bne}{wb,wc,trim3}{jump if non-blank found}
\inst{trim1}{dcv}{wa}{else decrement character count}
\inst{}{bnz}{wa,trim0}{loop back if more to check}
\lnie
\endln
\lnie
here if result is null (null or all-blank input)\endln
\lnie
\endln
\inst{trim2}{mov}{xr,dnamp}{wipe out input string block}
\inst{}{mov}{=nulls,xr}{load null result}
\inst{}{brn}{trim5}{merge to exit}
\vfill\break

\lnie
\endln
\lnie
trimr (continued)\endln
\lnie
\endln
\lnie
here with non-blank found (merge for no trim)\endln
\lnie
\endln
\inst{trim3}{mov}{wa,sclen(xr)}{set new length}
\inst{}{mov}{xr,xl}{copy string pointer}
\inst{}{psc}{xl,wa}{ready for storing blanks}
\inst{}{ctb}{wa,schar}{get length of block in bytes}
\inst{}{add}{xr,wa}{point past new block}
\inst{}{mov}{wa,dnamp}{set new top of storage pointer}
\inst{}{lct}{wa,=cfp$c}{get count of chars in word}
\inst{}{zer}{wc}{set zero char}
\lnie
\endln
\lnie
loop to zero pad last word of characters\endln
\lnie
\endln
\inst{trim4}{sch}{wc,(xl)+}{store zero character}
\inst{}{bct}{wa,trim4}{loop back till all stored}
\inst{}{csc}{xl}{complete store characters}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{trim5}{zer}{xl}{clear garbage xl pointer}
\inst{}{exi}{}{return to caller}
\inst{}{enp}{}{end procedure trimr}
\vfill\break

\lnie
\endln
\lnie
trxeq -- execute function type trace\endln
\lnie
\endln
\lnie
trxeq is used to execute a trace when a fourth argument\endln
\lnie
has been supplied. trace has already been decremented.\endln
\lnie
\endln
\lnie
(xr)                  pointer to trblk\endln
\lnie
(xl,wa)               name base,offset for variable\endln
\lnie
jsr  trxeq            call to execute trace\endln
\lnie
(wb,wc,ra)            destroyed\endln
\lnie
\endln
\lnie
the following stack entries are made before passing\endln
\lnie
control to the trace function using the cfunc routine.\endln
\lnie
\endln
\lnie
                      trxeq return point word(s)\endln
\lnie
                      saved value of trace keyword\endln
\lnie
                      trblk pointer\endln
\lnie
                      name base\endln
\lnie
                      name offset\endln
\lnie
                      saved value of r$cod\endln
\lnie
                      saved code ptr (-r$cod)\endln
\lnie
                      saved value of flptr\endln
\lnie
flptr --------------- zero (dummy fail offset)\endln
\lnie
                      nmblk for variable name\endln
\lnie
xs ------------------ trace tag\endln
\lnie
\endln
\lnie
r$cod and the code ptr are set to dummy values which\endln
\lnie
cause control to return to the trxeq procedure on success\endln
\lnie
or failure (trxeq ignores a failure condition).\endln
\lnie
\endln
\inst{trxeq}{prc}{r,0}{entry point (recursive)}
\inst{}{mov}{r$cod,wc}{load code block pointer}
\inst{}{scp}{wb}{get current code pointer}
\inst{}{sub}{wc,wb}{make code pointer into offset}
\inst{}{mov}{kvtra,-(xs)}{stack trace keyword value}
\inst{}{mov}{xr,-(xs)}{stack trblk pointer}
\inst{}{mov}{xl,-(xs)}{stack name base}
\inst{}{mov}{wa,-(xs)}{stack name offset}
\inst{}{mov}{wc,-(xs)}{stack code block pointer}
\inst{}{mov}{wb,-(xs)}{stack code pointer offset}
\inst{}{mov}{flptr,-(xs)}{stack old failure pointer}
\inst{}{zer}{-(xs)}{set dummy fail offset}
\inst{}{mov}{xs,flptr}{set new failure pointer}
\inst{}{zer}{kvtra}{reset trace keyword to zero}
\inst{}{mov}{=trxdc,wc}{load new (dummy) code blk pointer}
\inst{}{mov}{wc,r$cod}{set as code block pointer}
\inst{}{lcp}{wc}{and new code pointer}
\vfill\break

\lnie
\endln
\lnie
trxeq (continued)\endln
\lnie
\endln
\lnie
now prepare arguments for function\endln
\lnie
\endln
\inst{}{mov}{wa,wb}{save name offset}
\inst{}{mov}{*nmsi$,wa}{load nmblk size}
\inst{}{jsr}{alloc}{allocate space for nmblk}
\inst{}{mov}{=b$nml,(xr)}{set type word}
\inst{}{mov}{xl,nmbas(xr)}{store name base}
\inst{}{mov}{wb,nmofs(xr)}{store name offset}
\inst{}{mov}{6(xs),xl}{reload pointer to trblk}
\inst{}{mov}{xr,-(xs)}{stack nmblk pointer (1st argument)}
\inst{}{mov}{trtag(xl),-(xs)}{stack trace tag (2nd argument)}
\inst{}{mov}{trfnc(xl),xl}{load trace vrblk pointer}
\inst{}{mov}{vrfnc(xl),xl}{load trace function pointer}
\inst{}{beq}{xl,=stndf,trxq2}{jump if not a defined function}
\inst{}{mov}{=num02,wa}{set number of arguments to two}
\inst{}{brn}{cfunc}{jump to call function}
\lnie
\endln
\lnie
see o$txr for details of return to this point\endln
\lnie
\endln
\inst{trxq1}{mov}{flptr,xs}{point back to our stack entries}
\inst{}{ica}{xs}{pop off garbage fail offset}
\inst{}{mov}{(xs)+,flptr}{restore old failure pointer}
\inst{}{mov}{(xs)+,wb}{reload code offset}
\inst{}{mov}{(xs)+,wc}{load old code base pointer}
\inst{}{mov}{wc,xr}{copy cdblk pointer}
\inst{}{mov}{cdstm(xr),kvstn}{restore stmnt no}
\inst{}{mov}{(xs)+,wa}{reload name offset}
\inst{}{mov}{(xs)+,xl}{reload name base}
\inst{}{mov}{(xs)+,xr}{reload trblk pointer}
\inst{}{mov}{(xs)+,kvtra}{restore trace keyword value}
\inst{}{add}{wc,wb}{recompute absolute code pointer}
\inst{}{lcp}{wb}{restore code pointer}
\inst{}{mov}{wc,r$cod}{and code block pointer}
\inst{}{exi}{}{return to trxeq caller}
\lnie
\endln
\lnie
here if the target function is not defined\endln
\lnie
\endln
\inst{trxq2}{erb}{197,trace fourth}{arg is not function name or null}
\lnie
\endln
\inst{}{enp}{}{end procedure trxeq}
\vfill\break

\lnie
\endln
\lnie
xscan -- execution function argument scan\endln
\lnie
\endln
\lnie
xscan scans out one token in a prototype argument in\endln
\lnie
array,clear,data,define,load function calls. xscan\endln
\lnie
calls must be preceded by a call to the initialization\endln
\lnie
procedure xscni. the following variables are used.\endln
\lnie
\endln
\lnie
r$xsc                 pointer to scblk for function arg\endln
\lnie
xsofs                 offset (num chars scanned so far)\endln
\lnie
\endln
\lnie
(wa)                  non-zero to skip and trim blanks\endln
\lnie
(wc)                  delimiter one (ch$xx)\endln
\lnie
(xl)                  delimiter two (ch$xx)\endln
\lnie
jsr  xscan            call to scan next item\endln
\lnie
(xr)                  pointer to scblk for token scanned\endln
\lnie
(wa)                  completion code (see below)\endln
\lnie
(wc,xl)               destroyed\endln
\lnie
\endln
\lnie
the scan starts from the current position and continues\endln
\lnie
until one of the following three conditions occurs.\endln
\lnie
\endln
\lnie
1)   delimiter one is encountered  (wa set to 1)\endln
\lnie
\endln
\lnie
2)   delimiter two encountered  (wa set to 2)\endln
\lnie
\endln
\lnie
3)   end of string encountered  (wa set to 0)\endln
\lnie
\endln
\lnie
the result is a string containing all characters scanned\endln
\lnie
up to but not including any delimiter character.\endln
\lnie
the pointer is left pointing past the delimiter.\endln
\lnie
\endln
\lnie
if only one delimiter is to be detected, delimiter one\endln
\lnie
and delimiter two should be set to the same value.\endln
\lnie
\endln
\lnie
in the case where the end of string is encountered, the\endln
\lnie
string includes all the characters to the end of the\endln
\lnie
string. no further calls can be made to xscan until\endln
\lnie
xscni is called to initialize a new argument scan\endln
\vfill\break

\lnie
\endln
\lnie
xscan (continued)\endln
\lnie
\endln
\inst{xscan}{prc}{e,0}{entry point}
\inst{}{mov}{wb,xscwb}{preserve wb}
\inst{}{mov}{wa,-(xs)}{record blank skip flag}
\inst{}{mov}{wa,-(xs)}{and second copy}
\inst{}{mov}{r$xsc,xr}{point to argument string}
\inst{}{mov}{sclen(xr),wa}{load string length}
\inst{}{mov}{xsofs,wb}{load current offset}
\inst{}{sub}{wb,wa}{get number of remaining characters}
\inst{}{bze}{wa,xscn3}{jump if no characters left}
\inst{}{plc}{xr,wb}{point to current character}
\lnie
\endln
\lnie
loop to search for delimiter\endln
\lnie
\endln
\inst{xscn1}{lch}{wb,(xr)+}{load next character}
\inst{}{beq}{wb,wc,xscn4}{jump if delimiter one found}
\inst{}{beq}{wb,xl,xscn5}{jump if delimiter two found}
\inst{}{bze}{(xs),xscn2}{jump if not skipping blanks}
\inst{}{icv}{xsofs}{assume blank and delete it}
\ifmac{.caht}
\inst{}{beq}{wb,=ch$ht,xscn2}{jump if horizontal tab}
\asmac{fi}
\ifmac{.cavt}
\inst{}{beq}{wb,=ch$vt,xscn2}{jump if vertical tab}
\asmac{fi}
\inst{}{beq}{wb,=ch$bl,xscn2}{jump if blank}
\inst{}{dcv}{xsofs}{undelete non-blank character}
\inst{}{zer}{(xs)}{and discontinue blank checking}
\lnie
\endln
\lnie
here after performing any leading blank trimming.\endln
\lnie
\endln
\inst{xscn2}{dcv}{wa}{decrement count of chars left}
\inst{}{bnz}{wa,xscn1}{loop back if more chars to go}
\lnie
\endln
\lnie
here for runout\endln
\lnie
\endln
\inst{xscn3}{mov}{r$xsc,xl}{point to string block}
\inst{}{mov}{sclen(xl),wa}{get string length}
\inst{}{mov}{xsofs,wb}{load offset}
\inst{}{sub}{wb,wa}{get substring length}
\inst{}{zer}{r$xsc}{clear string ptr for collector}
\inst{}{zer}{xscrt}{set zero (runout) return code}
\inst{}{brn}{xscn7}{jump to exit}
\vfill\break

\lnie
\endln
\lnie
xscan (continued)\endln
\lnie
\endln
\lnie
here if delimiter one found\endln
\lnie
\endln
\inst{xscn4}{mov}{=num01,xscrt}{set return code}
\inst{}{brn}{xscn6}{jump to merge}
\lnie
\endln
\lnie
here if delimiter two found\endln
\lnie
\endln
\inst{xscn5}{mov}{=num02,xscrt}{set return code}
\lnie
\endln
\lnie
merge here after detecting a delimiter\endln
\lnie
\endln
\inst{xscn6}{mov}{r$xsc,xl}{reload pointer to string}
\inst{}{mov}{sclen(xl),wc}{get original length of string}
\inst{}{sub}{wa,wc}{minus chars left = chars scanned}
\inst{}{mov}{wc,wa}{move to reg for sbstr}
\inst{}{mov}{xsofs,wb}{set offset}
\inst{}{sub}{wb,wa}{compute length for sbstr}
\inst{}{icv}{wc}{adjust new cursor past delimiter}
\inst{}{mov}{wc,xsofs}{store new offset}
\lnie
\endln
\lnie
common exit point\endln
\lnie
\endln
\inst{xscn7}{zer}{xr}{clear garbage character ptr in xr}
\inst{}{jsr}{sbstr}{build sub-string}
\inst{}{ica}{xs}{remove copy of blank flag}
\inst{}{mov}{(xs)+,wb}{original blank skip/trim flag}
\inst{}{bze}{sclen(xr),xscn8}{cannot trim the null string}
\inst{}{jsr}{trimr}{trim trailing blanks if requested}
\lnie
\endln
\lnie
final exit point\endln
\lnie
\endln
\inst{xscn8}{mov}{xscrt,wa}{load return code}
\inst{}{mov}{xscwb,wb}{restore wb}
\inst{}{exi}{}{return to xscan caller}
\inst{}{enp}{}{end procedure xscan}
\vfill\break

\lnie
\endln
\lnie
xscni -- execution function argument scan\endln
\lnie
\endln
\lnie
xscni initializes the scan used for prototype arguments\endln
\lnie
in the clear, define, load, data, array functions. see\endln
\lnie
xscan for the procedure which is used after this call.\endln
\lnie
\endln
\lnie
-(xs)                 argument to be scanned (on stack)\endln
\lnie
jsr  xscni            call to scan argument\endln
\lnie
ppm  loc              transfer loc if arg is not string\endln
\lnie
ppm  loc              transfer loc if argument is null\endln
\lnie
(xs)                  popped\endln
\lnie
(xr,r$xsc)            argument (scblk ptr)\endln
\lnie
(wa)                  argument length\endln
\lnie
(ia,ra)               destroyed\endln
\lnie
\endln
\inst{xscni}{prc}{n,2}{entry point}
\inst{}{jsr}{gtstg}{fetch argument as string}
\inst{}{ppm}{xsci1}{jump if not convertible}
\inst{}{mov}{xr,r$xsc}{else store scblk ptr for xscan}
\inst{}{zer}{xsofs}{set offset to zero}
\inst{}{bze}{wa,xsci2}{jump if null string}
\inst{}{exi}{}{return to xscni caller}
\lnie
\endln
\lnie
here if argument is not a string\endln
\lnie
\endln
\inst{xsci1}{exi}{1}{take not-string error exit}
\lnie
\endln
\lnie
here for null string\endln
\lnie
\endln
\inst{xsci2}{exi}{2}{take null-string error exit}
\inst{}{enp}{}{end procedure xscni}
\vfill\break
{\bf spitbol--\rm stack overflow section}
\vskip1em
\lnie
\endln
\lnie
control comes here if the main stack overflows\endln
\lnie
\endln
\inst{}{sec}{}{start of stack overflow section}
\lnie
\endln
\inst{}{add}{=num04,errft}{force conclusive fatal error}
\inst{}{mov}{flptr,xs}{pop stack to avoid more fails}
\inst{}{bnz}{gbcfl,stak1}{jump if garbage collecting}
\inst{}{erb}{gbcfl,stak1}{jump if garbage collecting}
\lnie
\endln
\lnie
no chance of recovery in mid garbage collection\endln
\lnie
\endln
\inst{stak1}{mov}{=endso,xr}{point to message}
\inst{}{zer}{kvdmp}{memory is undumpable}
\inst{}{brn}{stopr}{give up}
\vfill\break
{\bf spitbol--\rm error section}
\vskip1em
\lnie
\endln
\lnie
this section of code is entered whenever a procedure\endln
\lnie
return via an err parameter or an erb opcode is obeyed.\endln
\lnie
\endln
\lnie
(wa)                  is the error code\endln
\lnie
\endln
\lnie
the global variable stage indicates the point at which\endln
\lnie
the error occured as follows.\endln
\lnie
\endln
\lnie
stage=stgic           error during initial compile\endln
\lnie
\endln
\lnie
stage=stgxc           error during compile at execute\endln
\lnie
                      time (code, convert function calls)\endln
\lnie
\endln
\lnie
stage=stgev           error during compilation of\endln
\lnie
                      expression at execution time\endln
\lnie
                      (eval, convert function call).\endln
\lnie
\endln
\lnie
stage=stgxt           error at execute time. compiler\endln
\lnie
                      not active.\endln
\lnie
\endln
\lnie
stage=stgce           error during initial compile after\endln
\lnie
                      scanning out the end line.\endln
\lnie
\endln
\lnie
stage=stgxe           error during compile at execute\endln
\lnie
                      time after scanning end line.\endln
\lnie
\endln
\lnie
stage=stgee           error during expression evaluation\endln
\lnie
\endln
\inst{}{sec}{}{start of error section}
\lnie
\endln
\inst{error}{beq}{r$cim,=cmlab,cmple}{jump if error in scanning label}
\inst{}{mov}{wa,kvert}{save error code}
\inst{}{zer}{scnrs}{reset rescan switch for scane}
\inst{}{zer}{scngo}{reset goto switch for scane}
\ifmac{.cpol}
\inst{}{mov}{=num01,polcs}{reset poll count}
\inst{}{mov}{=num01,polct}{reset poll count}
\asmac{fi}
\inst{}{mov}{stage,xr}{load current stage}
\inst{}{bsw}{xr,stgno}{jump to appropriate error circuit}
\inst{}{iff}{stgic,err01}{initial compile}
\inst{}{iff}{stgxc,err04}{execute time compile}
\inst{}{iff}{stgev,err04}{eval compiling expr.}
\inst{}{iff}{stgee,err04}{eval evaluating expr}
\inst{}{iff}{stgxt,err05}{execute time}
\inst{}{iff}{stgce,err01}{compile - after end}
\inst{}{iff}{stgxe,err04}{xeq compile-past end}
\inst{}{esw}{}{end switch on error type}
\vfill\break

\lnie
\endln
\lnie
error during initial compile\endln
\lnie
\endln
\lnie
the error message is printed as part of the compiler\endln
\lnie
output. this printout includes the offending line (if not\endln
\lnie
printed already) and an error flag under the appropriate\endln
\lnie
column as indicated by scnse unless scnse is set to zero.\endln
\lnie
\endln
\lnie
after printing the message, the generated code is\endln
\lnie
modified to an error call and control is returned to\endln
\lnie
the cmpil procedure after resetting the stack pointer.\endln
\lnie
\endln
\lnie
if the error occurs after the end line, control returns\endln
\lnie
in a slightly different manner to ensure proper cleanup.\endln
\lnie
\endln
\inst{err01}{mov}{cmpxs,xs}{reset stack pointer}
\inst{}{ssl}{cmpss}{restore s-r stack ptr for cmpil}
\inst{}{bnz}{errsp,err03}{jump if error suppress flag set}
\ifmac{.cera}
\ifmac{.csfn}
\inst{}{mov}{cmpsn,wc}{current statement}
\inst{}{jsr}{filnm}{obtain file name for this statement}
\asmac{fi}
\inst{}{mov}{scnse,wb}{column number}
\inst{}{mov}{rdcln,wc}{line number}
\inst{}{mov}{rdcln,wc}{line number}
\inst{}{jsr}{sysea}{advise system of error}
\inst{}{ppm}{erra3}{if system does not want print}
\inst{}{mov}{xr,-(xs)}{save any provided print message}
\asmac{fi}
\inst{}{mov}{erich,erlst}{set flag for listr}
\inst{}{jsr}{listr}{list line}
\inst{}{jsr}{prtis}{terminate listing}
\inst{}{zer}{erlst}{clear listr flag}
\inst{}{mov}{scnse,wa}{load scan element offset}
\inst{}{bze}{wa,err02}{skip if not set}
\ifmac{.caht}
\inst{}{lct}{wb,wa}{loop counter}
\inst{}{icv}{wa}{increase for ch$ex}
\inst{}{mov}{r$cim,xl}{point to bad statement}
\inst{}{jsr}{alocs}{string block for error flag}
\inst{}{mov}{xr,wa}{remember string ptr}
\inst{}{psc}{xr}{ready for character storing}
\inst{}{plc}{xl}{ready to get chars}
\lnie
\endln
\lnie
loop to replace all chars but tabs by blanks\endln
\lnie
\endln
\inst{erra1}{lch}{wc,(xl)+}{get next char}
\inst{}{beq}{wc,=ch$ht,erra2}{skip if tab}
\inst{}{mov}{=ch$bl,wc}{get a blank}
\vfill\break

\lnie
\endln
\lnie
merge to store blank or tab in error line\endln
\lnie
\endln
\inst{erra2}{sch}{wc,(xr)+}{store char}
\inst{}{bct}{wb,erra1}{loop}
\inst{}{mov}{=ch$ex,xl}{exclamation mark}
\inst{}{sch}{xl,(xr)}{store at end of error line}
\inst{}{csc}{xr}{end of sch loop}
\inst{}{mov}{=stnpd,profs}{allow for statement number}
\inst{}{mov}{wa,xr}{point to error line}
\inst{}{jsr}{prtst}{print error line}
\asmac{else}
\inst{}{mti}{prlen}{get print buffer length}
\inst{}{mfi}{gtnsi}{store as signed integer}
\inst{}{add}{=stnpd,wa}{adjust for statement number}
\inst{}{mti}{wa}{copy to integer accumulator}
\inst{}{rmi}{gtnsi}{remainder modulo print bfr length}
\inst{}{sti}{profs}{use as character offset}
\inst{}{mov}{=ch$ex,wa}{get exclamation mark}
\inst{}{jsr}{prtch}{generate under bad column}
\asmac{fi}
\lnie
\endln
\lnie
here after placing error flag as required\endln
\lnie
\endln
\inst{err02}{jsr}{prtis}{print blank line}
\ifmac{.cera}
\inst{}{mov}{(xs)+,xr}{restore any sysea message}
\inst{}{bze}{xr,erra0}{did sysea provide message to print}
\inst{}{jsr}{prtst}{print sysea message}
\asmac{fi}
\inst{erra0}{jsr}{ermsg}{generate flag and error message}
\inst{}{add}{=num03,lstlc}{bump page ctr for blank, error, blk}
\inst{erra3}{zer}{xr}{in case of fatal error}
\inst{}{bhi}{errft,=num03,stopr}{pack up if several fatals}
\lnie
\endln
\lnie
count error, inhibit execution if required\endln
\lnie
\endln
\inst{}{icv}{cmerc}{bump error count}
\inst{}{add}{cswer,noxeq}{inhibit xeq if -noerrors}
\inst{}{bne}{stage,=stgic,cmp10}{ special return if after end line}
\vfill\break

\lnie
\endln
\lnie
loop to scan to end of statement\endln
\lnie
\endln
\inst{err03}{mov}{r$cim,xr}{point to start of image}
\inst{}{plc}{xr}{point to first char}
\inst{}{lch}{xr,(xr)}{get first char}
\inst{}{beq}{xr,=ch$mn,cmpce}{jump if error in control card}
\inst{}{zer}{scnrs}{clear rescan flag}
\inst{}{mnz}{errsp}{set error suppress flag}
\inst{}{jsr}{scane}{scan next element}
\inst{}{bne}{xl,=t$smc,err03}{loop back if not statement end}
\inst{}{zer}{errsp}{clear error suppress flag}
\lnie
\endln
\lnie
generate error call in code and return to cmpil\endln
\lnie
\endln
\inst{}{mov}{*cdcod,cwcof}{reset offset in ccblk}
\inst{}{mov}{=ocer$,wa}{load compile error call}
\inst{}{jsr}{cdwrd}{generate it}
\inst{}{mov}{cwcof,cmsoc(xs)}{set success fill in offset}
\inst{}{mnz}{cmffc(xs)}{set failure fill in flag}
\inst{}{jsr}{cdwrd}{generate succ. fill in word}
\inst{}{brn}{cmpse}{merge to generate error as cdfal}
\lnie
\endln
\lnie
error during execute time compile or expression evaluatio\endln
\lnie
\endln
\lnie
execute time compilation is initiated through gtcod or\endln
\lnie
gtexp which are called by compile, code or eval.\endln
\lnie
before causing statement failure through exfal it is\endln
\lnie
helpful to set keyword errtext and for generality\endln
\lnie
these errors may be handled by the setexit mechanism.\endln
\lnie
\endln
\inst{err04}{bge}{errft,=num03,labo1}{abort if too many fatal errors}
\ifmac{.cpol}
\inst{}{beq}{kvert,=nm320,err06}{treat user interrupt specially}
\asmac{fi}
\inst{}{zer}{r$ccb}{forget garbage code block}
\inst{}{mov}{*cccod,cwcof}{set initial offset (mbe catspaw)}
\inst{}{ssl}{iniss}{restore main prog s-r stack ptr}
\inst{}{jsr}{ertex}{get fail message text}
\inst{}{dca}{xs}{ensure stack ok on loop start}
\lnie
\endln
\lnie
pop stack until find flptr for most deeply nested prog.\endln
\lnie
defined function call or call of eval / code.\endln
\lnie
\endln
\inst{erra4}{ica}{xs}{pop stack}
\inst{}{beq}{xs,flprt,errc4}{jump if prog defined fn call found}
\inst{}{bne}{xs,gtcef,erra4}{loop if not eval or code call yet}
\inst{}{mov}{=stgxt,stage}{re-set stage for execute}
\inst{}{mov}{r$gtc,r$cod}{recover code ptr}
\inst{}{mov}{xs,flptr}{restore fail pointer}
\inst{}{zer}{r$cim}{forget possible image}
\ifmac{.cinc}
\inst{}{zer}{cnind}{forget possible include}
\asmac{fi}
\lnie
\endln
\lnie
test errlimit\endln
\lnie
\endln
\inst{errb4}{bnz}{kverl,err07}{jump if errlimit non-zero}
\inst{}{brn}{exfal}{fail}
\lnie
\endln
\lnie
return from prog. defined function is outstanding\endln
\lnie
\endln
\inst{errc4}{mov}{flptr,xs}{restore stack from flptr}
\inst{}{brn}{errb4}{merge}
\vfill\break

\lnie
\endln
\lnie
error at execute time.\endln
\lnie
\endln
\lnie
the action taken on an error is as follows.\endln
\lnie
\endln
\lnie
if errlimit keyword is zero, an abort is signalled,\endln
\lnie
see coding for system label abort at l$abo.\endln
\lnie
\endln
\lnie
otherwise, errlimit is decremented and an errtype trace\endln
\lnie
generated if required. control returns either via a jump\endln
\lnie
to continue (to take the failure exit) or a specified\endln
\lnie
setexit trap is executed and control passes to the trap.\endln
\lnie
if 3 or more fatal errors occur an abort is signalled\endln
\lnie
regardless of errlimit and setexit - looping is all too\endln
\lnie
probable otherwise. fatal errors include stack overflow\endln
\lnie
and exceeding stlimit.\endln
\lnie
\endln
\inst{err05}{ssl}{iniss}{restore main prog s-r stack ptr}
\inst{}{bnz}{dmvch,err08}{jump if in mid-dump}
\lnie
\endln
\lnie
merge here from err08 and err04 (error 320)\endln
\lnie
\endln
\inst{err06}{bze}{kverl,labo1}{abort if errlimit is zero}
\inst{}{jsr}{ertex}{get fail message text}
\lnie
\endln
\lnie
merge from err04\endln
\lnie
\endln
\inst{err07}{bge}{errft,=num03,labo1}{abort if too many fatal errors}
\inst{}{dcv}{kverl}{decrement errlimit}
\inst{}{mov}{r$ert,xl}{load errtype trace pointer}
\inst{}{jsr}{ktrex}{generate errtype trace if required}
\inst{}{mov}{r$cod,wa}{get current code block}
\inst{}{mov}{wa,r$cnt}{set cdblk ptr for continuation}
\inst{}{scp}{wb}{current code pointer}
\inst{}{sub}{wa,wb}{offset within code block}
\inst{}{mov}{wb,stxoc}{save code ptr offset for scontinue}
\inst{}{mov}{flptr,xr}{set ptr to failure offset}
\inst{}{mov}{(xr),stxof}{save failure offset for continue}
\inst{}{mov}{r$sxc,xr}{load setexit cdblk pointer}
\inst{}{bze}{xr,lcnt1}{continue if no setexit trap}
\inst{}{zer}{r$sxc}{else reset trap}
\inst{}{mov}{=nulls,stxvr}{reset setexit arg to null}
\inst{}{mov}{(xr),xl}{load ptr to code block routine}
\inst{}{bri}{xl}{execute first trap statement}
\lnie
\endln
\lnie
interrupted partly through a dump whilst store is in a\endln
\lnie
mess so do a tidy up operation. see dumpr for details.\endln
\lnie
\endln
\inst{err08}{mov}{dmvch,xr}{chain head for affected vrblks}
\inst{}{bze}{xr,err06}{done if zero}
\inst{}{mov}{(xr),dmvch}{set next link as chain head}
\inst{}{jsr}{setvr}{restore vrget field}
\lnie
\endln
\lnie
label to mark end of code\endln
\lnie
\endln
\inst{s$yyy}{brn}{err08}{loop through chain}
\vfill\break
{\bf spitbol--\rm here endeth the code}
\vskip1em
\lnie
\endln
\lnie
end of assembly\endln
\lnie
\endln
\inst{}{end}{}{end macro-spitbol assembly}
\bye
